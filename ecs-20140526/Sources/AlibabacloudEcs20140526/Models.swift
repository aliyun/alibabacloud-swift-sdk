import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AcceptInquiredSystemEventRequest : Tea.TeaModel {
    public var choice: String?

    public var eventId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.choice != nil {
            map["Choice"] = self.choice!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Choice"] as? String {
            self.choice = value
        }
        if let value = dict["EventId"] as? String {
            self.eventId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class AcceptInquiredSystemEventResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AcceptInquiredSystemEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AcceptInquiredSystemEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AcceptInquiredSystemEventResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ActivateRouterInterfaceRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerInterfaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouterInterfaceId"] as? String {
            self.routerInterfaceId = value
        }
    }
}

public class ActivateRouterInterfaceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ActivateRouterInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ActivateRouterInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ActivateRouterInterfaceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddBandwidthPackageIpsRequest : Tea.TeaModel {
    public var bandwidthPackageId: String?

    public var clientToken: String?

    public var ipCount: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipCount != nil {
            map["IpCount"] = self.ipCount!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BandwidthPackageId"] as? String {
            self.bandwidthPackageId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["IpCount"] as? String {
            self.ipCount = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class AddBandwidthPackageIpsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddBandwidthPackageIpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddBandwidthPackageIpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddBandwidthPackageIpsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddTagsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tag: [AddTagsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [AddTagsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = AddTagsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class AddTagsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddTagsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AllocateDedicatedHostsRequest : Tea.TeaModel {
    public class NetworkAttributes : Tea.TeaModel {
        public var slbUdpTimeout: Int32?

        public var udpTimeout: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.slbUdpTimeout != nil {
                map["SlbUdpTimeout"] = self.slbUdpTimeout!
            }
            if self.udpTimeout != nil {
                map["UdpTimeout"] = self.udpTimeout!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SlbUdpTimeout"] as? Int32 {
                self.slbUdpTimeout = value
            }
            if let value = dict["UdpTimeout"] as? Int32 {
                self.udpTimeout = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var networkAttributes: AllocateDedicatedHostsRequest.NetworkAttributes?

    public var actionOnMaintenance: String?

    public var autoPlacement: String?

    public var autoReleaseTime: String?

    public var autoRenew: Bool?

    public var autoRenewPeriod: Int32?

    public var chargeType: String?

    public var clientToken: String?

    public var cpuOverCommitRatio: Double?

    public var dedicatedHostClusterId: String?

    public var dedicatedHostName: String?

    public var dedicatedHostType: String?

    public var description_: String?

    public var minQuantity: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var quantity: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [AllocateDedicatedHostsRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkAttributes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAttributes != nil {
            map["NetworkAttributes"] = self.networkAttributes?.toMap()
        }
        if self.actionOnMaintenance != nil {
            map["ActionOnMaintenance"] = self.actionOnMaintenance!
        }
        if self.autoPlacement != nil {
            map["AutoPlacement"] = self.autoPlacement!
        }
        if self.autoReleaseTime != nil {
            map["AutoReleaseTime"] = self.autoReleaseTime!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewPeriod != nil {
            map["AutoRenewPeriod"] = self.autoRenewPeriod!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.cpuOverCommitRatio != nil {
            map["CpuOverCommitRatio"] = self.cpuOverCommitRatio!
        }
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.dedicatedHostName != nil {
            map["DedicatedHostName"] = self.dedicatedHostName!
        }
        if self.dedicatedHostType != nil {
            map["DedicatedHostType"] = self.dedicatedHostType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.minQuantity != nil {
            map["MinQuantity"] = self.minQuantity!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.quantity != nil {
            map["Quantity"] = self.quantity!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NetworkAttributes"] as? [String: Any?] {
            var model = AllocateDedicatedHostsRequest.NetworkAttributes()
            model.fromMap(value)
            self.networkAttributes = model
        }
        if let value = dict["ActionOnMaintenance"] as? String {
            self.actionOnMaintenance = value
        }
        if let value = dict["AutoPlacement"] as? String {
            self.autoPlacement = value
        }
        if let value = dict["AutoReleaseTime"] as? String {
            self.autoReleaseTime = value
        }
        if let value = dict["AutoRenew"] as? Bool {
            self.autoRenew = value
        }
        if let value = dict["AutoRenewPeriod"] as? Int32 {
            self.autoRenewPeriod = value
        }
        if let value = dict["ChargeType"] as? String {
            self.chargeType = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CpuOverCommitRatio"] as? Double {
            self.cpuOverCommitRatio = value
        }
        if let value = dict["DedicatedHostClusterId"] as? String {
            self.dedicatedHostClusterId = value
        }
        if let value = dict["DedicatedHostName"] as? String {
            self.dedicatedHostName = value
        }
        if let value = dict["DedicatedHostType"] as? String {
            self.dedicatedHostType = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["MinQuantity"] as? Int32 {
            self.minQuantity = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PeriodUnit"] as? String {
            self.periodUnit = value
        }
        if let value = dict["Quantity"] as? Int32 {
            self.quantity = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [AllocateDedicatedHostsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = AllocateDedicatedHostsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class AllocateDedicatedHostsResponseBody : Tea.TeaModel {
    public class DedicatedHostIdSets : Tea.TeaModel {
        public var dedicatedHostId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dedicatedHostId != nil {
                map["DedicatedHostId"] = self.dedicatedHostId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DedicatedHostId"] as? [String] {
                self.dedicatedHostId = value
            }
        }
    }
    public var dedicatedHostIdSets: AllocateDedicatedHostsResponseBody.DedicatedHostIdSets?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dedicatedHostIdSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostIdSets != nil {
            map["DedicatedHostIdSets"] = self.dedicatedHostIdSets?.toMap()
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DedicatedHostIdSets"] as? [String: Any?] {
            var model = AllocateDedicatedHostsResponseBody.DedicatedHostIdSets()
            model.fromMap(value)
            self.dedicatedHostIdSets = model
        }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AllocateDedicatedHostsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AllocateDedicatedHostsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AllocateDedicatedHostsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AllocateEipAddressRequest : Tea.TeaModel {
    public var activityId: Int64?

    public var bandwidth: String?

    public var clientToken: String?

    public var ISP: String?

    public var internetChargeType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activityId != nil {
            map["ActivityId"] = self.activityId!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ISP != nil {
            map["ISP"] = self.ISP!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ActivityId"] as? Int64 {
            self.activityId = value
        }
        if let value = dict["Bandwidth"] as? String {
            self.bandwidth = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ISP"] as? String {
            self.ISP = value
        }
        if let value = dict["InternetChargeType"] as? String {
            self.internetChargeType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class AllocateEipAddressResponseBody : Tea.TeaModel {
    public var allocationId: String?

    public var eipAddress: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.eipAddress != nil {
            map["EipAddress"] = self.eipAddress!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AllocationId"] as? String {
            self.allocationId = value
        }
        if let value = dict["EipAddress"] as? String {
            self.eipAddress = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AllocateEipAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AllocateEipAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AllocateEipAddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AllocatePublicIpAddressRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ipAddress: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vlanId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ipAddress != nil {
            map["IpAddress"] = self.ipAddress!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vlanId != nil {
            map["VlanId"] = self.vlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["IpAddress"] as? String {
            self.ipAddress = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VlanId"] as? String {
            self.vlanId = value
        }
    }
}

public class AllocatePublicIpAddressResponseBody : Tea.TeaModel {
    public var ipAddress: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipAddress != nil {
            map["IpAddress"] = self.ipAddress!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IpAddress"] as? String {
            self.ipAddress = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AllocatePublicIpAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AllocatePublicIpAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AllocatePublicIpAddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ApplyAutoSnapshotPolicyRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var autoSnapshotPolicyId: String?

    public var diskIds: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.autoSnapshotPolicyId != nil {
            map["autoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
        }
        if self.diskIds != nil {
            map["diskIds"] = self.diskIds!
        }
        if self.regionId != nil {
            map["regionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["autoSnapshotPolicyId"] as? String {
            self.autoSnapshotPolicyId = value
        }
        if let value = dict["diskIds"] as? String {
            self.diskIds = value
        }
        if let value = dict["regionId"] as? String {
            self.regionId = value
        }
    }
}

public class ApplyAutoSnapshotPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ApplyAutoSnapshotPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyAutoSnapshotPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ApplyAutoSnapshotPolicyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AssignIpv6AddressesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ipv6Address: [String]?

    public var ipv6AddressCount: Int32?

    public var ipv6Prefix: [String]?

    public var ipv6PrefixCount: Int32?

    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipv6Address != nil {
            map["Ipv6Address"] = self.ipv6Address!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.ipv6Prefix != nil {
            map["Ipv6Prefix"] = self.ipv6Prefix!
        }
        if self.ipv6PrefixCount != nil {
            map["Ipv6PrefixCount"] = self.ipv6PrefixCount!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Ipv6Address"] as? [String] {
            self.ipv6Address = value
        }
        if let value = dict["Ipv6AddressCount"] as? Int32 {
            self.ipv6AddressCount = value
        }
        if let value = dict["Ipv6Prefix"] as? [String] {
            self.ipv6Prefix = value
        }
        if let value = dict["Ipv6PrefixCount"] as? Int32 {
            self.ipv6PrefixCount = value
        }
        if let value = dict["NetworkInterfaceId"] as? String {
            self.networkInterfaceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class AssignIpv6AddressesResponseBody : Tea.TeaModel {
    public class Ipv6PrefixSets : Tea.TeaModel {
        public var ipv6Prefix: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6Prefix != nil {
                map["Ipv6Prefix"] = self.ipv6Prefix!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Ipv6Prefix"] as? [String] {
                self.ipv6Prefix = value
            }
        }
    }
    public class Ipv6Sets : Tea.TeaModel {
        public var ipv6Address: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6Address != nil {
                map["Ipv6Address"] = self.ipv6Address!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Ipv6Address"] as? [String] {
                self.ipv6Address = value
            }
        }
    }
    public var ipv6PrefixSets: AssignIpv6AddressesResponseBody.Ipv6PrefixSets?

    public var ipv6Sets: AssignIpv6AddressesResponseBody.Ipv6Sets?

    public var networkInterfaceId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ipv6PrefixSets?.validate()
        try self.ipv6Sets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6PrefixSets != nil {
            map["Ipv6PrefixSets"] = self.ipv6PrefixSets?.toMap()
        }
        if self.ipv6Sets != nil {
            map["Ipv6Sets"] = self.ipv6Sets?.toMap()
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ipv6PrefixSets"] as? [String: Any?] {
            var model = AssignIpv6AddressesResponseBody.Ipv6PrefixSets()
            model.fromMap(value)
            self.ipv6PrefixSets = model
        }
        if let value = dict["Ipv6Sets"] as? [String: Any?] {
            var model = AssignIpv6AddressesResponseBody.Ipv6Sets()
            model.fromMap(value)
            self.ipv6Sets = model
        }
        if let value = dict["NetworkInterfaceId"] as? String {
            self.networkInterfaceId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AssignIpv6AddressesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssignIpv6AddressesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AssignIpv6AddressesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AssignPrivateIpAddressesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ipv4Prefix: [String]?

    public var ipv4PrefixCount: Int32?

    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var privateIpAddress: [String]?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var secondaryPrivateIpAddressCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipv4Prefix != nil {
            map["Ipv4Prefix"] = self.ipv4Prefix!
        }
        if self.ipv4PrefixCount != nil {
            map["Ipv4PrefixCount"] = self.ipv4PrefixCount!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.secondaryPrivateIpAddressCount != nil {
            map["SecondaryPrivateIpAddressCount"] = self.secondaryPrivateIpAddressCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Ipv4Prefix"] as? [String] {
            self.ipv4Prefix = value
        }
        if let value = dict["Ipv4PrefixCount"] as? Int32 {
            self.ipv4PrefixCount = value
        }
        if let value = dict["NetworkInterfaceId"] as? String {
            self.networkInterfaceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PrivateIpAddress"] as? [String] {
            self.privateIpAddress = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecondaryPrivateIpAddressCount"] as? Int32 {
            self.secondaryPrivateIpAddressCount = value
        }
    }
}

public class AssignPrivateIpAddressesResponseBody : Tea.TeaModel {
    public class AssignedPrivateIpAddressesSet : Tea.TeaModel {
        public class Ipv4PrefixSet : Tea.TeaModel {
            public var ipv4Prefixes: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipv4Prefixes != nil {
                    map["Ipv4Prefixes"] = self.ipv4Prefixes!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Ipv4Prefixes"] as? [String] {
                    self.ipv4Prefixes = value
                }
            }
        }
        public class PrivateIpSet : Tea.TeaModel {
            public var privateIpAddress: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.privateIpAddress != nil {
                    map["PrivateIpAddress"] = self.privateIpAddress!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["PrivateIpAddress"] as? [String] {
                    self.privateIpAddress = value
                }
            }
        }
        public var ipv4PrefixSet: AssignPrivateIpAddressesResponseBody.AssignedPrivateIpAddressesSet.Ipv4PrefixSet?

        public var networkInterfaceId: String?

        public var privateIpSet: AssignPrivateIpAddressesResponseBody.AssignedPrivateIpAddressesSet.PrivateIpSet?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.ipv4PrefixSet?.validate()
            try self.privateIpSet?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv4PrefixSet != nil {
                map["Ipv4PrefixSet"] = self.ipv4PrefixSet?.toMap()
            }
            if self.networkInterfaceId != nil {
                map["NetworkInterfaceId"] = self.networkInterfaceId!
            }
            if self.privateIpSet != nil {
                map["PrivateIpSet"] = self.privateIpSet?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Ipv4PrefixSet"] as? [String: Any?] {
                var model = AssignPrivateIpAddressesResponseBody.AssignedPrivateIpAddressesSet.Ipv4PrefixSet()
                model.fromMap(value)
                self.ipv4PrefixSet = model
            }
            if let value = dict["NetworkInterfaceId"] as? String {
                self.networkInterfaceId = value
            }
            if let value = dict["PrivateIpSet"] as? [String: Any?] {
                var model = AssignPrivateIpAddressesResponseBody.AssignedPrivateIpAddressesSet.PrivateIpSet()
                model.fromMap(value)
                self.privateIpSet = model
            }
        }
    }
    public var assignedPrivateIpAddressesSet: AssignPrivateIpAddressesResponseBody.AssignedPrivateIpAddressesSet?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.assignedPrivateIpAddressesSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assignedPrivateIpAddressesSet != nil {
            map["AssignedPrivateIpAddressesSet"] = self.assignedPrivateIpAddressesSet?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AssignedPrivateIpAddressesSet"] as? [String: Any?] {
            var model = AssignPrivateIpAddressesResponseBody.AssignedPrivateIpAddressesSet()
            model.fromMap(value)
            self.assignedPrivateIpAddressesSet = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AssignPrivateIpAddressesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssignPrivateIpAddressesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AssignPrivateIpAddressesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AssociateEipAddressRequest : Tea.TeaModel {
    public var allocationId: String?

    public var instanceId: String?

    public var instanceType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AllocationId"] as? String {
            self.allocationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class AssociateEipAddressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AssociateEipAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateEipAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AssociateEipAddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AssociateHaVipRequest : Tea.TeaModel {
    public var clientToken: String?

    public var haVipId: String?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.haVipId != nil {
            map["HaVipId"] = self.haVipId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["HaVipId"] as? String {
            self.haVipId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class AssociateHaVipResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AssociateHaVipResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateHaVipResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AssociateHaVipResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AttachClassicLinkVpcRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class AttachClassicLinkVpcResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AttachClassicLinkVpcResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachClassicLinkVpcResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AttachClassicLinkVpcResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AttachDiskRequest : Tea.TeaModel {
    public var bootable: Bool?

    public var deleteWithInstance: Bool?

    public var device: String?

    public var diskId: String?

    public var force: Bool?

    public var instanceId: String?

    public var keyPairName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var password: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bootable != nil {
            map["Bootable"] = self.bootable!
        }
        if self.deleteWithInstance != nil {
            map["DeleteWithInstance"] = self.deleteWithInstance!
        }
        if self.device != nil {
            map["Device"] = self.device!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Bootable"] as? Bool {
            self.bootable = value
        }
        if let value = dict["DeleteWithInstance"] as? Bool {
            self.deleteWithInstance = value
        }
        if let value = dict["Device"] as? String {
            self.device = value
        }
        if let value = dict["DiskId"] as? String {
            self.diskId = value
        }
        if let value = dict["Force"] as? Bool {
            self.force = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Password"] as? String {
            self.password = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class AttachDiskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AttachDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AttachDiskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AttachInstanceRamRoleRequest : Tea.TeaModel {
    public var instanceIds: String?

    public var ownerId: Int64?

    public var policy: String?

    public var ramRoleName: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Policy"] as? String {
            self.policy = value
        }
        if let value = dict["RamRoleName"] as? String {
            self.ramRoleName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class AttachInstanceRamRoleResponseBody : Tea.TeaModel {
    public class AttachInstanceRamRoleResults : Tea.TeaModel {
        public class AttachInstanceRamRoleResult : Tea.TeaModel {
            public var code: String?

            public var instanceId: String?

            public var message: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Code"] as? String {
                    self.code = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["Message"] as? String {
                    self.message = value
                }
                if let value = dict["Success"] as? Bool {
                    self.success = value
                }
            }
        }
        public var attachInstanceRamRoleResult: [AttachInstanceRamRoleResponseBody.AttachInstanceRamRoleResults.AttachInstanceRamRoleResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attachInstanceRamRoleResult != nil {
                var tmp : [Any] = []
                for k in self.attachInstanceRamRoleResult! {
                    tmp.append(k.toMap())
                }
                map["AttachInstanceRamRoleResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AttachInstanceRamRoleResult"] as? [Any?] {
                var tmp : [AttachInstanceRamRoleResponseBody.AttachInstanceRamRoleResults.AttachInstanceRamRoleResult] = []
                for v in value {
                    if v != nil {
                        var model = AttachInstanceRamRoleResponseBody.AttachInstanceRamRoleResults.AttachInstanceRamRoleResult()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.attachInstanceRamRoleResult = tmp
            }
        }
    }
    public var attachInstanceRamRoleResults: AttachInstanceRamRoleResponseBody.AttachInstanceRamRoleResults?

    public var failCount: Int32?

    public var ramRoleName: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.attachInstanceRamRoleResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachInstanceRamRoleResults != nil {
            map["AttachInstanceRamRoleResults"] = self.attachInstanceRamRoleResults?.toMap()
        }
        if self.failCount != nil {
            map["FailCount"] = self.failCount!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AttachInstanceRamRoleResults"] as? [String: Any?] {
            var model = AttachInstanceRamRoleResponseBody.AttachInstanceRamRoleResults()
            model.fromMap(value)
            self.attachInstanceRamRoleResults = model
        }
        if let value = dict["FailCount"] as? Int32 {
            self.failCount = value
        }
        if let value = dict["RamRoleName"] as? String {
            self.ramRoleName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class AttachInstanceRamRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachInstanceRamRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AttachInstanceRamRoleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AttachKeyPairRequest : Tea.TeaModel {
    public var instanceIds: String?

    public var keyPairName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class AttachKeyPairResponseBody : Tea.TeaModel {
    public class Results : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var code: String?

            public var instanceId: String?

            public var message: String?

            public var success: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Code"] as? String {
                    self.code = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["Message"] as? String {
                    self.message = value
                }
                if let value = dict["Success"] as? String {
                    self.success = value
                }
            }
        }
        public var result: [AttachKeyPairResponseBody.Results.Result]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Result"] as? [Any?] {
                var tmp : [AttachKeyPairResponseBody.Results.Result] = []
                for v in value {
                    if v != nil {
                        var model = AttachKeyPairResponseBody.Results.Result()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.result = tmp
            }
        }
    }
    public var failCount: String?

    public var keyPairName: String?

    public var requestId: String?

    public var results: AttachKeyPairResponseBody.Results?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.results?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failCount != nil {
            map["FailCount"] = self.failCount!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.results != nil {
            map["Results"] = self.results?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FailCount"] as? String {
            self.failCount = value
        }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Results"] as? [String: Any?] {
            var model = AttachKeyPairResponseBody.Results()
            model.fromMap(value)
            self.results = model
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
    }
}

public class AttachKeyPairResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachKeyPairResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AttachKeyPairResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AttachNetworkInterfaceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var networkCardIndex: Int32?

    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var trunkNetworkInstanceId: String?

    public var waitForNetworkConfigurationReady: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.networkCardIndex != nil {
            map["NetworkCardIndex"] = self.networkCardIndex!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.trunkNetworkInstanceId != nil {
            map["TrunkNetworkInstanceId"] = self.trunkNetworkInstanceId!
        }
        if self.waitForNetworkConfigurationReady != nil {
            map["WaitForNetworkConfigurationReady"] = self.waitForNetworkConfigurationReady!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NetworkCardIndex"] as? Int32 {
            self.networkCardIndex = value
        }
        if let value = dict["NetworkInterfaceId"] as? String {
            self.networkInterfaceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TrunkNetworkInstanceId"] as? String {
            self.trunkNetworkInstanceId = value
        }
        if let value = dict["WaitForNetworkConfigurationReady"] as? Bool {
            self.waitForNetworkConfigurationReady = value
        }
    }
}

public class AttachNetworkInterfaceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AttachNetworkInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachNetworkInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AttachNetworkInterfaceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AuthorizeSecurityGroupRequest : Tea.TeaModel {
    public class Permissions : Tea.TeaModel {
        public var description_: String?

        public var destCidrIp: String?

        public var ipProtocol: String?

        public var ipv6DestCidrIp: String?

        public var ipv6SourceCidrIp: String?

        public var nicType: String?

        public var policy: String?

        public var portRange: String?

        public var portRangeListId: String?

        public var priority: String?

        public var sourceCidrIp: String?

        public var sourceGroupId: String?

        public var sourceGroupOwnerAccount: String?

        public var sourceGroupOwnerId: Int64?

        public var sourcePortRange: String?

        public var sourcePrefixListId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.destCidrIp != nil {
                map["DestCidrIp"] = self.destCidrIp!
            }
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.ipv6DestCidrIp != nil {
                map["Ipv6DestCidrIp"] = self.ipv6DestCidrIp!
            }
            if self.ipv6SourceCidrIp != nil {
                map["Ipv6SourceCidrIp"] = self.ipv6SourceCidrIp!
            }
            if self.nicType != nil {
                map["NicType"] = self.nicType!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            if self.portRangeListId != nil {
                map["PortRangeListId"] = self.portRangeListId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.sourceCidrIp != nil {
                map["SourceCidrIp"] = self.sourceCidrIp!
            }
            if self.sourceGroupId != nil {
                map["SourceGroupId"] = self.sourceGroupId!
            }
            if self.sourceGroupOwnerAccount != nil {
                map["SourceGroupOwnerAccount"] = self.sourceGroupOwnerAccount!
            }
            if self.sourceGroupOwnerId != nil {
                map["SourceGroupOwnerId"] = self.sourceGroupOwnerId!
            }
            if self.sourcePortRange != nil {
                map["SourcePortRange"] = self.sourcePortRange!
            }
            if self.sourcePrefixListId != nil {
                map["SourcePrefixListId"] = self.sourcePrefixListId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DestCidrIp"] as? String {
                self.destCidrIp = value
            }
            if let value = dict["IpProtocol"] as? String {
                self.ipProtocol = value
            }
            if let value = dict["Ipv6DestCidrIp"] as? String {
                self.ipv6DestCidrIp = value
            }
            if let value = dict["Ipv6SourceCidrIp"] as? String {
                self.ipv6SourceCidrIp = value
            }
            if let value = dict["NicType"] as? String {
                self.nicType = value
            }
            if let value = dict["Policy"] as? String {
                self.policy = value
            }
            if let value = dict["PortRange"] as? String {
                self.portRange = value
            }
            if let value = dict["PortRangeListId"] as? String {
                self.portRangeListId = value
            }
            if let value = dict["Priority"] as? String {
                self.priority = value
            }
            if let value = dict["SourceCidrIp"] as? String {
                self.sourceCidrIp = value
            }
            if let value = dict["SourceGroupId"] as? String {
                self.sourceGroupId = value
            }
            if let value = dict["SourceGroupOwnerAccount"] as? String {
                self.sourceGroupOwnerAccount = value
            }
            if let value = dict["SourceGroupOwnerId"] as? Int64 {
                self.sourceGroupOwnerId = value
            }
            if let value = dict["SourcePortRange"] as? String {
                self.sourcePortRange = value
            }
            if let value = dict["SourcePrefixListId"] as? String {
                self.sourcePrefixListId = value
            }
        }
    }
    public var clientToken: String?

    public var description_: String?

    public var destCidrIp: String?

    public var ipProtocol: String?

    public var ipv6DestCidrIp: String?

    public var ipv6SourceCidrIp: String?

    public var nicType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var permissions: [AuthorizeSecurityGroupRequest.Permissions]?

    public var policy: String?

    public var portRange: String?

    public var priority: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public var sourceCidrIp: String?

    public var sourceGroupId: String?

    public var sourceGroupOwnerAccount: String?

    public var sourceGroupOwnerId: Int64?

    public var sourcePortRange: String?

    public var sourcePrefixListId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destCidrIp != nil {
            map["DestCidrIp"] = self.destCidrIp!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.ipv6DestCidrIp != nil {
            map["Ipv6DestCidrIp"] = self.ipv6DestCidrIp!
        }
        if self.ipv6SourceCidrIp != nil {
            map["Ipv6SourceCidrIp"] = self.ipv6SourceCidrIp!
        }
        if self.nicType != nil {
            map["NicType"] = self.nicType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.permissions != nil {
            var tmp : [Any] = []
            for k in self.permissions! {
                tmp.append(k.toMap())
            }
            map["Permissions"] = tmp
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.sourceCidrIp != nil {
            map["SourceCidrIp"] = self.sourceCidrIp!
        }
        if self.sourceGroupId != nil {
            map["SourceGroupId"] = self.sourceGroupId!
        }
        if self.sourceGroupOwnerAccount != nil {
            map["SourceGroupOwnerAccount"] = self.sourceGroupOwnerAccount!
        }
        if self.sourceGroupOwnerId != nil {
            map["SourceGroupOwnerId"] = self.sourceGroupOwnerId!
        }
        if self.sourcePortRange != nil {
            map["SourcePortRange"] = self.sourcePortRange!
        }
        if self.sourcePrefixListId != nil {
            map["SourcePrefixListId"] = self.sourcePrefixListId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DestCidrIp"] as? String {
            self.destCidrIp = value
        }
        if let value = dict["IpProtocol"] as? String {
            self.ipProtocol = value
        }
        if let value = dict["Ipv6DestCidrIp"] as? String {
            self.ipv6DestCidrIp = value
        }
        if let value = dict["Ipv6SourceCidrIp"] as? String {
            self.ipv6SourceCidrIp = value
        }
        if let value = dict["NicType"] as? String {
            self.nicType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Permissions"] as? [Any?] {
            var tmp : [AuthorizeSecurityGroupRequest.Permissions] = []
            for v in value {
                if v != nil {
                    var model = AuthorizeSecurityGroupRequest.Permissions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.permissions = tmp
        }
        if let value = dict["Policy"] as? String {
            self.policy = value
        }
        if let value = dict["PortRange"] as? String {
            self.portRange = value
        }
        if let value = dict["Priority"] as? String {
            self.priority = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SourceCidrIp"] as? String {
            self.sourceCidrIp = value
        }
        if let value = dict["SourceGroupId"] as? String {
            self.sourceGroupId = value
        }
        if let value = dict["SourceGroupOwnerAccount"] as? String {
            self.sourceGroupOwnerAccount = value
        }
        if let value = dict["SourceGroupOwnerId"] as? Int64 {
            self.sourceGroupOwnerId = value
        }
        if let value = dict["SourcePortRange"] as? String {
            self.sourcePortRange = value
        }
        if let value = dict["SourcePrefixListId"] as? String {
            self.sourcePrefixListId = value
        }
    }
}

public class AuthorizeSecurityGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AuthorizeSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AuthorizeSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AuthorizeSecurityGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AuthorizeSecurityGroupEgressRequest : Tea.TeaModel {
    public class Permissions : Tea.TeaModel {
        public var description_: String?

        public var destCidrIp: String?

        public var destGroupId: String?

        public var destGroupOwnerAccount: String?

        public var destGroupOwnerId: Int64?

        public var destPrefixListId: String?

        public var ipProtocol: String?

        public var ipv6DestCidrIp: String?

        public var ipv6SourceCidrIp: String?

        public var nicType: String?

        public var policy: String?

        public var portRange: String?

        public var portRangeListId: String?

        public var priority: String?

        public var sourceCidrIp: String?

        public var sourcePortRange: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.destCidrIp != nil {
                map["DestCidrIp"] = self.destCidrIp!
            }
            if self.destGroupId != nil {
                map["DestGroupId"] = self.destGroupId!
            }
            if self.destGroupOwnerAccount != nil {
                map["DestGroupOwnerAccount"] = self.destGroupOwnerAccount!
            }
            if self.destGroupOwnerId != nil {
                map["DestGroupOwnerId"] = self.destGroupOwnerId!
            }
            if self.destPrefixListId != nil {
                map["DestPrefixListId"] = self.destPrefixListId!
            }
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.ipv6DestCidrIp != nil {
                map["Ipv6DestCidrIp"] = self.ipv6DestCidrIp!
            }
            if self.ipv6SourceCidrIp != nil {
                map["Ipv6SourceCidrIp"] = self.ipv6SourceCidrIp!
            }
            if self.nicType != nil {
                map["NicType"] = self.nicType!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            if self.portRangeListId != nil {
                map["PortRangeListId"] = self.portRangeListId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.sourceCidrIp != nil {
                map["SourceCidrIp"] = self.sourceCidrIp!
            }
            if self.sourcePortRange != nil {
                map["SourcePortRange"] = self.sourcePortRange!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DestCidrIp"] as? String {
                self.destCidrIp = value
            }
            if let value = dict["DestGroupId"] as? String {
                self.destGroupId = value
            }
            if let value = dict["DestGroupOwnerAccount"] as? String {
                self.destGroupOwnerAccount = value
            }
            if let value = dict["DestGroupOwnerId"] as? Int64 {
                self.destGroupOwnerId = value
            }
            if let value = dict["DestPrefixListId"] as? String {
                self.destPrefixListId = value
            }
            if let value = dict["IpProtocol"] as? String {
                self.ipProtocol = value
            }
            if let value = dict["Ipv6DestCidrIp"] as? String {
                self.ipv6DestCidrIp = value
            }
            if let value = dict["Ipv6SourceCidrIp"] as? String {
                self.ipv6SourceCidrIp = value
            }
            if let value = dict["NicType"] as? String {
                self.nicType = value
            }
            if let value = dict["Policy"] as? String {
                self.policy = value
            }
            if let value = dict["PortRange"] as? String {
                self.portRange = value
            }
            if let value = dict["PortRangeListId"] as? String {
                self.portRangeListId = value
            }
            if let value = dict["Priority"] as? String {
                self.priority = value
            }
            if let value = dict["SourceCidrIp"] as? String {
                self.sourceCidrIp = value
            }
            if let value = dict["SourcePortRange"] as? String {
                self.sourcePortRange = value
            }
        }
    }
    public var clientToken: String?

    public var description_: String?

    public var destCidrIp: String?

    public var destGroupId: String?

    public var destGroupOwnerAccount: String?

    public var destGroupOwnerId: Int64?

    public var destPrefixListId: String?

    public var ipProtocol: String?

    public var ipv6DestCidrIp: String?

    public var ipv6SourceCidrIp: String?

    public var nicType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var permissions: [AuthorizeSecurityGroupEgressRequest.Permissions]?

    public var policy: String?

    public var portRange: String?

    public var priority: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public var sourceCidrIp: String?

    public var sourcePortRange: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destCidrIp != nil {
            map["DestCidrIp"] = self.destCidrIp!
        }
        if self.destGroupId != nil {
            map["DestGroupId"] = self.destGroupId!
        }
        if self.destGroupOwnerAccount != nil {
            map["DestGroupOwnerAccount"] = self.destGroupOwnerAccount!
        }
        if self.destGroupOwnerId != nil {
            map["DestGroupOwnerId"] = self.destGroupOwnerId!
        }
        if self.destPrefixListId != nil {
            map["DestPrefixListId"] = self.destPrefixListId!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.ipv6DestCidrIp != nil {
            map["Ipv6DestCidrIp"] = self.ipv6DestCidrIp!
        }
        if self.ipv6SourceCidrIp != nil {
            map["Ipv6SourceCidrIp"] = self.ipv6SourceCidrIp!
        }
        if self.nicType != nil {
            map["NicType"] = self.nicType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.permissions != nil {
            var tmp : [Any] = []
            for k in self.permissions! {
                tmp.append(k.toMap())
            }
            map["Permissions"] = tmp
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.sourceCidrIp != nil {
            map["SourceCidrIp"] = self.sourceCidrIp!
        }
        if self.sourcePortRange != nil {
            map["SourcePortRange"] = self.sourcePortRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DestCidrIp"] as? String {
            self.destCidrIp = value
        }
        if let value = dict["DestGroupId"] as? String {
            self.destGroupId = value
        }
        if let value = dict["DestGroupOwnerAccount"] as? String {
            self.destGroupOwnerAccount = value
        }
        if let value = dict["DestGroupOwnerId"] as? Int64 {
            self.destGroupOwnerId = value
        }
        if let value = dict["DestPrefixListId"] as? String {
            self.destPrefixListId = value
        }
        if let value = dict["IpProtocol"] as? String {
            self.ipProtocol = value
        }
        if let value = dict["Ipv6DestCidrIp"] as? String {
            self.ipv6DestCidrIp = value
        }
        if let value = dict["Ipv6SourceCidrIp"] as? String {
            self.ipv6SourceCidrIp = value
        }
        if let value = dict["NicType"] as? String {
            self.nicType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Permissions"] as? [Any?] {
            var tmp : [AuthorizeSecurityGroupEgressRequest.Permissions] = []
            for v in value {
                if v != nil {
                    var model = AuthorizeSecurityGroupEgressRequest.Permissions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.permissions = tmp
        }
        if let value = dict["Policy"] as? String {
            self.policy = value
        }
        if let value = dict["PortRange"] as? String {
            self.portRange = value
        }
        if let value = dict["Priority"] as? String {
            self.priority = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SourceCidrIp"] as? String {
            self.sourceCidrIp = value
        }
        if let value = dict["SourcePortRange"] as? String {
            self.sourcePortRange = value
        }
    }
}

public class AuthorizeSecurityGroupEgressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AuthorizeSecurityGroupEgressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AuthorizeSecurityGroupEgressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AuthorizeSecurityGroupEgressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CancelAutoSnapshotPolicyRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var diskIds: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.diskIds != nil {
            map["diskIds"] = self.diskIds!
        }
        if self.regionId != nil {
            map["regionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["diskIds"] as? String {
            self.diskIds = value
        }
        if let value = dict["regionId"] as? String {
            self.regionId = value
        }
    }
}

public class CancelAutoSnapshotPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CancelAutoSnapshotPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelAutoSnapshotPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CancelAutoSnapshotPolicyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CancelCopyImageRequest : Tea.TeaModel {
    public var imageId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CancelCopyImageResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CancelCopyImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelCopyImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CancelCopyImageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CancelImagePipelineExecutionRequest : Tea.TeaModel {
    public class TemplateTag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var executionId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var templateTag: [CancelImagePipelineExecutionRequest.TemplateTag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.executionId != nil {
            map["ExecutionId"] = self.executionId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.templateTag != nil {
            var tmp : [Any] = []
            for k in self.templateTag! {
                tmp.append(k.toMap())
            }
            map["TemplateTag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ExecutionId"] as? String {
            self.executionId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TemplateTag"] as? [Any?] {
            var tmp : [CancelImagePipelineExecutionRequest.TemplateTag] = []
            for v in value {
                if v != nil {
                    var model = CancelImagePipelineExecutionRequest.TemplateTag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.templateTag = tmp
        }
    }
}

public class CancelImagePipelineExecutionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CancelImagePipelineExecutionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelImagePipelineExecutionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CancelImagePipelineExecutionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CancelPhysicalConnectionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userCidr: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PhysicalConnectionId"] as? String {
            self.physicalConnectionId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["UserCidr"] as? String {
            self.userCidr = value
        }
    }
}

public class CancelPhysicalConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CancelPhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelPhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CancelPhysicalConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CancelSimulatedSystemEventsRequest : Tea.TeaModel {
    public var eventId: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EventId"] as? [String] {
            self.eventId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CancelSimulatedSystemEventsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CancelSimulatedSystemEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelSimulatedSystemEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CancelSimulatedSystemEventsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CancelTaskRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class CancelTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CancelTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CancelTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ConnectRouterInterfaceRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerInterfaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouterInterfaceId"] as? String {
            self.routerInterfaceId = value
        }
    }
}

public class ConnectRouterInterfaceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ConnectRouterInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConnectRouterInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ConnectRouterInterfaceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ConvertNatPublicIpToEipRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ConvertNatPublicIpToEipResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ConvertNatPublicIpToEipResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConvertNatPublicIpToEipResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ConvertNatPublicIpToEipResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CopyImageRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var destinationDescription: String?

    public var destinationImageName: String?

    public var destinationRegionId: String?

    public var dryRun: Bool?

    public var encryptAlgorithm: String?

    public var encrypted: Bool?

    public var imageId: String?

    public var KMSKeyId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CopyImageRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.destinationDescription != nil {
            map["DestinationDescription"] = self.destinationDescription!
        }
        if self.destinationImageName != nil {
            map["DestinationImageName"] = self.destinationImageName!
        }
        if self.destinationRegionId != nil {
            map["DestinationRegionId"] = self.destinationRegionId!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.encryptAlgorithm != nil {
            map["EncryptAlgorithm"] = self.encryptAlgorithm!
        }
        if self.encrypted != nil {
            map["Encrypted"] = self.encrypted!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.KMSKeyId != nil {
            map["KMSKeyId"] = self.KMSKeyId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DestinationDescription"] as? String {
            self.destinationDescription = value
        }
        if let value = dict["DestinationImageName"] as? String {
            self.destinationImageName = value
        }
        if let value = dict["DestinationRegionId"] as? String {
            self.destinationRegionId = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["EncryptAlgorithm"] as? String {
            self.encryptAlgorithm = value
        }
        if let value = dict["Encrypted"] as? Bool {
            self.encrypted = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["KMSKeyId"] as? String {
            self.KMSKeyId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CopyImageRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CopyImageRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class CopyImageResponseBody : Tea.TeaModel {
    public var imageId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CopyImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CopyImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CopyImageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CopySnapshotRequest : Tea.TeaModel {
    public class Arn : Tea.TeaModel {
        public var assumeRoleFor: Int64?

        public var roleType: String?

        public var rolearn: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assumeRoleFor != nil {
                map["AssumeRoleFor"] = self.assumeRoleFor!
            }
            if self.roleType != nil {
                map["RoleType"] = self.roleType!
            }
            if self.rolearn != nil {
                map["Rolearn"] = self.rolearn!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AssumeRoleFor"] as? Int64 {
                self.assumeRoleFor = value
            }
            if let value = dict["RoleType"] as? String {
                self.roleType = value
            }
            if let value = dict["Rolearn"] as? String {
                self.rolearn = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var arn: [CopySnapshotRequest.Arn]?

    public var clientToken: String?

    public var destinationRegionId: String?

    public var destinationSnapshotDescription: String?

    public var destinationSnapshotName: String?

    public var destinationStorageLocationArn: String?

    public var encrypted: Bool?

    public var KMSKeyId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var retentionDays: Int32?

    public var snapshotId: String?

    public var tag: [CopySnapshotRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.arn != nil {
            var tmp : [Any] = []
            for k in self.arn! {
                tmp.append(k.toMap())
            }
            map["Arn"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.destinationRegionId != nil {
            map["DestinationRegionId"] = self.destinationRegionId!
        }
        if self.destinationSnapshotDescription != nil {
            map["DestinationSnapshotDescription"] = self.destinationSnapshotDescription!
        }
        if self.destinationSnapshotName != nil {
            map["DestinationSnapshotName"] = self.destinationSnapshotName!
        }
        if self.destinationStorageLocationArn != nil {
            map["DestinationStorageLocationArn"] = self.destinationStorageLocationArn!
        }
        if self.encrypted != nil {
            map["Encrypted"] = self.encrypted!
        }
        if self.KMSKeyId != nil {
            map["KMSKeyId"] = self.KMSKeyId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.retentionDays != nil {
            map["RetentionDays"] = self.retentionDays!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Arn"] as? [Any?] {
            var tmp : [CopySnapshotRequest.Arn] = []
            for v in value {
                if v != nil {
                    var model = CopySnapshotRequest.Arn()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.arn = tmp
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DestinationRegionId"] as? String {
            self.destinationRegionId = value
        }
        if let value = dict["DestinationSnapshotDescription"] as? String {
            self.destinationSnapshotDescription = value
        }
        if let value = dict["DestinationSnapshotName"] as? String {
            self.destinationSnapshotName = value
        }
        if let value = dict["DestinationStorageLocationArn"] as? String {
            self.destinationStorageLocationArn = value
        }
        if let value = dict["Encrypted"] as? Bool {
            self.encrypted = value
        }
        if let value = dict["KMSKeyId"] as? String {
            self.KMSKeyId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RetentionDays"] as? Int32 {
            self.retentionDays = value
        }
        if let value = dict["SnapshotId"] as? String {
            self.snapshotId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CopySnapshotRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CopySnapshotRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class CopySnapshotResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var snapshotId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SnapshotId"] as? String {
            self.snapshotId = value
        }
    }
}

public class CopySnapshotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CopySnapshotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CopySnapshotResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateActivationRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var description_: String?

    public var instanceCount: Int32?

    public var instanceName: String?

    public var ipAddressRange: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateActivationRequest.Tag]?

    public var timeToLiveInHours: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceCount != nil {
            map["InstanceCount"] = self.instanceCount!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.ipAddressRange != nil {
            map["IpAddressRange"] = self.ipAddressRange!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.timeToLiveInHours != nil {
            map["TimeToLiveInHours"] = self.timeToLiveInHours!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["InstanceCount"] as? Int32 {
            self.instanceCount = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["IpAddressRange"] as? String {
            self.ipAddressRange = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateActivationRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateActivationRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["TimeToLiveInHours"] as? Int64 {
            self.timeToLiveInHours = value
        }
    }
}

public class CreateActivationResponseBody : Tea.TeaModel {
    public var activationCode: String?

    public var activationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activationCode != nil {
            map["ActivationCode"] = self.activationCode!
        }
        if self.activationId != nil {
            map["ActivationId"] = self.activationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ActivationCode"] as? String {
            self.activationCode = value
        }
        if let value = dict["ActivationId"] as? String {
            self.activationId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateActivationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateActivationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateActivationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateAutoProvisioningGroupRequest : Tea.TeaModel {
    public class LaunchConfiguration : Tea.TeaModel {
        public class Arn : Tea.TeaModel {
            public var assumeRoleFor: Int64?

            public var roleType: String?

            public var rolearn: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.assumeRoleFor != nil {
                    map["AssumeRoleFor"] = self.assumeRoleFor!
                }
                if self.roleType != nil {
                    map["RoleType"] = self.roleType!
                }
                if self.rolearn != nil {
                    map["Rolearn"] = self.rolearn!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AssumeRoleFor"] as? Int64 {
                    self.assumeRoleFor = value
                }
                if let value = dict["RoleType"] as? String {
                    self.roleType = value
                }
                if let value = dict["Rolearn"] as? String {
                    self.rolearn = value
                }
            }
        }
        public class DataDisk : Tea.TeaModel {
            public var autoSnapshotPolicyId: String?

            public var burstingEnabled: Bool?

            public var category: String?

            public var deleteWithInstance: Bool?

            public var description_: String?

            public var device: String?

            public var diskName: String?

            public var encryptAlgorithm: String?

            public var encrypted: Bool?

            public var kmsKeyId: String?

            public var performanceLevel: String?

            public var provisionedIops: Int64?

            public var size: Int32?

            public var snapshotId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoSnapshotPolicyId != nil {
                    map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
                }
                if self.burstingEnabled != nil {
                    map["BurstingEnabled"] = self.burstingEnabled!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.deleteWithInstance != nil {
                    map["DeleteWithInstance"] = self.deleteWithInstance!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.device != nil {
                    map["Device"] = self.device!
                }
                if self.diskName != nil {
                    map["DiskName"] = self.diskName!
                }
                if self.encryptAlgorithm != nil {
                    map["EncryptAlgorithm"] = self.encryptAlgorithm!
                }
                if self.encrypted != nil {
                    map["Encrypted"] = self.encrypted!
                }
                if self.kmsKeyId != nil {
                    map["KmsKeyId"] = self.kmsKeyId!
                }
                if self.performanceLevel != nil {
                    map["PerformanceLevel"] = self.performanceLevel!
                }
                if self.provisionedIops != nil {
                    map["ProvisionedIops"] = self.provisionedIops!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.snapshotId != nil {
                    map["SnapshotId"] = self.snapshotId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AutoSnapshotPolicyId"] as? String {
                    self.autoSnapshotPolicyId = value
                }
                if let value = dict["BurstingEnabled"] as? Bool {
                    self.burstingEnabled = value
                }
                if let value = dict["Category"] as? String {
                    self.category = value
                }
                if let value = dict["DeleteWithInstance"] as? Bool {
                    self.deleteWithInstance = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Device"] as? String {
                    self.device = value
                }
                if let value = dict["DiskName"] as? String {
                    self.diskName = value
                }
                if let value = dict["EncryptAlgorithm"] as? String {
                    self.encryptAlgorithm = value
                }
                if let value = dict["Encrypted"] as? Bool {
                    self.encrypted = value
                }
                if let value = dict["KmsKeyId"] as? String {
                    self.kmsKeyId = value
                }
                if let value = dict["PerformanceLevel"] as? String {
                    self.performanceLevel = value
                }
                if let value = dict["ProvisionedIops"] as? Int64 {
                    self.provisionedIops = value
                }
                if let value = dict["Size"] as? Int32 {
                    self.size = value
                }
                if let value = dict["SnapshotId"] as? String {
                    self.snapshotId = value
                }
            }
        }
        public class SystemDisk : Tea.TeaModel {
            public var autoSnapshotPolicyId: String?

            public var burstingEnabled: Bool?

            public var encryptAlgorithm: String?

            public var encrypted: String?

            public var KMSKeyId: String?

            public var provisionedIops: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoSnapshotPolicyId != nil {
                    map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
                }
                if self.burstingEnabled != nil {
                    map["BurstingEnabled"] = self.burstingEnabled!
                }
                if self.encryptAlgorithm != nil {
                    map["EncryptAlgorithm"] = self.encryptAlgorithm!
                }
                if self.encrypted != nil {
                    map["Encrypted"] = self.encrypted!
                }
                if self.KMSKeyId != nil {
                    map["KMSKeyId"] = self.KMSKeyId!
                }
                if self.provisionedIops != nil {
                    map["ProvisionedIops"] = self.provisionedIops!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AutoSnapshotPolicyId"] as? String {
                    self.autoSnapshotPolicyId = value
                }
                if let value = dict["BurstingEnabled"] as? Bool {
                    self.burstingEnabled = value
                }
                if let value = dict["EncryptAlgorithm"] as? String {
                    self.encryptAlgorithm = value
                }
                if let value = dict["Encrypted"] as? String {
                    self.encrypted = value
                }
                if let value = dict["KMSKeyId"] as? String {
                    self.KMSKeyId = value
                }
                if let value = dict["ProvisionedIops"] as? Int64 {
                    self.provisionedIops = value
                }
            }
        }
        public class Tag : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public class ImageOptions : Tea.TeaModel {
            public var loginAsNonRoot: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.loginAsNonRoot != nil {
                    map["LoginAsNonRoot"] = self.loginAsNonRoot!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LoginAsNonRoot"] as? Bool {
                    self.loginAsNonRoot = value
                }
            }
        }
        public var arn: [CreateAutoProvisioningGroupRequest.LaunchConfiguration.Arn]?

        public var autoReleaseTime: String?

        public var creditSpecification: String?

        public var dataDisk: [CreateAutoProvisioningGroupRequest.LaunchConfiguration.DataDisk]?

        public var deploymentSetId: String?

        public var hostName: String?

        public var hostNames: [String]?

        public var imageFamily: String?

        public var imageId: String?

        public var instanceDescription: String?

        public var instanceName: String?

        public var internetChargeType: String?

        public var internetMaxBandwidthIn: Int32?

        public var internetMaxBandwidthOut: Int32?

        public var ioOptimized: String?

        public var keyPairName: String?

        public var password: String?

        public var passwordInherit: Bool?

        public var ramRoleName: String?

        public var resourceGroupId: String?

        public var securityEnhancementStrategy: String?

        public var securityGroupId: String?

        public var securityGroupIds: [String]?

        public var systemDisk: CreateAutoProvisioningGroupRequest.LaunchConfiguration.SystemDisk?

        public var systemDiskCategory: String?

        public var systemDiskDescription: String?

        public var systemDiskName: String?

        public var systemDiskPerformanceLevel: String?

        public var systemDiskSize: Int32?

        public var tag: [CreateAutoProvisioningGroupRequest.LaunchConfiguration.Tag]?

        public var userData: String?

        public var autoRenew: Bool?

        public var autoRenewPeriod: Int32?

        public var imageOptions: CreateAutoProvisioningGroupRequest.LaunchConfiguration.ImageOptions?

        public var period: Int32?

        public var periodUnit: String?

        public var spotDuration: Int32?

        public var spotInterruptionBehavior: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.systemDisk?.validate()
            try self.imageOptions?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.arn != nil {
                var tmp : [Any] = []
                for k in self.arn! {
                    tmp.append(k.toMap())
                }
                map["Arn"] = tmp
            }
            if self.autoReleaseTime != nil {
                map["AutoReleaseTime"] = self.autoReleaseTime!
            }
            if self.creditSpecification != nil {
                map["CreditSpecification"] = self.creditSpecification!
            }
            if self.dataDisk != nil {
                var tmp : [Any] = []
                for k in self.dataDisk! {
                    tmp.append(k.toMap())
                }
                map["DataDisk"] = tmp
            }
            if self.deploymentSetId != nil {
                map["DeploymentSetId"] = self.deploymentSetId!
            }
            if self.hostName != nil {
                map["HostName"] = self.hostName!
            }
            if self.hostNames != nil {
                map["HostNames"] = self.hostNames!
            }
            if self.imageFamily != nil {
                map["ImageFamily"] = self.imageFamily!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.instanceDescription != nil {
                map["InstanceDescription"] = self.instanceDescription!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetChargeType != nil {
                map["InternetChargeType"] = self.internetChargeType!
            }
            if self.internetMaxBandwidthIn != nil {
                map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
            }
            if self.internetMaxBandwidthOut != nil {
                map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
            }
            if self.ioOptimized != nil {
                map["IoOptimized"] = self.ioOptimized!
            }
            if self.keyPairName != nil {
                map["KeyPairName"] = self.keyPairName!
            }
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.passwordInherit != nil {
                map["PasswordInherit"] = self.passwordInherit!
            }
            if self.ramRoleName != nil {
                map["RamRoleName"] = self.ramRoleName!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.securityEnhancementStrategy != nil {
                map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.securityGroupIds != nil {
                map["SecurityGroupIds"] = self.securityGroupIds!
            }
            if self.systemDisk != nil {
                map["SystemDisk"] = self.systemDisk?.toMap()
            }
            if self.systemDiskCategory != nil {
                map["SystemDiskCategory"] = self.systemDiskCategory!
            }
            if self.systemDiskDescription != nil {
                map["SystemDiskDescription"] = self.systemDiskDescription!
            }
            if self.systemDiskName != nil {
                map["SystemDiskName"] = self.systemDiskName!
            }
            if self.systemDiskPerformanceLevel != nil {
                map["SystemDiskPerformanceLevel"] = self.systemDiskPerformanceLevel!
            }
            if self.systemDiskSize != nil {
                map["SystemDiskSize"] = self.systemDiskSize!
            }
            if self.tag != nil {
                var tmp : [Any] = []
                for k in self.tag! {
                    tmp.append(k.toMap())
                }
                map["Tag"] = tmp
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            if self.autoRenew != nil {
                map["AutoRenew"] = self.autoRenew!
            }
            if self.autoRenewPeriod != nil {
                map["AutoRenewPeriod"] = self.autoRenewPeriod!
            }
            if self.imageOptions != nil {
                map["ImageOptions"] = self.imageOptions?.toMap()
            }
            if self.period != nil {
                map["Period"] = self.period!
            }
            if self.periodUnit != nil {
                map["PeriodUnit"] = self.periodUnit!
            }
            if self.spotDuration != nil {
                map["SpotDuration"] = self.spotDuration!
            }
            if self.spotInterruptionBehavior != nil {
                map["SpotInterruptionBehavior"] = self.spotInterruptionBehavior!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Arn"] as? [Any?] {
                var tmp : [CreateAutoProvisioningGroupRequest.LaunchConfiguration.Arn] = []
                for v in value {
                    if v != nil {
                        var model = CreateAutoProvisioningGroupRequest.LaunchConfiguration.Arn()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.arn = tmp
            }
            if let value = dict["AutoReleaseTime"] as? String {
                self.autoReleaseTime = value
            }
            if let value = dict["CreditSpecification"] as? String {
                self.creditSpecification = value
            }
            if let value = dict["DataDisk"] as? [Any?] {
                var tmp : [CreateAutoProvisioningGroupRequest.LaunchConfiguration.DataDisk] = []
                for v in value {
                    if v != nil {
                        var model = CreateAutoProvisioningGroupRequest.LaunchConfiguration.DataDisk()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataDisk = tmp
            }
            if let value = dict["DeploymentSetId"] as? String {
                self.deploymentSetId = value
            }
            if let value = dict["HostName"] as? String {
                self.hostName = value
            }
            if let value = dict["HostNames"] as? [String] {
                self.hostNames = value
            }
            if let value = dict["ImageFamily"] as? String {
                self.imageFamily = value
            }
            if let value = dict["ImageId"] as? String {
                self.imageId = value
            }
            if let value = dict["InstanceDescription"] as? String {
                self.instanceDescription = value
            }
            if let value = dict["InstanceName"] as? String {
                self.instanceName = value
            }
            if let value = dict["InternetChargeType"] as? String {
                self.internetChargeType = value
            }
            if let value = dict["InternetMaxBandwidthIn"] as? Int32 {
                self.internetMaxBandwidthIn = value
            }
            if let value = dict["InternetMaxBandwidthOut"] as? Int32 {
                self.internetMaxBandwidthOut = value
            }
            if let value = dict["IoOptimized"] as? String {
                self.ioOptimized = value
            }
            if let value = dict["KeyPairName"] as? String {
                self.keyPairName = value
            }
            if let value = dict["Password"] as? String {
                self.password = value
            }
            if let value = dict["PasswordInherit"] as? Bool {
                self.passwordInherit = value
            }
            if let value = dict["RamRoleName"] as? String {
                self.ramRoleName = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["SecurityEnhancementStrategy"] as? String {
                self.securityEnhancementStrategy = value
            }
            if let value = dict["SecurityGroupId"] as? String {
                self.securityGroupId = value
            }
            if let value = dict["SecurityGroupIds"] as? [String] {
                self.securityGroupIds = value
            }
            if let value = dict["SystemDisk"] as? [String: Any?] {
                var model = CreateAutoProvisioningGroupRequest.LaunchConfiguration.SystemDisk()
                model.fromMap(value)
                self.systemDisk = model
            }
            if let value = dict["SystemDiskCategory"] as? String {
                self.systemDiskCategory = value
            }
            if let value = dict["SystemDiskDescription"] as? String {
                self.systemDiskDescription = value
            }
            if let value = dict["SystemDiskName"] as? String {
                self.systemDiskName = value
            }
            if let value = dict["SystemDiskPerformanceLevel"] as? String {
                self.systemDiskPerformanceLevel = value
            }
            if let value = dict["SystemDiskSize"] as? Int32 {
                self.systemDiskSize = value
            }
            if let value = dict["Tag"] as? [Any?] {
                var tmp : [CreateAutoProvisioningGroupRequest.LaunchConfiguration.Tag] = []
                for v in value {
                    if v != nil {
                        var model = CreateAutoProvisioningGroupRequest.LaunchConfiguration.Tag()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tag = tmp
            }
            if let value = dict["UserData"] as? String {
                self.userData = value
            }
            if let value = dict["AutoRenew"] as? Bool {
                self.autoRenew = value
            }
            if let value = dict["AutoRenewPeriod"] as? Int32 {
                self.autoRenewPeriod = value
            }
            if let value = dict["ImageOptions"] as? [String: Any?] {
                var model = CreateAutoProvisioningGroupRequest.LaunchConfiguration.ImageOptions()
                model.fromMap(value)
                self.imageOptions = model
            }
            if let value = dict["Period"] as? Int32 {
                self.period = value
            }
            if let value = dict["PeriodUnit"] as? String {
                self.periodUnit = value
            }
            if let value = dict["SpotDuration"] as? Int32 {
                self.spotDuration = value
            }
            if let value = dict["SpotInterruptionBehavior"] as? String {
                self.spotInterruptionBehavior = value
            }
        }
    }
    public class DataDiskConfig : Tea.TeaModel {
        public var diskCategory: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diskCategory != nil {
                map["DiskCategory"] = self.diskCategory!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DiskCategory"] as? String {
                self.diskCategory = value
            }
        }
    }
    public class LaunchTemplateConfig : Tea.TeaModel {
        public var architectures: [String]?

        public var burstablePerformance: String?

        public var cores: [Int32]?

        public var excludedInstanceTypes: [String]?

        public var imageId: String?

        public var instanceFamilyLevel: String?

        public var instanceType: String?

        public var maxPrice: Double?

        public var maxQuantity: Int32?

        public var memories: [Double]?

        public var priority: Int32?

        public var vSwitchId: String?

        public var weightedCapacity: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.architectures != nil {
                map["Architectures"] = self.architectures!
            }
            if self.burstablePerformance != nil {
                map["BurstablePerformance"] = self.burstablePerformance!
            }
            if self.cores != nil {
                map["Cores"] = self.cores!
            }
            if self.excludedInstanceTypes != nil {
                map["ExcludedInstanceTypes"] = self.excludedInstanceTypes!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.instanceFamilyLevel != nil {
                map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.maxPrice != nil {
                map["MaxPrice"] = self.maxPrice!
            }
            if self.maxQuantity != nil {
                map["MaxQuantity"] = self.maxQuantity!
            }
            if self.memories != nil {
                map["Memories"] = self.memories!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Architectures"] as? [String] {
                self.architectures = value
            }
            if let value = dict["BurstablePerformance"] as? String {
                self.burstablePerformance = value
            }
            if let value = dict["Cores"] as? [Int32] {
                self.cores = value
            }
            if let value = dict["ExcludedInstanceTypes"] as? [String] {
                self.excludedInstanceTypes = value
            }
            if let value = dict["ImageId"] as? String {
                self.imageId = value
            }
            if let value = dict["InstanceFamilyLevel"] as? String {
                self.instanceFamilyLevel = value
            }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["MaxPrice"] as? Double {
                self.maxPrice = value
            }
            if let value = dict["MaxQuantity"] as? Int32 {
                self.maxQuantity = value
            }
            if let value = dict["Memories"] as? [Double] {
                self.memories = value
            }
            if let value = dict["Priority"] as? Int32 {
                self.priority = value
            }
            if let value = dict["VSwitchId"] as? String {
                self.vSwitchId = value
            }
            if let value = dict["WeightedCapacity"] as? Double {
                self.weightedCapacity = value
            }
        }
    }
    public class PrePaidOptions : Tea.TeaModel {
        public class SpecifyCapacityDistribution : Tea.TeaModel {
            public var instanceTypes: [String]?

            public var minTargetCapacity: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceTypes != nil {
                    map["InstanceTypes"] = self.instanceTypes!
                }
                if self.minTargetCapacity != nil {
                    map["MinTargetCapacity"] = self.minTargetCapacity!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["InstanceTypes"] as? [String] {
                    self.instanceTypes = value
                }
                if let value = dict["MinTargetCapacity"] as? Int32 {
                    self.minTargetCapacity = value
                }
            }
        }
        public var specifyCapacityDistribution: [CreateAutoProvisioningGroupRequest.PrePaidOptions.SpecifyCapacityDistribution]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.specifyCapacityDistribution != nil {
                var tmp : [Any] = []
                for k in self.specifyCapacityDistribution! {
                    tmp.append(k.toMap())
                }
                map["SpecifyCapacityDistribution"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SpecifyCapacityDistribution"] as? [Any?] {
                var tmp : [CreateAutoProvisioningGroupRequest.PrePaidOptions.SpecifyCapacityDistribution] = []
                for v in value {
                    if v != nil {
                        var model = CreateAutoProvisioningGroupRequest.PrePaidOptions.SpecifyCapacityDistribution()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.specifyCapacityDistribution = tmp
            }
        }
    }
    public class ResourcePoolOptions : Tea.TeaModel {
        public var privatePoolIds: [String]?

        public var strategy: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.privatePoolIds != nil {
                map["PrivatePoolIds"] = self.privatePoolIds!
            }
            if self.strategy != nil {
                map["Strategy"] = self.strategy!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PrivatePoolIds"] as? [String] {
                self.privatePoolIds = value
            }
            if let value = dict["Strategy"] as? String {
                self.strategy = value
            }
        }
    }
    public class SystemDiskConfig : Tea.TeaModel {
        public var diskCategory: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diskCategory != nil {
                map["DiskCategory"] = self.diskCategory!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DiskCategory"] as? String {
                self.diskCategory = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var launchConfiguration: CreateAutoProvisioningGroupRequest.LaunchConfiguration?

    public var autoProvisioningGroupName: String?

    public var autoProvisioningGroupType: String?

    public var clientToken: String?

    public var dataDiskConfig: [CreateAutoProvisioningGroupRequest.DataDiskConfig]?

    public var defaultTargetCapacityType: String?

    public var description_: String?

    public var excessCapacityTerminationPolicy: String?

    public var hibernationOptionsConfigured: Bool?

    public var launchTemplateConfig: [CreateAutoProvisioningGroupRequest.LaunchTemplateConfig]?

    public var launchTemplateId: String?

    public var launchTemplateVersion: String?

    public var maxSpotPrice: Double?

    public var minTargetCapacity: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var payAsYouGoAllocationStrategy: String?

    public var payAsYouGoTargetCapacity: String?

    public var prePaidOptions: CreateAutoProvisioningGroupRequest.PrePaidOptions?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourcePoolOptions: CreateAutoProvisioningGroupRequest.ResourcePoolOptions?

    public var spotAllocationStrategy: String?

    public var spotInstanceInterruptionBehavior: String?

    public var spotInstancePoolsToUseCount: Int32?

    public var spotTargetCapacity: String?

    public var systemDiskConfig: [CreateAutoProvisioningGroupRequest.SystemDiskConfig]?

    public var tag: [CreateAutoProvisioningGroupRequest.Tag]?

    public var terminateInstances: Bool?

    public var terminateInstancesWithExpiration: Bool?

    public var totalTargetCapacity: String?

    public var validFrom: String?

    public var validUntil: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.launchConfiguration?.validate()
        try self.prePaidOptions?.validate()
        try self.resourcePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.launchConfiguration != nil {
            map["LaunchConfiguration"] = self.launchConfiguration?.toMap()
        }
        if self.autoProvisioningGroupName != nil {
            map["AutoProvisioningGroupName"] = self.autoProvisioningGroupName!
        }
        if self.autoProvisioningGroupType != nil {
            map["AutoProvisioningGroupType"] = self.autoProvisioningGroupType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dataDiskConfig != nil {
            var tmp : [Any] = []
            for k in self.dataDiskConfig! {
                tmp.append(k.toMap())
            }
            map["DataDiskConfig"] = tmp
        }
        if self.defaultTargetCapacityType != nil {
            map["DefaultTargetCapacityType"] = self.defaultTargetCapacityType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.excessCapacityTerminationPolicy != nil {
            map["ExcessCapacityTerminationPolicy"] = self.excessCapacityTerminationPolicy!
        }
        if self.hibernationOptionsConfigured != nil {
            map["HibernationOptionsConfigured"] = self.hibernationOptionsConfigured!
        }
        if self.launchTemplateConfig != nil {
            var tmp : [Any] = []
            for k in self.launchTemplateConfig! {
                tmp.append(k.toMap())
            }
            map["LaunchTemplateConfig"] = tmp
        }
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateVersion != nil {
            map["LaunchTemplateVersion"] = self.launchTemplateVersion!
        }
        if self.maxSpotPrice != nil {
            map["MaxSpotPrice"] = self.maxSpotPrice!
        }
        if self.minTargetCapacity != nil {
            map["MinTargetCapacity"] = self.minTargetCapacity!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.payAsYouGoAllocationStrategy != nil {
            map["PayAsYouGoAllocationStrategy"] = self.payAsYouGoAllocationStrategy!
        }
        if self.payAsYouGoTargetCapacity != nil {
            map["PayAsYouGoTargetCapacity"] = self.payAsYouGoTargetCapacity!
        }
        if self.prePaidOptions != nil {
            map["PrePaidOptions"] = self.prePaidOptions?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourcePoolOptions != nil {
            map["ResourcePoolOptions"] = self.resourcePoolOptions?.toMap()
        }
        if self.spotAllocationStrategy != nil {
            map["SpotAllocationStrategy"] = self.spotAllocationStrategy!
        }
        if self.spotInstanceInterruptionBehavior != nil {
            map["SpotInstanceInterruptionBehavior"] = self.spotInstanceInterruptionBehavior!
        }
        if self.spotInstancePoolsToUseCount != nil {
            map["SpotInstancePoolsToUseCount"] = self.spotInstancePoolsToUseCount!
        }
        if self.spotTargetCapacity != nil {
            map["SpotTargetCapacity"] = self.spotTargetCapacity!
        }
        if self.systemDiskConfig != nil {
            var tmp : [Any] = []
            for k in self.systemDiskConfig! {
                tmp.append(k.toMap())
            }
            map["SystemDiskConfig"] = tmp
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.terminateInstances != nil {
            map["TerminateInstances"] = self.terminateInstances!
        }
        if self.terminateInstancesWithExpiration != nil {
            map["TerminateInstancesWithExpiration"] = self.terminateInstancesWithExpiration!
        }
        if self.totalTargetCapacity != nil {
            map["TotalTargetCapacity"] = self.totalTargetCapacity!
        }
        if self.validFrom != nil {
            map["ValidFrom"] = self.validFrom!
        }
        if self.validUntil != nil {
            map["ValidUntil"] = self.validUntil!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LaunchConfiguration"] as? [String: Any?] {
            var model = CreateAutoProvisioningGroupRequest.LaunchConfiguration()
            model.fromMap(value)
            self.launchConfiguration = model
        }
        if let value = dict["AutoProvisioningGroupName"] as? String {
            self.autoProvisioningGroupName = value
        }
        if let value = dict["AutoProvisioningGroupType"] as? String {
            self.autoProvisioningGroupType = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DataDiskConfig"] as? [Any?] {
            var tmp : [CreateAutoProvisioningGroupRequest.DataDiskConfig] = []
            for v in value {
                if v != nil {
                    var model = CreateAutoProvisioningGroupRequest.DataDiskConfig()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.dataDiskConfig = tmp
        }
        if let value = dict["DefaultTargetCapacityType"] as? String {
            self.defaultTargetCapacityType = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["ExcessCapacityTerminationPolicy"] as? String {
            self.excessCapacityTerminationPolicy = value
        }
        if let value = dict["HibernationOptionsConfigured"] as? Bool {
            self.hibernationOptionsConfigured = value
        }
        if let value = dict["LaunchTemplateConfig"] as? [Any?] {
            var tmp : [CreateAutoProvisioningGroupRequest.LaunchTemplateConfig] = []
            for v in value {
                if v != nil {
                    var model = CreateAutoProvisioningGroupRequest.LaunchTemplateConfig()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.launchTemplateConfig = tmp
        }
        if let value = dict["LaunchTemplateId"] as? String {
            self.launchTemplateId = value
        }
        if let value = dict["LaunchTemplateVersion"] as? String {
            self.launchTemplateVersion = value
        }
        if let value = dict["MaxSpotPrice"] as? Double {
            self.maxSpotPrice = value
        }
        if let value = dict["MinTargetCapacity"] as? String {
            self.minTargetCapacity = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PayAsYouGoAllocationStrategy"] as? String {
            self.payAsYouGoAllocationStrategy = value
        }
        if let value = dict["PayAsYouGoTargetCapacity"] as? String {
            self.payAsYouGoTargetCapacity = value
        }
        if let value = dict["PrePaidOptions"] as? [String: Any?] {
            var model = CreateAutoProvisioningGroupRequest.PrePaidOptions()
            model.fromMap(value)
            self.prePaidOptions = model
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourcePoolOptions"] as? [String: Any?] {
            var model = CreateAutoProvisioningGroupRequest.ResourcePoolOptions()
            model.fromMap(value)
            self.resourcePoolOptions = model
        }
        if let value = dict["SpotAllocationStrategy"] as? String {
            self.spotAllocationStrategy = value
        }
        if let value = dict["SpotInstanceInterruptionBehavior"] as? String {
            self.spotInstanceInterruptionBehavior = value
        }
        if let value = dict["SpotInstancePoolsToUseCount"] as? Int32 {
            self.spotInstancePoolsToUseCount = value
        }
        if let value = dict["SpotTargetCapacity"] as? String {
            self.spotTargetCapacity = value
        }
        if let value = dict["SystemDiskConfig"] as? [Any?] {
            var tmp : [CreateAutoProvisioningGroupRequest.SystemDiskConfig] = []
            for v in value {
                if v != nil {
                    var model = CreateAutoProvisioningGroupRequest.SystemDiskConfig()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.systemDiskConfig = tmp
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateAutoProvisioningGroupRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateAutoProvisioningGroupRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["TerminateInstances"] as? Bool {
            self.terminateInstances = value
        }
        if let value = dict["TerminateInstancesWithExpiration"] as? Bool {
            self.terminateInstancesWithExpiration = value
        }
        if let value = dict["TotalTargetCapacity"] as? String {
            self.totalTargetCapacity = value
        }
        if let value = dict["ValidFrom"] as? String {
            self.validFrom = value
        }
        if let value = dict["ValidUntil"] as? String {
            self.validUntil = value
        }
    }
}

public class CreateAutoProvisioningGroupShrinkRequest : Tea.TeaModel {
    public class LaunchConfiguration : Tea.TeaModel {
        public class Arn : Tea.TeaModel {
            public var assumeRoleFor: Int64?

            public var roleType: String?

            public var rolearn: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.assumeRoleFor != nil {
                    map["AssumeRoleFor"] = self.assumeRoleFor!
                }
                if self.roleType != nil {
                    map["RoleType"] = self.roleType!
                }
                if self.rolearn != nil {
                    map["Rolearn"] = self.rolearn!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AssumeRoleFor"] as? Int64 {
                    self.assumeRoleFor = value
                }
                if let value = dict["RoleType"] as? String {
                    self.roleType = value
                }
                if let value = dict["Rolearn"] as? String {
                    self.rolearn = value
                }
            }
        }
        public class DataDisk : Tea.TeaModel {
            public var autoSnapshotPolicyId: String?

            public var burstingEnabled: Bool?

            public var category: String?

            public var deleteWithInstance: Bool?

            public var description_: String?

            public var device: String?

            public var diskName: String?

            public var encryptAlgorithm: String?

            public var encrypted: Bool?

            public var kmsKeyId: String?

            public var performanceLevel: String?

            public var provisionedIops: Int64?

            public var size: Int32?

            public var snapshotId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoSnapshotPolicyId != nil {
                    map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
                }
                if self.burstingEnabled != nil {
                    map["BurstingEnabled"] = self.burstingEnabled!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.deleteWithInstance != nil {
                    map["DeleteWithInstance"] = self.deleteWithInstance!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.device != nil {
                    map["Device"] = self.device!
                }
                if self.diskName != nil {
                    map["DiskName"] = self.diskName!
                }
                if self.encryptAlgorithm != nil {
                    map["EncryptAlgorithm"] = self.encryptAlgorithm!
                }
                if self.encrypted != nil {
                    map["Encrypted"] = self.encrypted!
                }
                if self.kmsKeyId != nil {
                    map["KmsKeyId"] = self.kmsKeyId!
                }
                if self.performanceLevel != nil {
                    map["PerformanceLevel"] = self.performanceLevel!
                }
                if self.provisionedIops != nil {
                    map["ProvisionedIops"] = self.provisionedIops!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.snapshotId != nil {
                    map["SnapshotId"] = self.snapshotId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AutoSnapshotPolicyId"] as? String {
                    self.autoSnapshotPolicyId = value
                }
                if let value = dict["BurstingEnabled"] as? Bool {
                    self.burstingEnabled = value
                }
                if let value = dict["Category"] as? String {
                    self.category = value
                }
                if let value = dict["DeleteWithInstance"] as? Bool {
                    self.deleteWithInstance = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Device"] as? String {
                    self.device = value
                }
                if let value = dict["DiskName"] as? String {
                    self.diskName = value
                }
                if let value = dict["EncryptAlgorithm"] as? String {
                    self.encryptAlgorithm = value
                }
                if let value = dict["Encrypted"] as? Bool {
                    self.encrypted = value
                }
                if let value = dict["KmsKeyId"] as? String {
                    self.kmsKeyId = value
                }
                if let value = dict["PerformanceLevel"] as? String {
                    self.performanceLevel = value
                }
                if let value = dict["ProvisionedIops"] as? Int64 {
                    self.provisionedIops = value
                }
                if let value = dict["Size"] as? Int32 {
                    self.size = value
                }
                if let value = dict["SnapshotId"] as? String {
                    self.snapshotId = value
                }
            }
        }
        public class SystemDisk : Tea.TeaModel {
            public var autoSnapshotPolicyId: String?

            public var burstingEnabled: Bool?

            public var encryptAlgorithm: String?

            public var encrypted: String?

            public var KMSKeyId: String?

            public var provisionedIops: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoSnapshotPolicyId != nil {
                    map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
                }
                if self.burstingEnabled != nil {
                    map["BurstingEnabled"] = self.burstingEnabled!
                }
                if self.encryptAlgorithm != nil {
                    map["EncryptAlgorithm"] = self.encryptAlgorithm!
                }
                if self.encrypted != nil {
                    map["Encrypted"] = self.encrypted!
                }
                if self.KMSKeyId != nil {
                    map["KMSKeyId"] = self.KMSKeyId!
                }
                if self.provisionedIops != nil {
                    map["ProvisionedIops"] = self.provisionedIops!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AutoSnapshotPolicyId"] as? String {
                    self.autoSnapshotPolicyId = value
                }
                if let value = dict["BurstingEnabled"] as? Bool {
                    self.burstingEnabled = value
                }
                if let value = dict["EncryptAlgorithm"] as? String {
                    self.encryptAlgorithm = value
                }
                if let value = dict["Encrypted"] as? String {
                    self.encrypted = value
                }
                if let value = dict["KMSKeyId"] as? String {
                    self.KMSKeyId = value
                }
                if let value = dict["ProvisionedIops"] as? Int64 {
                    self.provisionedIops = value
                }
            }
        }
        public class Tag : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public class ImageOptions : Tea.TeaModel {
            public var loginAsNonRoot: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.loginAsNonRoot != nil {
                    map["LoginAsNonRoot"] = self.loginAsNonRoot!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LoginAsNonRoot"] as? Bool {
                    self.loginAsNonRoot = value
                }
            }
        }
        public var arn: [CreateAutoProvisioningGroupShrinkRequest.LaunchConfiguration.Arn]?

        public var autoReleaseTime: String?

        public var creditSpecification: String?

        public var dataDisk: [CreateAutoProvisioningGroupShrinkRequest.LaunchConfiguration.DataDisk]?

        public var deploymentSetId: String?

        public var hostName: String?

        public var hostNames: [String]?

        public var imageFamily: String?

        public var imageId: String?

        public var instanceDescription: String?

        public var instanceName: String?

        public var internetChargeType: String?

        public var internetMaxBandwidthIn: Int32?

        public var internetMaxBandwidthOut: Int32?

        public var ioOptimized: String?

        public var keyPairName: String?

        public var password: String?

        public var passwordInherit: Bool?

        public var ramRoleName: String?

        public var resourceGroupId: String?

        public var securityEnhancementStrategy: String?

        public var securityGroupId: String?

        public var securityGroupIds: [String]?

        public var systemDisk: CreateAutoProvisioningGroupShrinkRequest.LaunchConfiguration.SystemDisk?

        public var systemDiskCategory: String?

        public var systemDiskDescription: String?

        public var systemDiskName: String?

        public var systemDiskPerformanceLevel: String?

        public var systemDiskSize: Int32?

        public var tag: [CreateAutoProvisioningGroupShrinkRequest.LaunchConfiguration.Tag]?

        public var userData: String?

        public var autoRenew: Bool?

        public var autoRenewPeriod: Int32?

        public var imageOptions: CreateAutoProvisioningGroupShrinkRequest.LaunchConfiguration.ImageOptions?

        public var period: Int32?

        public var periodUnit: String?

        public var spotDuration: Int32?

        public var spotInterruptionBehavior: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.systemDisk?.validate()
            try self.imageOptions?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.arn != nil {
                var tmp : [Any] = []
                for k in self.arn! {
                    tmp.append(k.toMap())
                }
                map["Arn"] = tmp
            }
            if self.autoReleaseTime != nil {
                map["AutoReleaseTime"] = self.autoReleaseTime!
            }
            if self.creditSpecification != nil {
                map["CreditSpecification"] = self.creditSpecification!
            }
            if self.dataDisk != nil {
                var tmp : [Any] = []
                for k in self.dataDisk! {
                    tmp.append(k.toMap())
                }
                map["DataDisk"] = tmp
            }
            if self.deploymentSetId != nil {
                map["DeploymentSetId"] = self.deploymentSetId!
            }
            if self.hostName != nil {
                map["HostName"] = self.hostName!
            }
            if self.hostNames != nil {
                map["HostNames"] = self.hostNames!
            }
            if self.imageFamily != nil {
                map["ImageFamily"] = self.imageFamily!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.instanceDescription != nil {
                map["InstanceDescription"] = self.instanceDescription!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetChargeType != nil {
                map["InternetChargeType"] = self.internetChargeType!
            }
            if self.internetMaxBandwidthIn != nil {
                map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
            }
            if self.internetMaxBandwidthOut != nil {
                map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
            }
            if self.ioOptimized != nil {
                map["IoOptimized"] = self.ioOptimized!
            }
            if self.keyPairName != nil {
                map["KeyPairName"] = self.keyPairName!
            }
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.passwordInherit != nil {
                map["PasswordInherit"] = self.passwordInherit!
            }
            if self.ramRoleName != nil {
                map["RamRoleName"] = self.ramRoleName!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.securityEnhancementStrategy != nil {
                map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.securityGroupIds != nil {
                map["SecurityGroupIds"] = self.securityGroupIds!
            }
            if self.systemDisk != nil {
                map["SystemDisk"] = self.systemDisk?.toMap()
            }
            if self.systemDiskCategory != nil {
                map["SystemDiskCategory"] = self.systemDiskCategory!
            }
            if self.systemDiskDescription != nil {
                map["SystemDiskDescription"] = self.systemDiskDescription!
            }
            if self.systemDiskName != nil {
                map["SystemDiskName"] = self.systemDiskName!
            }
            if self.systemDiskPerformanceLevel != nil {
                map["SystemDiskPerformanceLevel"] = self.systemDiskPerformanceLevel!
            }
            if self.systemDiskSize != nil {
                map["SystemDiskSize"] = self.systemDiskSize!
            }
            if self.tag != nil {
                var tmp : [Any] = []
                for k in self.tag! {
                    tmp.append(k.toMap())
                }
                map["Tag"] = tmp
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            if self.autoRenew != nil {
                map["AutoRenew"] = self.autoRenew!
            }
            if self.autoRenewPeriod != nil {
                map["AutoRenewPeriod"] = self.autoRenewPeriod!
            }
            if self.imageOptions != nil {
                map["ImageOptions"] = self.imageOptions?.toMap()
            }
            if self.period != nil {
                map["Period"] = self.period!
            }
            if self.periodUnit != nil {
                map["PeriodUnit"] = self.periodUnit!
            }
            if self.spotDuration != nil {
                map["SpotDuration"] = self.spotDuration!
            }
            if self.spotInterruptionBehavior != nil {
                map["SpotInterruptionBehavior"] = self.spotInterruptionBehavior!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Arn"] as? [Any?] {
                var tmp : [CreateAutoProvisioningGroupShrinkRequest.LaunchConfiguration.Arn] = []
                for v in value {
                    if v != nil {
                        var model = CreateAutoProvisioningGroupShrinkRequest.LaunchConfiguration.Arn()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.arn = tmp
            }
            if let value = dict["AutoReleaseTime"] as? String {
                self.autoReleaseTime = value
            }
            if let value = dict["CreditSpecification"] as? String {
                self.creditSpecification = value
            }
            if let value = dict["DataDisk"] as? [Any?] {
                var tmp : [CreateAutoProvisioningGroupShrinkRequest.LaunchConfiguration.DataDisk] = []
                for v in value {
                    if v != nil {
                        var model = CreateAutoProvisioningGroupShrinkRequest.LaunchConfiguration.DataDisk()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataDisk = tmp
            }
            if let value = dict["DeploymentSetId"] as? String {
                self.deploymentSetId = value
            }
            if let value = dict["HostName"] as? String {
                self.hostName = value
            }
            if let value = dict["HostNames"] as? [String] {
                self.hostNames = value
            }
            if let value = dict["ImageFamily"] as? String {
                self.imageFamily = value
            }
            if let value = dict["ImageId"] as? String {
                self.imageId = value
            }
            if let value = dict["InstanceDescription"] as? String {
                self.instanceDescription = value
            }
            if let value = dict["InstanceName"] as? String {
                self.instanceName = value
            }
            if let value = dict["InternetChargeType"] as? String {
                self.internetChargeType = value
            }
            if let value = dict["InternetMaxBandwidthIn"] as? Int32 {
                self.internetMaxBandwidthIn = value
            }
            if let value = dict["InternetMaxBandwidthOut"] as? Int32 {
                self.internetMaxBandwidthOut = value
            }
            if let value = dict["IoOptimized"] as? String {
                self.ioOptimized = value
            }
            if let value = dict["KeyPairName"] as? String {
                self.keyPairName = value
            }
            if let value = dict["Password"] as? String {
                self.password = value
            }
            if let value = dict["PasswordInherit"] as? Bool {
                self.passwordInherit = value
            }
            if let value = dict["RamRoleName"] as? String {
                self.ramRoleName = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["SecurityEnhancementStrategy"] as? String {
                self.securityEnhancementStrategy = value
            }
            if let value = dict["SecurityGroupId"] as? String {
                self.securityGroupId = value
            }
            if let value = dict["SecurityGroupIds"] as? [String] {
                self.securityGroupIds = value
            }
            if let value = dict["SystemDisk"] as? [String: Any?] {
                var model = CreateAutoProvisioningGroupShrinkRequest.LaunchConfiguration.SystemDisk()
                model.fromMap(value)
                self.systemDisk = model
            }
            if let value = dict["SystemDiskCategory"] as? String {
                self.systemDiskCategory = value
            }
            if let value = dict["SystemDiskDescription"] as? String {
                self.systemDiskDescription = value
            }
            if let value = dict["SystemDiskName"] as? String {
                self.systemDiskName = value
            }
            if let value = dict["SystemDiskPerformanceLevel"] as? String {
                self.systemDiskPerformanceLevel = value
            }
            if let value = dict["SystemDiskSize"] as? Int32 {
                self.systemDiskSize = value
            }
            if let value = dict["Tag"] as? [Any?] {
                var tmp : [CreateAutoProvisioningGroupShrinkRequest.LaunchConfiguration.Tag] = []
                for v in value {
                    if v != nil {
                        var model = CreateAutoProvisioningGroupShrinkRequest.LaunchConfiguration.Tag()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tag = tmp
            }
            if let value = dict["UserData"] as? String {
                self.userData = value
            }
            if let value = dict["AutoRenew"] as? Bool {
                self.autoRenew = value
            }
            if let value = dict["AutoRenewPeriod"] as? Int32 {
                self.autoRenewPeriod = value
            }
            if let value = dict["ImageOptions"] as? [String: Any?] {
                var model = CreateAutoProvisioningGroupShrinkRequest.LaunchConfiguration.ImageOptions()
                model.fromMap(value)
                self.imageOptions = model
            }
            if let value = dict["Period"] as? Int32 {
                self.period = value
            }
            if let value = dict["PeriodUnit"] as? String {
                self.periodUnit = value
            }
            if let value = dict["SpotDuration"] as? Int32 {
                self.spotDuration = value
            }
            if let value = dict["SpotInterruptionBehavior"] as? String {
                self.spotInterruptionBehavior = value
            }
        }
    }
    public class DataDiskConfig : Tea.TeaModel {
        public var diskCategory: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diskCategory != nil {
                map["DiskCategory"] = self.diskCategory!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DiskCategory"] as? String {
                self.diskCategory = value
            }
        }
    }
    public class LaunchTemplateConfig : Tea.TeaModel {
        public var architectures: [String]?

        public var burstablePerformance: String?

        public var cores: [Int32]?

        public var excludedInstanceTypes: [String]?

        public var imageId: String?

        public var instanceFamilyLevel: String?

        public var instanceType: String?

        public var maxPrice: Double?

        public var maxQuantity: Int32?

        public var memories: [Double]?

        public var priority: Int32?

        public var vSwitchId: String?

        public var weightedCapacity: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.architectures != nil {
                map["Architectures"] = self.architectures!
            }
            if self.burstablePerformance != nil {
                map["BurstablePerformance"] = self.burstablePerformance!
            }
            if self.cores != nil {
                map["Cores"] = self.cores!
            }
            if self.excludedInstanceTypes != nil {
                map["ExcludedInstanceTypes"] = self.excludedInstanceTypes!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.instanceFamilyLevel != nil {
                map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.maxPrice != nil {
                map["MaxPrice"] = self.maxPrice!
            }
            if self.maxQuantity != nil {
                map["MaxQuantity"] = self.maxQuantity!
            }
            if self.memories != nil {
                map["Memories"] = self.memories!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Architectures"] as? [String] {
                self.architectures = value
            }
            if let value = dict["BurstablePerformance"] as? String {
                self.burstablePerformance = value
            }
            if let value = dict["Cores"] as? [Int32] {
                self.cores = value
            }
            if let value = dict["ExcludedInstanceTypes"] as? [String] {
                self.excludedInstanceTypes = value
            }
            if let value = dict["ImageId"] as? String {
                self.imageId = value
            }
            if let value = dict["InstanceFamilyLevel"] as? String {
                self.instanceFamilyLevel = value
            }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["MaxPrice"] as? Double {
                self.maxPrice = value
            }
            if let value = dict["MaxQuantity"] as? Int32 {
                self.maxQuantity = value
            }
            if let value = dict["Memories"] as? [Double] {
                self.memories = value
            }
            if let value = dict["Priority"] as? Int32 {
                self.priority = value
            }
            if let value = dict["VSwitchId"] as? String {
                self.vSwitchId = value
            }
            if let value = dict["WeightedCapacity"] as? Double {
                self.weightedCapacity = value
            }
        }
    }
    public class PrePaidOptions : Tea.TeaModel {
        public class SpecifyCapacityDistribution : Tea.TeaModel {
            public var instanceTypes: [String]?

            public var minTargetCapacity: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceTypes != nil {
                    map["InstanceTypes"] = self.instanceTypes!
                }
                if self.minTargetCapacity != nil {
                    map["MinTargetCapacity"] = self.minTargetCapacity!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["InstanceTypes"] as? [String] {
                    self.instanceTypes = value
                }
                if let value = dict["MinTargetCapacity"] as? Int32 {
                    self.minTargetCapacity = value
                }
            }
        }
        public var specifyCapacityDistribution: [CreateAutoProvisioningGroupShrinkRequest.PrePaidOptions.SpecifyCapacityDistribution]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.specifyCapacityDistribution != nil {
                var tmp : [Any] = []
                for k in self.specifyCapacityDistribution! {
                    tmp.append(k.toMap())
                }
                map["SpecifyCapacityDistribution"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SpecifyCapacityDistribution"] as? [Any?] {
                var tmp : [CreateAutoProvisioningGroupShrinkRequest.PrePaidOptions.SpecifyCapacityDistribution] = []
                for v in value {
                    if v != nil {
                        var model = CreateAutoProvisioningGroupShrinkRequest.PrePaidOptions.SpecifyCapacityDistribution()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.specifyCapacityDistribution = tmp
            }
        }
    }
    public class SystemDiskConfig : Tea.TeaModel {
        public var diskCategory: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diskCategory != nil {
                map["DiskCategory"] = self.diskCategory!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DiskCategory"] as? String {
                self.diskCategory = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var launchConfiguration: CreateAutoProvisioningGroupShrinkRequest.LaunchConfiguration?

    public var autoProvisioningGroupName: String?

    public var autoProvisioningGroupType: String?

    public var clientToken: String?

    public var dataDiskConfig: [CreateAutoProvisioningGroupShrinkRequest.DataDiskConfig]?

    public var defaultTargetCapacityType: String?

    public var description_: String?

    public var excessCapacityTerminationPolicy: String?

    public var hibernationOptionsConfigured: Bool?

    public var launchTemplateConfig: [CreateAutoProvisioningGroupShrinkRequest.LaunchTemplateConfig]?

    public var launchTemplateId: String?

    public var launchTemplateVersion: String?

    public var maxSpotPrice: Double?

    public var minTargetCapacity: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var payAsYouGoAllocationStrategy: String?

    public var payAsYouGoTargetCapacity: String?

    public var prePaidOptions: CreateAutoProvisioningGroupShrinkRequest.PrePaidOptions?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourcePoolOptionsShrink: String?

    public var spotAllocationStrategy: String?

    public var spotInstanceInterruptionBehavior: String?

    public var spotInstancePoolsToUseCount: Int32?

    public var spotTargetCapacity: String?

    public var systemDiskConfig: [CreateAutoProvisioningGroupShrinkRequest.SystemDiskConfig]?

    public var tag: [CreateAutoProvisioningGroupShrinkRequest.Tag]?

    public var terminateInstances: Bool?

    public var terminateInstancesWithExpiration: Bool?

    public var totalTargetCapacity: String?

    public var validFrom: String?

    public var validUntil: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.launchConfiguration?.validate()
        try self.prePaidOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.launchConfiguration != nil {
            map["LaunchConfiguration"] = self.launchConfiguration?.toMap()
        }
        if self.autoProvisioningGroupName != nil {
            map["AutoProvisioningGroupName"] = self.autoProvisioningGroupName!
        }
        if self.autoProvisioningGroupType != nil {
            map["AutoProvisioningGroupType"] = self.autoProvisioningGroupType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dataDiskConfig != nil {
            var tmp : [Any] = []
            for k in self.dataDiskConfig! {
                tmp.append(k.toMap())
            }
            map["DataDiskConfig"] = tmp
        }
        if self.defaultTargetCapacityType != nil {
            map["DefaultTargetCapacityType"] = self.defaultTargetCapacityType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.excessCapacityTerminationPolicy != nil {
            map["ExcessCapacityTerminationPolicy"] = self.excessCapacityTerminationPolicy!
        }
        if self.hibernationOptionsConfigured != nil {
            map["HibernationOptionsConfigured"] = self.hibernationOptionsConfigured!
        }
        if self.launchTemplateConfig != nil {
            var tmp : [Any] = []
            for k in self.launchTemplateConfig! {
                tmp.append(k.toMap())
            }
            map["LaunchTemplateConfig"] = tmp
        }
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateVersion != nil {
            map["LaunchTemplateVersion"] = self.launchTemplateVersion!
        }
        if self.maxSpotPrice != nil {
            map["MaxSpotPrice"] = self.maxSpotPrice!
        }
        if self.minTargetCapacity != nil {
            map["MinTargetCapacity"] = self.minTargetCapacity!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.payAsYouGoAllocationStrategy != nil {
            map["PayAsYouGoAllocationStrategy"] = self.payAsYouGoAllocationStrategy!
        }
        if self.payAsYouGoTargetCapacity != nil {
            map["PayAsYouGoTargetCapacity"] = self.payAsYouGoTargetCapacity!
        }
        if self.prePaidOptions != nil {
            map["PrePaidOptions"] = self.prePaidOptions?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourcePoolOptionsShrink != nil {
            map["ResourcePoolOptions"] = self.resourcePoolOptionsShrink!
        }
        if self.spotAllocationStrategy != nil {
            map["SpotAllocationStrategy"] = self.spotAllocationStrategy!
        }
        if self.spotInstanceInterruptionBehavior != nil {
            map["SpotInstanceInterruptionBehavior"] = self.spotInstanceInterruptionBehavior!
        }
        if self.spotInstancePoolsToUseCount != nil {
            map["SpotInstancePoolsToUseCount"] = self.spotInstancePoolsToUseCount!
        }
        if self.spotTargetCapacity != nil {
            map["SpotTargetCapacity"] = self.spotTargetCapacity!
        }
        if self.systemDiskConfig != nil {
            var tmp : [Any] = []
            for k in self.systemDiskConfig! {
                tmp.append(k.toMap())
            }
            map["SystemDiskConfig"] = tmp
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.terminateInstances != nil {
            map["TerminateInstances"] = self.terminateInstances!
        }
        if self.terminateInstancesWithExpiration != nil {
            map["TerminateInstancesWithExpiration"] = self.terminateInstancesWithExpiration!
        }
        if self.totalTargetCapacity != nil {
            map["TotalTargetCapacity"] = self.totalTargetCapacity!
        }
        if self.validFrom != nil {
            map["ValidFrom"] = self.validFrom!
        }
        if self.validUntil != nil {
            map["ValidUntil"] = self.validUntil!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LaunchConfiguration"] as? [String: Any?] {
            var model = CreateAutoProvisioningGroupShrinkRequest.LaunchConfiguration()
            model.fromMap(value)
            self.launchConfiguration = model
        }
        if let value = dict["AutoProvisioningGroupName"] as? String {
            self.autoProvisioningGroupName = value
        }
        if let value = dict["AutoProvisioningGroupType"] as? String {
            self.autoProvisioningGroupType = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DataDiskConfig"] as? [Any?] {
            var tmp : [CreateAutoProvisioningGroupShrinkRequest.DataDiskConfig] = []
            for v in value {
                if v != nil {
                    var model = CreateAutoProvisioningGroupShrinkRequest.DataDiskConfig()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.dataDiskConfig = tmp
        }
        if let value = dict["DefaultTargetCapacityType"] as? String {
            self.defaultTargetCapacityType = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["ExcessCapacityTerminationPolicy"] as? String {
            self.excessCapacityTerminationPolicy = value
        }
        if let value = dict["HibernationOptionsConfigured"] as? Bool {
            self.hibernationOptionsConfigured = value
        }
        if let value = dict["LaunchTemplateConfig"] as? [Any?] {
            var tmp : [CreateAutoProvisioningGroupShrinkRequest.LaunchTemplateConfig] = []
            for v in value {
                if v != nil {
                    var model = CreateAutoProvisioningGroupShrinkRequest.LaunchTemplateConfig()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.launchTemplateConfig = tmp
        }
        if let value = dict["LaunchTemplateId"] as? String {
            self.launchTemplateId = value
        }
        if let value = dict["LaunchTemplateVersion"] as? String {
            self.launchTemplateVersion = value
        }
        if let value = dict["MaxSpotPrice"] as? Double {
            self.maxSpotPrice = value
        }
        if let value = dict["MinTargetCapacity"] as? String {
            self.minTargetCapacity = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PayAsYouGoAllocationStrategy"] as? String {
            self.payAsYouGoAllocationStrategy = value
        }
        if let value = dict["PayAsYouGoTargetCapacity"] as? String {
            self.payAsYouGoTargetCapacity = value
        }
        if let value = dict["PrePaidOptions"] as? [String: Any?] {
            var model = CreateAutoProvisioningGroupShrinkRequest.PrePaidOptions()
            model.fromMap(value)
            self.prePaidOptions = model
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourcePoolOptions"] as? String {
            self.resourcePoolOptionsShrink = value
        }
        if let value = dict["SpotAllocationStrategy"] as? String {
            self.spotAllocationStrategy = value
        }
        if let value = dict["SpotInstanceInterruptionBehavior"] as? String {
            self.spotInstanceInterruptionBehavior = value
        }
        if let value = dict["SpotInstancePoolsToUseCount"] as? Int32 {
            self.spotInstancePoolsToUseCount = value
        }
        if let value = dict["SpotTargetCapacity"] as? String {
            self.spotTargetCapacity = value
        }
        if let value = dict["SystemDiskConfig"] as? [Any?] {
            var tmp : [CreateAutoProvisioningGroupShrinkRequest.SystemDiskConfig] = []
            for v in value {
                if v != nil {
                    var model = CreateAutoProvisioningGroupShrinkRequest.SystemDiskConfig()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.systemDiskConfig = tmp
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateAutoProvisioningGroupShrinkRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateAutoProvisioningGroupShrinkRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["TerminateInstances"] as? Bool {
            self.terminateInstances = value
        }
        if let value = dict["TerminateInstancesWithExpiration"] as? Bool {
            self.terminateInstancesWithExpiration = value
        }
        if let value = dict["TotalTargetCapacity"] as? String {
            self.totalTargetCapacity = value
        }
        if let value = dict["ValidFrom"] as? String {
            self.validFrom = value
        }
        if let value = dict["ValidUntil"] as? String {
            self.validUntil = value
        }
    }
}

public class CreateAutoProvisioningGroupResponseBody : Tea.TeaModel {
    public class LaunchResults : Tea.TeaModel {
        public class LaunchResult : Tea.TeaModel {
            public class InstanceIds : Tea.TeaModel {
                public var instanceId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["InstanceId"] as? [String] {
                        self.instanceId = value
                    }
                }
            }
            public var amount: Int32?

            public var errorCode: String?

            public var errorMsg: String?

            public var instanceIds: CreateAutoProvisioningGroupResponseBody.LaunchResults.LaunchResult.InstanceIds?

            public var instanceType: String?

            public var spotStrategy: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.instanceIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["Amount"] = self.amount!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.instanceIds != nil {
                    map["InstanceIds"] = self.instanceIds?.toMap()
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.spotStrategy != nil {
                    map["SpotStrategy"] = self.spotStrategy!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Amount"] as? Int32 {
                    self.amount = value
                }
                if let value = dict["ErrorCode"] as? String {
                    self.errorCode = value
                }
                if let value = dict["ErrorMsg"] as? String {
                    self.errorMsg = value
                }
                if let value = dict["InstanceIds"] as? [String: Any?] {
                    var model = CreateAutoProvisioningGroupResponseBody.LaunchResults.LaunchResult.InstanceIds()
                    model.fromMap(value)
                    self.instanceIds = model
                }
                if let value = dict["InstanceType"] as? String {
                    self.instanceType = value
                }
                if let value = dict["SpotStrategy"] as? String {
                    self.spotStrategy = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var launchResult: [CreateAutoProvisioningGroupResponseBody.LaunchResults.LaunchResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.launchResult != nil {
                var tmp : [Any] = []
                for k in self.launchResult! {
                    tmp.append(k.toMap())
                }
                map["LaunchResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LaunchResult"] as? [Any?] {
                var tmp : [CreateAutoProvisioningGroupResponseBody.LaunchResults.LaunchResult] = []
                for v in value {
                    if v != nil {
                        var model = CreateAutoProvisioningGroupResponseBody.LaunchResults.LaunchResult()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.launchResult = tmp
            }
        }
    }
    public var autoProvisioningGroupId: String?

    public var launchResults: CreateAutoProvisioningGroupResponseBody.LaunchResults?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.launchResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoProvisioningGroupId != nil {
            map["AutoProvisioningGroupId"] = self.autoProvisioningGroupId!
        }
        if self.launchResults != nil {
            map["LaunchResults"] = self.launchResults?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoProvisioningGroupId"] as? String {
            self.autoProvisioningGroupId = value
        }
        if let value = dict["LaunchResults"] as? [String: Any?] {
            var model = CreateAutoProvisioningGroupResponseBody.LaunchResults()
            model.fromMap(value)
            self.launchResults = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateAutoProvisioningGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAutoProvisioningGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateAutoProvisioningGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateAutoSnapshotPolicyRequest : Tea.TeaModel {
    public class CopyEncryptionConfiguration : Tea.TeaModel {
        public class Arn : Tea.TeaModel {
            public var assumeRoleFor: Int64?

            public var roleType: String?

            public var rolearn: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.assumeRoleFor != nil {
                    map["AssumeRoleFor"] = self.assumeRoleFor!
                }
                if self.roleType != nil {
                    map["RoleType"] = self.roleType!
                }
                if self.rolearn != nil {
                    map["Rolearn"] = self.rolearn!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AssumeRoleFor"] as? Int64 {
                    self.assumeRoleFor = value
                }
                if let value = dict["RoleType"] as? String {
                    self.roleType = value
                }
                if let value = dict["Rolearn"] as? String {
                    self.rolearn = value
                }
            }
        }
        public var arn: [CreateAutoSnapshotPolicyRequest.CopyEncryptionConfiguration.Arn]?

        public var encrypted: Bool?

        public var KMSKeyId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.arn != nil {
                var tmp : [Any] = []
                for k in self.arn! {
                    tmp.append(k.toMap())
                }
                map["Arn"] = tmp
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Arn"] as? [Any?] {
                var tmp : [CreateAutoSnapshotPolicyRequest.CopyEncryptionConfiguration.Arn] = []
                for v in value {
                    if v != nil {
                        var model = CreateAutoSnapshotPolicyRequest.CopyEncryptionConfiguration.Arn()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.arn = tmp
            }
            if let value = dict["Encrypted"] as? Bool {
                self.encrypted = value
            }
            if let value = dict["KMSKeyId"] as? String {
                self.KMSKeyId = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var copiedSnapshotsRetentionDays: Int32?

    public var copyEncryptionConfiguration: CreateAutoSnapshotPolicyRequest.CopyEncryptionConfiguration?

    public var enableCrossRegionCopy: Bool?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var storageLocationArn: String?

    public var tag: [CreateAutoSnapshotPolicyRequest.Tag]?

    public var targetCopyRegions: String?

    public var autoSnapshotPolicyName: String?

    public var regionId: String?

    public var repeatWeekdays: String?

    public var retentionDays: Int32?

    public var timePoints: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.copyEncryptionConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.copiedSnapshotsRetentionDays != nil {
            map["CopiedSnapshotsRetentionDays"] = self.copiedSnapshotsRetentionDays!
        }
        if self.copyEncryptionConfiguration != nil {
            map["CopyEncryptionConfiguration"] = self.copyEncryptionConfiguration?.toMap()
        }
        if self.enableCrossRegionCopy != nil {
            map["EnableCrossRegionCopy"] = self.enableCrossRegionCopy!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.storageLocationArn != nil {
            map["StorageLocationArn"] = self.storageLocationArn!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.targetCopyRegions != nil {
            map["TargetCopyRegions"] = self.targetCopyRegions!
        }
        if self.autoSnapshotPolicyName != nil {
            map["autoSnapshotPolicyName"] = self.autoSnapshotPolicyName!
        }
        if self.regionId != nil {
            map["regionId"] = self.regionId!
        }
        if self.repeatWeekdays != nil {
            map["repeatWeekdays"] = self.repeatWeekdays!
        }
        if self.retentionDays != nil {
            map["retentionDays"] = self.retentionDays!
        }
        if self.timePoints != nil {
            map["timePoints"] = self.timePoints!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CopiedSnapshotsRetentionDays"] as? Int32 {
            self.copiedSnapshotsRetentionDays = value
        }
        if let value = dict["CopyEncryptionConfiguration"] as? [String: Any?] {
            var model = CreateAutoSnapshotPolicyRequest.CopyEncryptionConfiguration()
            model.fromMap(value)
            self.copyEncryptionConfiguration = model
        }
        if let value = dict["EnableCrossRegionCopy"] as? Bool {
            self.enableCrossRegionCopy = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StorageLocationArn"] as? String {
            self.storageLocationArn = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateAutoSnapshotPolicyRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateAutoSnapshotPolicyRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["TargetCopyRegions"] as? String {
            self.targetCopyRegions = value
        }
        if let value = dict["autoSnapshotPolicyName"] as? String {
            self.autoSnapshotPolicyName = value
        }
        if let value = dict["regionId"] as? String {
            self.regionId = value
        }
        if let value = dict["repeatWeekdays"] as? String {
            self.repeatWeekdays = value
        }
        if let value = dict["retentionDays"] as? Int32 {
            self.retentionDays = value
        }
        if let value = dict["timePoints"] as? String {
            self.timePoints = value
        }
    }
}

public class CreateAutoSnapshotPolicyResponseBody : Tea.TeaModel {
    public var autoSnapshotPolicyId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoSnapshotPolicyId != nil {
            map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoSnapshotPolicyId"] as? String {
            self.autoSnapshotPolicyId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateAutoSnapshotPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAutoSnapshotPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateAutoSnapshotPolicyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateCapacityReservationRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var matchCriteria: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MatchCriteria"] as? String {
                self.matchCriteria = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var privatePoolOptions: CreateCapacityReservationRequest.PrivatePoolOptions?

    public var clientToken: String?

    public var description_: String?

    public var endTime: String?

    public var endTimeType: String?

    public var instanceAmount: Int32?

    public var instanceType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var platform: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public var tag: [CreateCapacityReservationRequest.Tag]?

    public var zoneId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.endTimeType != nil {
            map["EndTimeType"] = self.endTimeType!
        }
        if self.instanceAmount != nil {
            map["InstanceAmount"] = self.instanceAmount!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PrivatePoolOptions"] as? [String: Any?] {
            var model = CreateCapacityReservationRequest.PrivatePoolOptions()
            model.fromMap(value)
            self.privatePoolOptions = model
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["EndTimeType"] as? String {
            self.endTimeType = value
        }
        if let value = dict["InstanceAmount"] as? Int32 {
            self.instanceAmount = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Platform"] as? String {
            self.platform = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateCapacityReservationRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateCapacityReservationRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["ZoneId"] as? [String] {
            self.zoneId = value
        }
    }
}

public class CreateCapacityReservationResponseBody : Tea.TeaModel {
    public var privatePoolOptionsId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptionsId != nil {
            map["PrivatePoolOptionsId"] = self.privatePoolOptionsId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PrivatePoolOptionsId"] as? String {
            self.privatePoolOptionsId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateCapacityReservationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCapacityReservationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateCapacityReservationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateCommandRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var commandContent: String?

    public var contentEncoding: String?

    public var description_: String?

    public var enableParameter: Bool?

    public var launcher: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateCommandRequest.Tag]?

    public var timeout: Int64?

    public var type: String?

    public var workingDir: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandContent != nil {
            map["CommandContent"] = self.commandContent!
        }
        if self.contentEncoding != nil {
            map["ContentEncoding"] = self.contentEncoding!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enableParameter != nil {
            map["EnableParameter"] = self.enableParameter!
        }
        if self.launcher != nil {
            map["Launcher"] = self.launcher!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.workingDir != nil {
            map["WorkingDir"] = self.workingDir!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CommandContent"] as? String {
            self.commandContent = value
        }
        if let value = dict["ContentEncoding"] as? String {
            self.contentEncoding = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EnableParameter"] as? Bool {
            self.enableParameter = value
        }
        if let value = dict["Launcher"] as? String {
            self.launcher = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateCommandRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateCommandRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["Timeout"] as? Int64 {
            self.timeout = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["WorkingDir"] as? String {
            self.workingDir = value
        }
    }
}

public class CreateCommandResponseBody : Tea.TeaModel {
    public var commandId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandId != nil {
            map["CommandId"] = self.commandId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CommandId"] as? String {
            self.commandId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateCommandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCommandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateCommandResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDedicatedHostClusterRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var dedicatedHostClusterName: String?

    public var description_: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateDedicatedHostClusterRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostClusterName != nil {
            map["DedicatedHostClusterName"] = self.dedicatedHostClusterName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DedicatedHostClusterName"] as? String {
            self.dedicatedHostClusterName = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateDedicatedHostClusterRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateDedicatedHostClusterRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class CreateDedicatedHostClusterResponseBody : Tea.TeaModel {
    public var dedicatedHostClusterId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DedicatedHostClusterId"] as? String {
            self.dedicatedHostClusterId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateDedicatedHostClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDedicatedHostClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDedicatedHostClusterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDeploymentSetRequest : Tea.TeaModel {
    public var clientToken: String?

    public var deploymentSetName: String?

    public var description_: String?

    public var domain: String?

    public var granularity: String?

    public var groupCount: Int64?

    public var onUnableToRedeployFailedInstance: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var strategy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.deploymentSetName != nil {
            map["DeploymentSetName"] = self.deploymentSetName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.granularity != nil {
            map["Granularity"] = self.granularity!
        }
        if self.groupCount != nil {
            map["GroupCount"] = self.groupCount!
        }
        if self.onUnableToRedeployFailedInstance != nil {
            map["OnUnableToRedeployFailedInstance"] = self.onUnableToRedeployFailedInstance!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.strategy != nil {
            map["Strategy"] = self.strategy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DeploymentSetName"] as? String {
            self.deploymentSetName = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["Granularity"] as? String {
            self.granularity = value
        }
        if let value = dict["GroupCount"] as? Int64 {
            self.groupCount = value
        }
        if let value = dict["OnUnableToRedeployFailedInstance"] as? String {
            self.onUnableToRedeployFailedInstance = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Strategy"] as? String {
            self.strategy = value
        }
    }
}

public class CreateDeploymentSetResponseBody : Tea.TeaModel {
    public var deploymentSetId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeploymentSetId"] as? String {
            self.deploymentSetId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateDeploymentSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDeploymentSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDeploymentSetResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDiagnosticMetricSetRequest : Tea.TeaModel {
    public var description_: String?

    public var metricIds: [String]?

    public var metricSetName: String?

    public var regionId: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.metricIds != nil {
            map["MetricIds"] = self.metricIds!
        }
        if self.metricSetName != nil {
            map["MetricSetName"] = self.metricSetName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["MetricIds"] as? [String] {
            self.metricIds = value
        }
        if let value = dict["MetricSetName"] as? String {
            self.metricSetName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class CreateDiagnosticMetricSetResponseBody : Tea.TeaModel {
    public var metricSetId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.metricSetId != nil {
            map["MetricSetId"] = self.metricSetId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MetricSetId"] as? String {
            self.metricSetId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateDiagnosticMetricSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDiagnosticMetricSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDiagnosticMetricSetResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDiagnosticReportRequest : Tea.TeaModel {
    public var endTime: String?

    public var metricSetId: String?

    public var regionId: String?

    public var resourceId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.metricSetId != nil {
            map["MetricSetId"] = self.metricSetId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["MetricSetId"] as? String {
            self.metricSetId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class CreateDiagnosticReportResponseBody : Tea.TeaModel {
    public var reportId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ReportId"] as? String {
            self.reportId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateDiagnosticReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDiagnosticReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDiagnosticReportResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDiskRequest : Tea.TeaModel {
    public class Arn : Tea.TeaModel {
        public var assumeRoleFor: Int64?

        public var roleType: String?

        public var rolearn: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assumeRoleFor != nil {
                map["AssumeRoleFor"] = self.assumeRoleFor!
            }
            if self.roleType != nil {
                map["RoleType"] = self.roleType!
            }
            if self.rolearn != nil {
                map["Rolearn"] = self.rolearn!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AssumeRoleFor"] as? Int64 {
                self.assumeRoleFor = value
            }
            if let value = dict["RoleType"] as? String {
                self.roleType = value
            }
            if let value = dict["Rolearn"] as? String {
                self.rolearn = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var advancedFeatures: String?

    public var arn: [CreateDiskRequest.Arn]?

    public var burstingEnabled: Bool?

    public var clientToken: String?

    public var description_: String?

    public var diskCategory: String?

    public var diskName: String?

    public var encryptAlgorithm: String?

    public var encrypted: Bool?

    public var instanceId: String?

    public var KMSKeyId: String?

    public var multiAttach: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var performanceLevel: String?

    public var provisionedIops: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var size: Int32?

    public var snapshotId: String?

    public var storageClusterId: String?

    public var storageSetId: String?

    public var storageSetPartitionNumber: Int32?

    public var tag: [CreateDiskRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advancedFeatures != nil {
            map["AdvancedFeatures"] = self.advancedFeatures!
        }
        if self.arn != nil {
            var tmp : [Any] = []
            for k in self.arn! {
                tmp.append(k.toMap())
            }
            map["Arn"] = tmp
        }
        if self.burstingEnabled != nil {
            map["BurstingEnabled"] = self.burstingEnabled!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.diskCategory != nil {
            map["DiskCategory"] = self.diskCategory!
        }
        if self.diskName != nil {
            map["DiskName"] = self.diskName!
        }
        if self.encryptAlgorithm != nil {
            map["EncryptAlgorithm"] = self.encryptAlgorithm!
        }
        if self.encrypted != nil {
            map["Encrypted"] = self.encrypted!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.KMSKeyId != nil {
            map["KMSKeyId"] = self.KMSKeyId!
        }
        if self.multiAttach != nil {
            map["MultiAttach"] = self.multiAttach!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.performanceLevel != nil {
            map["PerformanceLevel"] = self.performanceLevel!
        }
        if self.provisionedIops != nil {
            map["ProvisionedIops"] = self.provisionedIops!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        if self.storageClusterId != nil {
            map["StorageClusterId"] = self.storageClusterId!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        if self.storageSetPartitionNumber != nil {
            map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AdvancedFeatures"] as? String {
            self.advancedFeatures = value
        }
        if let value = dict["Arn"] as? [Any?] {
            var tmp : [CreateDiskRequest.Arn] = []
            for v in value {
                if v != nil {
                    var model = CreateDiskRequest.Arn()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.arn = tmp
        }
        if let value = dict["BurstingEnabled"] as? Bool {
            self.burstingEnabled = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DiskCategory"] as? String {
            self.diskCategory = value
        }
        if let value = dict["DiskName"] as? String {
            self.diskName = value
        }
        if let value = dict["EncryptAlgorithm"] as? String {
            self.encryptAlgorithm = value
        }
        if let value = dict["Encrypted"] as? Bool {
            self.encrypted = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["KMSKeyId"] as? String {
            self.KMSKeyId = value
        }
        if let value = dict["MultiAttach"] as? String {
            self.multiAttach = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PerformanceLevel"] as? String {
            self.performanceLevel = value
        }
        if let value = dict["ProvisionedIops"] as? Int64 {
            self.provisionedIops = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Size"] as? Int32 {
            self.size = value
        }
        if let value = dict["SnapshotId"] as? String {
            self.snapshotId = value
        }
        if let value = dict["StorageClusterId"] as? String {
            self.storageClusterId = value
        }
        if let value = dict["StorageSetId"] as? String {
            self.storageSetId = value
        }
        if let value = dict["StorageSetPartitionNumber"] as? Int32 {
            self.storageSetPartitionNumber = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateDiskRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateDiskRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class CreateDiskResponseBody : Tea.TeaModel {
    public var diskId: String?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DiskId"] as? String {
            self.diskId = value
        }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDiskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateElasticityAssuranceRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var matchCriteria: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MatchCriteria"] as? String {
                self.matchCriteria = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
        }
    }
    public class RecurrenceRules : Tea.TeaModel {
        public var endHour: Int32?

        public var recurrenceType: String?

        public var recurrenceValue: String?

        public var startHour: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endHour != nil {
                map["EndHour"] = self.endHour!
            }
            if self.recurrenceType != nil {
                map["RecurrenceType"] = self.recurrenceType!
            }
            if self.recurrenceValue != nil {
                map["RecurrenceValue"] = self.recurrenceValue!
            }
            if self.startHour != nil {
                map["StartHour"] = self.startHour!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EndHour"] as? Int32 {
                self.endHour = value
            }
            if let value = dict["RecurrenceType"] as? String {
                self.recurrenceType = value
            }
            if let value = dict["RecurrenceValue"] as? String {
                self.recurrenceValue = value
            }
            if let value = dict["StartHour"] as? Int32 {
                self.startHour = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var privatePoolOptions: CreateElasticityAssuranceRequest.PrivatePoolOptions?

    public var assuranceTimes: String?

    public var autoRenew: Bool?

    public var autoRenewPeriod: Int32?

    public var clientToken: String?

    public var description_: String?

    public var instanceAmount: Int32?

    public var instanceCpuCoreCount: Int32?

    public var instanceType: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var recurrenceRules: [CreateElasticityAssuranceRequest.RecurrenceRules]?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public var tag: [CreateElasticityAssuranceRequest.Tag]?

    public var zoneId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.assuranceTimes != nil {
            map["AssuranceTimes"] = self.assuranceTimes!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewPeriod != nil {
            map["AutoRenewPeriod"] = self.autoRenewPeriod!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceAmount != nil {
            map["InstanceAmount"] = self.instanceAmount!
        }
        if self.instanceCpuCoreCount != nil {
            map["InstanceCpuCoreCount"] = self.instanceCpuCoreCount!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.recurrenceRules != nil {
            var tmp : [Any] = []
            for k in self.recurrenceRules! {
                tmp.append(k.toMap())
            }
            map["RecurrenceRules"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PrivatePoolOptions"] as? [String: Any?] {
            var model = CreateElasticityAssuranceRequest.PrivatePoolOptions()
            model.fromMap(value)
            self.privatePoolOptions = model
        }
        if let value = dict["AssuranceTimes"] as? String {
            self.assuranceTimes = value
        }
        if let value = dict["AutoRenew"] as? Bool {
            self.autoRenew = value
        }
        if let value = dict["AutoRenewPeriod"] as? Int32 {
            self.autoRenewPeriod = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["InstanceAmount"] as? Int32 {
            self.instanceAmount = value
        }
        if let value = dict["InstanceCpuCoreCount"] as? Int32 {
            self.instanceCpuCoreCount = value
        }
        if let value = dict["InstanceType"] as? [String] {
            self.instanceType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PeriodUnit"] as? String {
            self.periodUnit = value
        }
        if let value = dict["RecurrenceRules"] as? [Any?] {
            var tmp : [CreateElasticityAssuranceRequest.RecurrenceRules] = []
            for v in value {
                if v != nil {
                    var model = CreateElasticityAssuranceRequest.RecurrenceRules()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.recurrenceRules = tmp
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateElasticityAssuranceRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateElasticityAssuranceRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["ZoneId"] as? [String] {
            self.zoneId = value
        }
    }
}

public class CreateElasticityAssuranceResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var privatePoolOptionsId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.privatePoolOptionsId != nil {
            map["PrivatePoolOptionsId"] = self.privatePoolOptionsId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["PrivatePoolOptionsId"] as? String {
            self.privatePoolOptionsId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateElasticityAssuranceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateElasticityAssuranceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateElasticityAssuranceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateForwardEntryRequest : Tea.TeaModel {
    public var externalIp: String?

    public var externalPort: String?

    public var forwardTableId: String?

    public var internalIp: String?

    public var internalPort: String?

    public var ipProtocol: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.externalIp != nil {
            map["ExternalIp"] = self.externalIp!
        }
        if self.externalPort != nil {
            map["ExternalPort"] = self.externalPort!
        }
        if self.forwardTableId != nil {
            map["ForwardTableId"] = self.forwardTableId!
        }
        if self.internalIp != nil {
            map["InternalIp"] = self.internalIp!
        }
        if self.internalPort != nil {
            map["InternalPort"] = self.internalPort!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ExternalIp"] as? String {
            self.externalIp = value
        }
        if let value = dict["ExternalPort"] as? String {
            self.externalPort = value
        }
        if let value = dict["ForwardTableId"] as? String {
            self.forwardTableId = value
        }
        if let value = dict["InternalIp"] as? String {
            self.internalIp = value
        }
        if let value = dict["InternalPort"] as? String {
            self.internalPort = value
        }
        if let value = dict["IpProtocol"] as? String {
            self.ipProtocol = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CreateForwardEntryResponseBody : Tea.TeaModel {
    public var forwardEntryId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forwardEntryId != nil {
            map["ForwardEntryId"] = self.forwardEntryId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ForwardEntryId"] as? String {
            self.forwardEntryId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateForwardEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateForwardEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateForwardEntryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateHaVipRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var ipAddress: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ipAddress != nil {
            map["IpAddress"] = self.ipAddress!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["IpAddress"] as? String {
            self.ipAddress = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
    }
}

public class CreateHaVipResponseBody : Tea.TeaModel {
    public var haVipId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.haVipId != nil {
            map["HaVipId"] = self.haVipId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["HaVipId"] as? String {
            self.haVipId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateHaVipResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateHaVipResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateHaVipResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateHpcClusterRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CreateHpcClusterResponseBody : Tea.TeaModel {
    public var hpcClusterId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hpcClusterId != nil {
            map["HpcClusterId"] = self.hpcClusterId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["HpcClusterId"] as? String {
            self.hpcClusterId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateHpcClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateHpcClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateHpcClusterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateImageRequest : Tea.TeaModel {
    public class DiskDeviceMapping : Tea.TeaModel {
        public var device: String?

        public var diskType: String?

        public var size: Int32?

        public var snapshotId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.device != nil {
                map["Device"] = self.device!
            }
            if self.diskType != nil {
                map["DiskType"] = self.diskType!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Device"] as? String {
                self.device = value
            }
            if let value = dict["DiskType"] as? String {
                self.diskType = value
            }
            if let value = dict["Size"] as? Int32 {
                self.size = value
            }
            if let value = dict["SnapshotId"] as? String {
                self.snapshotId = value
            }
        }
    }
    public class Features : Tea.TeaModel {
        public var imdsSupport: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.imdsSupport != nil {
                map["ImdsSupport"] = self.imdsSupport!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ImdsSupport"] as? String {
                self.imdsSupport = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var architecture: String?

    public var bootMode: String?

    public var clientToken: String?

    public var description_: String?

    public var detectionStrategy: String?

    public var diskDeviceMapping: [CreateImageRequest.DiskDeviceMapping]?

    public var dryRun: Bool?

    public var features: CreateImageRequest.Features?

    public var imageFamily: String?

    public var imageName: String?

    public var imageVersion: String?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var platform: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snapshotId: String?

    public var tag: [CreateImageRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.features?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.architecture != nil {
            map["Architecture"] = self.architecture!
        }
        if self.bootMode != nil {
            map["BootMode"] = self.bootMode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.detectionStrategy != nil {
            map["DetectionStrategy"] = self.detectionStrategy!
        }
        if self.diskDeviceMapping != nil {
            var tmp : [Any] = []
            for k in self.diskDeviceMapping! {
                tmp.append(k.toMap())
            }
            map["DiskDeviceMapping"] = tmp
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.features != nil {
            map["Features"] = self.features?.toMap()
        }
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.imageVersion != nil {
            map["ImageVersion"] = self.imageVersion!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Architecture"] as? String {
            self.architecture = value
        }
        if let value = dict["BootMode"] as? String {
            self.bootMode = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DetectionStrategy"] as? String {
            self.detectionStrategy = value
        }
        if let value = dict["DiskDeviceMapping"] as? [Any?] {
            var tmp : [CreateImageRequest.DiskDeviceMapping] = []
            for v in value {
                if v != nil {
                    var model = CreateImageRequest.DiskDeviceMapping()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.diskDeviceMapping = tmp
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Features"] as? [String: Any?] {
            var model = CreateImageRequest.Features()
            model.fromMap(value)
            self.features = model
        }
        if let value = dict["ImageFamily"] as? String {
            self.imageFamily = value
        }
        if let value = dict["ImageName"] as? String {
            self.imageName = value
        }
        if let value = dict["ImageVersion"] as? String {
            self.imageVersion = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Platform"] as? String {
            self.platform = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SnapshotId"] as? String {
            self.snapshotId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateImageRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateImageRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class CreateImageResponseBody : Tea.TeaModel {
    public var imageId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateImageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateImageComponentRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var componentType: String?

    public var componentVersion: String?

    public var content: String?

    public var description_: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var systemType: String?

    public var tag: [CreateImageComponentRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.componentType != nil {
            map["ComponentType"] = self.componentType!
        }
        if self.componentVersion != nil {
            map["ComponentVersion"] = self.componentVersion!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.systemType != nil {
            map["SystemType"] = self.systemType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ComponentType"] as? String {
            self.componentType = value
        }
        if let value = dict["ComponentVersion"] as? String {
            self.componentVersion = value
        }
        if let value = dict["Content"] as? String {
            self.content = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SystemType"] as? String {
            self.systemType = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateImageComponentRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateImageComponentRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class CreateImageComponentResponseBody : Tea.TeaModel {
    public var imageComponentId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageComponentId != nil {
            map["ImageComponentId"] = self.imageComponentId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ImageComponentId"] as? String {
            self.imageComponentId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateImageComponentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateImageComponentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateImageComponentResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateImagePipelineRequest : Tea.TeaModel {
    public class AdvancedOptions : Tea.TeaModel {
        public var imageNameSuffix: String?

        public var retainCloudAssistant: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.imageNameSuffix != nil {
                map["ImageNameSuffix"] = self.imageNameSuffix!
            }
            if self.retainCloudAssistant != nil {
                map["RetainCloudAssistant"] = self.retainCloudAssistant!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ImageNameSuffix"] as? String {
                self.imageNameSuffix = value
            }
            if let value = dict["RetainCloudAssistant"] as? Bool {
                self.retainCloudAssistant = value
            }
        }
    }
    public class ImageOptions : Tea.TeaModel {
        public class ImageFeatures : Tea.TeaModel {
            public var nvmeSupport: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.nvmeSupport != nil {
                    map["NvmeSupport"] = self.nvmeSupport!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["NvmeSupport"] as? String {
                    self.nvmeSupport = value
                }
            }
        }
        public class ImageTags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var description_: String?

        public var imageFamily: String?

        public var imageFeatures: CreateImagePipelineRequest.ImageOptions.ImageFeatures?

        public var imageName: String?

        public var imageTags: [CreateImagePipelineRequest.ImageOptions.ImageTags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.imageFeatures?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.imageFamily != nil {
                map["ImageFamily"] = self.imageFamily!
            }
            if self.imageFeatures != nil {
                map["ImageFeatures"] = self.imageFeatures?.toMap()
            }
            if self.imageName != nil {
                map["ImageName"] = self.imageName!
            }
            if self.imageTags != nil {
                var tmp : [Any] = []
                for k in self.imageTags! {
                    tmp.append(k.toMap())
                }
                map["ImageTags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["ImageFamily"] as? String {
                self.imageFamily = value
            }
            if let value = dict["ImageFeatures"] as? [String: Any?] {
                var model = CreateImagePipelineRequest.ImageOptions.ImageFeatures()
                model.fromMap(value)
                self.imageFeatures = model
            }
            if let value = dict["ImageName"] as? String {
                self.imageName = value
            }
            if let value = dict["ImageTags"] as? [Any?] {
                var tmp : [CreateImagePipelineRequest.ImageOptions.ImageTags] = []
                for v in value {
                    if v != nil {
                        var model = CreateImagePipelineRequest.ImageOptions.ImageTags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.imageTags = tmp
            }
        }
    }
    public class ImportImageOptions : Tea.TeaModel {
        public class DiskDeviceMappings : Tea.TeaModel {
            public var diskImageSize: Int32?

            public var format: String?

            public var OSSBucket: String?

            public var OSSObject: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskImageSize != nil {
                    map["DiskImageSize"] = self.diskImageSize!
                }
                if self.format != nil {
                    map["Format"] = self.format!
                }
                if self.OSSBucket != nil {
                    map["OSSBucket"] = self.OSSBucket!
                }
                if self.OSSObject != nil {
                    map["OSSObject"] = self.OSSObject!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DiskImageSize"] as? Int32 {
                    self.diskImageSize = value
                }
                if let value = dict["Format"] as? String {
                    self.format = value
                }
                if let value = dict["OSSBucket"] as? String {
                    self.OSSBucket = value
                }
                if let value = dict["OSSObject"] as? String {
                    self.OSSObject = value
                }
            }
        }
        public class Features : Tea.TeaModel {
            public var nvmeSupport: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.nvmeSupport != nil {
                    map["NvmeSupport"] = self.nvmeSupport!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["NvmeSupport"] as? String {
                    self.nvmeSupport = value
                }
            }
        }
        public var architecture: String?

        public var bootMode: String?

        public var diskDeviceMappings: [CreateImagePipelineRequest.ImportImageOptions.DiskDeviceMappings]?

        public var features: CreateImagePipelineRequest.ImportImageOptions.Features?

        public var licenseType: String?

        public var OSType: String?

        public var platform: String?

        public var retainImportedImage: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.features?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.architecture != nil {
                map["Architecture"] = self.architecture!
            }
            if self.bootMode != nil {
                map["BootMode"] = self.bootMode!
            }
            if self.diskDeviceMappings != nil {
                var tmp : [Any] = []
                for k in self.diskDeviceMappings! {
                    tmp.append(k.toMap())
                }
                map["DiskDeviceMappings"] = tmp
            }
            if self.features != nil {
                map["Features"] = self.features?.toMap()
            }
            if self.licenseType != nil {
                map["LicenseType"] = self.licenseType!
            }
            if self.OSType != nil {
                map["OSType"] = self.OSType!
            }
            if self.platform != nil {
                map["Platform"] = self.platform!
            }
            if self.retainImportedImage != nil {
                map["RetainImportedImage"] = self.retainImportedImage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Architecture"] as? String {
                self.architecture = value
            }
            if let value = dict["BootMode"] as? String {
                self.bootMode = value
            }
            if let value = dict["DiskDeviceMappings"] as? [Any?] {
                var tmp : [CreateImagePipelineRequest.ImportImageOptions.DiskDeviceMappings] = []
                for v in value {
                    if v != nil {
                        var model = CreateImagePipelineRequest.ImportImageOptions.DiskDeviceMappings()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.diskDeviceMappings = tmp
            }
            if let value = dict["Features"] as? [String: Any?] {
                var model = CreateImagePipelineRequest.ImportImageOptions.Features()
                model.fromMap(value)
                self.features = model
            }
            if let value = dict["LicenseType"] as? String {
                self.licenseType = value
            }
            if let value = dict["OSType"] as? String {
                self.OSType = value
            }
            if let value = dict["Platform"] as? String {
                self.platform = value
            }
            if let value = dict["RetainImportedImage"] as? Bool {
                self.retainImportedImage = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var addAccount: [Int64]?

    public var advancedOptions: CreateImagePipelineRequest.AdvancedOptions?

    public var baseImage: String?

    public var baseImageType: String?

    public var buildContent: String?

    public var clientToken: String?

    public var deleteInstanceOnFailure: Bool?

    public var description_: String?

    public var imageFamily: String?

    public var imageName: String?

    public var imageOptions: CreateImagePipelineRequest.ImageOptions?

    public var importImageOptions: CreateImagePipelineRequest.ImportImageOptions?

    public var instanceType: String?

    public var internetMaxBandwidthOut: Int32?

    public var name: String?

    public var nvmeSupport: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var repairMode: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var systemDiskSize: Int32?

    public var tag: [CreateImagePipelineRequest.Tag]?

    public var testContent: String?

    public var toRegionId: [String]?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.advancedOptions?.validate()
        try self.imageOptions?.validate()
        try self.importImageOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addAccount != nil {
            map["AddAccount"] = self.addAccount!
        }
        if self.advancedOptions != nil {
            map["AdvancedOptions"] = self.advancedOptions?.toMap()
        }
        if self.baseImage != nil {
            map["BaseImage"] = self.baseImage!
        }
        if self.baseImageType != nil {
            map["BaseImageType"] = self.baseImageType!
        }
        if self.buildContent != nil {
            map["BuildContent"] = self.buildContent!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.deleteInstanceOnFailure != nil {
            map["DeleteInstanceOnFailure"] = self.deleteInstanceOnFailure!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.imageOptions != nil {
            map["ImageOptions"] = self.imageOptions?.toMap()
        }
        if self.importImageOptions != nil {
            map["ImportImageOptions"] = self.importImageOptions?.toMap()
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nvmeSupport != nil {
            map["NvmeSupport"] = self.nvmeSupport!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.repairMode != nil {
            map["RepairMode"] = self.repairMode!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.systemDiskSize != nil {
            map["SystemDiskSize"] = self.systemDiskSize!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.testContent != nil {
            map["TestContent"] = self.testContent!
        }
        if self.toRegionId != nil {
            map["ToRegionId"] = self.toRegionId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddAccount"] as? [Int64] {
            self.addAccount = value
        }
        if let value = dict["AdvancedOptions"] as? [String: Any?] {
            var model = CreateImagePipelineRequest.AdvancedOptions()
            model.fromMap(value)
            self.advancedOptions = model
        }
        if let value = dict["BaseImage"] as? String {
            self.baseImage = value
        }
        if let value = dict["BaseImageType"] as? String {
            self.baseImageType = value
        }
        if let value = dict["BuildContent"] as? String {
            self.buildContent = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DeleteInstanceOnFailure"] as? Bool {
            self.deleteInstanceOnFailure = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["ImageFamily"] as? String {
            self.imageFamily = value
        }
        if let value = dict["ImageName"] as? String {
            self.imageName = value
        }
        if let value = dict["ImageOptions"] as? [String: Any?] {
            var model = CreateImagePipelineRequest.ImageOptions()
            model.fromMap(value)
            self.imageOptions = model
        }
        if let value = dict["ImportImageOptions"] as? [String: Any?] {
            var model = CreateImagePipelineRequest.ImportImageOptions()
            model.fromMap(value)
            self.importImageOptions = model
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["InternetMaxBandwidthOut"] as? Int32 {
            self.internetMaxBandwidthOut = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NvmeSupport"] as? String {
            self.nvmeSupport = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RepairMode"] as? String {
            self.repairMode = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SystemDiskSize"] as? Int32 {
            self.systemDiskSize = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateImagePipelineRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateImagePipelineRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["TestContent"] as? String {
            self.testContent = value
        }
        if let value = dict["ToRegionId"] as? [String] {
            self.toRegionId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
    }
}

public class CreateImagePipelineResponseBody : Tea.TeaModel {
    public var imagePipelineId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imagePipelineId != nil {
            map["ImagePipelineId"] = self.imagePipelineId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ImagePipelineId"] as? String {
            self.imagePipelineId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateImagePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateImagePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateImagePipelineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateInstanceRequest : Tea.TeaModel {
    public class HibernationOptions : Tea.TeaModel {
        public var configured: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configured != nil {
                map["Configured"] = self.configured!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Configured"] as? Bool {
                self.configured = value
            }
        }
    }
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public var matchCriteria: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["MatchCriteria"] as? String {
                self.matchCriteria = value
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var category: String?

        public var description_: String?

        public var diskName: String?

        public var performanceLevel: String?

        public var size: Int32?

        public var storageClusterId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.storageClusterId != nil {
                map["StorageClusterId"] = self.storageClusterId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DiskName"] as? String {
                self.diskName = value
            }
            if let value = dict["PerformanceLevel"] as? String {
                self.performanceLevel = value
            }
            if let value = dict["Size"] as? Int32 {
                self.size = value
            }
            if let value = dict["StorageClusterId"] as? String {
                self.storageClusterId = value
            }
        }
    }
    public class Arn : Tea.TeaModel {
        public var assumeRoleFor: Int64?

        public var roleType: String?

        public var rolearn: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assumeRoleFor != nil {
                map["AssumeRoleFor"] = self.assumeRoleFor!
            }
            if self.roleType != nil {
                map["RoleType"] = self.roleType!
            }
            if self.rolearn != nil {
                map["Rolearn"] = self.rolearn!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AssumeRoleFor"] as? Int64 {
                self.assumeRoleFor = value
            }
            if let value = dict["RoleType"] as? String {
                self.roleType = value
            }
            if let value = dict["Rolearn"] as? String {
                self.rolearn = value
            }
        }
    }
    public class DataDisk : Tea.TeaModel {
        public var category: String?

        public var deleteWithInstance: Bool?

        public var description_: String?

        public var device: String?

        public var diskName: String?

        public var encryptAlgorithm: String?

        public var encrypted: Bool?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var size: Int32?

        public var snapshotId: String?

        public var storageClusterId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.device != nil {
                map["Device"] = self.device!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encryptAlgorithm != nil {
                map["EncryptAlgorithm"] = self.encryptAlgorithm!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            if self.storageClusterId != nil {
                map["StorageClusterId"] = self.storageClusterId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["DeleteWithInstance"] as? Bool {
                self.deleteWithInstance = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Device"] as? String {
                self.device = value
            }
            if let value = dict["DiskName"] as? String {
                self.diskName = value
            }
            if let value = dict["EncryptAlgorithm"] as? String {
                self.encryptAlgorithm = value
            }
            if let value = dict["Encrypted"] as? Bool {
                self.encrypted = value
            }
            if let value = dict["KMSKeyId"] as? String {
                self.KMSKeyId = value
            }
            if let value = dict["PerformanceLevel"] as? String {
                self.performanceLevel = value
            }
            if let value = dict["Size"] as? Int32 {
                self.size = value
            }
            if let value = dict["SnapshotId"] as? String {
                self.snapshotId = value
            }
            if let value = dict["StorageClusterId"] as? String {
                self.storageClusterId = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var hibernationOptions: CreateInstanceRequest.HibernationOptions?

    public var privatePoolOptions: CreateInstanceRequest.PrivatePoolOptions?

    public var systemDisk: CreateInstanceRequest.SystemDisk?

    public var affinity: String?

    public var arn: [CreateInstanceRequest.Arn]?

    public var autoRenew: Bool?

    public var autoRenewPeriod: Int32?

    public var clientToken: String?

    public var clusterId: String?

    public var creditSpecification: String?

    public var dataDisk: [CreateInstanceRequest.DataDisk]?

    public var dedicatedHostId: String?

    public var deletionProtection: Bool?

    public var deploymentSetGroupNo: Int32?

    public var deploymentSetId: String?

    public var description_: String?

    public var dryRun: Bool?

    public var hostName: String?

    public var hpcClusterId: String?

    public var httpEndpoint: String?

    public var httpPutResponseHopLimit: Int32?

    public var httpTokens: String?

    public var imageFamily: String?

    public var imageId: String?

    public var innerIpAddress: String?

    public var instanceChargeType: String?

    public var instanceName: String?

    public var instanceType: String?

    public var internetChargeType: String?

    public var internetMaxBandwidthIn: Int32?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var keyPairName: String?

    public var nodeControllerId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var password: String?

    public var passwordInherit: Bool?

    public var period: Int32?

    public var periodUnit: String?

    public var privateIpAddress: String?

    public var ramRoleName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityEnhancementStrategy: String?

    public var securityGroupId: String?

    public var spotDuration: Int32?

    public var spotInterruptionBehavior: String?

    public var spotPriceLimit: Double?

    public var spotStrategy: String?

    public var storageSetId: String?

    public var storageSetPartitionNumber: Int32?

    public var tag: [CreateInstanceRequest.Tag]?

    public var tenancy: String?

    public var useAdditionalService: Bool?

    public var userData: String?

    public var vSwitchId: String?

    public var vlanId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.hibernationOptions?.validate()
        try self.privatePoolOptions?.validate()
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hibernationOptions != nil {
            map["HibernationOptions"] = self.hibernationOptions?.toMap()
        }
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.affinity != nil {
            map["Affinity"] = self.affinity!
        }
        if self.arn != nil {
            var tmp : [Any] = []
            for k in self.arn! {
                tmp.append(k.toMap())
            }
            map["Arn"] = tmp
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewPeriod != nil {
            map["AutoRenewPeriod"] = self.autoRenewPeriod!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.creditSpecification != nil {
            map["CreditSpecification"] = self.creditSpecification!
        }
        if self.dataDisk != nil {
            var tmp : [Any] = []
            for k in self.dataDisk! {
                tmp.append(k.toMap())
            }
            map["DataDisk"] = tmp
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.deploymentSetGroupNo != nil {
            map["DeploymentSetGroupNo"] = self.deploymentSetGroupNo!
        }
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.hpcClusterId != nil {
            map["HpcClusterId"] = self.hpcClusterId!
        }
        if self.httpEndpoint != nil {
            map["HttpEndpoint"] = self.httpEndpoint!
        }
        if self.httpPutResponseHopLimit != nil {
            map["HttpPutResponseHopLimit"] = self.httpPutResponseHopLimit!
        }
        if self.httpTokens != nil {
            map["HttpTokens"] = self.httpTokens!
        }
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.innerIpAddress != nil {
            map["InnerIpAddress"] = self.innerIpAddress!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthIn != nil {
            map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.nodeControllerId != nil {
            map["NodeControllerId"] = self.nodeControllerId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityEnhancementStrategy != nil {
            map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.spotInterruptionBehavior != nil {
            map["SpotInterruptionBehavior"] = self.spotInterruptionBehavior!
        }
        if self.spotPriceLimit != nil {
            map["SpotPriceLimit"] = self.spotPriceLimit!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        if self.storageSetPartitionNumber != nil {
            map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.tenancy != nil {
            map["Tenancy"] = self.tenancy!
        }
        if self.useAdditionalService != nil {
            map["UseAdditionalService"] = self.useAdditionalService!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vlanId != nil {
            map["VlanId"] = self.vlanId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["HibernationOptions"] as? [String: Any?] {
            var model = CreateInstanceRequest.HibernationOptions()
            model.fromMap(value)
            self.hibernationOptions = model
        }
        if let value = dict["PrivatePoolOptions"] as? [String: Any?] {
            var model = CreateInstanceRequest.PrivatePoolOptions()
            model.fromMap(value)
            self.privatePoolOptions = model
        }
        if let value = dict["SystemDisk"] as? [String: Any?] {
            var model = CreateInstanceRequest.SystemDisk()
            model.fromMap(value)
            self.systemDisk = model
        }
        if let value = dict["Affinity"] as? String {
            self.affinity = value
        }
        if let value = dict["Arn"] as? [Any?] {
            var tmp : [CreateInstanceRequest.Arn] = []
            for v in value {
                if v != nil {
                    var model = CreateInstanceRequest.Arn()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.arn = tmp
        }
        if let value = dict["AutoRenew"] as? Bool {
            self.autoRenew = value
        }
        if let value = dict["AutoRenewPeriod"] as? Int32 {
            self.autoRenewPeriod = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["CreditSpecification"] as? String {
            self.creditSpecification = value
        }
        if let value = dict["DataDisk"] as? [Any?] {
            var tmp : [CreateInstanceRequest.DataDisk] = []
            for v in value {
                if v != nil {
                    var model = CreateInstanceRequest.DataDisk()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.dataDisk = tmp
        }
        if let value = dict["DedicatedHostId"] as? String {
            self.dedicatedHostId = value
        }
        if let value = dict["DeletionProtection"] as? Bool {
            self.deletionProtection = value
        }
        if let value = dict["DeploymentSetGroupNo"] as? Int32 {
            self.deploymentSetGroupNo = value
        }
        if let value = dict["DeploymentSetId"] as? String {
            self.deploymentSetId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["HostName"] as? String {
            self.hostName = value
        }
        if let value = dict["HpcClusterId"] as? String {
            self.hpcClusterId = value
        }
        if let value = dict["HttpEndpoint"] as? String {
            self.httpEndpoint = value
        }
        if let value = dict["HttpPutResponseHopLimit"] as? Int32 {
            self.httpPutResponseHopLimit = value
        }
        if let value = dict["HttpTokens"] as? String {
            self.httpTokens = value
        }
        if let value = dict["ImageFamily"] as? String {
            self.imageFamily = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["InnerIpAddress"] as? String {
            self.innerIpAddress = value
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["InternetChargeType"] as? String {
            self.internetChargeType = value
        }
        if let value = dict["InternetMaxBandwidthIn"] as? Int32 {
            self.internetMaxBandwidthIn = value
        }
        if let value = dict["InternetMaxBandwidthOut"] as? Int32 {
            self.internetMaxBandwidthOut = value
        }
        if let value = dict["IoOptimized"] as? String {
            self.ioOptimized = value
        }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["NodeControllerId"] as? String {
            self.nodeControllerId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Password"] as? String {
            self.password = value
        }
        if let value = dict["PasswordInherit"] as? Bool {
            self.passwordInherit = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PeriodUnit"] as? String {
            self.periodUnit = value
        }
        if let value = dict["PrivateIpAddress"] as? String {
            self.privateIpAddress = value
        }
        if let value = dict["RamRoleName"] as? String {
            self.ramRoleName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityEnhancementStrategy"] as? String {
            self.securityEnhancementStrategy = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SpotDuration"] as? Int32 {
            self.spotDuration = value
        }
        if let value = dict["SpotInterruptionBehavior"] as? String {
            self.spotInterruptionBehavior = value
        }
        if let value = dict["SpotPriceLimit"] as? Double {
            self.spotPriceLimit = value
        }
        if let value = dict["SpotStrategy"] as? String {
            self.spotStrategy = value
        }
        if let value = dict["StorageSetId"] as? String {
            self.storageSetId = value
        }
        if let value = dict["StorageSetPartitionNumber"] as? Int32 {
            self.storageSetPartitionNumber = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateInstanceRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateInstanceRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["Tenancy"] as? String {
            self.tenancy = value
        }
        if let value = dict["UseAdditionalService"] as? Bool {
            self.useAdditionalService = value
        }
        if let value = dict["UserData"] as? String {
            self.userData = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VlanId"] as? String {
            self.vlanId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class CreateInstanceResponseBody : Tea.TeaModel {
    public var instanceId: String?

    public var orderId: String?

    public var requestId: String?

    public var tradePrice: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tradePrice != nil {
            map["TradePrice"] = self.tradePrice!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TradePrice"] as? Double {
            self.tradePrice = value
        }
    }
}

public class CreateInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateKeyPairRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var keyPairName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateKeyPairRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateKeyPairRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateKeyPairRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class CreateKeyPairResponseBody : Tea.TeaModel {
    public var keyPairFingerPrint: String?

    public var keyPairId: String?

    public var keyPairName: String?

    public var privateKeyBody: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyPairFingerPrint != nil {
            map["KeyPairFingerPrint"] = self.keyPairFingerPrint!
        }
        if self.keyPairId != nil {
            map["KeyPairId"] = self.keyPairId!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.privateKeyBody != nil {
            map["PrivateKeyBody"] = self.privateKeyBody!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["KeyPairFingerPrint"] as? String {
            self.keyPairFingerPrint = value
        }
        if let value = dict["KeyPairId"] as? String {
            self.keyPairId = value
        }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["PrivateKeyBody"] as? String {
            self.privateKeyBody = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateKeyPairResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateKeyPairResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateKeyPairResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateLaunchTemplateRequest : Tea.TeaModel {
    public class SystemDisk : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var category: String?

        public var deleteWithInstance: Bool?

        public var description_: String?

        public var diskName: String?

        public var encrypted: String?

        public var iops: Int32?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.iops != nil {
                map["Iops"] = self.iops!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AutoSnapshotPolicyId"] as? String {
                self.autoSnapshotPolicyId = value
            }
            if let value = dict["BurstingEnabled"] as? Bool {
                self.burstingEnabled = value
            }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["DeleteWithInstance"] as? Bool {
                self.deleteWithInstance = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DiskName"] as? String {
                self.diskName = value
            }
            if let value = dict["Encrypted"] as? String {
                self.encrypted = value
            }
            if let value = dict["Iops"] as? Int32 {
                self.iops = value
            }
            if let value = dict["KMSKeyId"] as? String {
                self.KMSKeyId = value
            }
            if let value = dict["PerformanceLevel"] as? String {
                self.performanceLevel = value
            }
            if let value = dict["ProvisionedIops"] as? Int64 {
                self.provisionedIops = value
            }
            if let value = dict["Size"] as? Int32 {
                self.size = value
            }
        }
    }
    public class DataDisk : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var category: String?

        public var deleteWithInstance: Bool?

        public var description_: String?

        public var device: String?

        public var diskName: String?

        public var encrypted: String?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public var snapshotId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.device != nil {
                map["Device"] = self.device!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AutoSnapshotPolicyId"] as? String {
                self.autoSnapshotPolicyId = value
            }
            if let value = dict["BurstingEnabled"] as? Bool {
                self.burstingEnabled = value
            }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["DeleteWithInstance"] as? Bool {
                self.deleteWithInstance = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Device"] as? String {
                self.device = value
            }
            if let value = dict["DiskName"] as? String {
                self.diskName = value
            }
            if let value = dict["Encrypted"] as? String {
                self.encrypted = value
            }
            if let value = dict["KMSKeyId"] as? String {
                self.KMSKeyId = value
            }
            if let value = dict["PerformanceLevel"] as? String {
                self.performanceLevel = value
            }
            if let value = dict["ProvisionedIops"] as? Int64 {
                self.provisionedIops = value
            }
            if let value = dict["Size"] as? Int32 {
                self.size = value
            }
            if let value = dict["SnapshotId"] as? String {
                self.snapshotId = value
            }
        }
    }
    public class NetworkInterface : Tea.TeaModel {
        public var deleteOnRelease: Bool?

        public var description_: String?

        public var instanceType: String?

        public var networkInterfaceName: String?

        public var networkInterfaceTrafficMode: String?

        public var primaryIpAddress: String?

        public var securityGroupId: String?

        public var securityGroupIds: [String]?

        public var vSwitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deleteOnRelease != nil {
                map["DeleteOnRelease"] = self.deleteOnRelease!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.networkInterfaceName != nil {
                map["NetworkInterfaceName"] = self.networkInterfaceName!
            }
            if self.networkInterfaceTrafficMode != nil {
                map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
            }
            if self.primaryIpAddress != nil {
                map["PrimaryIpAddress"] = self.primaryIpAddress!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.securityGroupIds != nil {
                map["SecurityGroupIds"] = self.securityGroupIds!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DeleteOnRelease"] as? Bool {
                self.deleteOnRelease = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["NetworkInterfaceName"] as? String {
                self.networkInterfaceName = value
            }
            if let value = dict["NetworkInterfaceTrafficMode"] as? String {
                self.networkInterfaceTrafficMode = value
            }
            if let value = dict["PrimaryIpAddress"] as? String {
                self.primaryIpAddress = value
            }
            if let value = dict["SecurityGroupId"] as? String {
                self.securityGroupId = value
            }
            if let value = dict["SecurityGroupIds"] as? [String] {
                self.securityGroupIds = value
            }
            if let value = dict["VSwitchId"] as? String {
                self.vSwitchId = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class TemplateTag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var systemDisk: CreateLaunchTemplateRequest.SystemDisk?

    public var autoReleaseTime: String?

    public var autoRenew: Bool?

    public var autoRenewPeriod: Int32?

    public var creditSpecification: String?

    public var dataDisk: [CreateLaunchTemplateRequest.DataDisk]?

    public var deletionProtection: Bool?

    public var deploymentSetId: String?

    public var description_: String?

    public var enableVmOsConfig: Bool?

    public var hostName: String?

    public var httpEndpoint: String?

    public var httpPutResponseHopLimit: Int32?

    public var httpTokens: String?

    public var imageId: String?

    public var imageOwnerAlias: String?

    public var instanceChargeType: String?

    public var instanceName: String?

    public var instanceType: String?

    public var internetChargeType: String?

    public var internetMaxBandwidthIn: Int32?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var ipv6AddressCount: Int32?

    public var keyPairName: String?

    public var launchTemplateName: String?

    public var networkInterface: [CreateLaunchTemplateRequest.NetworkInterface]?

    public var networkType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var passwordInherit: Bool?

    public var period: Int32?

    public var periodUnit: String?

    public var privateIpAddress: String?

    public var ramRoleName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityEnhancementStrategy: String?

    public var securityGroupId: String?

    public var securityGroupIds: [String]?

    public var spotDuration: Int32?

    public var spotPriceLimit: Double?

    public var spotStrategy: String?

    public var tag: [CreateLaunchTemplateRequest.Tag]?

    public var templateResourceGroupId: String?

    public var templateTag: [CreateLaunchTemplateRequest.TemplateTag]?

    public var userData: String?

    public var vSwitchId: String?

    public var versionDescription: String?

    public var vpcId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.autoReleaseTime != nil {
            map["AutoReleaseTime"] = self.autoReleaseTime!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewPeriod != nil {
            map["AutoRenewPeriod"] = self.autoRenewPeriod!
        }
        if self.creditSpecification != nil {
            map["CreditSpecification"] = self.creditSpecification!
        }
        if self.dataDisk != nil {
            var tmp : [Any] = []
            for k in self.dataDisk! {
                tmp.append(k.toMap())
            }
            map["DataDisk"] = tmp
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enableVmOsConfig != nil {
            map["EnableVmOsConfig"] = self.enableVmOsConfig!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.httpEndpoint != nil {
            map["HttpEndpoint"] = self.httpEndpoint!
        }
        if self.httpPutResponseHopLimit != nil {
            map["HttpPutResponseHopLimit"] = self.httpPutResponseHopLimit!
        }
        if self.httpTokens != nil {
            map["HttpTokens"] = self.httpTokens!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageOwnerAlias != nil {
            map["ImageOwnerAlias"] = self.imageOwnerAlias!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthIn != nil {
            map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.launchTemplateName != nil {
            map["LaunchTemplateName"] = self.launchTemplateName!
        }
        if self.networkInterface != nil {
            var tmp : [Any] = []
            for k in self.networkInterface! {
                tmp.append(k.toMap())
            }
            map["NetworkInterface"] = tmp
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityEnhancementStrategy != nil {
            map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds!
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.spotPriceLimit != nil {
            map["SpotPriceLimit"] = self.spotPriceLimit!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.templateResourceGroupId != nil {
            map["TemplateResourceGroupId"] = self.templateResourceGroupId!
        }
        if self.templateTag != nil {
            var tmp : [Any] = []
            for k in self.templateTag! {
                tmp.append(k.toMap())
            }
            map["TemplateTag"] = tmp
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.versionDescription != nil {
            map["VersionDescription"] = self.versionDescription!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["SystemDisk"] as? [String: Any?] {
            var model = CreateLaunchTemplateRequest.SystemDisk()
            model.fromMap(value)
            self.systemDisk = model
        }
        if let value = dict["AutoReleaseTime"] as? String {
            self.autoReleaseTime = value
        }
        if let value = dict["AutoRenew"] as? Bool {
            self.autoRenew = value
        }
        if let value = dict["AutoRenewPeriod"] as? Int32 {
            self.autoRenewPeriod = value
        }
        if let value = dict["CreditSpecification"] as? String {
            self.creditSpecification = value
        }
        if let value = dict["DataDisk"] as? [Any?] {
            var tmp : [CreateLaunchTemplateRequest.DataDisk] = []
            for v in value {
                if v != nil {
                    var model = CreateLaunchTemplateRequest.DataDisk()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.dataDisk = tmp
        }
        if let value = dict["DeletionProtection"] as? Bool {
            self.deletionProtection = value
        }
        if let value = dict["DeploymentSetId"] as? String {
            self.deploymentSetId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EnableVmOsConfig"] as? Bool {
            self.enableVmOsConfig = value
        }
        if let value = dict["HostName"] as? String {
            self.hostName = value
        }
        if let value = dict["HttpEndpoint"] as? String {
            self.httpEndpoint = value
        }
        if let value = dict["HttpPutResponseHopLimit"] as? Int32 {
            self.httpPutResponseHopLimit = value
        }
        if let value = dict["HttpTokens"] as? String {
            self.httpTokens = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["ImageOwnerAlias"] as? String {
            self.imageOwnerAlias = value
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["InternetChargeType"] as? String {
            self.internetChargeType = value
        }
        if let value = dict["InternetMaxBandwidthIn"] as? Int32 {
            self.internetMaxBandwidthIn = value
        }
        if let value = dict["InternetMaxBandwidthOut"] as? Int32 {
            self.internetMaxBandwidthOut = value
        }
        if let value = dict["IoOptimized"] as? String {
            self.ioOptimized = value
        }
        if let value = dict["Ipv6AddressCount"] as? Int32 {
            self.ipv6AddressCount = value
        }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["LaunchTemplateName"] as? String {
            self.launchTemplateName = value
        }
        if let value = dict["NetworkInterface"] as? [Any?] {
            var tmp : [CreateLaunchTemplateRequest.NetworkInterface] = []
            for v in value {
                if v != nil {
                    var model = CreateLaunchTemplateRequest.NetworkInterface()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.networkInterface = tmp
        }
        if let value = dict["NetworkType"] as? String {
            self.networkType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PasswordInherit"] as? Bool {
            self.passwordInherit = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PeriodUnit"] as? String {
            self.periodUnit = value
        }
        if let value = dict["PrivateIpAddress"] as? String {
            self.privateIpAddress = value
        }
        if let value = dict["RamRoleName"] as? String {
            self.ramRoleName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityEnhancementStrategy"] as? String {
            self.securityEnhancementStrategy = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SecurityGroupIds"] as? [String] {
            self.securityGroupIds = value
        }
        if let value = dict["SpotDuration"] as? Int32 {
            self.spotDuration = value
        }
        if let value = dict["SpotPriceLimit"] as? Double {
            self.spotPriceLimit = value
        }
        if let value = dict["SpotStrategy"] as? String {
            self.spotStrategy = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateLaunchTemplateRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateLaunchTemplateRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["TemplateResourceGroupId"] as? String {
            self.templateResourceGroupId = value
        }
        if let value = dict["TemplateTag"] as? [Any?] {
            var tmp : [CreateLaunchTemplateRequest.TemplateTag] = []
            for v in value {
                if v != nil {
                    var model = CreateLaunchTemplateRequest.TemplateTag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.templateTag = tmp
        }
        if let value = dict["UserData"] as? String {
            self.userData = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VersionDescription"] as? String {
            self.versionDescription = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class CreateLaunchTemplateResponseBody : Tea.TeaModel {
    public var launchTemplateId: String?

    public var launchTemplateVersionNumber: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateVersionNumber != nil {
            map["LaunchTemplateVersionNumber"] = self.launchTemplateVersionNumber!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LaunchTemplateId"] as? String {
            self.launchTemplateId = value
        }
        if let value = dict["LaunchTemplateVersionNumber"] as? Int64 {
            self.launchTemplateVersionNumber = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateLaunchTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLaunchTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateLaunchTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateLaunchTemplateVersionRequest : Tea.TeaModel {
    public class SystemDisk : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var category: String?

        public var deleteWithInstance: Bool?

        public var description_: String?

        public var diskName: String?

        public var encrypted: String?

        public var iops: Int32?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.iops != nil {
                map["Iops"] = self.iops!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AutoSnapshotPolicyId"] as? String {
                self.autoSnapshotPolicyId = value
            }
            if let value = dict["BurstingEnabled"] as? Bool {
                self.burstingEnabled = value
            }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["DeleteWithInstance"] as? Bool {
                self.deleteWithInstance = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DiskName"] as? String {
                self.diskName = value
            }
            if let value = dict["Encrypted"] as? String {
                self.encrypted = value
            }
            if let value = dict["Iops"] as? Int32 {
                self.iops = value
            }
            if let value = dict["KMSKeyId"] as? String {
                self.KMSKeyId = value
            }
            if let value = dict["PerformanceLevel"] as? String {
                self.performanceLevel = value
            }
            if let value = dict["ProvisionedIops"] as? Int64 {
                self.provisionedIops = value
            }
            if let value = dict["Size"] as? Int32 {
                self.size = value
            }
        }
    }
    public class DataDisk : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var category: String?

        public var deleteWithInstance: Bool?

        public var description_: String?

        public var device: String?

        public var diskName: String?

        public var encrypted: String?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public var snapshotId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.device != nil {
                map["Device"] = self.device!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AutoSnapshotPolicyId"] as? String {
                self.autoSnapshotPolicyId = value
            }
            if let value = dict["BurstingEnabled"] as? Bool {
                self.burstingEnabled = value
            }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["DeleteWithInstance"] as? Bool {
                self.deleteWithInstance = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Device"] as? String {
                self.device = value
            }
            if let value = dict["DiskName"] as? String {
                self.diskName = value
            }
            if let value = dict["Encrypted"] as? String {
                self.encrypted = value
            }
            if let value = dict["KMSKeyId"] as? String {
                self.KMSKeyId = value
            }
            if let value = dict["PerformanceLevel"] as? String {
                self.performanceLevel = value
            }
            if let value = dict["ProvisionedIops"] as? Int64 {
                self.provisionedIops = value
            }
            if let value = dict["Size"] as? Int32 {
                self.size = value
            }
            if let value = dict["SnapshotId"] as? String {
                self.snapshotId = value
            }
        }
    }
    public class NetworkInterface : Tea.TeaModel {
        public var deleteOnRelease: Bool?

        public var description_: String?

        public var instanceType: String?

        public var networkInterfaceName: String?

        public var networkInterfaceTrafficMode: String?

        public var primaryIpAddress: String?

        public var securityGroupId: String?

        public var securityGroupIds: [String]?

        public var vSwitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deleteOnRelease != nil {
                map["DeleteOnRelease"] = self.deleteOnRelease!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.networkInterfaceName != nil {
                map["NetworkInterfaceName"] = self.networkInterfaceName!
            }
            if self.networkInterfaceTrafficMode != nil {
                map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
            }
            if self.primaryIpAddress != nil {
                map["PrimaryIpAddress"] = self.primaryIpAddress!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.securityGroupIds != nil {
                map["SecurityGroupIds"] = self.securityGroupIds!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DeleteOnRelease"] as? Bool {
                self.deleteOnRelease = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["NetworkInterfaceName"] as? String {
                self.networkInterfaceName = value
            }
            if let value = dict["NetworkInterfaceTrafficMode"] as? String {
                self.networkInterfaceTrafficMode = value
            }
            if let value = dict["PrimaryIpAddress"] as? String {
                self.primaryIpAddress = value
            }
            if let value = dict["SecurityGroupId"] as? String {
                self.securityGroupId = value
            }
            if let value = dict["SecurityGroupIds"] as? [String] {
                self.securityGroupIds = value
            }
            if let value = dict["VSwitchId"] as? String {
                self.vSwitchId = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var systemDisk: CreateLaunchTemplateVersionRequest.SystemDisk?

    public var autoReleaseTime: String?

    public var autoRenew: Bool?

    public var autoRenewPeriod: Int32?

    public var creditSpecification: String?

    public var dataDisk: [CreateLaunchTemplateVersionRequest.DataDisk]?

    public var deletionProtection: Bool?

    public var deploymentSetId: String?

    public var description_: String?

    public var enableVmOsConfig: Bool?

    public var hostName: String?

    public var httpEndpoint: String?

    public var httpPutResponseHopLimit: Int32?

    public var httpTokens: String?

    public var imageId: String?

    public var imageOwnerAlias: String?

    public var instanceChargeType: String?

    public var instanceName: String?

    public var instanceType: String?

    public var internetChargeType: String?

    public var internetMaxBandwidthIn: Int32?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var ipv6AddressCount: Int32?

    public var keyPairName: String?

    public var launchTemplateId: String?

    public var launchTemplateName: String?

    public var networkInterface: [CreateLaunchTemplateVersionRequest.NetworkInterface]?

    public var networkType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var passwordInherit: Bool?

    public var period: Int32?

    public var periodUnit: String?

    public var privateIpAddress: String?

    public var ramRoleName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityEnhancementStrategy: String?

    public var securityGroupId: String?

    public var securityGroupIds: [String]?

    public var spotDuration: Int32?

    public var spotPriceLimit: Double?

    public var spotStrategy: String?

    public var tag: [CreateLaunchTemplateVersionRequest.Tag]?

    public var userData: String?

    public var vSwitchId: String?

    public var versionDescription: String?

    public var vpcId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.autoReleaseTime != nil {
            map["AutoReleaseTime"] = self.autoReleaseTime!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewPeriod != nil {
            map["AutoRenewPeriod"] = self.autoRenewPeriod!
        }
        if self.creditSpecification != nil {
            map["CreditSpecification"] = self.creditSpecification!
        }
        if self.dataDisk != nil {
            var tmp : [Any] = []
            for k in self.dataDisk! {
                tmp.append(k.toMap())
            }
            map["DataDisk"] = tmp
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enableVmOsConfig != nil {
            map["EnableVmOsConfig"] = self.enableVmOsConfig!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.httpEndpoint != nil {
            map["HttpEndpoint"] = self.httpEndpoint!
        }
        if self.httpPutResponseHopLimit != nil {
            map["HttpPutResponseHopLimit"] = self.httpPutResponseHopLimit!
        }
        if self.httpTokens != nil {
            map["HttpTokens"] = self.httpTokens!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageOwnerAlias != nil {
            map["ImageOwnerAlias"] = self.imageOwnerAlias!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthIn != nil {
            map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateName != nil {
            map["LaunchTemplateName"] = self.launchTemplateName!
        }
        if self.networkInterface != nil {
            var tmp : [Any] = []
            for k in self.networkInterface! {
                tmp.append(k.toMap())
            }
            map["NetworkInterface"] = tmp
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityEnhancementStrategy != nil {
            map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds!
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.spotPriceLimit != nil {
            map["SpotPriceLimit"] = self.spotPriceLimit!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.versionDescription != nil {
            map["VersionDescription"] = self.versionDescription!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["SystemDisk"] as? [String: Any?] {
            var model = CreateLaunchTemplateVersionRequest.SystemDisk()
            model.fromMap(value)
            self.systemDisk = model
        }
        if let value = dict["AutoReleaseTime"] as? String {
            self.autoReleaseTime = value
        }
        if let value = dict["AutoRenew"] as? Bool {
            self.autoRenew = value
        }
        if let value = dict["AutoRenewPeriod"] as? Int32 {
            self.autoRenewPeriod = value
        }
        if let value = dict["CreditSpecification"] as? String {
            self.creditSpecification = value
        }
        if let value = dict["DataDisk"] as? [Any?] {
            var tmp : [CreateLaunchTemplateVersionRequest.DataDisk] = []
            for v in value {
                if v != nil {
                    var model = CreateLaunchTemplateVersionRequest.DataDisk()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.dataDisk = tmp
        }
        if let value = dict["DeletionProtection"] as? Bool {
            self.deletionProtection = value
        }
        if let value = dict["DeploymentSetId"] as? String {
            self.deploymentSetId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EnableVmOsConfig"] as? Bool {
            self.enableVmOsConfig = value
        }
        if let value = dict["HostName"] as? String {
            self.hostName = value
        }
        if let value = dict["HttpEndpoint"] as? String {
            self.httpEndpoint = value
        }
        if let value = dict["HttpPutResponseHopLimit"] as? Int32 {
            self.httpPutResponseHopLimit = value
        }
        if let value = dict["HttpTokens"] as? String {
            self.httpTokens = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["ImageOwnerAlias"] as? String {
            self.imageOwnerAlias = value
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["InternetChargeType"] as? String {
            self.internetChargeType = value
        }
        if let value = dict["InternetMaxBandwidthIn"] as? Int32 {
            self.internetMaxBandwidthIn = value
        }
        if let value = dict["InternetMaxBandwidthOut"] as? Int32 {
            self.internetMaxBandwidthOut = value
        }
        if let value = dict["IoOptimized"] as? String {
            self.ioOptimized = value
        }
        if let value = dict["Ipv6AddressCount"] as? Int32 {
            self.ipv6AddressCount = value
        }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["LaunchTemplateId"] as? String {
            self.launchTemplateId = value
        }
        if let value = dict["LaunchTemplateName"] as? String {
            self.launchTemplateName = value
        }
        if let value = dict["NetworkInterface"] as? [Any?] {
            var tmp : [CreateLaunchTemplateVersionRequest.NetworkInterface] = []
            for v in value {
                if v != nil {
                    var model = CreateLaunchTemplateVersionRequest.NetworkInterface()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.networkInterface = tmp
        }
        if let value = dict["NetworkType"] as? String {
            self.networkType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PasswordInherit"] as? Bool {
            self.passwordInherit = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PeriodUnit"] as? String {
            self.periodUnit = value
        }
        if let value = dict["PrivateIpAddress"] as? String {
            self.privateIpAddress = value
        }
        if let value = dict["RamRoleName"] as? String {
            self.ramRoleName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityEnhancementStrategy"] as? String {
            self.securityEnhancementStrategy = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SecurityGroupIds"] as? [String] {
            self.securityGroupIds = value
        }
        if let value = dict["SpotDuration"] as? Int32 {
            self.spotDuration = value
        }
        if let value = dict["SpotPriceLimit"] as? Double {
            self.spotPriceLimit = value
        }
        if let value = dict["SpotStrategy"] as? String {
            self.spotStrategy = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateLaunchTemplateVersionRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateLaunchTemplateVersionRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["UserData"] as? String {
            self.userData = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VersionDescription"] as? String {
            self.versionDescription = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class CreateLaunchTemplateVersionResponseBody : Tea.TeaModel {
    public var launchTemplateId: String?

    public var launchTemplateVersionNumber: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateVersionNumber != nil {
            map["LaunchTemplateVersionNumber"] = self.launchTemplateVersionNumber!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LaunchTemplateId"] as? String {
            self.launchTemplateId = value
        }
        if let value = dict["LaunchTemplateVersionNumber"] as? Int64 {
            self.launchTemplateVersionNumber = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateLaunchTemplateVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLaunchTemplateVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateLaunchTemplateVersionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateNatGatewayRequest : Tea.TeaModel {
    public class BandwidthPackage : Tea.TeaModel {
        public var bandwidth: Int32?

        public var ipCount: Int32?

        public var zone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth!
            }
            if self.ipCount != nil {
                map["IpCount"] = self.ipCount!
            }
            if self.zone != nil {
                map["Zone"] = self.zone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Bandwidth"] as? Int32 {
                self.bandwidth = value
            }
            if let value = dict["IpCount"] as? Int32 {
                self.ipCount = value
            }
            if let value = dict["Zone"] as? String {
                self.zone = value
            }
        }
    }
    public var bandwidthPackage: [CreateNatGatewayRequest.BandwidthPackage]?

    public var clientToken: String?

    public var description_: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackage != nil {
            var tmp : [Any] = []
            for k in self.bandwidthPackage! {
                tmp.append(k.toMap())
            }
            map["BandwidthPackage"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BandwidthPackage"] as? [Any?] {
            var tmp : [CreateNatGatewayRequest.BandwidthPackage] = []
            for v in value {
                if v != nil {
                    var model = CreateNatGatewayRequest.BandwidthPackage()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.bandwidthPackage = tmp
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class CreateNatGatewayResponseBody : Tea.TeaModel {
    public class BandwidthPackageIds : Tea.TeaModel {
        public var bandwidthPackageId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bandwidthPackageId != nil {
                map["BandwidthPackageId"] = self.bandwidthPackageId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BandwidthPackageId"] as? [String] {
                self.bandwidthPackageId = value
            }
        }
    }
    public class ForwardTableIds : Tea.TeaModel {
        public var forwardTableId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.forwardTableId != nil {
                map["ForwardTableId"] = self.forwardTableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ForwardTableId"] as? [String] {
                self.forwardTableId = value
            }
        }
    }
    public var bandwidthPackageIds: CreateNatGatewayResponseBody.BandwidthPackageIds?

    public var forwardTableIds: CreateNatGatewayResponseBody.ForwardTableIds?

    public var natGatewayId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.bandwidthPackageIds?.validate()
        try self.forwardTableIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageIds != nil {
            map["BandwidthPackageIds"] = self.bandwidthPackageIds?.toMap()
        }
        if self.forwardTableIds != nil {
            map["ForwardTableIds"] = self.forwardTableIds?.toMap()
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BandwidthPackageIds"] as? [String: Any?] {
            var model = CreateNatGatewayResponseBody.BandwidthPackageIds()
            model.fromMap(value)
            self.bandwidthPackageIds = model
        }
        if let value = dict["ForwardTableIds"] as? [String: Any?] {
            var model = CreateNatGatewayResponseBody.ForwardTableIds()
            model.fromMap(value)
            self.forwardTableIds = model
        }
        if let value = dict["NatGatewayId"] as? String {
            self.natGatewayId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateNatGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNatGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateNatGatewayResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateNetworkInterfaceRequest : Tea.TeaModel {
    public class ConnectionTrackingConfiguration : Tea.TeaModel {
        public var tcpClosedAndTimeWaitTimeout: Int32?

        public var tcpEstablishedTimeout: Int32?

        public var udpTimeout: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tcpClosedAndTimeWaitTimeout != nil {
                map["TcpClosedAndTimeWaitTimeout"] = self.tcpClosedAndTimeWaitTimeout!
            }
            if self.tcpEstablishedTimeout != nil {
                map["TcpEstablishedTimeout"] = self.tcpEstablishedTimeout!
            }
            if self.udpTimeout != nil {
                map["UdpTimeout"] = self.udpTimeout!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TcpClosedAndTimeWaitTimeout"] as? Int32 {
                self.tcpClosedAndTimeWaitTimeout = value
            }
            if let value = dict["TcpEstablishedTimeout"] as? Int32 {
                self.tcpEstablishedTimeout = value
            }
            if let value = dict["UdpTimeout"] as? Int32 {
                self.udpTimeout = value
            }
        }
    }
    public class EnhancedNetwork : Tea.TeaModel {
        public var enableRss: Bool?

        public var enableSriov: Bool?

        public var virtualFunctionQuantity: Int32?

        public var virtualFunctionTotalQueueNumber: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableRss != nil {
                map["EnableRss"] = self.enableRss!
            }
            if self.enableSriov != nil {
                map["EnableSriov"] = self.enableSriov!
            }
            if self.virtualFunctionQuantity != nil {
                map["VirtualFunctionQuantity"] = self.virtualFunctionQuantity!
            }
            if self.virtualFunctionTotalQueueNumber != nil {
                map["VirtualFunctionTotalQueueNumber"] = self.virtualFunctionTotalQueueNumber!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EnableRss"] as? Bool {
                self.enableRss = value
            }
            if let value = dict["EnableSriov"] as? Bool {
                self.enableSriov = value
            }
            if let value = dict["VirtualFunctionQuantity"] as? Int32 {
                self.virtualFunctionQuantity = value
            }
            if let value = dict["VirtualFunctionTotalQueueNumber"] as? Int32 {
                self.virtualFunctionTotalQueueNumber = value
            }
        }
    }
    public class NetworkInterfaceTrafficConfig : Tea.TeaModel {
        public var networkInterfaceTrafficMode: String?

        public var queueNumber: Int32?

        public var queuePairNumber: Int32?

        public var rxQueueSize: Int32?

        public var txQueueSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.networkInterfaceTrafficMode != nil {
                map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
            }
            if self.queueNumber != nil {
                map["QueueNumber"] = self.queueNumber!
            }
            if self.queuePairNumber != nil {
                map["QueuePairNumber"] = self.queuePairNumber!
            }
            if self.rxQueueSize != nil {
                map["RxQueueSize"] = self.rxQueueSize!
            }
            if self.txQueueSize != nil {
                map["TxQueueSize"] = self.txQueueSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["NetworkInterfaceTrafficMode"] as? String {
                self.networkInterfaceTrafficMode = value
            }
            if let value = dict["QueueNumber"] as? Int32 {
                self.queueNumber = value
            }
            if let value = dict["QueuePairNumber"] as? Int32 {
                self.queuePairNumber = value
            }
            if let value = dict["RxQueueSize"] as? Int32 {
                self.rxQueueSize = value
            }
            if let value = dict["TxQueueSize"] as? Int32 {
                self.txQueueSize = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var businessType: String?

    public var clientToken: String?

    public var connectionTrackingConfiguration: CreateNetworkInterfaceRequest.ConnectionTrackingConfiguration?

    public var deleteOnRelease: Bool?

    public var description_: String?

    public var enhancedNetwork: CreateNetworkInterfaceRequest.EnhancedNetwork?

    public var instanceType: String?

    public var ipv4Prefix: [String]?

    public var ipv4PrefixCount: Int32?

    public var ipv6Address: [String]?

    public var ipv6AddressCount: Int32?

    public var ipv6Prefix: [String]?

    public var ipv6PrefixCount: Int32?

    public var networkInterfaceName: String?

    public var networkInterfaceTrafficConfig: CreateNetworkInterfaceRequest.NetworkInterfaceTrafficConfig?

    public var networkInterfaceTrafficMode: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var primaryIpAddress: String?

    public var privateIpAddress: [String]?

    public var queueNumber: Int32?

    public var queuePairNumber: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var rxQueueSize: Int32?

    public var secondaryPrivateIpAddressCount: Int32?

    public var securityGroupId: String?

    public var securityGroupIds: [String]?

    public var sourceDestCheck: Bool?

    public var tag: [CreateNetworkInterfaceRequest.Tag]?

    public var txQueueSize: Int32?

    public var vSwitchId: String?

    public var visible: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.connectionTrackingConfiguration?.validate()
        try self.enhancedNetwork?.validate()
        try self.networkInterfaceTrafficConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessType != nil {
            map["BusinessType"] = self.businessType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.connectionTrackingConfiguration != nil {
            map["ConnectionTrackingConfiguration"] = self.connectionTrackingConfiguration?.toMap()
        }
        if self.deleteOnRelease != nil {
            map["DeleteOnRelease"] = self.deleteOnRelease!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enhancedNetwork != nil {
            map["EnhancedNetwork"] = self.enhancedNetwork?.toMap()
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ipv4Prefix != nil {
            map["Ipv4Prefix"] = self.ipv4Prefix!
        }
        if self.ipv4PrefixCount != nil {
            map["Ipv4PrefixCount"] = self.ipv4PrefixCount!
        }
        if self.ipv6Address != nil {
            map["Ipv6Address"] = self.ipv6Address!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.ipv6Prefix != nil {
            map["Ipv6Prefix"] = self.ipv6Prefix!
        }
        if self.ipv6PrefixCount != nil {
            map["Ipv6PrefixCount"] = self.ipv6PrefixCount!
        }
        if self.networkInterfaceName != nil {
            map["NetworkInterfaceName"] = self.networkInterfaceName!
        }
        if self.networkInterfaceTrafficConfig != nil {
            map["NetworkInterfaceTrafficConfig"] = self.networkInterfaceTrafficConfig?.toMap()
        }
        if self.networkInterfaceTrafficMode != nil {
            map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.primaryIpAddress != nil {
            map["PrimaryIpAddress"] = self.primaryIpAddress!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.queueNumber != nil {
            map["QueueNumber"] = self.queueNumber!
        }
        if self.queuePairNumber != nil {
            map["QueuePairNumber"] = self.queuePairNumber!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.rxQueueSize != nil {
            map["RxQueueSize"] = self.rxQueueSize!
        }
        if self.secondaryPrivateIpAddressCount != nil {
            map["SecondaryPrivateIpAddressCount"] = self.secondaryPrivateIpAddressCount!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds!
        }
        if self.sourceDestCheck != nil {
            map["SourceDestCheck"] = self.sourceDestCheck!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.txQueueSize != nil {
            map["TxQueueSize"] = self.txQueueSize!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.visible != nil {
            map["Visible"] = self.visible!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BusinessType"] as? String {
            self.businessType = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConnectionTrackingConfiguration"] as? [String: Any?] {
            var model = CreateNetworkInterfaceRequest.ConnectionTrackingConfiguration()
            model.fromMap(value)
            self.connectionTrackingConfiguration = model
        }
        if let value = dict["DeleteOnRelease"] as? Bool {
            self.deleteOnRelease = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EnhancedNetwork"] as? [String: Any?] {
            var model = CreateNetworkInterfaceRequest.EnhancedNetwork()
            model.fromMap(value)
            self.enhancedNetwork = model
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["Ipv4Prefix"] as? [String] {
            self.ipv4Prefix = value
        }
        if let value = dict["Ipv4PrefixCount"] as? Int32 {
            self.ipv4PrefixCount = value
        }
        if let value = dict["Ipv6Address"] as? [String] {
            self.ipv6Address = value
        }
        if let value = dict["Ipv6AddressCount"] as? Int32 {
            self.ipv6AddressCount = value
        }
        if let value = dict["Ipv6Prefix"] as? [String] {
            self.ipv6Prefix = value
        }
        if let value = dict["Ipv6PrefixCount"] as? Int32 {
            self.ipv6PrefixCount = value
        }
        if let value = dict["NetworkInterfaceName"] as? String {
            self.networkInterfaceName = value
        }
        if let value = dict["NetworkInterfaceTrafficConfig"] as? [String: Any?] {
            var model = CreateNetworkInterfaceRequest.NetworkInterfaceTrafficConfig()
            model.fromMap(value)
            self.networkInterfaceTrafficConfig = model
        }
        if let value = dict["NetworkInterfaceTrafficMode"] as? String {
            self.networkInterfaceTrafficMode = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PrimaryIpAddress"] as? String {
            self.primaryIpAddress = value
        }
        if let value = dict["PrivateIpAddress"] as? [String] {
            self.privateIpAddress = value
        }
        if let value = dict["QueueNumber"] as? Int32 {
            self.queueNumber = value
        }
        if let value = dict["QueuePairNumber"] as? Int32 {
            self.queuePairNumber = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RxQueueSize"] as? Int32 {
            self.rxQueueSize = value
        }
        if let value = dict["SecondaryPrivateIpAddressCount"] as? Int32 {
            self.secondaryPrivateIpAddressCount = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SecurityGroupIds"] as? [String] {
            self.securityGroupIds = value
        }
        if let value = dict["SourceDestCheck"] as? Bool {
            self.sourceDestCheck = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateNetworkInterfaceRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateNetworkInterfaceRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["TxQueueSize"] as? Int32 {
            self.txQueueSize = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["Visible"] as? Bool {
            self.visible = value
        }
    }
}

public class CreateNetworkInterfaceResponseBody : Tea.TeaModel {
    public class Ipv4PrefixSets : Tea.TeaModel {
        public class Ipv4PrefixSet : Tea.TeaModel {
            public var ipv4Prefix: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipv4Prefix != nil {
                    map["Ipv4Prefix"] = self.ipv4Prefix!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Ipv4Prefix"] as? String {
                    self.ipv4Prefix = value
                }
            }
        }
        public var ipv4PrefixSet: [CreateNetworkInterfaceResponseBody.Ipv4PrefixSets.Ipv4PrefixSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv4PrefixSet != nil {
                var tmp : [Any] = []
                for k in self.ipv4PrefixSet! {
                    tmp.append(k.toMap())
                }
                map["Ipv4PrefixSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Ipv4PrefixSet"] as? [Any?] {
                var tmp : [CreateNetworkInterfaceResponseBody.Ipv4PrefixSets.Ipv4PrefixSet] = []
                for v in value {
                    if v != nil {
                        var model = CreateNetworkInterfaceResponseBody.Ipv4PrefixSets.Ipv4PrefixSet()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ipv4PrefixSet = tmp
            }
        }
    }
    public class Ipv6PrefixSets : Tea.TeaModel {
        public class Ipv6PrefixSet : Tea.TeaModel {
            public var ipv6Prefix: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipv6Prefix != nil {
                    map["Ipv6Prefix"] = self.ipv6Prefix!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Ipv6Prefix"] as? String {
                    self.ipv6Prefix = value
                }
            }
        }
        public var ipv6PrefixSet: [CreateNetworkInterfaceResponseBody.Ipv6PrefixSets.Ipv6PrefixSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6PrefixSet != nil {
                var tmp : [Any] = []
                for k in self.ipv6PrefixSet! {
                    tmp.append(k.toMap())
                }
                map["Ipv6PrefixSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Ipv6PrefixSet"] as? [Any?] {
                var tmp : [CreateNetworkInterfaceResponseBody.Ipv6PrefixSets.Ipv6PrefixSet] = []
                for v in value {
                    if v != nil {
                        var model = CreateNetworkInterfaceResponseBody.Ipv6PrefixSets.Ipv6PrefixSet()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ipv6PrefixSet = tmp
            }
        }
    }
    public class Ipv6Sets : Tea.TeaModel {
        public class Ipv6Set : Tea.TeaModel {
            public var ipv6Address: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipv6Address != nil {
                    map["Ipv6Address"] = self.ipv6Address!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Ipv6Address"] as? String {
                    self.ipv6Address = value
                }
            }
        }
        public var ipv6Set: [CreateNetworkInterfaceResponseBody.Ipv6Sets.Ipv6Set]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6Set != nil {
                var tmp : [Any] = []
                for k in self.ipv6Set! {
                    tmp.append(k.toMap())
                }
                map["Ipv6Set"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Ipv6Set"] as? [Any?] {
                var tmp : [CreateNetworkInterfaceResponseBody.Ipv6Sets.Ipv6Set] = []
                for v in value {
                    if v != nil {
                        var model = CreateNetworkInterfaceResponseBody.Ipv6Sets.Ipv6Set()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ipv6Set = tmp
            }
        }
    }
    public class PrivateIpSets : Tea.TeaModel {
        public class PrivateIpSet : Tea.TeaModel {
            public var primary: Bool?

            public var privateIpAddress: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.primary != nil {
                    map["Primary"] = self.primary!
                }
                if self.privateIpAddress != nil {
                    map["PrivateIpAddress"] = self.privateIpAddress!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Primary"] as? Bool {
                    self.primary = value
                }
                if let value = dict["PrivateIpAddress"] as? String {
                    self.privateIpAddress = value
                }
            }
        }
        public var privateIpSet: [CreateNetworkInterfaceResponseBody.PrivateIpSets.PrivateIpSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.privateIpSet != nil {
                var tmp : [Any] = []
                for k in self.privateIpSet! {
                    tmp.append(k.toMap())
                }
                map["PrivateIpSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PrivateIpSet"] as? [Any?] {
                var tmp : [CreateNetworkInterfaceResponseBody.PrivateIpSets.PrivateIpSet] = []
                for v in value {
                    if v != nil {
                        var model = CreateNetworkInterfaceResponseBody.PrivateIpSets.PrivateIpSet()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.privateIpSet = tmp
            }
        }
    }
    public class SecurityGroupIds : Tea.TeaModel {
        public var securityGroupId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SecurityGroupId"] as? [String] {
                self.securityGroupId = value
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public class Tag : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public var tag: [CreateNetworkInterfaceResponseBody.Tags.Tag]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tag != nil {
                var tmp : [Any] = []
                for k in self.tag! {
                    tmp.append(k.toMap())
                }
                map["Tag"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Tag"] as? [Any?] {
                var tmp : [CreateNetworkInterfaceResponseBody.Tags.Tag] = []
                for v in value {
                    if v != nil {
                        var model = CreateNetworkInterfaceResponseBody.Tags.Tag()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tag = tmp
            }
        }
    }
    public var description_: String?

    public var ipv4PrefixSets: CreateNetworkInterfaceResponseBody.Ipv4PrefixSets?

    public var ipv6PrefixSets: CreateNetworkInterfaceResponseBody.Ipv6PrefixSets?

    public var ipv6Sets: CreateNetworkInterfaceResponseBody.Ipv6Sets?

    public var macAddress: String?

    public var networkInterfaceId: String?

    public var networkInterfaceName: String?

    public var ownerId: String?

    public var privateIpAddress: String?

    public var privateIpSets: CreateNetworkInterfaceResponseBody.PrivateIpSets?

    public var requestId: String?

    public var resourceGroupId: String?

    public var securityGroupIds: CreateNetworkInterfaceResponseBody.SecurityGroupIds?

    public var serviceID: Int64?

    public var serviceManaged: Bool?

    public var sourceDestCheck: Bool?

    public var status: String?

    public var tags: CreateNetworkInterfaceResponseBody.Tags?

    public var type: String?

    public var vSwitchId: String?

    public var vpcId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ipv4PrefixSets?.validate()
        try self.ipv6PrefixSets?.validate()
        try self.ipv6Sets?.validate()
        try self.privateIpSets?.validate()
        try self.securityGroupIds?.validate()
        try self.tags?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ipv4PrefixSets != nil {
            map["Ipv4PrefixSets"] = self.ipv4PrefixSets?.toMap()
        }
        if self.ipv6PrefixSets != nil {
            map["Ipv6PrefixSets"] = self.ipv6PrefixSets?.toMap()
        }
        if self.ipv6Sets != nil {
            map["Ipv6Sets"] = self.ipv6Sets?.toMap()
        }
        if self.macAddress != nil {
            map["MacAddress"] = self.macAddress!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.networkInterfaceName != nil {
            map["NetworkInterfaceName"] = self.networkInterfaceName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.privateIpSets != nil {
            map["PrivateIpSets"] = self.privateIpSets?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds?.toMap()
        }
        if self.serviceID != nil {
            map["ServiceID"] = self.serviceID!
        }
        if self.serviceManaged != nil {
            map["ServiceManaged"] = self.serviceManaged!
        }
        if self.sourceDestCheck != nil {
            map["SourceDestCheck"] = self.sourceDestCheck!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tags != nil {
            map["Tags"] = self.tags?.toMap()
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Ipv4PrefixSets"] as? [String: Any?] {
            var model = CreateNetworkInterfaceResponseBody.Ipv4PrefixSets()
            model.fromMap(value)
            self.ipv4PrefixSets = model
        }
        if let value = dict["Ipv6PrefixSets"] as? [String: Any?] {
            var model = CreateNetworkInterfaceResponseBody.Ipv6PrefixSets()
            model.fromMap(value)
            self.ipv6PrefixSets = model
        }
        if let value = dict["Ipv6Sets"] as? [String: Any?] {
            var model = CreateNetworkInterfaceResponseBody.Ipv6Sets()
            model.fromMap(value)
            self.ipv6Sets = model
        }
        if let value = dict["MacAddress"] as? String {
            self.macAddress = value
        }
        if let value = dict["NetworkInterfaceId"] as? String {
            self.networkInterfaceId = value
        }
        if let value = dict["NetworkInterfaceName"] as? String {
            self.networkInterfaceName = value
        }
        if let value = dict["OwnerId"] as? String {
            self.ownerId = value
        }
        if let value = dict["PrivateIpAddress"] as? String {
            self.privateIpAddress = value
        }
        if let value = dict["PrivateIpSets"] as? [String: Any?] {
            var model = CreateNetworkInterfaceResponseBody.PrivateIpSets()
            model.fromMap(value)
            self.privateIpSets = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["SecurityGroupIds"] as? [String: Any?] {
            var model = CreateNetworkInterfaceResponseBody.SecurityGroupIds()
            model.fromMap(value)
            self.securityGroupIds = model
        }
        if let value = dict["ServiceID"] as? Int64 {
            self.serviceID = value
        }
        if let value = dict["ServiceManaged"] as? Bool {
            self.serviceManaged = value
        }
        if let value = dict["SourceDestCheck"] as? Bool {
            self.sourceDestCheck = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tags"] as? [String: Any?] {
            var model = CreateNetworkInterfaceResponseBody.Tags()
            model.fromMap(value)
            self.tags = model
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class CreateNetworkInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNetworkInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateNetworkInterfaceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateNetworkInterfacePermissionRequest : Tea.TeaModel {
    public var accountId: Int64?

    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var permission: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.permission != nil {
            map["Permission"] = self.permission!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountId"] as? Int64 {
            self.accountId = value
        }
        if let value = dict["NetworkInterfaceId"] as? String {
            self.networkInterfaceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Permission"] as? String {
            self.permission = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CreateNetworkInterfacePermissionResponseBody : Tea.TeaModel {
    public class NetworkInterfacePermission : Tea.TeaModel {
        public var accountId: Int64?

        public var networkInterfaceId: String?

        public var networkInterfacePermissionId: String?

        public var permission: String?

        public var permissionState: String?

        public var serviceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.networkInterfaceId != nil {
                map["NetworkInterfaceId"] = self.networkInterfaceId!
            }
            if self.networkInterfacePermissionId != nil {
                map["NetworkInterfacePermissionId"] = self.networkInterfacePermissionId!
            }
            if self.permission != nil {
                map["Permission"] = self.permission!
            }
            if self.permissionState != nil {
                map["PermissionState"] = self.permissionState!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountId"] as? Int64 {
                self.accountId = value
            }
            if let value = dict["NetworkInterfaceId"] as? String {
                self.networkInterfaceId = value
            }
            if let value = dict["NetworkInterfacePermissionId"] as? String {
                self.networkInterfacePermissionId = value
            }
            if let value = dict["Permission"] as? String {
                self.permission = value
            }
            if let value = dict["PermissionState"] as? String {
                self.permissionState = value
            }
            if let value = dict["ServiceName"] as? String {
                self.serviceName = value
            }
        }
    }
    public var networkInterfacePermission: CreateNetworkInterfacePermissionResponseBody.NetworkInterfacePermission?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkInterfacePermission?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkInterfacePermission != nil {
            map["NetworkInterfacePermission"] = self.networkInterfacePermission?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NetworkInterfacePermission"] as? [String: Any?] {
            var model = CreateNetworkInterfacePermissionResponseBody.NetworkInterfacePermission()
            model.fromMap(value)
            self.networkInterfacePermission = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateNetworkInterfacePermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNetworkInterfacePermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateNetworkInterfacePermissionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreatePhysicalConnectionRequest : Tea.TeaModel {
    public var accessPointId: String?

    public var circuitCode: String?

    public var clientToken: String?

    public var description_: String?

    public var lineOperator: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerLocation: String?

    public var portType: String?

    public var redundantPhysicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var type: String?

    public var userCidr: String?

    public var bandwidth: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessPointId != nil {
            map["AccessPointId"] = self.accessPointId!
        }
        if self.circuitCode != nil {
            map["CircuitCode"] = self.circuitCode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.lineOperator != nil {
            map["LineOperator"] = self.lineOperator!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerLocation != nil {
            map["PeerLocation"] = self.peerLocation!
        }
        if self.portType != nil {
            map["PortType"] = self.portType!
        }
        if self.redundantPhysicalConnectionId != nil {
            map["RedundantPhysicalConnectionId"] = self.redundantPhysicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        if self.bandwidth != nil {
            map["bandwidth"] = self.bandwidth!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessPointId"] as? String {
            self.accessPointId = value
        }
        if let value = dict["CircuitCode"] as? String {
            self.circuitCode = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["LineOperator"] as? String {
            self.lineOperator = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PeerLocation"] as? String {
            self.peerLocation = value
        }
        if let value = dict["PortType"] as? String {
            self.portType = value
        }
        if let value = dict["RedundantPhysicalConnectionId"] as? String {
            self.redundantPhysicalConnectionId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["UserCidr"] as? String {
            self.userCidr = value
        }
        if let value = dict["bandwidth"] as? Int32 {
            self.bandwidth = value
        }
    }
}

public class CreatePhysicalConnectionResponseBody : Tea.TeaModel {
    public var physicalConnectionId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PhysicalConnectionId"] as? String {
            self.physicalConnectionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreatePhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreatePhysicalConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreatePortRangeListRequest : Tea.TeaModel {
    public class Entry : Tea.TeaModel {
        public var description_: String?

        public var portRange: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["PortRange"] as? String {
                self.portRange = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var description_: String?

    public var entry: [CreatePortRangeListRequest.Entry]?

    public var maxEntries: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var portRangeListName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreatePortRangeListRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.entry != nil {
            var tmp : [Any] = []
            for k in self.entry! {
                tmp.append(k.toMap())
            }
            map["Entry"] = tmp
        }
        if self.maxEntries != nil {
            map["MaxEntries"] = self.maxEntries!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.portRangeListName != nil {
            map["PortRangeListName"] = self.portRangeListName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Entry"] as? [Any?] {
            var tmp : [CreatePortRangeListRequest.Entry] = []
            for v in value {
                if v != nil {
                    var model = CreatePortRangeListRequest.Entry()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.entry = tmp
        }
        if let value = dict["MaxEntries"] as? Int32 {
            self.maxEntries = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PortRangeListName"] as? String {
            self.portRangeListName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreatePortRangeListRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreatePortRangeListRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class CreatePortRangeListResponseBody : Tea.TeaModel {
    public var portRangeListId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.portRangeListId != nil {
            map["PortRangeListId"] = self.portRangeListId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PortRangeListId"] as? String {
            self.portRangeListId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreatePortRangeListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePortRangeListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreatePortRangeListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreatePrefixListRequest : Tea.TeaModel {
    public class Entry : Tea.TeaModel {
        public var cidr: String?

        public var description_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidr != nil {
                map["Cidr"] = self.cidr!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Cidr"] as? String {
                self.cidr = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var addressFamily: String?

    public var clientToken: String?

    public var description_: String?

    public var entry: [CreatePrefixListRequest.Entry]?

    public var maxEntries: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var prefixListName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreatePrefixListRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressFamily != nil {
            map["AddressFamily"] = self.addressFamily!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.entry != nil {
            var tmp : [Any] = []
            for k in self.entry! {
                tmp.append(k.toMap())
            }
            map["Entry"] = tmp
        }
        if self.maxEntries != nil {
            map["MaxEntries"] = self.maxEntries!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.prefixListName != nil {
            map["PrefixListName"] = self.prefixListName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddressFamily"] as? String {
            self.addressFamily = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Entry"] as? [Any?] {
            var tmp : [CreatePrefixListRequest.Entry] = []
            for v in value {
                if v != nil {
                    var model = CreatePrefixListRequest.Entry()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.entry = tmp
        }
        if let value = dict["MaxEntries"] as? Int32 {
            self.maxEntries = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PrefixListName"] as? String {
            self.prefixListName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreatePrefixListRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreatePrefixListRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class CreatePrefixListResponseBody : Tea.TeaModel {
    public var prefixListId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.prefixListId != nil {
            map["PrefixListId"] = self.prefixListId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PrefixListId"] as? String {
            self.prefixListId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreatePrefixListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePrefixListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreatePrefixListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateRouteEntryRequest : Tea.TeaModel {
    public class NextHopList : Tea.TeaModel {
        public var nextHopId: String?

        public var nextHopType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nextHopId != nil {
                map["NextHopId"] = self.nextHopId!
            }
            if self.nextHopType != nil {
                map["NextHopType"] = self.nextHopType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["NextHopId"] as? String {
                self.nextHopId = value
            }
            if let value = dict["NextHopType"] as? String {
                self.nextHopType = value
            }
        }
    }
    public var clientToken: String?

    public var destinationCidrBlock: String?

    public var nextHopId: String?

    public var nextHopList: [CreateRouteEntryRequest.NextHopList]?

    public var nextHopType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.destinationCidrBlock != nil {
            map["DestinationCidrBlock"] = self.destinationCidrBlock!
        }
        if self.nextHopId != nil {
            map["NextHopId"] = self.nextHopId!
        }
        if self.nextHopList != nil {
            var tmp : [Any] = []
            for k in self.nextHopList! {
                tmp.append(k.toMap())
            }
            map["NextHopList"] = tmp
        }
        if self.nextHopType != nil {
            map["NextHopType"] = self.nextHopType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DestinationCidrBlock"] as? String {
            self.destinationCidrBlock = value
        }
        if let value = dict["NextHopId"] as? String {
            self.nextHopId = value
        }
        if let value = dict["NextHopList"] as? [Any?] {
            var tmp : [CreateRouteEntryRequest.NextHopList] = []
            for v in value {
                if v != nil {
                    var model = CreateRouteEntryRequest.NextHopList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.nextHopList = tmp
        }
        if let value = dict["NextHopType"] as? String {
            self.nextHopType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteTableId"] as? String {
            self.routeTableId = value
        }
    }
}

public class CreateRouteEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateRouteEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRouteEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateRouteEntryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateRouterInterfaceRequest : Tea.TeaModel {
    public var accessPointId: String?

    public var autoPay: Bool?

    public var clientToken: String?

    public var description_: String?

    public var healthCheckSourceIp: String?

    public var healthCheckTargetIp: String?

    public var instanceChargeType: String?

    public var name: String?

    public var oppositeAccessPointId: String?

    public var oppositeInterfaceId: String?

    public var oppositeInterfaceOwnerId: String?

    public var oppositeRegionId: String?

    public var oppositeRouterId: String?

    public var oppositeRouterType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var pricingCycle: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var role: String?

    public var routerId: String?

    public var routerType: String?

    public var spec: String?

    public var userCidr: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessPointId != nil {
            map["AccessPointId"] = self.accessPointId!
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.healthCheckSourceIp != nil {
            map["HealthCheckSourceIp"] = self.healthCheckSourceIp!
        }
        if self.healthCheckTargetIp != nil {
            map["HealthCheckTargetIp"] = self.healthCheckTargetIp!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.oppositeAccessPointId != nil {
            map["OppositeAccessPointId"] = self.oppositeAccessPointId!
        }
        if self.oppositeInterfaceId != nil {
            map["OppositeInterfaceId"] = self.oppositeInterfaceId!
        }
        if self.oppositeInterfaceOwnerId != nil {
            map["OppositeInterfaceOwnerId"] = self.oppositeInterfaceOwnerId!
        }
        if self.oppositeRegionId != nil {
            map["OppositeRegionId"] = self.oppositeRegionId!
        }
        if self.oppositeRouterId != nil {
            map["OppositeRouterId"] = self.oppositeRouterId!
        }
        if self.oppositeRouterType != nil {
            map["OppositeRouterType"] = self.oppositeRouterType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.pricingCycle != nil {
            map["PricingCycle"] = self.pricingCycle!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        if self.routerId != nil {
            map["RouterId"] = self.routerId!
        }
        if self.routerType != nil {
            map["RouterType"] = self.routerType!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessPointId"] as? String {
            self.accessPointId = value
        }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["HealthCheckSourceIp"] as? String {
            self.healthCheckSourceIp = value
        }
        if let value = dict["HealthCheckTargetIp"] as? String {
            self.healthCheckTargetIp = value
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OppositeAccessPointId"] as? String {
            self.oppositeAccessPointId = value
        }
        if let value = dict["OppositeInterfaceId"] as? String {
            self.oppositeInterfaceId = value
        }
        if let value = dict["OppositeInterfaceOwnerId"] as? String {
            self.oppositeInterfaceOwnerId = value
        }
        if let value = dict["OppositeRegionId"] as? String {
            self.oppositeRegionId = value
        }
        if let value = dict["OppositeRouterId"] as? String {
            self.oppositeRouterId = value
        }
        if let value = dict["OppositeRouterType"] as? String {
            self.oppositeRouterType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PricingCycle"] as? String {
            self.pricingCycle = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Role"] as? String {
            self.role = value
        }
        if let value = dict["RouterId"] as? String {
            self.routerId = value
        }
        if let value = dict["RouterType"] as? String {
            self.routerType = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
        if let value = dict["UserCidr"] as? String {
            self.userCidr = value
        }
    }
}

public class CreateRouterInterfaceResponseBody : Tea.TeaModel {
    public var orderId: Int64?

    public var requestId: String?

    public var routerInterfaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrderId"] as? Int64 {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RouterInterfaceId"] as? String {
            self.routerInterfaceId = value
        }
    }
}

public class CreateRouterInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRouterInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateRouterInterfaceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateSavingsPlanRequest : Tea.TeaModel {
    public var chargeType: String?

    public var committedAmount: String?

    public var instanceTypeFamily: String?

    public var instanceTypeFamilyGroup: String?

    public var offeringType: String?

    public var period: String?

    public var periodUnit: String?

    public var planType: String?

    public var regionId: String?

    public var resourceId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.committedAmount != nil {
            map["CommittedAmount"] = self.committedAmount!
        }
        if self.instanceTypeFamily != nil {
            map["InstanceTypeFamily"] = self.instanceTypeFamily!
        }
        if self.instanceTypeFamilyGroup != nil {
            map["InstanceTypeFamilyGroup"] = self.instanceTypeFamilyGroup!
        }
        if self.offeringType != nil {
            map["OfferingType"] = self.offeringType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.planType != nil {
            map["PlanType"] = self.planType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChargeType"] as? String {
            self.chargeType = value
        }
        if let value = dict["CommittedAmount"] as? String {
            self.committedAmount = value
        }
        if let value = dict["InstanceTypeFamily"] as? String {
            self.instanceTypeFamily = value
        }
        if let value = dict["InstanceTypeFamilyGroup"] as? String {
            self.instanceTypeFamilyGroup = value
        }
        if let value = dict["OfferingType"] as? String {
            self.offeringType = value
        }
        if let value = dict["Period"] as? String {
            self.period = value
        }
        if let value = dict["PeriodUnit"] as? String {
            self.periodUnit = value
        }
        if let value = dict["PlanType"] as? String {
            self.planType = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
    }
}

public class CreateSavingsPlanResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public var savingsPlanId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.savingsPlanId != nil {
            map["SavingsPlanId"] = self.savingsPlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SavingsPlanId"] as? String {
            self.savingsPlanId = value
        }
    }
}

public class CreateSavingsPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSavingsPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateSavingsPlanResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateSecurityGroupRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupName: String?

    public var securityGroupType: String?

    public var serviceManaged: Bool?

    public var tag: [CreateSecurityGroupRequest.Tag]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupName != nil {
            map["SecurityGroupName"] = self.securityGroupName!
        }
        if self.securityGroupType != nil {
            map["SecurityGroupType"] = self.securityGroupType!
        }
        if self.serviceManaged != nil {
            map["ServiceManaged"] = self.serviceManaged!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityGroupName"] as? String {
            self.securityGroupName = value
        }
        if let value = dict["SecurityGroupType"] as? String {
            self.securityGroupType = value
        }
        if let value = dict["ServiceManaged"] as? Bool {
            self.serviceManaged = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateSecurityGroupRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateSecurityGroupRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class CreateSecurityGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
    }
}

public class CreateSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateSecurityGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateSimulatedSystemEventsRequest : Tea.TeaModel {
    public var eventType: String?

    public var instanceId: [String]?

    public var notBefore: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventType != nil {
            map["EventType"] = self.eventType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.notBefore != nil {
            map["NotBefore"] = self.notBefore!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EventType"] as? String {
            self.eventType = value
        }
        if let value = dict["InstanceId"] as? [String] {
            self.instanceId = value
        }
        if let value = dict["NotBefore"] as? String {
            self.notBefore = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CreateSimulatedSystemEventsResponseBody : Tea.TeaModel {
    public class EventIdSet : Tea.TeaModel {
        public var eventId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventId != nil {
                map["EventId"] = self.eventId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EventId"] as? [String] {
                self.eventId = value
            }
        }
    }
    public var eventIdSet: CreateSimulatedSystemEventsResponseBody.EventIdSet?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eventIdSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventIdSet != nil {
            map["EventIdSet"] = self.eventIdSet?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EventIdSet"] as? [String: Any?] {
            var model = CreateSimulatedSystemEventsResponseBody.EventIdSet()
            model.fromMap(value)
            self.eventIdSet = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateSimulatedSystemEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSimulatedSystemEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateSimulatedSystemEventsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateSnapshotRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var category: String?

    public var clientToken: String?

    public var description_: String?

    public var diskId: String?

    public var instantAccess: Bool?

    public var instantAccessRetentionDays: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var retentionDays: Int32?

    public var snapshotName: String?

    public var storageLocationArn: String?

    public var tag: [CreateSnapshotRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.instantAccess != nil {
            map["InstantAccess"] = self.instantAccess!
        }
        if self.instantAccessRetentionDays != nil {
            map["InstantAccessRetentionDays"] = self.instantAccessRetentionDays!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.retentionDays != nil {
            map["RetentionDays"] = self.retentionDays!
        }
        if self.snapshotName != nil {
            map["SnapshotName"] = self.snapshotName!
        }
        if self.storageLocationArn != nil {
            map["StorageLocationArn"] = self.storageLocationArn!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Category"] as? String {
            self.category = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DiskId"] as? String {
            self.diskId = value
        }
        if let value = dict["InstantAccess"] as? Bool {
            self.instantAccess = value
        }
        if let value = dict["InstantAccessRetentionDays"] as? Int32 {
            self.instantAccessRetentionDays = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RetentionDays"] as? Int32 {
            self.retentionDays = value
        }
        if let value = dict["SnapshotName"] as? String {
            self.snapshotName = value
        }
        if let value = dict["StorageLocationArn"] as? String {
            self.storageLocationArn = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateSnapshotRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateSnapshotRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class CreateSnapshotResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var snapshotId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SnapshotId"] as? String {
            self.snapshotId = value
        }
    }
}

public class CreateSnapshotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSnapshotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateSnapshotResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateSnapshotGroupRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var description_: String?

    public var diskId: [String]?

    public var excludeDiskId: [String]?

    public var instanceId: String?

    public var instantAccess: Bool?

    public var instantAccessRetentionDays: Int32?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var storageLocationArn: String?

    public var tag: [CreateSnapshotGroupRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.excludeDiskId != nil {
            map["ExcludeDiskId"] = self.excludeDiskId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instantAccess != nil {
            map["InstantAccess"] = self.instantAccess!
        }
        if self.instantAccessRetentionDays != nil {
            map["InstantAccessRetentionDays"] = self.instantAccessRetentionDays!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.storageLocationArn != nil {
            map["StorageLocationArn"] = self.storageLocationArn!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DiskId"] as? [String] {
            self.diskId = value
        }
        if let value = dict["ExcludeDiskId"] as? [String] {
            self.excludeDiskId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstantAccess"] as? Bool {
            self.instantAccess = value
        }
        if let value = dict["InstantAccessRetentionDays"] as? Int32 {
            self.instantAccessRetentionDays = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StorageLocationArn"] as? String {
            self.storageLocationArn = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateSnapshotGroupRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateSnapshotGroupRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class CreateSnapshotGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var snapshotGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotGroupId != nil {
            map["SnapshotGroupId"] = self.snapshotGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SnapshotGroupId"] as? String {
            self.snapshotGroupId = value
        }
    }
}

public class CreateSnapshotGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSnapshotGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateSnapshotGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateStorageSetRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var description_: String?

    public var maxPartitionNumber: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var storageSetName: String?

    public var tag: [CreateStorageSetRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.maxPartitionNumber != nil {
            map["MaxPartitionNumber"] = self.maxPartitionNumber!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.storageSetName != nil {
            map["StorageSetName"] = self.storageSetName!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["MaxPartitionNumber"] as? Int32 {
            self.maxPartitionNumber = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StorageSetName"] as? String {
            self.storageSetName = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateStorageSetRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateStorageSetRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class CreateStorageSetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var storageSetId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StorageSetId"] as? String {
            self.storageSetId = value
        }
    }
}

public class CreateStorageSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateStorageSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateStorageSetResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateVSwitchRequest : Tea.TeaModel {
    public var cidrBlock: String?

    public var clientToken: String?

    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchName: String?

    public var vpcId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchName != nil {
            map["VSwitchName"] = self.vSwitchName!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CidrBlock"] as? String {
            self.cidrBlock = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VSwitchName"] as? String {
            self.vSwitchName = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class CreateVSwitchResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
    }
}

public class CreateVSwitchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVSwitchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateVSwitchResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateVirtualBorderRouterRequest : Tea.TeaModel {
    public var circuitCode: String?

    public var clientToken: String?

    public var description_: String?

    public var localGatewayIp: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerGatewayIp: String?

    public var peeringSubnetMask: String?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userCidr: String?

    public var vbrOwnerId: Int64?

    public var vlanId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.circuitCode != nil {
            map["CircuitCode"] = self.circuitCode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.localGatewayIp != nil {
            map["LocalGatewayIp"] = self.localGatewayIp!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerGatewayIp != nil {
            map["PeerGatewayIp"] = self.peerGatewayIp!
        }
        if self.peeringSubnetMask != nil {
            map["PeeringSubnetMask"] = self.peeringSubnetMask!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        if self.vbrOwnerId != nil {
            map["VbrOwnerId"] = self.vbrOwnerId!
        }
        if self.vlanId != nil {
            map["VlanId"] = self.vlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CircuitCode"] as? String {
            self.circuitCode = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["LocalGatewayIp"] as? String {
            self.localGatewayIp = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PeerGatewayIp"] as? String {
            self.peerGatewayIp = value
        }
        if let value = dict["PeeringSubnetMask"] as? String {
            self.peeringSubnetMask = value
        }
        if let value = dict["PhysicalConnectionId"] as? String {
            self.physicalConnectionId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["UserCidr"] as? String {
            self.userCidr = value
        }
        if let value = dict["VbrOwnerId"] as? Int64 {
            self.vbrOwnerId = value
        }
        if let value = dict["VlanId"] as? Int32 {
            self.vlanId = value
        }
    }
}

public class CreateVirtualBorderRouterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vbrId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["VbrId"] as? String {
            self.vbrId = value
        }
    }
}

public class CreateVirtualBorderRouterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVirtualBorderRouterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateVirtualBorderRouterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateVpcRequest : Tea.TeaModel {
    public var cidrBlock: String?

    public var clientToken: String?

    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userCidr: String?

    public var vpcName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        if self.vpcName != nil {
            map["VpcName"] = self.vpcName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CidrBlock"] as? String {
            self.cidrBlock = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["UserCidr"] as? String {
            self.userCidr = value
        }
        if let value = dict["VpcName"] as? String {
            self.vpcName = value
        }
    }
}

public class CreateVpcResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var routeTableId: String?

    public var VRouterId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        if self.VRouterId != nil {
            map["VRouterId"] = self.VRouterId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RouteTableId"] as? String {
            self.routeTableId = value
        }
        if let value = dict["VRouterId"] as? String {
            self.VRouterId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class CreateVpcResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVpcResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateVpcResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeactivateRouterInterfaceRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerInterfaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouterInterfaceId"] as? String {
            self.routerInterfaceId = value
        }
    }
}

public class DeactivateRouterInterfaceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeactivateRouterInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeactivateRouterInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeactivateRouterInterfaceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteActivationRequest : Tea.TeaModel {
    public var activationId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activationId != nil {
            map["ActivationId"] = self.activationId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ActivationId"] as? String {
            self.activationId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteActivationResponseBody : Tea.TeaModel {
    public class Activation : Tea.TeaModel {
        public var activationId: String?

        public var creationTime: String?

        public var deregisteredCount: Int32?

        public var description_: String?

        public var instanceCount: Int32?

        public var instanceName: String?

        public var ipAddressRange: String?

        public var registeredCount: Int32?

        public var timeToLiveInHours: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activationId != nil {
                map["ActivationId"] = self.activationId!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.deregisteredCount != nil {
                map["DeregisteredCount"] = self.deregisteredCount!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.instanceCount != nil {
                map["InstanceCount"] = self.instanceCount!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.ipAddressRange != nil {
                map["IpAddressRange"] = self.ipAddressRange!
            }
            if self.registeredCount != nil {
                map["RegisteredCount"] = self.registeredCount!
            }
            if self.timeToLiveInHours != nil {
                map["TimeToLiveInHours"] = self.timeToLiveInHours!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ActivationId"] as? String {
                self.activationId = value
            }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["DeregisteredCount"] as? Int32 {
                self.deregisteredCount = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["InstanceCount"] as? Int32 {
                self.instanceCount = value
            }
            if let value = dict["InstanceName"] as? String {
                self.instanceName = value
            }
            if let value = dict["IpAddressRange"] as? String {
                self.ipAddressRange = value
            }
            if let value = dict["RegisteredCount"] as? Int32 {
                self.registeredCount = value
            }
            if let value = dict["TimeToLiveInHours"] as? Int64 {
                self.timeToLiveInHours = value
            }
        }
    }
    public var activation: DeleteActivationResponseBody.Activation?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.activation?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activation != nil {
            map["Activation"] = self.activation?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Activation"] as? [String: Any?] {
            var model = DeleteActivationResponseBody.Activation()
            model.fromMap(value)
            self.activation = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteActivationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteActivationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteActivationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteAutoProvisioningGroupRequest : Tea.TeaModel {
    public var autoProvisioningGroupId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var terminateInstances: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoProvisioningGroupId != nil {
            map["AutoProvisioningGroupId"] = self.autoProvisioningGroupId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.terminateInstances != nil {
            map["TerminateInstances"] = self.terminateInstances!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoProvisioningGroupId"] as? String {
            self.autoProvisioningGroupId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TerminateInstances"] as? Bool {
            self.terminateInstances = value
        }
    }
}

public class DeleteAutoProvisioningGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteAutoProvisioningGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAutoProvisioningGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteAutoProvisioningGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteAutoSnapshotPolicyRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var autoSnapshotPolicyId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.autoSnapshotPolicyId != nil {
            map["autoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
        }
        if self.regionId != nil {
            map["regionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["autoSnapshotPolicyId"] as? String {
            self.autoSnapshotPolicyId = value
        }
        if let value = dict["regionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeleteAutoSnapshotPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteAutoSnapshotPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAutoSnapshotPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteAutoSnapshotPolicyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteBandwidthPackageRequest : Tea.TeaModel {
    public var bandwidthPackageId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BandwidthPackageId"] as? String {
            self.bandwidthPackageId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteBandwidthPackageResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteBandwidthPackageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBandwidthPackageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteBandwidthPackageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteCommandRequest : Tea.TeaModel {
    public var commandId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandId != nil {
            map["CommandId"] = self.commandId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CommandId"] as? String {
            self.commandId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteCommandResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteCommandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCommandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteCommandResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDedicatedHostClusterRequest : Tea.TeaModel {
    public var dedicatedHostClusterId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DedicatedHostClusterId"] as? String {
            self.dedicatedHostClusterId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteDedicatedHostClusterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteDedicatedHostClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDedicatedHostClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDedicatedHostClusterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDeploymentSetRequest : Tea.TeaModel {
    public var deploymentSetId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeploymentSetId"] as? String {
            self.deploymentSetId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteDeploymentSetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteDeploymentSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDeploymentSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDeploymentSetResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDiagnosticMetricSetsRequest : Tea.TeaModel {
    public var metricSetIds: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.metricSetIds != nil {
            map["MetricSetIds"] = self.metricSetIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MetricSetIds"] as? [String] {
            self.metricSetIds = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeleteDiagnosticMetricSetsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteDiagnosticMetricSetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDiagnosticMetricSetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDiagnosticMetricSetsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDiagnosticReportsRequest : Tea.TeaModel {
    public var regionId: String?

    public var reportIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reportIds != nil {
            map["ReportIds"] = self.reportIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ReportIds"] as? [String] {
            self.reportIds = value
        }
    }
}

public class DeleteDiagnosticReportsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteDiagnosticReportsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDiagnosticReportsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDiagnosticReportsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDiskRequest : Tea.TeaModel {
    public var diskId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DiskId"] as? String {
            self.diskId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteDiskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDiskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteForwardEntryRequest : Tea.TeaModel {
    public var forwardEntryId: String?

    public var forwardTableId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forwardEntryId != nil {
            map["ForwardEntryId"] = self.forwardEntryId!
        }
        if self.forwardTableId != nil {
            map["ForwardTableId"] = self.forwardTableId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ForwardEntryId"] as? String {
            self.forwardEntryId = value
        }
        if let value = dict["ForwardTableId"] as? String {
            self.forwardTableId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteForwardEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteForwardEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteForwardEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteForwardEntryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteHaVipRequest : Tea.TeaModel {
    public var clientToken: String?

    public var haVipId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.haVipId != nil {
            map["HaVipId"] = self.haVipId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["HaVipId"] as? String {
            self.haVipId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteHaVipResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteHaVipResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteHaVipResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteHaVipResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteHpcClusterRequest : Tea.TeaModel {
    public var clientToken: String?

    public var hpcClusterId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.hpcClusterId != nil {
            map["HpcClusterId"] = self.hpcClusterId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["HpcClusterId"] as? String {
            self.hpcClusterId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteHpcClusterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteHpcClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteHpcClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteHpcClusterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteImageRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var force: Bool?

    public var imageId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Force"] as? Bool {
            self.force = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteImageResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteImageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteImageComponentRequest : Tea.TeaModel {
    public var imageComponentId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageComponentId != nil {
            map["ImageComponentId"] = self.imageComponentId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ImageComponentId"] as? String {
            self.imageComponentId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteImageComponentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteImageComponentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteImageComponentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteImageComponentResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteImagePipelineRequest : Tea.TeaModel {
    public var imagePipelineId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imagePipelineId != nil {
            map["ImagePipelineId"] = self.imagePipelineId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ImagePipelineId"] as? String {
            self.imagePipelineId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteImagePipelineResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteImagePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteImagePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteImagePipelineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteInstanceRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var force: Bool?

    public var forceStop: Bool?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var terminateSubscription: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.forceStop != nil {
            map["ForceStop"] = self.forceStop!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.terminateSubscription != nil {
            map["TerminateSubscription"] = self.terminateSubscription!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Force"] as? Bool {
            self.force = value
        }
        if let value = dict["ForceStop"] as? Bool {
            self.forceStop = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TerminateSubscription"] as? Bool {
            self.terminateSubscription = value
        }
    }
}

public class DeleteInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteInstancesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var force: Bool?

    public var forceStop: Bool?

    public var instanceId: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var terminateSubscription: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.forceStop != nil {
            map["ForceStop"] = self.forceStop!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.terminateSubscription != nil {
            map["TerminateSubscription"] = self.terminateSubscription!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Force"] as? Bool {
            self.force = value
        }
        if let value = dict["ForceStop"] as? Bool {
            self.forceStop = value
        }
        if let value = dict["InstanceId"] as? [String] {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TerminateSubscription"] as? Bool {
            self.terminateSubscription = value
        }
    }
}

public class DeleteInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteKeyPairsRequest : Tea.TeaModel {
    public var keyPairNames: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyPairNames != nil {
            map["KeyPairNames"] = self.keyPairNames!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["KeyPairNames"] as? String {
            self.keyPairNames = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteKeyPairsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteKeyPairsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteKeyPairsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteKeyPairsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLaunchTemplateRequest : Tea.TeaModel {
    public var launchTemplateId: String?

    public var launchTemplateName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateName != nil {
            map["LaunchTemplateName"] = self.launchTemplateName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LaunchTemplateId"] as? String {
            self.launchTemplateId = value
        }
        if let value = dict["LaunchTemplateName"] as? String {
            self.launchTemplateName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteLaunchTemplateResponseBody : Tea.TeaModel {
    public class LaunchTemplateVersionNumbers : Tea.TeaModel {
        public var versionNumbers: [Int64]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.versionNumbers != nil {
                map["versionNumbers"] = self.versionNumbers!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["versionNumbers"] as? [Int64] {
                self.versionNumbers = value
            }
        }
    }
    public var launchTemplateId: String?

    public var launchTemplateVersionNumbers: DeleteLaunchTemplateResponseBody.LaunchTemplateVersionNumbers?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.launchTemplateVersionNumbers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateVersionNumbers != nil {
            map["LaunchTemplateVersionNumbers"] = self.launchTemplateVersionNumbers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LaunchTemplateId"] as? String {
            self.launchTemplateId = value
        }
        if let value = dict["LaunchTemplateVersionNumbers"] as? [String: Any?] {
            var model = DeleteLaunchTemplateResponseBody.LaunchTemplateVersionNumbers()
            model.fromMap(value)
            self.launchTemplateVersionNumbers = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLaunchTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLaunchTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLaunchTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLaunchTemplateVersionRequest : Tea.TeaModel {
    public var deleteVersion: [Int64]?

    public var launchTemplateId: String?

    public var launchTemplateName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteVersion != nil {
            map["DeleteVersion"] = self.deleteVersion!
        }
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateName != nil {
            map["LaunchTemplateName"] = self.launchTemplateName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeleteVersion"] as? [Int64] {
            self.deleteVersion = value
        }
        if let value = dict["LaunchTemplateId"] as? String {
            self.launchTemplateId = value
        }
        if let value = dict["LaunchTemplateName"] as? String {
            self.launchTemplateName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteLaunchTemplateVersionResponseBody : Tea.TeaModel {
    public class LaunchTemplateVersions : Tea.TeaModel {
        public class LaunchTemplateVersion : Tea.TeaModel {
            public var launchTemplateId: String?

            public var launchTemplateVersionNumber: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.launchTemplateId != nil {
                    map["LaunchTemplateId"] = self.launchTemplateId!
                }
                if self.launchTemplateVersionNumber != nil {
                    map["LaunchTemplateVersionNumber"] = self.launchTemplateVersionNumber!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LaunchTemplateId"] as? String {
                    self.launchTemplateId = value
                }
                if let value = dict["LaunchTemplateVersionNumber"] as? Int64 {
                    self.launchTemplateVersionNumber = value
                }
            }
        }
        public var launchTemplateVersion: [DeleteLaunchTemplateVersionResponseBody.LaunchTemplateVersions.LaunchTemplateVersion]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.launchTemplateVersion != nil {
                var tmp : [Any] = []
                for k in self.launchTemplateVersion! {
                    tmp.append(k.toMap())
                }
                map["LaunchTemplateVersion"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LaunchTemplateVersion"] as? [Any?] {
                var tmp : [DeleteLaunchTemplateVersionResponseBody.LaunchTemplateVersions.LaunchTemplateVersion] = []
                for v in value {
                    if v != nil {
                        var model = DeleteLaunchTemplateVersionResponseBody.LaunchTemplateVersions.LaunchTemplateVersion()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.launchTemplateVersion = tmp
            }
        }
    }
    public var launchTemplateVersions: DeleteLaunchTemplateVersionResponseBody.LaunchTemplateVersions?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.launchTemplateVersions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.launchTemplateVersions != nil {
            map["LaunchTemplateVersions"] = self.launchTemplateVersions?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LaunchTemplateVersions"] as? [String: Any?] {
            var model = DeleteLaunchTemplateVersionResponseBody.LaunchTemplateVersions()
            model.fromMap(value)
            self.launchTemplateVersions = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLaunchTemplateVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLaunchTemplateVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLaunchTemplateVersionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteNatGatewayRequest : Tea.TeaModel {
    public var natGatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NatGatewayId"] as? String {
            self.natGatewayId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteNatGatewayResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteNatGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNatGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteNatGatewayResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteNetworkInterfaceRequest : Tea.TeaModel {
    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NetworkInterfaceId"] as? String {
            self.networkInterfaceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteNetworkInterfaceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteNetworkInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNetworkInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteNetworkInterfaceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteNetworkInterfacePermissionRequest : Tea.TeaModel {
    public var force: Bool?

    public var networkInterfacePermissionId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.networkInterfacePermissionId != nil {
            map["NetworkInterfacePermissionId"] = self.networkInterfacePermissionId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Force"] as? Bool {
            self.force = value
        }
        if let value = dict["NetworkInterfacePermissionId"] as? String {
            self.networkInterfacePermissionId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteNetworkInterfacePermissionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteNetworkInterfacePermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNetworkInterfacePermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteNetworkInterfacePermissionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeletePhysicalConnectionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PhysicalConnectionId"] as? String {
            self.physicalConnectionId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeletePhysicalConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeletePhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeletePhysicalConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeletePortRangeListRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var portRangeListId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.portRangeListId != nil {
            map["PortRangeListId"] = self.portRangeListId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PortRangeListId"] as? String {
            self.portRangeListId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeletePortRangeListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeletePortRangeListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePortRangeListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeletePortRangeListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeletePrefixListRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var prefixListId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.prefixListId != nil {
            map["PrefixListId"] = self.prefixListId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PrefixListId"] as? String {
            self.prefixListId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeletePrefixListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeletePrefixListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePrefixListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeletePrefixListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteRouteEntryRequest : Tea.TeaModel {
    public class NextHopList : Tea.TeaModel {
        public var nextHopId: String?

        public var nextHopType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nextHopId != nil {
                map["NextHopId"] = self.nextHopId!
            }
            if self.nextHopType != nil {
                map["NextHopType"] = self.nextHopType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["NextHopId"] as? String {
                self.nextHopId = value
            }
            if let value = dict["NextHopType"] as? String {
                self.nextHopType = value
            }
        }
    }
    public var destinationCidrBlock: String?

    public var nextHopId: String?

    public var nextHopList: [DeleteRouteEntryRequest.NextHopList]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationCidrBlock != nil {
            map["DestinationCidrBlock"] = self.destinationCidrBlock!
        }
        if self.nextHopId != nil {
            map["NextHopId"] = self.nextHopId!
        }
        if self.nextHopList != nil {
            var tmp : [Any] = []
            for k in self.nextHopList! {
                tmp.append(k.toMap())
            }
            map["NextHopList"] = tmp
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DestinationCidrBlock"] as? String {
            self.destinationCidrBlock = value
        }
        if let value = dict["NextHopId"] as? String {
            self.nextHopId = value
        }
        if let value = dict["NextHopList"] as? [Any?] {
            var tmp : [DeleteRouteEntryRequest.NextHopList] = []
            for v in value {
                if v != nil {
                    var model = DeleteRouteEntryRequest.NextHopList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.nextHopList = tmp
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteTableId"] as? String {
            self.routeTableId = value
        }
    }
}

public class DeleteRouteEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteRouteEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRouteEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteRouteEntryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteRouterInterfaceRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerInterfaceId: String?

    public var userCidr: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouterInterfaceId"] as? String {
            self.routerInterfaceId = value
        }
        if let value = dict["UserCidr"] as? String {
            self.userCidr = value
        }
    }
}

public class DeleteRouterInterfaceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteRouterInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRouterInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteRouterInterfaceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteSecurityGroupRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
    }
}

public class DeleteSecurityGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteSecurityGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteSnapshotRequest : Tea.TeaModel {
    public var force: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snapshotId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Force"] as? Bool {
            self.force = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SnapshotId"] as? String {
            self.snapshotId = value
        }
    }
}

public class DeleteSnapshotResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteSnapshotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSnapshotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteSnapshotResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteSnapshotGroupRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snapshotGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snapshotGroupId != nil {
            map["SnapshotGroupId"] = self.snapshotGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SnapshotGroupId"] as? String {
            self.snapshotGroupId = value
        }
    }
}

public class DeleteSnapshotGroupResponseBody : Tea.TeaModel {
    public class OperationProgressSet : Tea.TeaModel {
        public class OperationProgress : Tea.TeaModel {
            public class RelatedItemSet : Tea.TeaModel {
                public class RelatedItem : Tea.TeaModel {
                    public var name: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Name"] as? String {
                            self.name = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var relatedItem: [DeleteSnapshotGroupResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet.RelatedItem]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.relatedItem != nil {
                        var tmp : [Any] = []
                        for k in self.relatedItem! {
                            tmp.append(k.toMap())
                        }
                        map["RelatedItem"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RelatedItem"] as? [Any?] {
                        var tmp : [DeleteSnapshotGroupResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet.RelatedItem] = []
                        for v in value {
                            if v != nil {
                                var model = DeleteSnapshotGroupResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet.RelatedItem()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.relatedItem = tmp
                    }
                }
            }
            public var errorCode: String?

            public var errorMsg: String?

            public var operationStatus: String?

            public var relatedItemSet: DeleteSnapshotGroupResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.relatedItemSet?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.operationStatus != nil {
                    map["OperationStatus"] = self.operationStatus!
                }
                if self.relatedItemSet != nil {
                    map["RelatedItemSet"] = self.relatedItemSet?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ErrorCode"] as? String {
                    self.errorCode = value
                }
                if let value = dict["ErrorMsg"] as? String {
                    self.errorMsg = value
                }
                if let value = dict["OperationStatus"] as? String {
                    self.operationStatus = value
                }
                if let value = dict["RelatedItemSet"] as? [String: Any?] {
                    var model = DeleteSnapshotGroupResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet()
                    model.fromMap(value)
                    self.relatedItemSet = model
                }
            }
        }
        public var operationProgress: [DeleteSnapshotGroupResponseBody.OperationProgressSet.OperationProgress]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.operationProgress != nil {
                var tmp : [Any] = []
                for k in self.operationProgress! {
                    tmp.append(k.toMap())
                }
                map["OperationProgress"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OperationProgress"] as? [Any?] {
                var tmp : [DeleteSnapshotGroupResponseBody.OperationProgressSet.OperationProgress] = []
                for v in value {
                    if v != nil {
                        var model = DeleteSnapshotGroupResponseBody.OperationProgressSet.OperationProgress()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.operationProgress = tmp
            }
        }
    }
    public var operationProgressSet: DeleteSnapshotGroupResponseBody.OperationProgressSet?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.operationProgressSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationProgressSet != nil {
            map["OperationProgressSet"] = self.operationProgressSet?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OperationProgressSet"] as? [String: Any?] {
            var model = DeleteSnapshotGroupResponseBody.OperationProgressSet()
            model.fromMap(value)
            self.operationProgressSet = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteSnapshotGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSnapshotGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteSnapshotGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteStorageSetRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var storageSetId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StorageSetId"] as? String {
            self.storageSetId = value
        }
    }
}

public class DeleteStorageSetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteStorageSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteStorageSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteStorageSetResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteVSwitchRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
    }
}

public class DeleteVSwitchResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteVSwitchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVSwitchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteVSwitchResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteVirtualBorderRouterRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userCidr: String?

    public var vbrId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["UserCidr"] as? String {
            self.userCidr = value
        }
        if let value = dict["VbrId"] as? String {
            self.vbrId = value
        }
    }
}

public class DeleteVirtualBorderRouterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteVirtualBorderRouterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVirtualBorderRouterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteVirtualBorderRouterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteVpcRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class DeleteVpcResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteVpcResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVpcResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteVpcResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeregisterManagedInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeregisterManagedInstanceResponseBody : Tea.TeaModel {
    public class Instance : Tea.TeaModel {
        public var activationId: String?

        public var agentVersion: String?

        public var hostname: String?

        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var invocationCount: Int64?

        public var lastInvokedTime: String?

        public var machineId: String?

        public var osType: String?

        public var osVersion: String?

        public var registrationTime: String?

        public var resourceGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activationId != nil {
                map["ActivationId"] = self.activationId!
            }
            if self.agentVersion != nil {
                map["AgentVersion"] = self.agentVersion!
            }
            if self.hostname != nil {
                map["Hostname"] = self.hostname!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.invocationCount != nil {
                map["InvocationCount"] = self.invocationCount!
            }
            if self.lastInvokedTime != nil {
                map["LastInvokedTime"] = self.lastInvokedTime!
            }
            if self.machineId != nil {
                map["MachineId"] = self.machineId!
            }
            if self.osType != nil {
                map["OsType"] = self.osType!
            }
            if self.osVersion != nil {
                map["OsVersion"] = self.osVersion!
            }
            if self.registrationTime != nil {
                map["RegistrationTime"] = self.registrationTime!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ActivationId"] as? String {
                self.activationId = value
            }
            if let value = dict["AgentVersion"] as? String {
                self.agentVersion = value
            }
            if let value = dict["Hostname"] as? String {
                self.hostname = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["InstanceName"] as? String {
                self.instanceName = value
            }
            if let value = dict["InternetIp"] as? String {
                self.internetIp = value
            }
            if let value = dict["IntranetIp"] as? String {
                self.intranetIp = value
            }
            if let value = dict["InvocationCount"] as? Int64 {
                self.invocationCount = value
            }
            if let value = dict["LastInvokedTime"] as? String {
                self.lastInvokedTime = value
            }
            if let value = dict["MachineId"] as? String {
                self.machineId = value
            }
            if let value = dict["OsType"] as? String {
                self.osType = value
            }
            if let value = dict["OsVersion"] as? String {
                self.osVersion = value
            }
            if let value = dict["RegistrationTime"] as? String {
                self.registrationTime = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
        }
    }
    public var instance: DeregisterManagedInstanceResponseBody.Instance?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instance?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instance != nil {
            map["Instance"] = self.instance?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Instance"] as? [String: Any?] {
            var model = DeregisterManagedInstanceResponseBody.Instance()
            model.fromMap(value)
            self.instance = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeregisterManagedInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeregisterManagedInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeregisterManagedInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAccessPointsRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? [String] {
                self.value = value
            }
        }
    }
    public var filter: [DescribeAccessPointsRequest.Filter]?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Filter"] as? [Any?] {
            var tmp : [DescribeAccessPointsRequest.Filter] = []
            for v in value {
                if v != nil {
                    var model = DescribeAccessPointsRequest.Filter()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.filter = tmp
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class DescribeAccessPointsResponseBody : Tea.TeaModel {
    public class AccessPointSet : Tea.TeaModel {
        public class AccessPointType : Tea.TeaModel {
            public var accessPointId: String?

            public var attachedRegionNo: String?

            public var description_: String?

            public var hostOperator: String?

            public var location: String?

            public var name: String?

            public var status: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessPointId != nil {
                    map["AccessPointId"] = self.accessPointId!
                }
                if self.attachedRegionNo != nil {
                    map["AttachedRegionNo"] = self.attachedRegionNo!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.hostOperator != nil {
                    map["HostOperator"] = self.hostOperator!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccessPointId"] as? String {
                    self.accessPointId = value
                }
                if let value = dict["AttachedRegionNo"] as? String {
                    self.attachedRegionNo = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["HostOperator"] as? String {
                    self.hostOperator = value
                }
                if let value = dict["Location"] as? String {
                    self.location = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var accessPointType: [DescribeAccessPointsResponseBody.AccessPointSet.AccessPointType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessPointType != nil {
                var tmp : [Any] = []
                for k in self.accessPointType! {
                    tmp.append(k.toMap())
                }
                map["AccessPointType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccessPointType"] as? [Any?] {
                var tmp : [DescribeAccessPointsResponseBody.AccessPointSet.AccessPointType] = []
                for v in value {
                    if v != nil {
                        var model = DescribeAccessPointsResponseBody.AccessPointSet.AccessPointType()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.accessPointType = tmp
            }
        }
    }
    public var accessPointSet: DescribeAccessPointsResponseBody.AccessPointSet?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accessPointSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessPointSet != nil {
            map["AccessPointSet"] = self.accessPointSet?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessPointSet"] as? [String: Any?] {
            var model = DescribeAccessPointsResponseBody.AccessPointSet()
            model.fromMap(value)
            self.accessPointSet = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeAccessPointsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAccessPointsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAccessPointsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAccountAttributesRequest : Tea.TeaModel {
    public var attributeName: [String]?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attributeName != nil {
            map["AttributeName"] = self.attributeName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AttributeName"] as? [String] {
            self.attributeName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribeAccountAttributesResponseBody : Tea.TeaModel {
    public class AccountAttributeItems : Tea.TeaModel {
        public class AccountAttributeItem : Tea.TeaModel {
            public class AttributeValues : Tea.TeaModel {
                public class ValueItem : Tea.TeaModel {
                    public var count: Int32?

                    public var diskCategory: String?

                    public var expiredTime: String?

                    public var instanceChargeType: String?

                    public var instanceType: String?

                    public var value: String?

                    public var zoneId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        if self.diskCategory != nil {
                            map["DiskCategory"] = self.diskCategory!
                        }
                        if self.expiredTime != nil {
                            map["ExpiredTime"] = self.expiredTime!
                        }
                        if self.instanceChargeType != nil {
                            map["InstanceChargeType"] = self.instanceChargeType!
                        }
                        if self.instanceType != nil {
                            map["InstanceType"] = self.instanceType!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        if self.zoneId != nil {
                            map["ZoneId"] = self.zoneId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Count"] as? Int32 {
                            self.count = value
                        }
                        if let value = dict["DiskCategory"] as? String {
                            self.diskCategory = value
                        }
                        if let value = dict["ExpiredTime"] as? String {
                            self.expiredTime = value
                        }
                        if let value = dict["InstanceChargeType"] as? String {
                            self.instanceChargeType = value
                        }
                        if let value = dict["InstanceType"] as? String {
                            self.instanceType = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                        if let value = dict["ZoneId"] as? String {
                            self.zoneId = value
                        }
                    }
                }
                public var valueItem: [DescribeAccountAttributesResponseBody.AccountAttributeItems.AccountAttributeItem.AttributeValues.ValueItem]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.valueItem != nil {
                        var tmp : [Any] = []
                        for k in self.valueItem! {
                            tmp.append(k.toMap())
                        }
                        map["ValueItem"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ValueItem"] as? [Any?] {
                        var tmp : [DescribeAccountAttributesResponseBody.AccountAttributeItems.AccountAttributeItem.AttributeValues.ValueItem] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeAccountAttributesResponseBody.AccountAttributeItems.AccountAttributeItem.AttributeValues.ValueItem()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.valueItem = tmp
                    }
                }
            }
            public var attributeName: String?

            public var attributeValues: DescribeAccountAttributesResponseBody.AccountAttributeItems.AccountAttributeItem.AttributeValues?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.attributeValues?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.attributeName != nil {
                    map["AttributeName"] = self.attributeName!
                }
                if self.attributeValues != nil {
                    map["AttributeValues"] = self.attributeValues?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AttributeName"] as? String {
                    self.attributeName = value
                }
                if let value = dict["AttributeValues"] as? [String: Any?] {
                    var model = DescribeAccountAttributesResponseBody.AccountAttributeItems.AccountAttributeItem.AttributeValues()
                    model.fromMap(value)
                    self.attributeValues = model
                }
            }
        }
        public var accountAttributeItem: [DescribeAccountAttributesResponseBody.AccountAttributeItems.AccountAttributeItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountAttributeItem != nil {
                var tmp : [Any] = []
                for k in self.accountAttributeItem! {
                    tmp.append(k.toMap())
                }
                map["AccountAttributeItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountAttributeItem"] as? [Any?] {
                var tmp : [DescribeAccountAttributesResponseBody.AccountAttributeItems.AccountAttributeItem] = []
                for v in value {
                    if v != nil {
                        var model = DescribeAccountAttributesResponseBody.AccountAttributeItems.AccountAttributeItem()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.accountAttributeItem = tmp
            }
        }
    }
    public var accountAttributeItems: DescribeAccountAttributesResponseBody.AccountAttributeItems?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountAttributeItems?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountAttributeItems != nil {
            map["AccountAttributeItems"] = self.accountAttributeItems?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountAttributeItems"] as? [String: Any?] {
            var model = DescribeAccountAttributesResponseBody.AccountAttributeItems()
            model.fromMap(value)
            self.accountAttributeItems = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeAccountAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAccountAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAccountAttributesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeActivationsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var activationId: String?

    public var instanceName: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeActivationsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activationId != nil {
            map["ActivationId"] = self.activationId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ActivationId"] as? String {
            self.activationId = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeActivationsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeActivationsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribeActivationsResponseBody : Tea.TeaModel {
    public class ActivationList : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public var activationId: String?

        public var creationTime: String?

        public var deregisteredCount: Int32?

        public var description_: String?

        public var disabled: Bool?

        public var instanceCount: Int32?

        public var instanceName: String?

        public var ipAddressRange: String?

        public var registeredCount: Int32?

        public var resourceGroupId: String?

        public var tags: [DescribeActivationsResponseBody.ActivationList.Tags]?

        public var timeToLiveInHours: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activationId != nil {
                map["ActivationId"] = self.activationId!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.deregisteredCount != nil {
                map["DeregisteredCount"] = self.deregisteredCount!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.disabled != nil {
                map["Disabled"] = self.disabled!
            }
            if self.instanceCount != nil {
                map["InstanceCount"] = self.instanceCount!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.ipAddressRange != nil {
                map["IpAddressRange"] = self.ipAddressRange!
            }
            if self.registeredCount != nil {
                map["RegisteredCount"] = self.registeredCount!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.timeToLiveInHours != nil {
                map["TimeToLiveInHours"] = self.timeToLiveInHours!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ActivationId"] as? String {
                self.activationId = value
            }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["DeregisteredCount"] as? Int32 {
                self.deregisteredCount = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Disabled"] as? Bool {
                self.disabled = value
            }
            if let value = dict["InstanceCount"] as? Int32 {
                self.instanceCount = value
            }
            if let value = dict["InstanceName"] as? String {
                self.instanceName = value
            }
            if let value = dict["IpAddressRange"] as? String {
                self.ipAddressRange = value
            }
            if let value = dict["RegisteredCount"] as? Int32 {
                self.registeredCount = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [DescribeActivationsResponseBody.ActivationList.Tags] = []
                for v in value {
                    if v != nil {
                        var model = DescribeActivationsResponseBody.ActivationList.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["TimeToLiveInHours"] as? Int64 {
                self.timeToLiveInHours = value
            }
        }
    }
    public var activationList: [DescribeActivationsResponseBody.ActivationList]?

    public var nextToken: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activationList != nil {
            var tmp : [Any] = []
            for k in self.activationList! {
                tmp.append(k.toMap())
            }
            map["ActivationList"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ActivationList"] as? [Any?] {
            var tmp : [DescribeActivationsResponseBody.ActivationList] = []
            for v in value {
                if v != nil {
                    var model = DescribeActivationsResponseBody.ActivationList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.activationList = tmp
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribeActivationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeActivationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeActivationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAutoProvisioningGroupHistoryRequest : Tea.TeaModel {
    public var autoProvisioningGroupId: String?

    public var endTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoProvisioningGroupId != nil {
            map["AutoProvisioningGroupId"] = self.autoProvisioningGroupId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoProvisioningGroupId"] as? String {
            self.autoProvisioningGroupId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeAutoProvisioningGroupHistoryResponseBody : Tea.TeaModel {
    public class AutoProvisioningGroupHistories : Tea.TeaModel {
        public class AutoProvisioningGroupHistory : Tea.TeaModel {
            public class ActivityDetails : Tea.TeaModel {
                public class ActivityDetail : Tea.TeaModel {
                    public var detail: String?

                    public var status: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.detail != nil {
                            map["Detail"] = self.detail!
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Detail"] as? String {
                            self.detail = value
                        }
                        if let value = dict["Status"] as? String {
                            self.status = value
                        }
                    }
                }
                public var activityDetail: [DescribeAutoProvisioningGroupHistoryResponseBody.AutoProvisioningGroupHistories.AutoProvisioningGroupHistory.ActivityDetails.ActivityDetail]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.activityDetail != nil {
                        var tmp : [Any] = []
                        for k in self.activityDetail! {
                            tmp.append(k.toMap())
                        }
                        map["ActivityDetail"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ActivityDetail"] as? [Any?] {
                        var tmp : [DescribeAutoProvisioningGroupHistoryResponseBody.AutoProvisioningGroupHistories.AutoProvisioningGroupHistory.ActivityDetails.ActivityDetail] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeAutoProvisioningGroupHistoryResponseBody.AutoProvisioningGroupHistories.AutoProvisioningGroupHistory.ActivityDetails.ActivityDetail()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.activityDetail = tmp
                    }
                }
            }
            public var activityDetails: DescribeAutoProvisioningGroupHistoryResponseBody.AutoProvisioningGroupHistories.AutoProvisioningGroupHistory.ActivityDetails?

            public var lastEventTime: String?

            public var startTime: String?

            public var status: String?

            public var taskId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.activityDetails?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activityDetails != nil {
                    map["ActivityDetails"] = self.activityDetails?.toMap()
                }
                if self.lastEventTime != nil {
                    map["LastEventTime"] = self.lastEventTime!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ActivityDetails"] as? [String: Any?] {
                    var model = DescribeAutoProvisioningGroupHistoryResponseBody.AutoProvisioningGroupHistories.AutoProvisioningGroupHistory.ActivityDetails()
                    model.fromMap(value)
                    self.activityDetails = model
                }
                if let value = dict["LastEventTime"] as? String {
                    self.lastEventTime = value
                }
                if let value = dict["StartTime"] as? String {
                    self.startTime = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["TaskId"] as? String {
                    self.taskId = value
                }
            }
        }
        public var autoProvisioningGroupHistory: [DescribeAutoProvisioningGroupHistoryResponseBody.AutoProvisioningGroupHistories.AutoProvisioningGroupHistory]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoProvisioningGroupHistory != nil {
                var tmp : [Any] = []
                for k in self.autoProvisioningGroupHistory! {
                    tmp.append(k.toMap())
                }
                map["AutoProvisioningGroupHistory"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AutoProvisioningGroupHistory"] as? [Any?] {
                var tmp : [DescribeAutoProvisioningGroupHistoryResponseBody.AutoProvisioningGroupHistories.AutoProvisioningGroupHistory] = []
                for v in value {
                    if v != nil {
                        var model = DescribeAutoProvisioningGroupHistoryResponseBody.AutoProvisioningGroupHistories.AutoProvisioningGroupHistory()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.autoProvisioningGroupHistory = tmp
            }
        }
    }
    public var autoProvisioningGroupHistories: DescribeAutoProvisioningGroupHistoryResponseBody.AutoProvisioningGroupHistories?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.autoProvisioningGroupHistories?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoProvisioningGroupHistories != nil {
            map["AutoProvisioningGroupHistories"] = self.autoProvisioningGroupHistories?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoProvisioningGroupHistories"] as? [String: Any?] {
            var model = DescribeAutoProvisioningGroupHistoryResponseBody.AutoProvisioningGroupHistories()
            model.fromMap(value)
            self.autoProvisioningGroupHistories = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeAutoProvisioningGroupHistoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAutoProvisioningGroupHistoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAutoProvisioningGroupHistoryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAutoProvisioningGroupInstancesRequest : Tea.TeaModel {
    public var autoProvisioningGroupId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoProvisioningGroupId != nil {
            map["AutoProvisioningGroupId"] = self.autoProvisioningGroupId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoProvisioningGroupId"] as? String {
            self.autoProvisioningGroupId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeAutoProvisioningGroupInstancesResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public class Instance : Tea.TeaModel {
            public var CPU: Int32?

            public var creationTime: String?

            public var instanceId: String?

            public var instanceType: String?

            public var ioOptimized: Bool?

            public var isSpot: Bool?

            public var memory: Int32?

            public var networkType: String?

            public var osType: String?

            public var regionId: String?

            public var status: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.CPU != nil {
                    map["CPU"] = self.CPU!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.ioOptimized != nil {
                    map["IoOptimized"] = self.ioOptimized!
                }
                if self.isSpot != nil {
                    map["IsSpot"] = self.isSpot!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.networkType != nil {
                    map["NetworkType"] = self.networkType!
                }
                if self.osType != nil {
                    map["OsType"] = self.osType!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CPU"] as? Int32 {
                    self.CPU = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["InstanceType"] as? String {
                    self.instanceType = value
                }
                if let value = dict["IoOptimized"] as? Bool {
                    self.ioOptimized = value
                }
                if let value = dict["IsSpot"] as? Bool {
                    self.isSpot = value
                }
                if let value = dict["Memory"] as? Int32 {
                    self.memory = value
                }
                if let value = dict["NetworkType"] as? String {
                    self.networkType = value
                }
                if let value = dict["OsType"] as? String {
                    self.osType = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var instance: [DescribeAutoProvisioningGroupInstancesResponseBody.Instances.Instance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instance != nil {
                var tmp : [Any] = []
                for k in self.instance! {
                    tmp.append(k.toMap())
                }
                map["Instance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Instance"] as? [Any?] {
                var tmp : [DescribeAutoProvisioningGroupInstancesResponseBody.Instances.Instance] = []
                for v in value {
                    if v != nil {
                        var model = DescribeAutoProvisioningGroupInstancesResponseBody.Instances.Instance()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instance = tmp
            }
        }
    }
    public var instances: DescribeAutoProvisioningGroupInstancesResponseBody.Instances?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            map["Instances"] = self.instances?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Instances"] as? [String: Any?] {
            var model = DescribeAutoProvisioningGroupInstancesResponseBody.Instances()
            model.fromMap(value)
            self.instances = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeAutoProvisioningGroupInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAutoProvisioningGroupInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAutoProvisioningGroupInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAutoProvisioningGroupsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var autoProvisioningGroupId: [String]?

    public var autoProvisioningGroupName: String?

    public var autoProvisioningGroupStatus: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeAutoProvisioningGroupsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoProvisioningGroupId != nil {
            map["AutoProvisioningGroupId"] = self.autoProvisioningGroupId!
        }
        if self.autoProvisioningGroupName != nil {
            map["AutoProvisioningGroupName"] = self.autoProvisioningGroupName!
        }
        if self.autoProvisioningGroupStatus != nil {
            map["AutoProvisioningGroupStatus"] = self.autoProvisioningGroupStatus!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoProvisioningGroupId"] as? [String] {
            self.autoProvisioningGroupId = value
        }
        if let value = dict["AutoProvisioningGroupName"] as? String {
            self.autoProvisioningGroupName = value
        }
        if let value = dict["AutoProvisioningGroupStatus"] as? [String] {
            self.autoProvisioningGroupStatus = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeAutoProvisioningGroupsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeAutoProvisioningGroupsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribeAutoProvisioningGroupsResponseBody : Tea.TeaModel {
    public class AutoProvisioningGroups : Tea.TeaModel {
        public class AutoProvisioningGroup : Tea.TeaModel {
            public class LaunchTemplateConfigs : Tea.TeaModel {
                public class LaunchTemplateConfig : Tea.TeaModel {
                    public var instanceType: String?

                    public var maxPrice: Double?

                    public var priority: Double?

                    public var vSwitchId: String?

                    public var weightedCapacity: Double?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.instanceType != nil {
                            map["InstanceType"] = self.instanceType!
                        }
                        if self.maxPrice != nil {
                            map["MaxPrice"] = self.maxPrice!
                        }
                        if self.priority != nil {
                            map["Priority"] = self.priority!
                        }
                        if self.vSwitchId != nil {
                            map["VSwitchId"] = self.vSwitchId!
                        }
                        if self.weightedCapacity != nil {
                            map["WeightedCapacity"] = self.weightedCapacity!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["InstanceType"] as? String {
                            self.instanceType = value
                        }
                        if let value = dict["MaxPrice"] as? Double {
                            self.maxPrice = value
                        }
                        if let value = dict["Priority"] as? Double {
                            self.priority = value
                        }
                        if let value = dict["VSwitchId"] as? String {
                            self.vSwitchId = value
                        }
                        if let value = dict["WeightedCapacity"] as? Double {
                            self.weightedCapacity = value
                        }
                    }
                }
                public var launchTemplateConfig: [DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.LaunchTemplateConfigs.LaunchTemplateConfig]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.launchTemplateConfig != nil {
                        var tmp : [Any] = []
                        for k in self.launchTemplateConfig! {
                            tmp.append(k.toMap())
                        }
                        map["LaunchTemplateConfig"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["LaunchTemplateConfig"] as? [Any?] {
                        var tmp : [DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.LaunchTemplateConfigs.LaunchTemplateConfig] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.LaunchTemplateConfigs.LaunchTemplateConfig()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.launchTemplateConfig = tmp
                    }
                }
            }
            public class PayAsYouGoOptions : Tea.TeaModel {
                public var allocationStrategy: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.allocationStrategy != nil {
                        map["AllocationStrategy"] = self.allocationStrategy!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AllocationStrategy"] as? String {
                        self.allocationStrategy = value
                    }
                }
            }
            public class SpotOptions : Tea.TeaModel {
                public var allocationStrategy: String?

                public var instanceInterruptionBehavior: String?

                public var instancePoolsToUseCount: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.allocationStrategy != nil {
                        map["AllocationStrategy"] = self.allocationStrategy!
                    }
                    if self.instanceInterruptionBehavior != nil {
                        map["InstanceInterruptionBehavior"] = self.instanceInterruptionBehavior!
                    }
                    if self.instancePoolsToUseCount != nil {
                        map["InstancePoolsToUseCount"] = self.instancePoolsToUseCount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AllocationStrategy"] as? String {
                        self.allocationStrategy = value
                    }
                    if let value = dict["InstanceInterruptionBehavior"] as? String {
                        self.instanceInterruptionBehavior = value
                    }
                    if let value = dict["InstancePoolsToUseCount"] as? Int32 {
                        self.instancePoolsToUseCount = value
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["TagKey"] as? String {
                            self.tagKey = value
                        }
                        if let value = dict["TagValue"] as? String {
                            self.tagValue = value
                        }
                    }
                }
                public var tag: [DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public class TargetCapacitySpecification : Tea.TeaModel {
                public var defaultTargetCapacityType: String?

                public var payAsYouGoTargetCapacity: Double?

                public var spotTargetCapacity: Double?

                public var totalTargetCapacity: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.defaultTargetCapacityType != nil {
                        map["DefaultTargetCapacityType"] = self.defaultTargetCapacityType!
                    }
                    if self.payAsYouGoTargetCapacity != nil {
                        map["PayAsYouGoTargetCapacity"] = self.payAsYouGoTargetCapacity!
                    }
                    if self.spotTargetCapacity != nil {
                        map["SpotTargetCapacity"] = self.spotTargetCapacity!
                    }
                    if self.totalTargetCapacity != nil {
                        map["TotalTargetCapacity"] = self.totalTargetCapacity!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DefaultTargetCapacityType"] as? String {
                        self.defaultTargetCapacityType = value
                    }
                    if let value = dict["PayAsYouGoTargetCapacity"] as? Double {
                        self.payAsYouGoTargetCapacity = value
                    }
                    if let value = dict["SpotTargetCapacity"] as? Double {
                        self.spotTargetCapacity = value
                    }
                    if let value = dict["TotalTargetCapacity"] as? Double {
                        self.totalTargetCapacity = value
                    }
                }
            }
            public var autoProvisioningGroupId: String?

            public var autoProvisioningGroupName: String?

            public var autoProvisioningGroupType: String?

            public var creationTime: String?

            public var excessCapacityTerminationPolicy: String?

            public var launchTemplateConfigs: DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.LaunchTemplateConfigs?

            public var launchTemplateId: String?

            public var launchTemplateVersion: String?

            public var maxSpotPrice: Double?

            public var payAsYouGoOptions: DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.PayAsYouGoOptions?

            public var regionId: String?

            public var resourceGroupId: String?

            public var spotOptions: DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.SpotOptions?

            public var state: String?

            public var status: String?

            public var tags: DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.Tags?

            public var targetCapacitySpecification: DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.TargetCapacitySpecification?

            public var terminateInstances: Bool?

            public var terminateInstancesWithExpiration: Bool?

            public var validFrom: String?

            public var validUntil: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.launchTemplateConfigs?.validate()
                try self.payAsYouGoOptions?.validate()
                try self.spotOptions?.validate()
                try self.tags?.validate()
                try self.targetCapacitySpecification?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoProvisioningGroupId != nil {
                    map["AutoProvisioningGroupId"] = self.autoProvisioningGroupId!
                }
                if self.autoProvisioningGroupName != nil {
                    map["AutoProvisioningGroupName"] = self.autoProvisioningGroupName!
                }
                if self.autoProvisioningGroupType != nil {
                    map["AutoProvisioningGroupType"] = self.autoProvisioningGroupType!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.excessCapacityTerminationPolicy != nil {
                    map["ExcessCapacityTerminationPolicy"] = self.excessCapacityTerminationPolicy!
                }
                if self.launchTemplateConfigs != nil {
                    map["LaunchTemplateConfigs"] = self.launchTemplateConfigs?.toMap()
                }
                if self.launchTemplateId != nil {
                    map["LaunchTemplateId"] = self.launchTemplateId!
                }
                if self.launchTemplateVersion != nil {
                    map["LaunchTemplateVersion"] = self.launchTemplateVersion!
                }
                if self.maxSpotPrice != nil {
                    map["MaxSpotPrice"] = self.maxSpotPrice!
                }
                if self.payAsYouGoOptions != nil {
                    map["PayAsYouGoOptions"] = self.payAsYouGoOptions?.toMap()
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.spotOptions != nil {
                    map["SpotOptions"] = self.spotOptions?.toMap()
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.targetCapacitySpecification != nil {
                    map["TargetCapacitySpecification"] = self.targetCapacitySpecification?.toMap()
                }
                if self.terminateInstances != nil {
                    map["TerminateInstances"] = self.terminateInstances!
                }
                if self.terminateInstancesWithExpiration != nil {
                    map["TerminateInstancesWithExpiration"] = self.terminateInstancesWithExpiration!
                }
                if self.validFrom != nil {
                    map["ValidFrom"] = self.validFrom!
                }
                if self.validUntil != nil {
                    map["ValidUntil"] = self.validUntil!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AutoProvisioningGroupId"] as? String {
                    self.autoProvisioningGroupId = value
                }
                if let value = dict["AutoProvisioningGroupName"] as? String {
                    self.autoProvisioningGroupName = value
                }
                if let value = dict["AutoProvisioningGroupType"] as? String {
                    self.autoProvisioningGroupType = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["ExcessCapacityTerminationPolicy"] as? String {
                    self.excessCapacityTerminationPolicy = value
                }
                if let value = dict["LaunchTemplateConfigs"] as? [String: Any?] {
                    var model = DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.LaunchTemplateConfigs()
                    model.fromMap(value)
                    self.launchTemplateConfigs = model
                }
                if let value = dict["LaunchTemplateId"] as? String {
                    self.launchTemplateId = value
                }
                if let value = dict["LaunchTemplateVersion"] as? String {
                    self.launchTemplateVersion = value
                }
                if let value = dict["MaxSpotPrice"] as? Double {
                    self.maxSpotPrice = value
                }
                if let value = dict["PayAsYouGoOptions"] as? [String: Any?] {
                    var model = DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.PayAsYouGoOptions()
                    model.fromMap(value)
                    self.payAsYouGoOptions = model
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["SpotOptions"] as? [String: Any?] {
                    var model = DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.SpotOptions()
                    model.fromMap(value)
                    self.spotOptions = model
                }
                if let value = dict["State"] as? String {
                    self.state = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["TargetCapacitySpecification"] as? [String: Any?] {
                    var model = DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.TargetCapacitySpecification()
                    model.fromMap(value)
                    self.targetCapacitySpecification = model
                }
                if let value = dict["TerminateInstances"] as? Bool {
                    self.terminateInstances = value
                }
                if let value = dict["TerminateInstancesWithExpiration"] as? Bool {
                    self.terminateInstancesWithExpiration = value
                }
                if let value = dict["ValidFrom"] as? String {
                    self.validFrom = value
                }
                if let value = dict["ValidUntil"] as? String {
                    self.validUntil = value
                }
            }
        }
        public var autoProvisioningGroup: [DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoProvisioningGroup != nil {
                var tmp : [Any] = []
                for k in self.autoProvisioningGroup! {
                    tmp.append(k.toMap())
                }
                map["AutoProvisioningGroup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AutoProvisioningGroup"] as? [Any?] {
                var tmp : [DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup] = []
                for v in value {
                    if v != nil {
                        var model = DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.autoProvisioningGroup = tmp
            }
        }
    }
    public var autoProvisioningGroups: DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.autoProvisioningGroups?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoProvisioningGroups != nil {
            map["AutoProvisioningGroups"] = self.autoProvisioningGroups?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoProvisioningGroups"] as? [String: Any?] {
            var model = DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups()
            model.fromMap(value)
            self.autoProvisioningGroups = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeAutoProvisioningGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAutoProvisioningGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAutoProvisioningGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAutoSnapshotPolicyExRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var autoSnapshotPolicyId: String?

    public var autoSnapshotPolicyName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeAutoSnapshotPolicyExRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoSnapshotPolicyId != nil {
            map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
        }
        if self.autoSnapshotPolicyName != nil {
            map["AutoSnapshotPolicyName"] = self.autoSnapshotPolicyName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoSnapshotPolicyId"] as? String {
            self.autoSnapshotPolicyId = value
        }
        if let value = dict["AutoSnapshotPolicyName"] as? String {
            self.autoSnapshotPolicyName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeAutoSnapshotPolicyExRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeAutoSnapshotPolicyExRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribeAutoSnapshotPolicyExResponseBody : Tea.TeaModel {
    public class AutoSnapshotPolicies : Tea.TeaModel {
        public class AutoSnapshotPolicy : Tea.TeaModel {
            public class CopyEncryptionConfiguration : Tea.TeaModel {
                public var encrypted: Bool?

                public var KMSKeyId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.encrypted != nil {
                        map["Encrypted"] = self.encrypted!
                    }
                    if self.KMSKeyId != nil {
                        map["KMSKeyId"] = self.KMSKeyId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Encrypted"] as? Bool {
                        self.encrypted = value
                    }
                    if let value = dict["KMSKeyId"] as? String {
                        self.KMSKeyId = value
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["TagKey"] as? String {
                            self.tagKey = value
                        }
                        if let value = dict["TagValue"] as? String {
                            self.tagValue = value
                        }
                    }
                }
                public var tag: [DescribeAutoSnapshotPolicyExResponseBody.AutoSnapshotPolicies.AutoSnapshotPolicy.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeAutoSnapshotPolicyExResponseBody.AutoSnapshotPolicies.AutoSnapshotPolicy.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeAutoSnapshotPolicyExResponseBody.AutoSnapshotPolicies.AutoSnapshotPolicy.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var autoSnapshotPolicyId: String?

            public var autoSnapshotPolicyName: String?

            public var copiedSnapshotsRetentionDays: Int32?

            public var copyEncryptionConfiguration: DescribeAutoSnapshotPolicyExResponseBody.AutoSnapshotPolicies.AutoSnapshotPolicy.CopyEncryptionConfiguration?

            public var creationTime: String?

            public var diskNums: Int32?

            public var enableCrossRegionCopy: Bool?

            public var regionId: String?

            public var repeatWeekdays: String?

            public var resourceGroupId: String?

            public var retentionDays: Int32?

            public var status: String?

            public var tags: DescribeAutoSnapshotPolicyExResponseBody.AutoSnapshotPolicies.AutoSnapshotPolicy.Tags?

            public var targetCopyRegions: String?

            public var timePoints: String?

            public var type: String?

            public var volumeNums: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.copyEncryptionConfiguration?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoSnapshotPolicyId != nil {
                    map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
                }
                if self.autoSnapshotPolicyName != nil {
                    map["AutoSnapshotPolicyName"] = self.autoSnapshotPolicyName!
                }
                if self.copiedSnapshotsRetentionDays != nil {
                    map["CopiedSnapshotsRetentionDays"] = self.copiedSnapshotsRetentionDays!
                }
                if self.copyEncryptionConfiguration != nil {
                    map["CopyEncryptionConfiguration"] = self.copyEncryptionConfiguration?.toMap()
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.diskNums != nil {
                    map["DiskNums"] = self.diskNums!
                }
                if self.enableCrossRegionCopy != nil {
                    map["EnableCrossRegionCopy"] = self.enableCrossRegionCopy!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.repeatWeekdays != nil {
                    map["RepeatWeekdays"] = self.repeatWeekdays!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.retentionDays != nil {
                    map["RetentionDays"] = self.retentionDays!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.targetCopyRegions != nil {
                    map["TargetCopyRegions"] = self.targetCopyRegions!
                }
                if self.timePoints != nil {
                    map["TimePoints"] = self.timePoints!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.volumeNums != nil {
                    map["VolumeNums"] = self.volumeNums!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AutoSnapshotPolicyId"] as? String {
                    self.autoSnapshotPolicyId = value
                }
                if let value = dict["AutoSnapshotPolicyName"] as? String {
                    self.autoSnapshotPolicyName = value
                }
                if let value = dict["CopiedSnapshotsRetentionDays"] as? Int32 {
                    self.copiedSnapshotsRetentionDays = value
                }
                if let value = dict["CopyEncryptionConfiguration"] as? [String: Any?] {
                    var model = DescribeAutoSnapshotPolicyExResponseBody.AutoSnapshotPolicies.AutoSnapshotPolicy.CopyEncryptionConfiguration()
                    model.fromMap(value)
                    self.copyEncryptionConfiguration = model
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["DiskNums"] as? Int32 {
                    self.diskNums = value
                }
                if let value = dict["EnableCrossRegionCopy"] as? Bool {
                    self.enableCrossRegionCopy = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["RepeatWeekdays"] as? String {
                    self.repeatWeekdays = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["RetentionDays"] as? Int32 {
                    self.retentionDays = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeAutoSnapshotPolicyExResponseBody.AutoSnapshotPolicies.AutoSnapshotPolicy.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["TargetCopyRegions"] as? String {
                    self.targetCopyRegions = value
                }
                if let value = dict["TimePoints"] as? String {
                    self.timePoints = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["VolumeNums"] as? Int32 {
                    self.volumeNums = value
                }
            }
        }
        public var autoSnapshotPolicy: [DescribeAutoSnapshotPolicyExResponseBody.AutoSnapshotPolicies.AutoSnapshotPolicy]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicy != nil {
                var tmp : [Any] = []
                for k in self.autoSnapshotPolicy! {
                    tmp.append(k.toMap())
                }
                map["AutoSnapshotPolicy"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AutoSnapshotPolicy"] as? [Any?] {
                var tmp : [DescribeAutoSnapshotPolicyExResponseBody.AutoSnapshotPolicies.AutoSnapshotPolicy] = []
                for v in value {
                    if v != nil {
                        var model = DescribeAutoSnapshotPolicyExResponseBody.AutoSnapshotPolicies.AutoSnapshotPolicy()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.autoSnapshotPolicy = tmp
            }
        }
    }
    public var autoSnapshotPolicies: DescribeAutoSnapshotPolicyExResponseBody.AutoSnapshotPolicies?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.autoSnapshotPolicies?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoSnapshotPolicies != nil {
            map["AutoSnapshotPolicies"] = self.autoSnapshotPolicies?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoSnapshotPolicies"] as? [String: Any?] {
            var model = DescribeAutoSnapshotPolicyExResponseBody.AutoSnapshotPolicies()
            model.fromMap(value)
            self.autoSnapshotPolicies = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeAutoSnapshotPolicyExResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAutoSnapshotPolicyExResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAutoSnapshotPolicyExResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAvailableResourceRequest : Tea.TeaModel {
    public var cores: Int32?

    public var dataDiskCategory: String?

    public var dedicatedHostId: String?

    public var destinationResource: String?

    public var instanceChargeType: String?

    public var instanceType: String?

    public var ioOptimized: String?

    public var memory: Double?

    public var networkCategory: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var scope: String?

    public var spotDuration: Int32?

    public var spotStrategy: String?

    public var systemDiskCategory: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cores != nil {
            map["Cores"] = self.cores!
        }
        if self.dataDiskCategory != nil {
            map["DataDiskCategory"] = self.dataDiskCategory!
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.destinationResource != nil {
            map["DestinationResource"] = self.destinationResource!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.networkCategory != nil {
            map["NetworkCategory"] = self.networkCategory!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.systemDiskCategory != nil {
            map["SystemDiskCategory"] = self.systemDiskCategory!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Cores"] as? Int32 {
            self.cores = value
        }
        if let value = dict["DataDiskCategory"] as? String {
            self.dataDiskCategory = value
        }
        if let value = dict["DedicatedHostId"] as? String {
            self.dedicatedHostId = value
        }
        if let value = dict["DestinationResource"] as? String {
            self.destinationResource = value
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["IoOptimized"] as? String {
            self.ioOptimized = value
        }
        if let value = dict["Memory"] as? Double {
            self.memory = value
        }
        if let value = dict["NetworkCategory"] as? String {
            self.networkCategory = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Scope"] as? String {
            self.scope = value
        }
        if let value = dict["SpotDuration"] as? Int32 {
            self.spotDuration = value
        }
        if let value = dict["SpotStrategy"] as? String {
            self.spotStrategy = value
        }
        if let value = dict["SystemDiskCategory"] as? String {
            self.systemDiskCategory = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribeAvailableResourceResponseBody : Tea.TeaModel {
    public class AvailableZones : Tea.TeaModel {
        public class AvailableZone : Tea.TeaModel {
            public class AvailableResources : Tea.TeaModel {
                public class AvailableResource : Tea.TeaModel {
                    public class SupportedResources : Tea.TeaModel {
                        public class SupportedResource : Tea.TeaModel {
                            public var max: Int32?

                            public var min: Int32?

                            public var status: String?

                            public var statusCategory: String?

                            public var unit: String?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.max != nil {
                                    map["Max"] = self.max!
                                }
                                if self.min != nil {
                                    map["Min"] = self.min!
                                }
                                if self.status != nil {
                                    map["Status"] = self.status!
                                }
                                if self.statusCategory != nil {
                                    map["StatusCategory"] = self.statusCategory!
                                }
                                if self.unit != nil {
                                    map["Unit"] = self.unit!
                                }
                                if self.value != nil {
                                    map["Value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["Max"] as? Int32 {
                                    self.max = value
                                }
                                if let value = dict["Min"] as? Int32 {
                                    self.min = value
                                }
                                if let value = dict["Status"] as? String {
                                    self.status = value
                                }
                                if let value = dict["StatusCategory"] as? String {
                                    self.statusCategory = value
                                }
                                if let value = dict["Unit"] as? String {
                                    self.unit = value
                                }
                                if let value = dict["Value"] as? String {
                                    self.value = value
                                }
                            }
                        }
                        public var supportedResource: [DescribeAvailableResourceResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.SupportedResources.SupportedResource]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.supportedResource != nil {
                                var tmp : [Any] = []
                                for k in self.supportedResource! {
                                    tmp.append(k.toMap())
                                }
                                map["SupportedResource"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["SupportedResource"] as? [Any?] {
                                var tmp : [DescribeAvailableResourceResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.SupportedResources.SupportedResource] = []
                                for v in value {
                                    if v != nil {
                                        var model = DescribeAvailableResourceResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.SupportedResources.SupportedResource()
                                        if v != nil {
                                            model.fromMap(v as? [String: Any?])
                                        }
                                        tmp.append(model)
                                    }
                                }
                                self.supportedResource = tmp
                            }
                        }
                    }
                    public var supportedResources: DescribeAvailableResourceResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.SupportedResources?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.supportedResources?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.supportedResources != nil {
                            map["SupportedResources"] = self.supportedResources?.toMap()
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["SupportedResources"] as? [String: Any?] {
                            var model = DescribeAvailableResourceResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.SupportedResources()
                            model.fromMap(value)
                            self.supportedResources = model
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                    }
                }
                public var availableResource: [DescribeAvailableResourceResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.availableResource != nil {
                        var tmp : [Any] = []
                        for k in self.availableResource! {
                            tmp.append(k.toMap())
                        }
                        map["AvailableResource"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AvailableResource"] as? [Any?] {
                        var tmp : [DescribeAvailableResourceResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeAvailableResourceResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.availableResource = tmp
                    }
                }
            }
            public var availableResources: DescribeAvailableResourceResponseBody.AvailableZones.AvailableZone.AvailableResources?

            public var regionId: String?

            public var status: String?

            public var statusCategory: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.availableResources?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.availableResources != nil {
                    map["AvailableResources"] = self.availableResources?.toMap()
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.statusCategory != nil {
                    map["StatusCategory"] = self.statusCategory!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AvailableResources"] as? [String: Any?] {
                    var model = DescribeAvailableResourceResponseBody.AvailableZones.AvailableZone.AvailableResources()
                    model.fromMap(value)
                    self.availableResources = model
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["StatusCategory"] as? String {
                    self.statusCategory = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var availableZone: [DescribeAvailableResourceResponseBody.AvailableZones.AvailableZone]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.availableZone != nil {
                var tmp : [Any] = []
                for k in self.availableZone! {
                    tmp.append(k.toMap())
                }
                map["AvailableZone"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AvailableZone"] as? [Any?] {
                var tmp : [DescribeAvailableResourceResponseBody.AvailableZones.AvailableZone] = []
                for v in value {
                    if v != nil {
                        var model = DescribeAvailableResourceResponseBody.AvailableZones.AvailableZone()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.availableZone = tmp
            }
        }
    }
    public var availableZones: DescribeAvailableResourceResponseBody.AvailableZones?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.availableZones?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableZones != nil {
            map["AvailableZones"] = self.availableZones?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AvailableZones"] as? [String: Any?] {
            var model = DescribeAvailableResourceResponseBody.AvailableZones()
            model.fromMap(value)
            self.availableZones = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeAvailableResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAvailableResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAvailableResourceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeBandwidthLimitationRequest : Tea.TeaModel {
    public var instanceChargeType: String?

    public var instanceType: String?

    public var operationType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var spotStrategy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.operationType != nil {
            map["OperationType"] = self.operationType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["OperationType"] as? String {
            self.operationType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SpotStrategy"] as? String {
            self.spotStrategy = value
        }
    }
}

public class DescribeBandwidthLimitationResponseBody : Tea.TeaModel {
    public class Bandwidths : Tea.TeaModel {
        public class Bandwidth : Tea.TeaModel {
            public var internetChargeType: String?

            public var max: Int32?

            public var min: Int32?

            public var unit: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.internetChargeType != nil {
                    map["InternetChargeType"] = self.internetChargeType!
                }
                if self.max != nil {
                    map["Max"] = self.max!
                }
                if self.min != nil {
                    map["Min"] = self.min!
                }
                if self.unit != nil {
                    map["Unit"] = self.unit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["InternetChargeType"] as? String {
                    self.internetChargeType = value
                }
                if let value = dict["Max"] as? Int32 {
                    self.max = value
                }
                if let value = dict["Min"] as? Int32 {
                    self.min = value
                }
                if let value = dict["Unit"] as? String {
                    self.unit = value
                }
            }
        }
        public var bandwidth: [DescribeBandwidthLimitationResponseBody.Bandwidths.Bandwidth]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bandwidth != nil {
                var tmp : [Any] = []
                for k in self.bandwidth! {
                    tmp.append(k.toMap())
                }
                map["Bandwidth"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Bandwidth"] as? [Any?] {
                var tmp : [DescribeBandwidthLimitationResponseBody.Bandwidths.Bandwidth] = []
                for v in value {
                    if v != nil {
                        var model = DescribeBandwidthLimitationResponseBody.Bandwidths.Bandwidth()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.bandwidth = tmp
            }
        }
    }
    public var bandwidths: DescribeBandwidthLimitationResponseBody.Bandwidths?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.bandwidths?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidths != nil {
            map["Bandwidths"] = self.bandwidths?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Bandwidths"] as? [String: Any?] {
            var model = DescribeBandwidthLimitationResponseBody.Bandwidths()
            model.fromMap(value)
            self.bandwidths = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeBandwidthLimitationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBandwidthLimitationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeBandwidthLimitationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeBandwidthPackagesRequest : Tea.TeaModel {
    public var bandwidthPackageId: String?

    public var natGatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BandwidthPackageId"] as? String {
            self.bandwidthPackageId = value
        }
        if let value = dict["NatGatewayId"] as? String {
            self.natGatewayId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeBandwidthPackagesResponseBody : Tea.TeaModel {
    public class BandwidthPackages : Tea.TeaModel {
        public class BandwidthPackage : Tea.TeaModel {
            public class PublicIpAddresses : Tea.TeaModel {
                public class PublicIpAddresse : Tea.TeaModel {
                    public var allocationId: String?

                    public var ipAddress: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.allocationId != nil {
                            map["AllocationId"] = self.allocationId!
                        }
                        if self.ipAddress != nil {
                            map["IpAddress"] = self.ipAddress!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AllocationId"] as? String {
                            self.allocationId = value
                        }
                        if let value = dict["IpAddress"] as? String {
                            self.ipAddress = value
                        }
                    }
                }
                public var publicIpAddresse: [DescribeBandwidthPackagesResponseBody.BandwidthPackages.BandwidthPackage.PublicIpAddresses.PublicIpAddresse]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.publicIpAddresse != nil {
                        var tmp : [Any] = []
                        for k in self.publicIpAddresse! {
                            tmp.append(k.toMap())
                        }
                        map["PublicIpAddresse"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["PublicIpAddresse"] as? [Any?] {
                        var tmp : [DescribeBandwidthPackagesResponseBody.BandwidthPackages.BandwidthPackage.PublicIpAddresses.PublicIpAddresse] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeBandwidthPackagesResponseBody.BandwidthPackages.BandwidthPackage.PublicIpAddresses.PublicIpAddresse()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.publicIpAddresse = tmp
                    }
                }
            }
            public var bandwidth: String?

            public var bandwidthPackageId: String?

            public var businessStatus: String?

            public var creationTime: String?

            public var description_: String?

            public var ISP: String?

            public var instanceChargeType: String?

            public var internetChargeType: String?

            public var ipCount: String?

            public var name: String?

            public var natGatewayId: String?

            public var publicIpAddresses: DescribeBandwidthPackagesResponseBody.BandwidthPackages.BandwidthPackage.PublicIpAddresses?

            public var regionId: String?

            public var status: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.publicIpAddresses?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bandwidth != nil {
                    map["Bandwidth"] = self.bandwidth!
                }
                if self.bandwidthPackageId != nil {
                    map["BandwidthPackageId"] = self.bandwidthPackageId!
                }
                if self.businessStatus != nil {
                    map["BusinessStatus"] = self.businessStatus!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ISP != nil {
                    map["ISP"] = self.ISP!
                }
                if self.instanceChargeType != nil {
                    map["InstanceChargeType"] = self.instanceChargeType!
                }
                if self.internetChargeType != nil {
                    map["InternetChargeType"] = self.internetChargeType!
                }
                if self.ipCount != nil {
                    map["IpCount"] = self.ipCount!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.natGatewayId != nil {
                    map["NatGatewayId"] = self.natGatewayId!
                }
                if self.publicIpAddresses != nil {
                    map["PublicIpAddresses"] = self.publicIpAddresses?.toMap()
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Bandwidth"] as? String {
                    self.bandwidth = value
                }
                if let value = dict["BandwidthPackageId"] as? String {
                    self.bandwidthPackageId = value
                }
                if let value = dict["BusinessStatus"] as? String {
                    self.businessStatus = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["ISP"] as? String {
                    self.ISP = value
                }
                if let value = dict["InstanceChargeType"] as? String {
                    self.instanceChargeType = value
                }
                if let value = dict["InternetChargeType"] as? String {
                    self.internetChargeType = value
                }
                if let value = dict["IpCount"] as? String {
                    self.ipCount = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["NatGatewayId"] as? String {
                    self.natGatewayId = value
                }
                if let value = dict["PublicIpAddresses"] as? [String: Any?] {
                    var model = DescribeBandwidthPackagesResponseBody.BandwidthPackages.BandwidthPackage.PublicIpAddresses()
                    model.fromMap(value)
                    self.publicIpAddresses = model
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var bandwidthPackage: [DescribeBandwidthPackagesResponseBody.BandwidthPackages.BandwidthPackage]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bandwidthPackage != nil {
                var tmp : [Any] = []
                for k in self.bandwidthPackage! {
                    tmp.append(k.toMap())
                }
                map["BandwidthPackage"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BandwidthPackage"] as? [Any?] {
                var tmp : [DescribeBandwidthPackagesResponseBody.BandwidthPackages.BandwidthPackage] = []
                for v in value {
                    if v != nil {
                        var model = DescribeBandwidthPackagesResponseBody.BandwidthPackages.BandwidthPackage()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.bandwidthPackage = tmp
            }
        }
    }
    public var bandwidthPackages: DescribeBandwidthPackagesResponseBody.BandwidthPackages?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.bandwidthPackages?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackages != nil {
            map["BandwidthPackages"] = self.bandwidthPackages?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BandwidthPackages"] as? [String: Any?] {
            var model = DescribeBandwidthPackagesResponseBody.BandwidthPackages()
            model.fromMap(value)
            self.bandwidthPackages = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeBandwidthPackagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBandwidthPackagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeBandwidthPackagesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCapacityReservationInstancesRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Id"] as? String {
                self.id = value
            }
        }
    }
    public var privatePoolOptions: DescribeCapacityReservationInstancesRequest.PrivatePoolOptions?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PrivatePoolOptions"] as? [String: Any?] {
            var model = DescribeCapacityReservationInstancesRequest.PrivatePoolOptions()
            model.fromMap(value)
            self.privatePoolOptions = model
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeCapacityReservationInstancesResponseBody : Tea.TeaModel {
    public class CapacityReservationItem : Tea.TeaModel {
        public class InstanceIdSet : Tea.TeaModel {
            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
            }
        }
        public var instanceIdSet: [DescribeCapacityReservationInstancesResponseBody.CapacityReservationItem.InstanceIdSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceIdSet != nil {
                var tmp : [Any] = []
                for k in self.instanceIdSet! {
                    tmp.append(k.toMap())
                }
                map["InstanceIdSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceIdSet"] as? [Any?] {
                var tmp : [DescribeCapacityReservationInstancesResponseBody.CapacityReservationItem.InstanceIdSet] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCapacityReservationInstancesResponseBody.CapacityReservationItem.InstanceIdSet()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instanceIdSet = tmp
            }
        }
    }
    public var capacityReservationItem: DescribeCapacityReservationInstancesResponseBody.CapacityReservationItem?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.capacityReservationItem?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.capacityReservationItem != nil {
            map["CapacityReservationItem"] = self.capacityReservationItem?.toMap()
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CapacityReservationItem"] as? [String: Any?] {
            var model = DescribeCapacityReservationInstancesResponseBody.CapacityReservationItem()
            model.fromMap(value)
            self.capacityReservationItem = model
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeCapacityReservationInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCapacityReservationInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCapacityReservationInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCapacityReservationsRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var ids: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ids != nil {
                map["Ids"] = self.ids!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Ids"] as? String {
                self.ids = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var privatePoolOptions: DescribeCapacityReservationsRequest.PrivatePoolOptions?

    public var instanceChargeType: String?

    public var instanceType: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var platform: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public var tag: [DescribeCapacityReservationsRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PrivatePoolOptions"] as? [String: Any?] {
            var model = DescribeCapacityReservationsRequest.PrivatePoolOptions()
            model.fromMap(value)
            self.privatePoolOptions = model
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Platform"] as? String {
            self.platform = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeCapacityReservationsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeCapacityReservationsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribeCapacityReservationsResponseBody : Tea.TeaModel {
    public class CapacityReservationSet : Tea.TeaModel {
        public class CapacityReservationItem : Tea.TeaModel {
            public class AllocatedResources : Tea.TeaModel {
                public class AllocatedResource : Tea.TeaModel {
                    public class CapacityReservationUsages : Tea.TeaModel {
                        public class CapacityReservationUsage : Tea.TeaModel {
                            public var accountId: String?

                            public var serviceName: String?

                            public var usedAmount: Int32?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.accountId != nil {
                                    map["AccountId"] = self.accountId!
                                }
                                if self.serviceName != nil {
                                    map["ServiceName"] = self.serviceName!
                                }
                                if self.usedAmount != nil {
                                    map["UsedAmount"] = self.usedAmount!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["AccountId"] as? String {
                                    self.accountId = value
                                }
                                if let value = dict["ServiceName"] as? String {
                                    self.serviceName = value
                                }
                                if let value = dict["UsedAmount"] as? Int32 {
                                    self.usedAmount = value
                                }
                            }
                        }
                        public var capacityReservationUsage: [DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.AllocatedResources.AllocatedResource.CapacityReservationUsages.CapacityReservationUsage]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.capacityReservationUsage != nil {
                                var tmp : [Any] = []
                                for k in self.capacityReservationUsage! {
                                    tmp.append(k.toMap())
                                }
                                map["CapacityReservationUsage"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["CapacityReservationUsage"] as? [Any?] {
                                var tmp : [DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.AllocatedResources.AllocatedResource.CapacityReservationUsages.CapacityReservationUsage] = []
                                for v in value {
                                    if v != nil {
                                        var model = DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.AllocatedResources.AllocatedResource.CapacityReservationUsages.CapacityReservationUsage()
                                        if v != nil {
                                            model.fromMap(v as? [String: Any?])
                                        }
                                        tmp.append(model)
                                    }
                                }
                                self.capacityReservationUsage = tmp
                            }
                        }
                    }
                    public var availableAmount: Int32?

                    public var capacityReservationUsages: DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.AllocatedResources.AllocatedResource.CapacityReservationUsages?

                    public var instanceType: String?

                    public var totalAmount: Int32?

                    public var usedAmount: Int32?

                    public var zoneId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.capacityReservationUsages?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.availableAmount != nil {
                            map["AvailableAmount"] = self.availableAmount!
                        }
                        if self.capacityReservationUsages != nil {
                            map["CapacityReservationUsages"] = self.capacityReservationUsages?.toMap()
                        }
                        if self.instanceType != nil {
                            map["InstanceType"] = self.instanceType!
                        }
                        if self.totalAmount != nil {
                            map["TotalAmount"] = self.totalAmount!
                        }
                        if self.usedAmount != nil {
                            map["UsedAmount"] = self.usedAmount!
                        }
                        if self.zoneId != nil {
                            map["zoneId"] = self.zoneId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AvailableAmount"] as? Int32 {
                            self.availableAmount = value
                        }
                        if let value = dict["CapacityReservationUsages"] as? [String: Any?] {
                            var model = DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.AllocatedResources.AllocatedResource.CapacityReservationUsages()
                            model.fromMap(value)
                            self.capacityReservationUsages = model
                        }
                        if let value = dict["InstanceType"] as? String {
                            self.instanceType = value
                        }
                        if let value = dict["TotalAmount"] as? Int32 {
                            self.totalAmount = value
                        }
                        if let value = dict["UsedAmount"] as? Int32 {
                            self.usedAmount = value
                        }
                        if let value = dict["zoneId"] as? String {
                            self.zoneId = value
                        }
                    }
                }
                public var allocatedResource: [DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.AllocatedResources.AllocatedResource]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.allocatedResource != nil {
                        var tmp : [Any] = []
                        for k in self.allocatedResource! {
                            tmp.append(k.toMap())
                        }
                        map["AllocatedResource"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AllocatedResource"] as? [Any?] {
                        var tmp : [DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.AllocatedResources.AllocatedResource] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.AllocatedResources.AllocatedResource()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.allocatedResource = tmp
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["TagKey"] as? String {
                            self.tagKey = value
                        }
                        if let value = dict["TagValue"] as? String {
                            self.tagValue = value
                        }
                    }
                }
                public var tag: [DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var allocatedResources: DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.AllocatedResources?

            public var capacityReservationOwnerId: String?

            public var description_: String?

            public var endTime: String?

            public var endTimeType: String?

            public var instanceChargeType: String?

            public var platform: String?

            public var privatePoolOptionsId: String?

            public var privatePoolOptionsMatchCriteria: String?

            public var privatePoolOptionsName: String?

            public var regionId: String?

            public var reservedInstanceId: String?

            public var resourceGroupId: String?

            public var savingPlanId: String?

            public var startTime: String?

            public var startTimeType: String?

            public var status: String?

            public var tags: DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.Tags?

            public var timeSlot: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.allocatedResources?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allocatedResources != nil {
                    map["AllocatedResources"] = self.allocatedResources?.toMap()
                }
                if self.capacityReservationOwnerId != nil {
                    map["CapacityReservationOwnerId"] = self.capacityReservationOwnerId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.endTimeType != nil {
                    map["EndTimeType"] = self.endTimeType!
                }
                if self.instanceChargeType != nil {
                    map["InstanceChargeType"] = self.instanceChargeType!
                }
                if self.platform != nil {
                    map["Platform"] = self.platform!
                }
                if self.privatePoolOptionsId != nil {
                    map["PrivatePoolOptionsId"] = self.privatePoolOptionsId!
                }
                if self.privatePoolOptionsMatchCriteria != nil {
                    map["PrivatePoolOptionsMatchCriteria"] = self.privatePoolOptionsMatchCriteria!
                }
                if self.privatePoolOptionsName != nil {
                    map["PrivatePoolOptionsName"] = self.privatePoolOptionsName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.reservedInstanceId != nil {
                    map["ReservedInstanceId"] = self.reservedInstanceId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.savingPlanId != nil {
                    map["SavingPlanId"] = self.savingPlanId!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.startTimeType != nil {
                    map["StartTimeType"] = self.startTimeType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.timeSlot != nil {
                    map["TimeSlot"] = self.timeSlot!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AllocatedResources"] as? [String: Any?] {
                    var model = DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.AllocatedResources()
                    model.fromMap(value)
                    self.allocatedResources = model
                }
                if let value = dict["CapacityReservationOwnerId"] as? String {
                    self.capacityReservationOwnerId = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["EndTime"] as? String {
                    self.endTime = value
                }
                if let value = dict["EndTimeType"] as? String {
                    self.endTimeType = value
                }
                if let value = dict["InstanceChargeType"] as? String {
                    self.instanceChargeType = value
                }
                if let value = dict["Platform"] as? String {
                    self.platform = value
                }
                if let value = dict["PrivatePoolOptionsId"] as? String {
                    self.privatePoolOptionsId = value
                }
                if let value = dict["PrivatePoolOptionsMatchCriteria"] as? String {
                    self.privatePoolOptionsMatchCriteria = value
                }
                if let value = dict["PrivatePoolOptionsName"] as? String {
                    self.privatePoolOptionsName = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ReservedInstanceId"] as? String {
                    self.reservedInstanceId = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["SavingPlanId"] as? String {
                    self.savingPlanId = value
                }
                if let value = dict["StartTime"] as? String {
                    self.startTime = value
                }
                if let value = dict["StartTimeType"] as? String {
                    self.startTimeType = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["TimeSlot"] as? String {
                    self.timeSlot = value
                }
            }
        }
        public var capacityReservationItem: [DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.capacityReservationItem != nil {
                var tmp : [Any] = []
                for k in self.capacityReservationItem! {
                    tmp.append(k.toMap())
                }
                map["CapacityReservationItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CapacityReservationItem"] as? [Any?] {
                var tmp : [DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.capacityReservationItem = tmp
            }
        }
    }
    public var capacityReservationSet: DescribeCapacityReservationsResponseBody.CapacityReservationSet?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.capacityReservationSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.capacityReservationSet != nil {
            map["CapacityReservationSet"] = self.capacityReservationSet?.toMap()
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CapacityReservationSet"] as? [String: Any?] {
            var model = DescribeCapacityReservationsResponseBody.CapacityReservationSet()
            model.fromMap(value)
            self.capacityReservationSet = model
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeCapacityReservationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCapacityReservationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCapacityReservationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeClassicLinkInstancesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerId: Int64?

    public var pageNumber: String?

    public var pageSize: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? String {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class DescribeClassicLinkInstancesResponseBody : Tea.TeaModel {
    public class Links : Tea.TeaModel {
        public class Link : Tea.TeaModel {
            public var instanceId: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
            }
        }
        public var link: [DescribeClassicLinkInstancesResponseBody.Links.Link]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.link != nil {
                var tmp : [Any] = []
                for k in self.link! {
                    tmp.append(k.toMap())
                }
                map["Link"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Link"] as? [Any?] {
                var tmp : [DescribeClassicLinkInstancesResponseBody.Links.Link] = []
                for v in value {
                    if v != nil {
                        var model = DescribeClassicLinkInstancesResponseBody.Links.Link()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.link = tmp
            }
        }
    }
    public var links: DescribeClassicLinkInstancesResponseBody.Links?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.links?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.links != nil {
            map["Links"] = self.links?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Links"] as? [String: Any?] {
            var model = DescribeClassicLinkInstancesResponseBody.Links()
            model.fromMap(value)
            self.links = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeClassicLinkInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeClassicLinkInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeClassicLinkInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCloudAssistantSettingsRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var settingType: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.settingType != nil {
            map["SettingType"] = self.settingType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SettingType"] as? [String] {
            self.settingType = value
        }
    }
}

public class DescribeCloudAssistantSettingsResponseBody : Tea.TeaModel {
    public class AgentUpgradeConfig : Tea.TeaModel {
        public class AllowedUpgradeWindows : Tea.TeaModel {
            public var allowedUpgradeWindow: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allowedUpgradeWindow != nil {
                    map["AllowedUpgradeWindow"] = self.allowedUpgradeWindow!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AllowedUpgradeWindow"] as? [String] {
                    self.allowedUpgradeWindow = value
                }
            }
        }
        public var allowedUpgradeWindows: DescribeCloudAssistantSettingsResponseBody.AgentUpgradeConfig.AllowedUpgradeWindows?

        public var enabled: Bool?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.allowedUpgradeWindows?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowedUpgradeWindows != nil {
                map["AllowedUpgradeWindows"] = self.allowedUpgradeWindows?.toMap()
            }
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.timeZone != nil {
                map["TimeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AllowedUpgradeWindows"] as? [String: Any?] {
                var model = DescribeCloudAssistantSettingsResponseBody.AgentUpgradeConfig.AllowedUpgradeWindows()
                model.fromMap(value)
                self.allowedUpgradeWindows = model
            }
            if let value = dict["Enabled"] as? Bool {
                self.enabled = value
            }
            if let value = dict["TimeZone"] as? String {
                self.timeZone = value
            }
        }
    }
    public class OssDeliveryConfigs : Tea.TeaModel {
        public class OssDeliveryConfig : Tea.TeaModel {
            public var bucketName: String?

            public var deliveryType: String?

            public var enabled: Bool?

            public var encryptionAlgorithm: String?

            public var encryptionKeyId: String?

            public var encryptionType: String?

            public var prefix_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucketName != nil {
                    map["BucketName"] = self.bucketName!
                }
                if self.deliveryType != nil {
                    map["DeliveryType"] = self.deliveryType!
                }
                if self.enabled != nil {
                    map["Enabled"] = self.enabled!
                }
                if self.encryptionAlgorithm != nil {
                    map["EncryptionAlgorithm"] = self.encryptionAlgorithm!
                }
                if self.encryptionKeyId != nil {
                    map["EncryptionKeyId"] = self.encryptionKeyId!
                }
                if self.encryptionType != nil {
                    map["EncryptionType"] = self.encryptionType!
                }
                if self.prefix_ != nil {
                    map["Prefix"] = self.prefix_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BucketName"] as? String {
                    self.bucketName = value
                }
                if let value = dict["DeliveryType"] as? String {
                    self.deliveryType = value
                }
                if let value = dict["Enabled"] as? Bool {
                    self.enabled = value
                }
                if let value = dict["EncryptionAlgorithm"] as? String {
                    self.encryptionAlgorithm = value
                }
                if let value = dict["EncryptionKeyId"] as? String {
                    self.encryptionKeyId = value
                }
                if let value = dict["EncryptionType"] as? String {
                    self.encryptionType = value
                }
                if let value = dict["Prefix"] as? String {
                    self.prefix_ = value
                }
            }
        }
        public var ossDeliveryConfig: [DescribeCloudAssistantSettingsResponseBody.OssDeliveryConfigs.OssDeliveryConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ossDeliveryConfig != nil {
                var tmp : [Any] = []
                for k in self.ossDeliveryConfig! {
                    tmp.append(k.toMap())
                }
                map["OssDeliveryConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OssDeliveryConfig"] as? [Any?] {
                var tmp : [DescribeCloudAssistantSettingsResponseBody.OssDeliveryConfigs.OssDeliveryConfig] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCloudAssistantSettingsResponseBody.OssDeliveryConfigs.OssDeliveryConfig()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ossDeliveryConfig = tmp
            }
        }
    }
    public class SlsDeliveryConfigs : Tea.TeaModel {
        public class SlsDeliveryConfig : Tea.TeaModel {
            public var deliveryType: String?

            public var enabled: Bool?

            public var logstoreName: String?

            public var projectName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.deliveryType != nil {
                    map["DeliveryType"] = self.deliveryType!
                }
                if self.enabled != nil {
                    map["Enabled"] = self.enabled!
                }
                if self.logstoreName != nil {
                    map["LogstoreName"] = self.logstoreName!
                }
                if self.projectName != nil {
                    map["ProjectName"] = self.projectName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DeliveryType"] as? String {
                    self.deliveryType = value
                }
                if let value = dict["Enabled"] as? Bool {
                    self.enabled = value
                }
                if let value = dict["LogstoreName"] as? String {
                    self.logstoreName = value
                }
                if let value = dict["ProjectName"] as? String {
                    self.projectName = value
                }
            }
        }
        public var slsDeliveryConfig: [DescribeCloudAssistantSettingsResponseBody.SlsDeliveryConfigs.SlsDeliveryConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.slsDeliveryConfig != nil {
                var tmp : [Any] = []
                for k in self.slsDeliveryConfig! {
                    tmp.append(k.toMap())
                }
                map["SlsDeliveryConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SlsDeliveryConfig"] as? [Any?] {
                var tmp : [DescribeCloudAssistantSettingsResponseBody.SlsDeliveryConfigs.SlsDeliveryConfig] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCloudAssistantSettingsResponseBody.SlsDeliveryConfigs.SlsDeliveryConfig()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.slsDeliveryConfig = tmp
            }
        }
    }
    public var agentUpgradeConfig: DescribeCloudAssistantSettingsResponseBody.AgentUpgradeConfig?

    public var ossDeliveryConfigs: DescribeCloudAssistantSettingsResponseBody.OssDeliveryConfigs?

    public var requestId: String?

    public var slsDeliveryConfigs: DescribeCloudAssistantSettingsResponseBody.SlsDeliveryConfigs?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.agentUpgradeConfig?.validate()
        try self.ossDeliveryConfigs?.validate()
        try self.slsDeliveryConfigs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentUpgradeConfig != nil {
            map["AgentUpgradeConfig"] = self.agentUpgradeConfig?.toMap()
        }
        if self.ossDeliveryConfigs != nil {
            map["OssDeliveryConfigs"] = self.ossDeliveryConfigs?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.slsDeliveryConfigs != nil {
            map["SlsDeliveryConfigs"] = self.slsDeliveryConfigs?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AgentUpgradeConfig"] as? [String: Any?] {
            var model = DescribeCloudAssistantSettingsResponseBody.AgentUpgradeConfig()
            model.fromMap(value)
            self.agentUpgradeConfig = model
        }
        if let value = dict["OssDeliveryConfigs"] as? [String: Any?] {
            var model = DescribeCloudAssistantSettingsResponseBody.OssDeliveryConfigs()
            model.fromMap(value)
            self.ossDeliveryConfigs = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SlsDeliveryConfigs"] as? [String: Any?] {
            var model = DescribeCloudAssistantSettingsResponseBody.SlsDeliveryConfigs()
            model.fromMap(value)
            self.slsDeliveryConfigs = model
        }
    }
}

public class DescribeCloudAssistantSettingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudAssistantSettingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCloudAssistantSettingsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCloudAssistantStatusRequest : Tea.TeaModel {
    public var instanceId: [String]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var OSType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.OSType != nil {
            map["OSType"] = self.OSType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? [String] {
            self.instanceId = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OSType"] as? String {
            self.OSType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeCloudAssistantStatusResponseBody : Tea.TeaModel {
    public class InstanceCloudAssistantStatusSet : Tea.TeaModel {
        public class InstanceCloudAssistantStatus : Tea.TeaModel {
            public var activeTaskCount: Int64?

            public var cloudAssistantStatus: String?

            public var cloudAssistantVersion: String?

            public var instanceId: String?

            public var invocationCount: Int64?

            public var lastHeartbeatTime: String?

            public var lastInvokedTime: String?

            public var OSType: String?

            public var supportSessionManager: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activeTaskCount != nil {
                    map["ActiveTaskCount"] = self.activeTaskCount!
                }
                if self.cloudAssistantStatus != nil {
                    map["CloudAssistantStatus"] = self.cloudAssistantStatus!
                }
                if self.cloudAssistantVersion != nil {
                    map["CloudAssistantVersion"] = self.cloudAssistantVersion!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.invocationCount != nil {
                    map["InvocationCount"] = self.invocationCount!
                }
                if self.lastHeartbeatTime != nil {
                    map["LastHeartbeatTime"] = self.lastHeartbeatTime!
                }
                if self.lastInvokedTime != nil {
                    map["LastInvokedTime"] = self.lastInvokedTime!
                }
                if self.OSType != nil {
                    map["OSType"] = self.OSType!
                }
                if self.supportSessionManager != nil {
                    map["SupportSessionManager"] = self.supportSessionManager!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ActiveTaskCount"] as? Int64 {
                    self.activeTaskCount = value
                }
                if let value = dict["CloudAssistantStatus"] as? String {
                    self.cloudAssistantStatus = value
                }
                if let value = dict["CloudAssistantVersion"] as? String {
                    self.cloudAssistantVersion = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["InvocationCount"] as? Int64 {
                    self.invocationCount = value
                }
                if let value = dict["LastHeartbeatTime"] as? String {
                    self.lastHeartbeatTime = value
                }
                if let value = dict["LastInvokedTime"] as? String {
                    self.lastInvokedTime = value
                }
                if let value = dict["OSType"] as? String {
                    self.OSType = value
                }
                if let value = dict["SupportSessionManager"] as? Bool {
                    self.supportSessionManager = value
                }
            }
        }
        public var instanceCloudAssistantStatus: [DescribeCloudAssistantStatusResponseBody.InstanceCloudAssistantStatusSet.InstanceCloudAssistantStatus]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceCloudAssistantStatus != nil {
                var tmp : [Any] = []
                for k in self.instanceCloudAssistantStatus! {
                    tmp.append(k.toMap())
                }
                map["InstanceCloudAssistantStatus"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceCloudAssistantStatus"] as? [Any?] {
                var tmp : [DescribeCloudAssistantStatusResponseBody.InstanceCloudAssistantStatusSet.InstanceCloudAssistantStatus] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCloudAssistantStatusResponseBody.InstanceCloudAssistantStatusSet.InstanceCloudAssistantStatus()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instanceCloudAssistantStatus = tmp
            }
        }
    }
    public var instanceCloudAssistantStatusSet: DescribeCloudAssistantStatusResponseBody.InstanceCloudAssistantStatusSet?

    public var nextToken: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceCloudAssistantStatusSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceCloudAssistantStatusSet != nil {
            map["InstanceCloudAssistantStatusSet"] = self.instanceCloudAssistantStatusSet?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceCloudAssistantStatusSet"] as? [String: Any?] {
            var model = DescribeCloudAssistantStatusResponseBody.InstanceCloudAssistantStatusSet()
            model.fromMap(value)
            self.instanceCloudAssistantStatusSet = model
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribeCloudAssistantStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudAssistantStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCloudAssistantStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeClustersRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeClustersResponseBody : Tea.TeaModel {
    public class Clusters : Tea.TeaModel {
        public class Cluster : Tea.TeaModel {
            public var clusterId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ClusterId"] as? String {
                    self.clusterId = value
                }
            }
        }
        public var cluster: [DescribeClustersResponseBody.Clusters.Cluster]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cluster != nil {
                var tmp : [Any] = []
                for k in self.cluster! {
                    tmp.append(k.toMap())
                }
                map["Cluster"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Cluster"] as? [Any?] {
                var tmp : [DescribeClustersResponseBody.Clusters.Cluster] = []
                for v in value {
                    if v != nil {
                        var model = DescribeClustersResponseBody.Clusters.Cluster()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.cluster = tmp
            }
        }
    }
    public var clusters: DescribeClustersResponseBody.Clusters?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clusters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusters != nil {
            map["Clusters"] = self.clusters?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Clusters"] as? [String: Any?] {
            var model = DescribeClustersResponseBody.Clusters()
            model.fromMap(value)
            self.clusters = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeClustersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeClustersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeClustersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCommandsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var commandId: String?

    public var contentEncoding: String?

    public var description_: String?

    public var latest: Bool?

    public var maxResults: Int32?

    public var name: String?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var provider: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeCommandsRequest.Tag]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandId != nil {
            map["CommandId"] = self.commandId!
        }
        if self.contentEncoding != nil {
            map["ContentEncoding"] = self.contentEncoding!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.latest != nil {
            map["Latest"] = self.latest!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.provider != nil {
            map["Provider"] = self.provider!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CommandId"] as? String {
            self.commandId = value
        }
        if let value = dict["ContentEncoding"] as? String {
            self.contentEncoding = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Latest"] as? Bool {
            self.latest = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["Provider"] as? String {
            self.provider = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeCommandsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeCommandsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class DescribeCommandsResponseBody : Tea.TeaModel {
    public class Commands : Tea.TeaModel {
        public class Command : Tea.TeaModel {
            public class ParameterDefinitions : Tea.TeaModel {
                public class ParameterDefinition : Tea.TeaModel {
                    public class PossibleValues : Tea.TeaModel {
                        public var possibleValue: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.possibleValue != nil {
                                map["PossibleValue"] = self.possibleValue!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["PossibleValue"] as? [String] {
                                self.possibleValue = value
                            }
                        }
                    }
                    public var defaultValue: String?

                    public var description_: String?

                    public var parameterName: String?

                    public var patternRegex: String?

                    public var possibleValues: DescribeCommandsResponseBody.Commands.Command.ParameterDefinitions.ParameterDefinition.PossibleValues?

                    public var required_: Bool?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.possibleValues?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.defaultValue != nil {
                            map["DefaultValue"] = self.defaultValue!
                        }
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.parameterName != nil {
                            map["ParameterName"] = self.parameterName!
                        }
                        if self.patternRegex != nil {
                            map["PatternRegex"] = self.patternRegex!
                        }
                        if self.possibleValues != nil {
                            map["PossibleValues"] = self.possibleValues?.toMap()
                        }
                        if self.required_ != nil {
                            map["Required"] = self.required_!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["DefaultValue"] as? String {
                            self.defaultValue = value
                        }
                        if let value = dict["Description"] as? String {
                            self.description_ = value
                        }
                        if let value = dict["ParameterName"] as? String {
                            self.parameterName = value
                        }
                        if let value = dict["PatternRegex"] as? String {
                            self.patternRegex = value
                        }
                        if let value = dict["PossibleValues"] as? [String: Any?] {
                            var model = DescribeCommandsResponseBody.Commands.Command.ParameterDefinitions.ParameterDefinition.PossibleValues()
                            model.fromMap(value)
                            self.possibleValues = model
                        }
                        if let value = dict["Required"] as? Bool {
                            self.required_ = value
                        }
                    }
                }
                public var parameterDefinition: [DescribeCommandsResponseBody.Commands.Command.ParameterDefinitions.ParameterDefinition]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.parameterDefinition != nil {
                        var tmp : [Any] = []
                        for k in self.parameterDefinition! {
                            tmp.append(k.toMap())
                        }
                        map["ParameterDefinition"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ParameterDefinition"] as? [Any?] {
                        var tmp : [DescribeCommandsResponseBody.Commands.Command.ParameterDefinitions.ParameterDefinition] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeCommandsResponseBody.Commands.Command.ParameterDefinitions.ParameterDefinition()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.parameterDefinition = tmp
                    }
                }
            }
            public class ParameterNames : Tea.TeaModel {
                public var parameterName: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.parameterName != nil {
                        map["ParameterName"] = self.parameterName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ParameterName"] as? [String] {
                        self.parameterName = value
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["TagKey"] as? String {
                            self.tagKey = value
                        }
                        if let value = dict["TagValue"] as? String {
                            self.tagValue = value
                        }
                    }
                }
                public var tag: [DescribeCommandsResponseBody.Commands.Command.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeCommandsResponseBody.Commands.Command.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeCommandsResponseBody.Commands.Command.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var category: String?

            public var commandContent: String?

            public var commandId: String?

            public var creationTime: String?

            public var description_: String?

            public var enableParameter: Bool?

            public var invokeTimes: Int32?

            public var latest: Bool?

            public var launcher: String?

            public var name: String?

            public var parameterDefinitions: DescribeCommandsResponseBody.Commands.Command.ParameterDefinitions?

            public var parameterNames: DescribeCommandsResponseBody.Commands.Command.ParameterNames?

            public var provider: String?

            public var resourceGroupId: String?

            public var tags: DescribeCommandsResponseBody.Commands.Command.Tags?

            public var timeout: Int64?

            public var type: String?

            public var version: Int32?

            public var workingDir: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.parameterDefinitions?.validate()
                try self.parameterNames?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.commandContent != nil {
                    map["CommandContent"] = self.commandContent!
                }
                if self.commandId != nil {
                    map["CommandId"] = self.commandId!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.enableParameter != nil {
                    map["EnableParameter"] = self.enableParameter!
                }
                if self.invokeTimes != nil {
                    map["InvokeTimes"] = self.invokeTimes!
                }
                if self.latest != nil {
                    map["Latest"] = self.latest!
                }
                if self.launcher != nil {
                    map["Launcher"] = self.launcher!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.parameterDefinitions != nil {
                    map["ParameterDefinitions"] = self.parameterDefinitions?.toMap()
                }
                if self.parameterNames != nil {
                    map["ParameterNames"] = self.parameterNames?.toMap()
                }
                if self.provider != nil {
                    map["Provider"] = self.provider!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                if self.workingDir != nil {
                    map["WorkingDir"] = self.workingDir!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Category"] as? String {
                    self.category = value
                }
                if let value = dict["CommandContent"] as? String {
                    self.commandContent = value
                }
                if let value = dict["CommandId"] as? String {
                    self.commandId = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["EnableParameter"] as? Bool {
                    self.enableParameter = value
                }
                if let value = dict["InvokeTimes"] as? Int32 {
                    self.invokeTimes = value
                }
                if let value = dict["Latest"] as? Bool {
                    self.latest = value
                }
                if let value = dict["Launcher"] as? String {
                    self.launcher = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["ParameterDefinitions"] as? [String: Any?] {
                    var model = DescribeCommandsResponseBody.Commands.Command.ParameterDefinitions()
                    model.fromMap(value)
                    self.parameterDefinitions = model
                }
                if let value = dict["ParameterNames"] as? [String: Any?] {
                    var model = DescribeCommandsResponseBody.Commands.Command.ParameterNames()
                    model.fromMap(value)
                    self.parameterNames = model
                }
                if let value = dict["Provider"] as? String {
                    self.provider = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeCommandsResponseBody.Commands.Command.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["Timeout"] as? Int64 {
                    self.timeout = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["Version"] as? Int32 {
                    self.version = value
                }
                if let value = dict["WorkingDir"] as? String {
                    self.workingDir = value
                }
            }
        }
        public var command: [DescribeCommandsResponseBody.Commands.Command]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.command != nil {
                var tmp : [Any] = []
                for k in self.command! {
                    tmp.append(k.toMap())
                }
                map["Command"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Command"] as? [Any?] {
                var tmp : [DescribeCommandsResponseBody.Commands.Command] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCommandsResponseBody.Commands.Command()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.command = tmp
            }
        }
    }
    public var commands: DescribeCommandsResponseBody.Commands?

    public var nextToken: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.commands?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commands != nil {
            map["Commands"] = self.commands?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Commands"] as? [String: Any?] {
            var model = DescribeCommandsResponseBody.Commands()
            model.fromMap(value)
            self.commands = model
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribeCommandsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCommandsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCommandsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDedicatedHostAutoRenewRequest : Tea.TeaModel {
    public var dedicatedHostIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostIds != nil {
            map["DedicatedHostIds"] = self.dedicatedHostIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DedicatedHostIds"] as? String {
            self.dedicatedHostIds = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeDedicatedHostAutoRenewResponseBody : Tea.TeaModel {
    public class DedicatedHostRenewAttributes : Tea.TeaModel {
        public class DedicatedHostRenewAttribute : Tea.TeaModel {
            public var autoRenewEnabled: Bool?

            public var autoRenewWithEcs: String?

            public var dedicatedHostId: String?

            public var duration: Int32?

            public var periodUnit: String?

            public var renewalStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoRenewEnabled != nil {
                    map["AutoRenewEnabled"] = self.autoRenewEnabled!
                }
                if self.autoRenewWithEcs != nil {
                    map["AutoRenewWithEcs"] = self.autoRenewWithEcs!
                }
                if self.dedicatedHostId != nil {
                    map["DedicatedHostId"] = self.dedicatedHostId!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.periodUnit != nil {
                    map["PeriodUnit"] = self.periodUnit!
                }
                if self.renewalStatus != nil {
                    map["RenewalStatus"] = self.renewalStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AutoRenewEnabled"] as? Bool {
                    self.autoRenewEnabled = value
                }
                if let value = dict["AutoRenewWithEcs"] as? String {
                    self.autoRenewWithEcs = value
                }
                if let value = dict["DedicatedHostId"] as? String {
                    self.dedicatedHostId = value
                }
                if let value = dict["Duration"] as? Int32 {
                    self.duration = value
                }
                if let value = dict["PeriodUnit"] as? String {
                    self.periodUnit = value
                }
                if let value = dict["RenewalStatus"] as? String {
                    self.renewalStatus = value
                }
            }
        }
        public var dedicatedHostRenewAttribute: [DescribeDedicatedHostAutoRenewResponseBody.DedicatedHostRenewAttributes.DedicatedHostRenewAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dedicatedHostRenewAttribute != nil {
                var tmp : [Any] = []
                for k in self.dedicatedHostRenewAttribute! {
                    tmp.append(k.toMap())
                }
                map["DedicatedHostRenewAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DedicatedHostRenewAttribute"] as? [Any?] {
                var tmp : [DescribeDedicatedHostAutoRenewResponseBody.DedicatedHostRenewAttributes.DedicatedHostRenewAttribute] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDedicatedHostAutoRenewResponseBody.DedicatedHostRenewAttributes.DedicatedHostRenewAttribute()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dedicatedHostRenewAttribute = tmp
            }
        }
    }
    public var dedicatedHostRenewAttributes: DescribeDedicatedHostAutoRenewResponseBody.DedicatedHostRenewAttributes?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dedicatedHostRenewAttributes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostRenewAttributes != nil {
            map["DedicatedHostRenewAttributes"] = self.dedicatedHostRenewAttributes?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DedicatedHostRenewAttributes"] as? [String: Any?] {
            var model = DescribeDedicatedHostAutoRenewResponseBody.DedicatedHostRenewAttributes()
            model.fromMap(value)
            self.dedicatedHostRenewAttributes = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDedicatedHostAutoRenewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDedicatedHostAutoRenewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDedicatedHostAutoRenewResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDedicatedHostClustersRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var dedicatedHostClusterIds: String?

    public var dedicatedHostClusterName: String?

    public var lockReason: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public var tag: [DescribeDedicatedHostClustersRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostClusterIds != nil {
            map["DedicatedHostClusterIds"] = self.dedicatedHostClusterIds!
        }
        if self.dedicatedHostClusterName != nil {
            map["DedicatedHostClusterName"] = self.dedicatedHostClusterName!
        }
        if self.lockReason != nil {
            map["LockReason"] = self.lockReason!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DedicatedHostClusterIds"] as? String {
            self.dedicatedHostClusterIds = value
        }
        if let value = dict["DedicatedHostClusterName"] as? String {
            self.dedicatedHostClusterName = value
        }
        if let value = dict["LockReason"] as? String {
            self.lockReason = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeDedicatedHostClustersRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeDedicatedHostClustersRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribeDedicatedHostClustersResponseBody : Tea.TeaModel {
    public class DedicatedHostClusters : Tea.TeaModel {
        public class DedicatedHostCluster : Tea.TeaModel {
            public class DedicatedHostClusterCapacity : Tea.TeaModel {
                public class AvailableInstanceTypes : Tea.TeaModel {
                    public class AvailableInstanceType : Tea.TeaModel {
                        public var availableInstanceCapacity: Int32?

                        public var instanceType: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.availableInstanceCapacity != nil {
                                map["AvailableInstanceCapacity"] = self.availableInstanceCapacity!
                            }
                            if self.instanceType != nil {
                                map["InstanceType"] = self.instanceType!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["AvailableInstanceCapacity"] as? Int32 {
                                self.availableInstanceCapacity = value
                            }
                            if let value = dict["InstanceType"] as? String {
                                self.instanceType = value
                            }
                        }
                    }
                    public var availableInstanceType: [DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity.AvailableInstanceTypes.AvailableInstanceType]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.availableInstanceType != nil {
                            var tmp : [Any] = []
                            for k in self.availableInstanceType! {
                                tmp.append(k.toMap())
                            }
                            map["AvailableInstanceType"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AvailableInstanceType"] as? [Any?] {
                            var tmp : [DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity.AvailableInstanceTypes.AvailableInstanceType] = []
                            for v in value {
                                if v != nil {
                                    var model = DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity.AvailableInstanceTypes.AvailableInstanceType()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.availableInstanceType = tmp
                        }
                    }
                }
                public class LocalStorageCapacities : Tea.TeaModel {
                    public class LocalStorageCapacity : Tea.TeaModel {
                        public var availableDisk: Int32?

                        public var dataDiskCategory: String?

                        public var totalDisk: Int32?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.availableDisk != nil {
                                map["AvailableDisk"] = self.availableDisk!
                            }
                            if self.dataDiskCategory != nil {
                                map["DataDiskCategory"] = self.dataDiskCategory!
                            }
                            if self.totalDisk != nil {
                                map["TotalDisk"] = self.totalDisk!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["AvailableDisk"] as? Int32 {
                                self.availableDisk = value
                            }
                            if let value = dict["DataDiskCategory"] as? String {
                                self.dataDiskCategory = value
                            }
                            if let value = dict["TotalDisk"] as? Int32 {
                                self.totalDisk = value
                            }
                        }
                    }
                    public var localStorageCapacity: [DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity.LocalStorageCapacities.LocalStorageCapacity]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.localStorageCapacity != nil {
                            var tmp : [Any] = []
                            for k in self.localStorageCapacity! {
                                tmp.append(k.toMap())
                            }
                            map["LocalStorageCapacity"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["LocalStorageCapacity"] as? [Any?] {
                            var tmp : [DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity.LocalStorageCapacities.LocalStorageCapacity] = []
                            for v in value {
                                if v != nil {
                                    var model = DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity.LocalStorageCapacities.LocalStorageCapacity()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.localStorageCapacity = tmp
                        }
                    }
                }
                public var availableInstanceTypes: DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity.AvailableInstanceTypes?

                public var availableMemory: Int32?

                public var availableVcpus: Int32?

                public var localStorageCapacities: DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity.LocalStorageCapacities?

                public var totalMemory: Int32?

                public var totalVcpus: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.availableInstanceTypes?.validate()
                    try self.localStorageCapacities?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.availableInstanceTypes != nil {
                        map["AvailableInstanceTypes"] = self.availableInstanceTypes?.toMap()
                    }
                    if self.availableMemory != nil {
                        map["AvailableMemory"] = self.availableMemory!
                    }
                    if self.availableVcpus != nil {
                        map["AvailableVcpus"] = self.availableVcpus!
                    }
                    if self.localStorageCapacities != nil {
                        map["LocalStorageCapacities"] = self.localStorageCapacities?.toMap()
                    }
                    if self.totalMemory != nil {
                        map["TotalMemory"] = self.totalMemory!
                    }
                    if self.totalVcpus != nil {
                        map["TotalVcpus"] = self.totalVcpus!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AvailableInstanceTypes"] as? [String: Any?] {
                        var model = DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity.AvailableInstanceTypes()
                        model.fromMap(value)
                        self.availableInstanceTypes = model
                    }
                    if let value = dict["AvailableMemory"] as? Int32 {
                        self.availableMemory = value
                    }
                    if let value = dict["AvailableVcpus"] as? Int32 {
                        self.availableVcpus = value
                    }
                    if let value = dict["LocalStorageCapacities"] as? [String: Any?] {
                        var model = DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity.LocalStorageCapacities()
                        model.fromMap(value)
                        self.localStorageCapacities = model
                    }
                    if let value = dict["TotalMemory"] as? Int32 {
                        self.totalMemory = value
                    }
                    if let value = dict["TotalVcpus"] as? Int32 {
                        self.totalVcpus = value
                    }
                }
            }
            public class DedicatedHostIds : Tea.TeaModel {
                public var dedicatedHostId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dedicatedHostId != nil {
                        map["DedicatedHostId"] = self.dedicatedHostId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DedicatedHostId"] as? [String] {
                        self.dedicatedHostId = value
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["TagKey"] as? String {
                            self.tagKey = value
                        }
                        if let value = dict["TagValue"] as? String {
                            self.tagValue = value
                        }
                    }
                }
                public var tag: [DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var dedicatedHostClusterCapacity: DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity?

            public var dedicatedHostClusterId: String?

            public var dedicatedHostClusterName: String?

            public var dedicatedHostIds: DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostIds?

            public var description_: String?

            public var regionId: String?

            public var resourceGroupId: String?

            public var tags: DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.Tags?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dedicatedHostClusterCapacity?.validate()
                try self.dedicatedHostIds?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dedicatedHostClusterCapacity != nil {
                    map["DedicatedHostClusterCapacity"] = self.dedicatedHostClusterCapacity?.toMap()
                }
                if self.dedicatedHostClusterId != nil {
                    map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
                }
                if self.dedicatedHostClusterName != nil {
                    map["DedicatedHostClusterName"] = self.dedicatedHostClusterName!
                }
                if self.dedicatedHostIds != nil {
                    map["DedicatedHostIds"] = self.dedicatedHostIds?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DedicatedHostClusterCapacity"] as? [String: Any?] {
                    var model = DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity()
                    model.fromMap(value)
                    self.dedicatedHostClusterCapacity = model
                }
                if let value = dict["DedicatedHostClusterId"] as? String {
                    self.dedicatedHostClusterId = value
                }
                if let value = dict["DedicatedHostClusterName"] as? String {
                    self.dedicatedHostClusterName = value
                }
                if let value = dict["DedicatedHostIds"] as? [String: Any?] {
                    var model = DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostIds()
                    model.fromMap(value)
                    self.dedicatedHostIds = model
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var dedicatedHostCluster: [DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dedicatedHostCluster != nil {
                var tmp : [Any] = []
                for k in self.dedicatedHostCluster! {
                    tmp.append(k.toMap())
                }
                map["DedicatedHostCluster"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DedicatedHostCluster"] as? [Any?] {
                var tmp : [DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dedicatedHostCluster = tmp
            }
        }
    }
    public var dedicatedHostClusters: DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dedicatedHostClusters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostClusters != nil {
            map["DedicatedHostClusters"] = self.dedicatedHostClusters?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DedicatedHostClusters"] as? [String: Any?] {
            var model = DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters()
            model.fromMap(value)
            self.dedicatedHostClusters = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeDedicatedHostClustersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDedicatedHostClustersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDedicatedHostClustersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDedicatedHostTypesRequest : Tea.TeaModel {
    public var dedicatedHostType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var supportedInstanceTypeFamily: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostType != nil {
            map["DedicatedHostType"] = self.dedicatedHostType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.supportedInstanceTypeFamily != nil {
            map["SupportedInstanceTypeFamily"] = self.supportedInstanceTypeFamily!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DedicatedHostType"] as? String {
            self.dedicatedHostType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SupportedInstanceTypeFamily"] as? String {
            self.supportedInstanceTypeFamily = value
        }
    }
}

public class DescribeDedicatedHostTypesResponseBody : Tea.TeaModel {
    public class DedicatedHostTypes : Tea.TeaModel {
        public class DedicatedHostType : Tea.TeaModel {
            public class SupportedInstanceTypeFamilies : Tea.TeaModel {
                public var supportedInstanceTypeFamily: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.supportedInstanceTypeFamily != nil {
                        map["SupportedInstanceTypeFamily"] = self.supportedInstanceTypeFamily!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["SupportedInstanceTypeFamily"] as? [String] {
                        self.supportedInstanceTypeFamily = value
                    }
                }
            }
            public class SupportedInstanceTypesList : Tea.TeaModel {
                public var supportedInstanceTypesList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.supportedInstanceTypesList != nil {
                        map["SupportedInstanceTypesList"] = self.supportedInstanceTypesList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["SupportedInstanceTypesList"] as? [String] {
                        self.supportedInstanceTypesList = value
                    }
                }
            }
            public var cores: Int32?

            public var cpuOverCommitRatioRange: String?

            public var dedicatedHostType: String?

            public var GPUSpec: String?

            public var localStorageAmount: Int32?

            public var localStorageCapacity: Int64?

            public var localStorageCategory: String?

            public var memorySize: Double?

            public var physicalGpus: Int32?

            public var sockets: Int32?

            public var supportCpuOverCommitRatio: Bool?

            public var supportedInstanceTypeFamilies: DescribeDedicatedHostTypesResponseBody.DedicatedHostTypes.DedicatedHostType.SupportedInstanceTypeFamilies?

            public var supportedInstanceTypesList: DescribeDedicatedHostTypesResponseBody.DedicatedHostTypes.DedicatedHostType.SupportedInstanceTypesList?

            public var totalVcpus: Int32?

            public var totalVgpus: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.supportedInstanceTypeFamilies?.validate()
                try self.supportedInstanceTypesList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cores != nil {
                    map["Cores"] = self.cores!
                }
                if self.cpuOverCommitRatioRange != nil {
                    map["CpuOverCommitRatioRange"] = self.cpuOverCommitRatioRange!
                }
                if self.dedicatedHostType != nil {
                    map["DedicatedHostType"] = self.dedicatedHostType!
                }
                if self.GPUSpec != nil {
                    map["GPUSpec"] = self.GPUSpec!
                }
                if self.localStorageAmount != nil {
                    map["LocalStorageAmount"] = self.localStorageAmount!
                }
                if self.localStorageCapacity != nil {
                    map["LocalStorageCapacity"] = self.localStorageCapacity!
                }
                if self.localStorageCategory != nil {
                    map["LocalStorageCategory"] = self.localStorageCategory!
                }
                if self.memorySize != nil {
                    map["MemorySize"] = self.memorySize!
                }
                if self.physicalGpus != nil {
                    map["PhysicalGpus"] = self.physicalGpus!
                }
                if self.sockets != nil {
                    map["Sockets"] = self.sockets!
                }
                if self.supportCpuOverCommitRatio != nil {
                    map["SupportCpuOverCommitRatio"] = self.supportCpuOverCommitRatio!
                }
                if self.supportedInstanceTypeFamilies != nil {
                    map["SupportedInstanceTypeFamilies"] = self.supportedInstanceTypeFamilies?.toMap()
                }
                if self.supportedInstanceTypesList != nil {
                    map["SupportedInstanceTypesList"] = self.supportedInstanceTypesList?.toMap()
                }
                if self.totalVcpus != nil {
                    map["TotalVcpus"] = self.totalVcpus!
                }
                if self.totalVgpus != nil {
                    map["TotalVgpus"] = self.totalVgpus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Cores"] as? Int32 {
                    self.cores = value
                }
                if let value = dict["CpuOverCommitRatioRange"] as? String {
                    self.cpuOverCommitRatioRange = value
                }
                if let value = dict["DedicatedHostType"] as? String {
                    self.dedicatedHostType = value
                }
                if let value = dict["GPUSpec"] as? String {
                    self.GPUSpec = value
                }
                if let value = dict["LocalStorageAmount"] as? Int32 {
                    self.localStorageAmount = value
                }
                if let value = dict["LocalStorageCapacity"] as? Int64 {
                    self.localStorageCapacity = value
                }
                if let value = dict["LocalStorageCategory"] as? String {
                    self.localStorageCategory = value
                }
                if let value = dict["MemorySize"] as? Double {
                    self.memorySize = value
                }
                if let value = dict["PhysicalGpus"] as? Int32 {
                    self.physicalGpus = value
                }
                if let value = dict["Sockets"] as? Int32 {
                    self.sockets = value
                }
                if let value = dict["SupportCpuOverCommitRatio"] as? Bool {
                    self.supportCpuOverCommitRatio = value
                }
                if let value = dict["SupportedInstanceTypeFamilies"] as? [String: Any?] {
                    var model = DescribeDedicatedHostTypesResponseBody.DedicatedHostTypes.DedicatedHostType.SupportedInstanceTypeFamilies()
                    model.fromMap(value)
                    self.supportedInstanceTypeFamilies = model
                }
                if let value = dict["SupportedInstanceTypesList"] as? [String: Any?] {
                    var model = DescribeDedicatedHostTypesResponseBody.DedicatedHostTypes.DedicatedHostType.SupportedInstanceTypesList()
                    model.fromMap(value)
                    self.supportedInstanceTypesList = model
                }
                if let value = dict["TotalVcpus"] as? Int32 {
                    self.totalVcpus = value
                }
                if let value = dict["TotalVgpus"] as? Int32 {
                    self.totalVgpus = value
                }
            }
        }
        public var dedicatedHostType: [DescribeDedicatedHostTypesResponseBody.DedicatedHostTypes.DedicatedHostType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dedicatedHostType != nil {
                var tmp : [Any] = []
                for k in self.dedicatedHostType! {
                    tmp.append(k.toMap())
                }
                map["DedicatedHostType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DedicatedHostType"] as? [Any?] {
                var tmp : [DescribeDedicatedHostTypesResponseBody.DedicatedHostTypes.DedicatedHostType] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDedicatedHostTypesResponseBody.DedicatedHostTypes.DedicatedHostType()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dedicatedHostType = tmp
            }
        }
    }
    public var dedicatedHostTypes: DescribeDedicatedHostTypesResponseBody.DedicatedHostTypes?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dedicatedHostTypes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostTypes != nil {
            map["DedicatedHostTypes"] = self.dedicatedHostTypes?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DedicatedHostTypes"] as? [String: Any?] {
            var model = DescribeDedicatedHostTypesResponseBody.DedicatedHostTypes()
            model.fromMap(value)
            self.dedicatedHostTypes = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDedicatedHostTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDedicatedHostTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDedicatedHostTypesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDedicatedHostsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var dedicatedHostClusterId: String?

    public var dedicatedHostIds: String?

    public var dedicatedHostName: String?

    public var dedicatedHostType: String?

    public var lockReason: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var socketDetails: String?

    public var status: String?

    public var tag: [DescribeDedicatedHostsRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.dedicatedHostIds != nil {
            map["DedicatedHostIds"] = self.dedicatedHostIds!
        }
        if self.dedicatedHostName != nil {
            map["DedicatedHostName"] = self.dedicatedHostName!
        }
        if self.dedicatedHostType != nil {
            map["DedicatedHostType"] = self.dedicatedHostType!
        }
        if self.lockReason != nil {
            map["LockReason"] = self.lockReason!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.socketDetails != nil {
            map["SocketDetails"] = self.socketDetails!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DedicatedHostClusterId"] as? String {
            self.dedicatedHostClusterId = value
        }
        if let value = dict["DedicatedHostIds"] as? String {
            self.dedicatedHostIds = value
        }
        if let value = dict["DedicatedHostName"] as? String {
            self.dedicatedHostName = value
        }
        if let value = dict["DedicatedHostType"] as? String {
            self.dedicatedHostType = value
        }
        if let value = dict["LockReason"] as? String {
            self.lockReason = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SocketDetails"] as? String {
            self.socketDetails = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeDedicatedHostsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeDedicatedHostsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribeDedicatedHostsResponseBody : Tea.TeaModel {
    public class DedicatedHosts : Tea.TeaModel {
        public class DedicatedHost : Tea.TeaModel {
            public class SchedulerOptions : Tea.TeaModel {
                public var managedPrivateSpaceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.managedPrivateSpaceId != nil {
                        map["ManagedPrivateSpaceId"] = self.managedPrivateSpaceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ManagedPrivateSpaceId"] as? String {
                        self.managedPrivateSpaceId = value
                    }
                }
            }
            public class Capacity : Tea.TeaModel {
                public class SocketCapacities : Tea.TeaModel {
                    public class SocketCapacity : Tea.TeaModel {
                        public var availableMemory: Double?

                        public var availableVcpu: Int32?

                        public var socketId: Int32?

                        public var totalMemory: Double?

                        public var totalVcpu: Int32?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.availableMemory != nil {
                                map["AvailableMemory"] = self.availableMemory!
                            }
                            if self.availableVcpu != nil {
                                map["AvailableVcpu"] = self.availableVcpu!
                            }
                            if self.socketId != nil {
                                map["SocketId"] = self.socketId!
                            }
                            if self.totalMemory != nil {
                                map["TotalMemory"] = self.totalMemory!
                            }
                            if self.totalVcpu != nil {
                                map["TotalVcpu"] = self.totalVcpu!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["AvailableMemory"] as? Double {
                                self.availableMemory = value
                            }
                            if let value = dict["AvailableVcpu"] as? Int32 {
                                self.availableVcpu = value
                            }
                            if let value = dict["SocketId"] as? Int32 {
                                self.socketId = value
                            }
                            if let value = dict["TotalMemory"] as? Double {
                                self.totalMemory = value
                            }
                            if let value = dict["TotalVcpu"] as? Int32 {
                                self.totalVcpu = value
                            }
                        }
                    }
                    public var socketCapacity: [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Capacity.SocketCapacities.SocketCapacity]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.socketCapacity != nil {
                            var tmp : [Any] = []
                            for k in self.socketCapacity! {
                                tmp.append(k.toMap())
                            }
                            map["SocketCapacity"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["SocketCapacity"] as? [Any?] {
                            var tmp : [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Capacity.SocketCapacities.SocketCapacity] = []
                            for v in value {
                                if v != nil {
                                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Capacity.SocketCapacities.SocketCapacity()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.socketCapacity = tmp
                        }
                    }
                }
                public var availableLocalStorage: Int32?

                public var availableMemory: Double?

                public var availableVcpus: Int32?

                public var availableVgpus: Int32?

                public var localStorageCategory: String?

                public var socketCapacities: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Capacity.SocketCapacities?

                public var totalLocalStorage: Int32?

                public var totalMemory: Double?

                public var totalVcpus: Int32?

                public var totalVgpus: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.socketCapacities?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.availableLocalStorage != nil {
                        map["AvailableLocalStorage"] = self.availableLocalStorage!
                    }
                    if self.availableMemory != nil {
                        map["AvailableMemory"] = self.availableMemory!
                    }
                    if self.availableVcpus != nil {
                        map["AvailableVcpus"] = self.availableVcpus!
                    }
                    if self.availableVgpus != nil {
                        map["AvailableVgpus"] = self.availableVgpus!
                    }
                    if self.localStorageCategory != nil {
                        map["LocalStorageCategory"] = self.localStorageCategory!
                    }
                    if self.socketCapacities != nil {
                        map["SocketCapacities"] = self.socketCapacities?.toMap()
                    }
                    if self.totalLocalStorage != nil {
                        map["TotalLocalStorage"] = self.totalLocalStorage!
                    }
                    if self.totalMemory != nil {
                        map["TotalMemory"] = self.totalMemory!
                    }
                    if self.totalVcpus != nil {
                        map["TotalVcpus"] = self.totalVcpus!
                    }
                    if self.totalVgpus != nil {
                        map["TotalVgpus"] = self.totalVgpus!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AvailableLocalStorage"] as? Int32 {
                        self.availableLocalStorage = value
                    }
                    if let value = dict["AvailableMemory"] as? Double {
                        self.availableMemory = value
                    }
                    if let value = dict["AvailableVcpus"] as? Int32 {
                        self.availableVcpus = value
                    }
                    if let value = dict["AvailableVgpus"] as? Int32 {
                        self.availableVgpus = value
                    }
                    if let value = dict["LocalStorageCategory"] as? String {
                        self.localStorageCategory = value
                    }
                    if let value = dict["SocketCapacities"] as? [String: Any?] {
                        var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Capacity.SocketCapacities()
                        model.fromMap(value)
                        self.socketCapacities = model
                    }
                    if let value = dict["TotalLocalStorage"] as? Int32 {
                        self.totalLocalStorage = value
                    }
                    if let value = dict["TotalMemory"] as? Double {
                        self.totalMemory = value
                    }
                    if let value = dict["TotalVcpus"] as? Int32 {
                        self.totalVcpus = value
                    }
                    if let value = dict["TotalVgpus"] as? Int32 {
                        self.totalVgpus = value
                    }
                }
            }
            public class HostDetailInfo : Tea.TeaModel {
                public var serialNumber: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.serialNumber != nil {
                        map["SerialNumber"] = self.serialNumber!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["SerialNumber"] as? String {
                        self.serialNumber = value
                    }
                }
            }
            public class Instances : Tea.TeaModel {
                public class Instance : Tea.TeaModel {
                    public var instanceId: String?

                    public var instanceOwnerId: Int64?

                    public var instanceType: String?

                    public var socketId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.instanceOwnerId != nil {
                            map["InstanceOwnerId"] = self.instanceOwnerId!
                        }
                        if self.instanceType != nil {
                            map["InstanceType"] = self.instanceType!
                        }
                        if self.socketId != nil {
                            map["SocketId"] = self.socketId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["InstanceId"] as? String {
                            self.instanceId = value
                        }
                        if let value = dict["InstanceOwnerId"] as? Int64 {
                            self.instanceOwnerId = value
                        }
                        if let value = dict["InstanceType"] as? String {
                            self.instanceType = value
                        }
                        if let value = dict["SocketId"] as? String {
                            self.socketId = value
                        }
                    }
                }
                public var instance: [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Instances.Instance]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instance != nil {
                        var tmp : [Any] = []
                        for k in self.instance! {
                            tmp.append(k.toMap())
                        }
                        map["Instance"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Instance"] as? [Any?] {
                        var tmp : [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Instances.Instance] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Instances.Instance()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.instance = tmp
                    }
                }
            }
            public class NetworkAttributes : Tea.TeaModel {
                public var slbUdpTimeout: Int32?

                public var udpTimeout: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.slbUdpTimeout != nil {
                        map["SlbUdpTimeout"] = self.slbUdpTimeout!
                    }
                    if self.udpTimeout != nil {
                        map["UdpTimeout"] = self.udpTimeout!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["SlbUdpTimeout"] as? Int32 {
                        self.slbUdpTimeout = value
                    }
                    if let value = dict["UdpTimeout"] as? Int32 {
                        self.udpTimeout = value
                    }
                }
            }
            public class OperationLocks : Tea.TeaModel {
                public class OperationLock : Tea.TeaModel {
                    public var lockReason: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.lockReason != nil {
                            map["LockReason"] = self.lockReason!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["LockReason"] as? String {
                            self.lockReason = value
                        }
                    }
                }
                public var operationLock: [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.OperationLocks.OperationLock]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.operationLock != nil {
                        var tmp : [Any] = []
                        for k in self.operationLock! {
                            tmp.append(k.toMap())
                        }
                        map["OperationLock"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["OperationLock"] as? [Any?] {
                        var tmp : [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.OperationLocks.OperationLock] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.OperationLocks.OperationLock()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.operationLock = tmp
                    }
                }
            }
            public class SupportedCustomInstanceTypeFamilies : Tea.TeaModel {
                public var supportedCustomInstanceTypeFamily: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.supportedCustomInstanceTypeFamily != nil {
                        map["SupportedCustomInstanceTypeFamily"] = self.supportedCustomInstanceTypeFamily!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["SupportedCustomInstanceTypeFamily"] as? [String] {
                        self.supportedCustomInstanceTypeFamily = value
                    }
                }
            }
            public class SupportedInstanceTypeFamilies : Tea.TeaModel {
                public var supportedInstanceTypeFamily: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.supportedInstanceTypeFamily != nil {
                        map["SupportedInstanceTypeFamily"] = self.supportedInstanceTypeFamily!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["SupportedInstanceTypeFamily"] as? [String] {
                        self.supportedInstanceTypeFamily = value
                    }
                }
            }
            public class SupportedInstanceTypesList : Tea.TeaModel {
                public var supportedInstanceTypesList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.supportedInstanceTypesList != nil {
                        map["SupportedInstanceTypesList"] = self.supportedInstanceTypesList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["SupportedInstanceTypesList"] as? [String] {
                        self.supportedInstanceTypesList = value
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["TagKey"] as? String {
                            self.tagKey = value
                        }
                        if let value = dict["TagValue"] as? String {
                            self.tagValue = value
                        }
                    }
                }
                public var tag: [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var schedulerOptions: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.SchedulerOptions?

            public var actionOnMaintenance: String?

            public var autoPlacement: String?

            public var autoReleaseTime: String?

            public var capacity: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Capacity?

            public var chargeType: String?

            public var cores: Int32?

            public var cpuOverCommitRatio: Double?

            public var creationTime: String?

            public var dedicatedHostClusterId: String?

            public var dedicatedHostId: String?

            public var dedicatedHostName: String?

            public var dedicatedHostOwnerId: Int64?

            public var dedicatedHostType: String?

            public var description_: String?

            public var expiredTime: String?

            public var GPUSpec: String?

            public var hostDetailInfo: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.HostDetailInfo?

            public var instances: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Instances?

            public var machineId: String?

            public var networkAttributes: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.NetworkAttributes?

            public var operationLocks: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.OperationLocks?

            public var physicalGpus: Int32?

            public var regionId: String?

            public var resourceGroupId: String?

            public var saleCycle: String?

            public var sockets: Int32?

            public var status: String?

            public var supportedCustomInstanceTypeFamilies: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.SupportedCustomInstanceTypeFamilies?

            public var supportedInstanceTypeFamilies: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.SupportedInstanceTypeFamilies?

            public var supportedInstanceTypesList: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.SupportedInstanceTypesList?

            public var tags: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Tags?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.schedulerOptions?.validate()
                try self.capacity?.validate()
                try self.hostDetailInfo?.validate()
                try self.instances?.validate()
                try self.networkAttributes?.validate()
                try self.operationLocks?.validate()
                try self.supportedCustomInstanceTypeFamilies?.validate()
                try self.supportedInstanceTypeFamilies?.validate()
                try self.supportedInstanceTypesList?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.schedulerOptions != nil {
                    map["SchedulerOptions"] = self.schedulerOptions?.toMap()
                }
                if self.actionOnMaintenance != nil {
                    map["ActionOnMaintenance"] = self.actionOnMaintenance!
                }
                if self.autoPlacement != nil {
                    map["AutoPlacement"] = self.autoPlacement!
                }
                if self.autoReleaseTime != nil {
                    map["AutoReleaseTime"] = self.autoReleaseTime!
                }
                if self.capacity != nil {
                    map["Capacity"] = self.capacity?.toMap()
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.cores != nil {
                    map["Cores"] = self.cores!
                }
                if self.cpuOverCommitRatio != nil {
                    map["CpuOverCommitRatio"] = self.cpuOverCommitRatio!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.dedicatedHostClusterId != nil {
                    map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
                }
                if self.dedicatedHostId != nil {
                    map["DedicatedHostId"] = self.dedicatedHostId!
                }
                if self.dedicatedHostName != nil {
                    map["DedicatedHostName"] = self.dedicatedHostName!
                }
                if self.dedicatedHostOwnerId != nil {
                    map["DedicatedHostOwnerId"] = self.dedicatedHostOwnerId!
                }
                if self.dedicatedHostType != nil {
                    map["DedicatedHostType"] = self.dedicatedHostType!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.GPUSpec != nil {
                    map["GPUSpec"] = self.GPUSpec!
                }
                if self.hostDetailInfo != nil {
                    map["HostDetailInfo"] = self.hostDetailInfo?.toMap()
                }
                if self.instances != nil {
                    map["Instances"] = self.instances?.toMap()
                }
                if self.machineId != nil {
                    map["MachineId"] = self.machineId!
                }
                if self.networkAttributes != nil {
                    map["NetworkAttributes"] = self.networkAttributes?.toMap()
                }
                if self.operationLocks != nil {
                    map["OperationLocks"] = self.operationLocks?.toMap()
                }
                if self.physicalGpus != nil {
                    map["PhysicalGpus"] = self.physicalGpus!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.saleCycle != nil {
                    map["SaleCycle"] = self.saleCycle!
                }
                if self.sockets != nil {
                    map["Sockets"] = self.sockets!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.supportedCustomInstanceTypeFamilies != nil {
                    map["SupportedCustomInstanceTypeFamilies"] = self.supportedCustomInstanceTypeFamilies?.toMap()
                }
                if self.supportedInstanceTypeFamilies != nil {
                    map["SupportedInstanceTypeFamilies"] = self.supportedInstanceTypeFamilies?.toMap()
                }
                if self.supportedInstanceTypesList != nil {
                    map["SupportedInstanceTypesList"] = self.supportedInstanceTypesList?.toMap()
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["SchedulerOptions"] as? [String: Any?] {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.SchedulerOptions()
                    model.fromMap(value)
                    self.schedulerOptions = model
                }
                if let value = dict["ActionOnMaintenance"] as? String {
                    self.actionOnMaintenance = value
                }
                if let value = dict["AutoPlacement"] as? String {
                    self.autoPlacement = value
                }
                if let value = dict["AutoReleaseTime"] as? String {
                    self.autoReleaseTime = value
                }
                if let value = dict["Capacity"] as? [String: Any?] {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Capacity()
                    model.fromMap(value)
                    self.capacity = model
                }
                if let value = dict["ChargeType"] as? String {
                    self.chargeType = value
                }
                if let value = dict["Cores"] as? Int32 {
                    self.cores = value
                }
                if let value = dict["CpuOverCommitRatio"] as? Double {
                    self.cpuOverCommitRatio = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["DedicatedHostClusterId"] as? String {
                    self.dedicatedHostClusterId = value
                }
                if let value = dict["DedicatedHostId"] as? String {
                    self.dedicatedHostId = value
                }
                if let value = dict["DedicatedHostName"] as? String {
                    self.dedicatedHostName = value
                }
                if let value = dict["DedicatedHostOwnerId"] as? Int64 {
                    self.dedicatedHostOwnerId = value
                }
                if let value = dict["DedicatedHostType"] as? String {
                    self.dedicatedHostType = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["ExpiredTime"] as? String {
                    self.expiredTime = value
                }
                if let value = dict["GPUSpec"] as? String {
                    self.GPUSpec = value
                }
                if let value = dict["HostDetailInfo"] as? [String: Any?] {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.HostDetailInfo()
                    model.fromMap(value)
                    self.hostDetailInfo = model
                }
                if let value = dict["Instances"] as? [String: Any?] {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Instances()
                    model.fromMap(value)
                    self.instances = model
                }
                if let value = dict["MachineId"] as? String {
                    self.machineId = value
                }
                if let value = dict["NetworkAttributes"] as? [String: Any?] {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.NetworkAttributes()
                    model.fromMap(value)
                    self.networkAttributes = model
                }
                if let value = dict["OperationLocks"] as? [String: Any?] {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.OperationLocks()
                    model.fromMap(value)
                    self.operationLocks = model
                }
                if let value = dict["PhysicalGpus"] as? Int32 {
                    self.physicalGpus = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["SaleCycle"] as? String {
                    self.saleCycle = value
                }
                if let value = dict["Sockets"] as? Int32 {
                    self.sockets = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["SupportedCustomInstanceTypeFamilies"] as? [String: Any?] {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.SupportedCustomInstanceTypeFamilies()
                    model.fromMap(value)
                    self.supportedCustomInstanceTypeFamilies = model
                }
                if let value = dict["SupportedInstanceTypeFamilies"] as? [String: Any?] {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.SupportedInstanceTypeFamilies()
                    model.fromMap(value)
                    self.supportedInstanceTypeFamilies = model
                }
                if let value = dict["SupportedInstanceTypesList"] as? [String: Any?] {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.SupportedInstanceTypesList()
                    model.fromMap(value)
                    self.supportedInstanceTypesList = model
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var dedicatedHost: [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dedicatedHost != nil {
                var tmp : [Any] = []
                for k in self.dedicatedHost! {
                    tmp.append(k.toMap())
                }
                map["DedicatedHost"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DedicatedHost"] as? [Any?] {
                var tmp : [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dedicatedHost = tmp
            }
        }
    }
    public var dedicatedHosts: DescribeDedicatedHostsResponseBody.DedicatedHosts?

    public var nextToken: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dedicatedHosts?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHosts != nil {
            map["DedicatedHosts"] = self.dedicatedHosts?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DedicatedHosts"] as? [String: Any?] {
            var model = DescribeDedicatedHostsResponseBody.DedicatedHosts()
            model.fromMap(value)
            self.dedicatedHosts = model
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeDedicatedHostsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDedicatedHostsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDedicatedHostsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDeploymentSetSupportedInstanceTypeFamilyRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var strategy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.strategy != nil {
            map["Strategy"] = self.strategy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Strategy"] as? String {
            self.strategy = value
        }
    }
}

public class DescribeDeploymentSetSupportedInstanceTypeFamilyResponseBody : Tea.TeaModel {
    public var instanceTypeFamilies: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceTypeFamilies != nil {
            map["InstanceTypeFamilies"] = self.instanceTypeFamilies!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceTypeFamilies"] as? String {
            self.instanceTypeFamilies = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDeploymentSetSupportedInstanceTypeFamilyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDeploymentSetSupportedInstanceTypeFamilyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDeploymentSetSupportedInstanceTypeFamilyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDeploymentSetsRequest : Tea.TeaModel {
    public var deploymentSetIds: String?

    public var deploymentSetName: String?

    public var domain: String?

    public var granularity: String?

    public var networkType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var strategy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deploymentSetIds != nil {
            map["DeploymentSetIds"] = self.deploymentSetIds!
        }
        if self.deploymentSetName != nil {
            map["DeploymentSetName"] = self.deploymentSetName!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.granularity != nil {
            map["Granularity"] = self.granularity!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.strategy != nil {
            map["Strategy"] = self.strategy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeploymentSetIds"] as? String {
            self.deploymentSetIds = value
        }
        if let value = dict["DeploymentSetName"] as? String {
            self.deploymentSetName = value
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["Granularity"] as? String {
            self.granularity = value
        }
        if let value = dict["NetworkType"] as? String {
            self.networkType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Strategy"] as? String {
            self.strategy = value
        }
    }
}

public class DescribeDeploymentSetsResponseBody : Tea.TeaModel {
    public class DeploymentSets : Tea.TeaModel {
        public class DeploymentSet : Tea.TeaModel {
            public class Capacities : Tea.TeaModel {
                public class Capacity : Tea.TeaModel {
                    public var availableAmount: Int32?

                    public var usedAmount: Int32?

                    public var zoneId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.availableAmount != nil {
                            map["AvailableAmount"] = self.availableAmount!
                        }
                        if self.usedAmount != nil {
                            map["UsedAmount"] = self.usedAmount!
                        }
                        if self.zoneId != nil {
                            map["ZoneId"] = self.zoneId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AvailableAmount"] as? Int32 {
                            self.availableAmount = value
                        }
                        if let value = dict["UsedAmount"] as? Int32 {
                            self.usedAmount = value
                        }
                        if let value = dict["ZoneId"] as? String {
                            self.zoneId = value
                        }
                    }
                }
                public var capacity: [DescribeDeploymentSetsResponseBody.DeploymentSets.DeploymentSet.Capacities.Capacity]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.capacity != nil {
                        var tmp : [Any] = []
                        for k in self.capacity! {
                            tmp.append(k.toMap())
                        }
                        map["Capacity"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Capacity"] as? [Any?] {
                        var tmp : [DescribeDeploymentSetsResponseBody.DeploymentSets.DeploymentSet.Capacities.Capacity] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDeploymentSetsResponseBody.DeploymentSets.DeploymentSet.Capacities.Capacity()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.capacity = tmp
                    }
                }
            }
            public class InstanceIds : Tea.TeaModel {
                public var instanceId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["InstanceId"] as? [String] {
                        self.instanceId = value
                    }
                }
            }
            public var capacities: DescribeDeploymentSetsResponseBody.DeploymentSets.DeploymentSet.Capacities?

            public var creationTime: String?

            public var deploymentSetDescription: String?

            public var deploymentSetId: String?

            public var deploymentSetName: String?

            public var deploymentStrategy: String?

            public var domain: String?

            public var granularity: String?

            public var groupCount: Int32?

            public var instanceAmount: Int32?

            public var instanceIds: DescribeDeploymentSetsResponseBody.DeploymentSets.DeploymentSet.InstanceIds?

            public var strategy: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.capacities?.validate()
                try self.instanceIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.capacities != nil {
                    map["Capacities"] = self.capacities?.toMap()
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.deploymentSetDescription != nil {
                    map["DeploymentSetDescription"] = self.deploymentSetDescription!
                }
                if self.deploymentSetId != nil {
                    map["DeploymentSetId"] = self.deploymentSetId!
                }
                if self.deploymentSetName != nil {
                    map["DeploymentSetName"] = self.deploymentSetName!
                }
                if self.deploymentStrategy != nil {
                    map["DeploymentStrategy"] = self.deploymentStrategy!
                }
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.granularity != nil {
                    map["Granularity"] = self.granularity!
                }
                if self.groupCount != nil {
                    map["GroupCount"] = self.groupCount!
                }
                if self.instanceAmount != nil {
                    map["InstanceAmount"] = self.instanceAmount!
                }
                if self.instanceIds != nil {
                    map["InstanceIds"] = self.instanceIds?.toMap()
                }
                if self.strategy != nil {
                    map["Strategy"] = self.strategy!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Capacities"] as? [String: Any?] {
                    var model = DescribeDeploymentSetsResponseBody.DeploymentSets.DeploymentSet.Capacities()
                    model.fromMap(value)
                    self.capacities = model
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["DeploymentSetDescription"] as? String {
                    self.deploymentSetDescription = value
                }
                if let value = dict["DeploymentSetId"] as? String {
                    self.deploymentSetId = value
                }
                if let value = dict["DeploymentSetName"] as? String {
                    self.deploymentSetName = value
                }
                if let value = dict["DeploymentStrategy"] as? String {
                    self.deploymentStrategy = value
                }
                if let value = dict["Domain"] as? String {
                    self.domain = value
                }
                if let value = dict["Granularity"] as? String {
                    self.granularity = value
                }
                if let value = dict["GroupCount"] as? Int32 {
                    self.groupCount = value
                }
                if let value = dict["InstanceAmount"] as? Int32 {
                    self.instanceAmount = value
                }
                if let value = dict["InstanceIds"] as? [String: Any?] {
                    var model = DescribeDeploymentSetsResponseBody.DeploymentSets.DeploymentSet.InstanceIds()
                    model.fromMap(value)
                    self.instanceIds = model
                }
                if let value = dict["Strategy"] as? String {
                    self.strategy = value
                }
            }
        }
        public var deploymentSet: [DescribeDeploymentSetsResponseBody.DeploymentSets.DeploymentSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deploymentSet != nil {
                var tmp : [Any] = []
                for k in self.deploymentSet! {
                    tmp.append(k.toMap())
                }
                map["DeploymentSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DeploymentSet"] as? [Any?] {
                var tmp : [DescribeDeploymentSetsResponseBody.DeploymentSets.DeploymentSet] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDeploymentSetsResponseBody.DeploymentSets.DeploymentSet()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.deploymentSet = tmp
            }
        }
    }
    public var deploymentSets: DescribeDeploymentSetsResponseBody.DeploymentSets?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.deploymentSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deploymentSets != nil {
            map["DeploymentSets"] = self.deploymentSets?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeploymentSets"] as? [String: Any?] {
            var model = DescribeDeploymentSetsResponseBody.DeploymentSets()
            model.fromMap(value)
            self.deploymentSets = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeDeploymentSetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDeploymentSetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDeploymentSetsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDiagnosticMetricSetsRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var metricSetIds: [String]?

    public var nextToken: String?

    public var regionId: String?

    public var resourceType: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.metricSetIds != nil {
            map["MetricSetIds"] = self.metricSetIds!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["MetricSetIds"] as? [String] {
            self.metricSetIds = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class DescribeDiagnosticMetricSetsResponseBody : Tea.TeaModel {
    public class MetricSets : Tea.TeaModel {
        public var description_: String?

        public var metricIds: [String]?

        public var metricSetId: String?

        public var metricSetName: String?

        public var resourceType: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.metricIds != nil {
                map["MetricIds"] = self.metricIds!
            }
            if self.metricSetId != nil {
                map["MetricSetId"] = self.metricSetId!
            }
            if self.metricSetName != nil {
                map["MetricSetName"] = self.metricSetName!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["MetricIds"] as? [String] {
                self.metricIds = value
            }
            if let value = dict["MetricSetId"] as? String {
                self.metricSetId = value
            }
            if let value = dict["MetricSetName"] as? String {
                self.metricSetName = value
            }
            if let value = dict["ResourceType"] as? String {
                self.resourceType = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var metricSets: [DescribeDiagnosticMetricSetsResponseBody.MetricSets]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.metricSets != nil {
            var tmp : [Any] = []
            for k in self.metricSets! {
                tmp.append(k.toMap())
            }
            map["MetricSets"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MetricSets"] as? [Any?] {
            var tmp : [DescribeDiagnosticMetricSetsResponseBody.MetricSets] = []
            for v in value {
                if v != nil {
                    var model = DescribeDiagnosticMetricSetsResponseBody.MetricSets()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.metricSets = tmp
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDiagnosticMetricSetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiagnosticMetricSetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDiagnosticMetricSetsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDiagnosticMetricsRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var metricIds: [String]?

    public var nextToken: String?

    public var regionId: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.metricIds != nil {
            map["MetricIds"] = self.metricIds!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["MetricIds"] as? [String] {
            self.metricIds = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class DescribeDiagnosticMetricsResponseBody : Tea.TeaModel {
    public class Metrics : Tea.TeaModel {
        public var description_: String?

        public var guestMetric: Bool?

        public var metricCategory: String?

        public var metricId: String?

        public var metricName: String?

        public var resourceType: String?

        public var supportedOperatingSystem: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.guestMetric != nil {
                map["GuestMetric"] = self.guestMetric!
            }
            if self.metricCategory != nil {
                map["MetricCategory"] = self.metricCategory!
            }
            if self.metricId != nil {
                map["MetricId"] = self.metricId!
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.supportedOperatingSystem != nil {
                map["SupportedOperatingSystem"] = self.supportedOperatingSystem!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["GuestMetric"] as? Bool {
                self.guestMetric = value
            }
            if let value = dict["MetricCategory"] as? String {
                self.metricCategory = value
            }
            if let value = dict["MetricId"] as? String {
                self.metricId = value
            }
            if let value = dict["MetricName"] as? String {
                self.metricName = value
            }
            if let value = dict["ResourceType"] as? String {
                self.resourceType = value
            }
            if let value = dict["SupportedOperatingSystem"] as? String {
                self.supportedOperatingSystem = value
            }
        }
    }
    public var metrics: [DescribeDiagnosticMetricsResponseBody.Metrics]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.metrics != nil {
            var tmp : [Any] = []
            for k in self.metrics! {
                tmp.append(k.toMap())
            }
            map["Metrics"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Metrics"] as? [Any?] {
            var tmp : [DescribeDiagnosticMetricsResponseBody.Metrics] = []
            for v in value {
                if v != nil {
                    var model = DescribeDiagnosticMetricsResponseBody.Metrics()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.metrics = tmp
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDiagnosticMetricsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiagnosticMetricsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDiagnosticMetricsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDiagnosticReportAttributesRequest : Tea.TeaModel {
    public var regionId: String?

    public var reportId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ReportId"] as? String {
            self.reportId = value
        }
    }
}

public class DescribeDiagnosticReportAttributesResponseBody : Tea.TeaModel {
    public class MetricResults : Tea.TeaModel {
        public class MetricResult : Tea.TeaModel {
            public class Issues : Tea.TeaModel {
                public class Issue : Tea.TeaModel {
                    public var additional: String?

                    public var issueId: String?

                    public var occurrenceTime: String?

                    public var severity: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.additional != nil {
                            map["Additional"] = self.additional!
                        }
                        if self.issueId != nil {
                            map["IssueId"] = self.issueId!
                        }
                        if self.occurrenceTime != nil {
                            map["OccurrenceTime"] = self.occurrenceTime!
                        }
                        if self.severity != nil {
                            map["Severity"] = self.severity!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Additional"] as? String {
                            self.additional = value
                        }
                        if let value = dict["IssueId"] as? String {
                            self.issueId = value
                        }
                        if let value = dict["OccurrenceTime"] as? String {
                            self.occurrenceTime = value
                        }
                        if let value = dict["Severity"] as? String {
                            self.severity = value
                        }
                    }
                }
                public var issue: [DescribeDiagnosticReportAttributesResponseBody.MetricResults.MetricResult.Issues.Issue]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.issue != nil {
                        var tmp : [Any] = []
                        for k in self.issue! {
                            tmp.append(k.toMap())
                        }
                        map["Issue"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Issue"] as? [Any?] {
                        var tmp : [DescribeDiagnosticReportAttributesResponseBody.MetricResults.MetricResult.Issues.Issue] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDiagnosticReportAttributesResponseBody.MetricResults.MetricResult.Issues.Issue()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.issue = tmp
                    }
                }
            }
            public var issues: DescribeDiagnosticReportAttributesResponseBody.MetricResults.MetricResult.Issues?

            public var metricCategory: String?

            public var metricId: String?

            public var severity: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.issues?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.issues != nil {
                    map["Issues"] = self.issues?.toMap()
                }
                if self.metricCategory != nil {
                    map["MetricCategory"] = self.metricCategory!
                }
                if self.metricId != nil {
                    map["MetricId"] = self.metricId!
                }
                if self.severity != nil {
                    map["Severity"] = self.severity!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Issues"] as? [String: Any?] {
                    var model = DescribeDiagnosticReportAttributesResponseBody.MetricResults.MetricResult.Issues()
                    model.fromMap(value)
                    self.issues = model
                }
                if let value = dict["MetricCategory"] as? String {
                    self.metricCategory = value
                }
                if let value = dict["MetricId"] as? String {
                    self.metricId = value
                }
                if let value = dict["Severity"] as? String {
                    self.severity = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var metricResult: [DescribeDiagnosticReportAttributesResponseBody.MetricResults.MetricResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metricResult != nil {
                var tmp : [Any] = []
                for k in self.metricResult! {
                    tmp.append(k.toMap())
                }
                map["MetricResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MetricResult"] as? [Any?] {
                var tmp : [DescribeDiagnosticReportAttributesResponseBody.MetricResults.MetricResult] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDiagnosticReportAttributesResponseBody.MetricResults.MetricResult()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.metricResult = tmp
            }
        }
    }
    public var attributes: String?

    public var creationTime: String?

    public var endTime: String?

    public var finishedTime: String?

    public var metricResults: DescribeDiagnosticReportAttributesResponseBody.MetricResults?

    public var metricSetId: String?

    public var reportId: String?

    public var requestId: String?

    public var resourceId: String?

    public var resourceType: String?

    public var severity: String?

    public var startTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.metricResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attributes != nil {
            map["Attributes"] = self.attributes!
        }
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.finishedTime != nil {
            map["FinishedTime"] = self.finishedTime!
        }
        if self.metricResults != nil {
            map["MetricResults"] = self.metricResults?.toMap()
        }
        if self.metricSetId != nil {
            map["MetricSetId"] = self.metricSetId!
        }
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.severity != nil {
            map["Severity"] = self.severity!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Attributes"] as? String {
            self.attributes = value
        }
        if let value = dict["CreationTime"] as? String {
            self.creationTime = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["FinishedTime"] as? String {
            self.finishedTime = value
        }
        if let value = dict["MetricResults"] as? [String: Any?] {
            var model = DescribeDiagnosticReportAttributesResponseBody.MetricResults()
            model.fromMap(value)
            self.metricResults = model
        }
        if let value = dict["MetricSetId"] as? String {
            self.metricSetId = value
        }
        if let value = dict["ReportId"] as? String {
            self.reportId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Severity"] as? String {
            self.severity = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class DescribeDiagnosticReportAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiagnosticReportAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDiagnosticReportAttributesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDiagnosticReportsRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var regionId: String?

    public var reportIds: [String]?

    public var resourceIds: [String]?

    public var severity: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reportIds != nil {
            map["ReportIds"] = self.reportIds!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.severity != nil {
            map["Severity"] = self.severity!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ReportIds"] as? [String] {
            self.reportIds = value
        }
        if let value = dict["ResourceIds"] as? [String] {
            self.resourceIds = value
        }
        if let value = dict["Severity"] as? String {
            self.severity = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class DescribeDiagnosticReportsResponseBody : Tea.TeaModel {
    public class Reports : Tea.TeaModel {
        public class Report : Tea.TeaModel {
            public class Issues : Tea.TeaModel {
                public class Issue : Tea.TeaModel {
                    public var issueId: String?

                    public var metricCategory: String?

                    public var metricId: String?

                    public var severity: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.issueId != nil {
                            map["IssueId"] = self.issueId!
                        }
                        if self.metricCategory != nil {
                            map["MetricCategory"] = self.metricCategory!
                        }
                        if self.metricId != nil {
                            map["MetricId"] = self.metricId!
                        }
                        if self.severity != nil {
                            map["Severity"] = self.severity!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["IssueId"] as? String {
                            self.issueId = value
                        }
                        if let value = dict["MetricCategory"] as? String {
                            self.metricCategory = value
                        }
                        if let value = dict["MetricId"] as? String {
                            self.metricId = value
                        }
                        if let value = dict["Severity"] as? String {
                            self.severity = value
                        }
                    }
                }
                public var issue: [DescribeDiagnosticReportsResponseBody.Reports.Report.Issues.Issue]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.issue != nil {
                        var tmp : [Any] = []
                        for k in self.issue! {
                            tmp.append(k.toMap())
                        }
                        map["Issue"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Issue"] as? [Any?] {
                        var tmp : [DescribeDiagnosticReportsResponseBody.Reports.Report.Issues.Issue] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDiagnosticReportsResponseBody.Reports.Report.Issues.Issue()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.issue = tmp
                    }
                }
            }
            public var creationTime: String?

            public var endTime: String?

            public var finishedTime: String?

            public var issues: DescribeDiagnosticReportsResponseBody.Reports.Report.Issues?

            public var metricSetId: String?

            public var reportId: String?

            public var resourceId: String?

            public var resourceType: String?

            public var severity: String?

            public var startTime: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.issues?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.finishedTime != nil {
                    map["FinishedTime"] = self.finishedTime!
                }
                if self.issues != nil {
                    map["Issues"] = self.issues?.toMap()
                }
                if self.metricSetId != nil {
                    map["MetricSetId"] = self.metricSetId!
                }
                if self.reportId != nil {
                    map["ReportId"] = self.reportId!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.severity != nil {
                    map["Severity"] = self.severity!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["EndTime"] as? String {
                    self.endTime = value
                }
                if let value = dict["FinishedTime"] as? String {
                    self.finishedTime = value
                }
                if let value = dict["Issues"] as? [String: Any?] {
                    var model = DescribeDiagnosticReportsResponseBody.Reports.Report.Issues()
                    model.fromMap(value)
                    self.issues = model
                }
                if let value = dict["MetricSetId"] as? String {
                    self.metricSetId = value
                }
                if let value = dict["ReportId"] as? String {
                    self.reportId = value
                }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
                if let value = dict["Severity"] as? String {
                    self.severity = value
                }
                if let value = dict["StartTime"] as? String {
                    self.startTime = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var report: [DescribeDiagnosticReportsResponseBody.Reports.Report]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.report != nil {
                var tmp : [Any] = []
                for k in self.report! {
                    tmp.append(k.toMap())
                }
                map["Report"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Report"] as? [Any?] {
                var tmp : [DescribeDiagnosticReportsResponseBody.Reports.Report] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDiagnosticReportsResponseBody.Reports.Report()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.report = tmp
            }
        }
    }
    public var nextToken: String?

    public var reports: DescribeDiagnosticReportsResponseBody.Reports?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.reports?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.reports != nil {
            map["Reports"] = self.reports?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["Reports"] as? [String: Any?] {
            var model = DescribeDiagnosticReportsResponseBody.Reports()
            model.fromMap(value)
            self.reports = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDiagnosticReportsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiagnosticReportsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDiagnosticReportsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDiskDefaultKMSKeyIdRequest : Tea.TeaModel {
    public var regionId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeDiskDefaultKMSKeyIdResponseBody : Tea.TeaModel {
    public var KMSKeyId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.KMSKeyId != nil {
            map["KMSKeyId"] = self.KMSKeyId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["KMSKeyId"] as? String {
            self.KMSKeyId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDiskDefaultKMSKeyIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiskDefaultKMSKeyIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDiskDefaultKMSKeyIdResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDiskEncryptionByDefaultStatusRequest : Tea.TeaModel {
    public var regionId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeDiskEncryptionByDefaultStatusResponseBody : Tea.TeaModel {
    public var encrypted: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.encrypted != nil {
            map["Encrypted"] = self.encrypted!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Encrypted"] as? Bool {
            self.encrypted = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDiskEncryptionByDefaultStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiskEncryptionByDefaultStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDiskEncryptionByDefaultStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDiskMonitorDataRequest : Tea.TeaModel {
    public var diskId: String?

    public var endTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DiskId"] as? String {
            self.diskId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeDiskMonitorDataResponseBody : Tea.TeaModel {
    public class MonitorData : Tea.TeaModel {
        public class DiskMonitorData : Tea.TeaModel {
            public var BPSRead: Int32?

            public var BPSTotal: Int32?

            public var BPSWrite: Int32?

            public var diskId: String?

            public var IOPSRead: Int32?

            public var IOPSTotal: Int32?

            public var IOPSWrite: Int32?

            public var latencyRead: Int32?

            public var latencyWrite: Int32?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.BPSRead != nil {
                    map["BPSRead"] = self.BPSRead!
                }
                if self.BPSTotal != nil {
                    map["BPSTotal"] = self.BPSTotal!
                }
                if self.BPSWrite != nil {
                    map["BPSWrite"] = self.BPSWrite!
                }
                if self.diskId != nil {
                    map["DiskId"] = self.diskId!
                }
                if self.IOPSRead != nil {
                    map["IOPSRead"] = self.IOPSRead!
                }
                if self.IOPSTotal != nil {
                    map["IOPSTotal"] = self.IOPSTotal!
                }
                if self.IOPSWrite != nil {
                    map["IOPSWrite"] = self.IOPSWrite!
                }
                if self.latencyRead != nil {
                    map["LatencyRead"] = self.latencyRead!
                }
                if self.latencyWrite != nil {
                    map["LatencyWrite"] = self.latencyWrite!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BPSRead"] as? Int32 {
                    self.BPSRead = value
                }
                if let value = dict["BPSTotal"] as? Int32 {
                    self.BPSTotal = value
                }
                if let value = dict["BPSWrite"] as? Int32 {
                    self.BPSWrite = value
                }
                if let value = dict["DiskId"] as? String {
                    self.diskId = value
                }
                if let value = dict["IOPSRead"] as? Int32 {
                    self.IOPSRead = value
                }
                if let value = dict["IOPSTotal"] as? Int32 {
                    self.IOPSTotal = value
                }
                if let value = dict["IOPSWrite"] as? Int32 {
                    self.IOPSWrite = value
                }
                if let value = dict["LatencyRead"] as? Int32 {
                    self.latencyRead = value
                }
                if let value = dict["LatencyWrite"] as? Int32 {
                    self.latencyWrite = value
                }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
            }
        }
        public var diskMonitorData: [DescribeDiskMonitorDataResponseBody.MonitorData.DiskMonitorData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diskMonitorData != nil {
                var tmp : [Any] = []
                for k in self.diskMonitorData! {
                    tmp.append(k.toMap())
                }
                map["DiskMonitorData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DiskMonitorData"] as? [Any?] {
                var tmp : [DescribeDiskMonitorDataResponseBody.MonitorData.DiskMonitorData] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDiskMonitorDataResponseBody.MonitorData.DiskMonitorData()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.diskMonitorData = tmp
            }
        }
    }
    public var monitorData: DescribeDiskMonitorDataResponseBody.MonitorData?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.monitorData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorData != nil {
            map["MonitorData"] = self.monitorData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MonitorData"] as? [String: Any?] {
            var model = DescribeDiskMonitorDataResponseBody.MonitorData()
            model.fromMap(value)
            self.monitorData = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeDiskMonitorDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiskMonitorDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDiskMonitorDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDisksRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var filter: [DescribeDisksRequest.Filter]?

    public var additionalAttributes: [String]?

    public var autoSnapshotPolicyId: String?

    public var category: String?

    public var deleteAutoSnapshot: Bool?

    public var deleteWithInstance: Bool?

    public var diskChargeType: String?

    public var diskIds: String?

    public var diskName: String?

    public var diskType: String?

    public var dryRun: Bool?

    public var enableAutoSnapshot: Bool?

    public var enableAutomatedSnapshotPolicy: Bool?

    public var enableShared: Bool?

    public var encrypted: Bool?

    public var instanceId: String?

    public var KMSKeyId: String?

    public var lockReason: String?

    public var maxResults: Int32?

    public var multiAttach: String?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var portable: Bool?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snapshotId: String?

    public var status: String?

    public var tag: [DescribeDisksRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.additionalAttributes != nil {
            map["AdditionalAttributes"] = self.additionalAttributes!
        }
        if self.autoSnapshotPolicyId != nil {
            map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
        }
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.deleteAutoSnapshot != nil {
            map["DeleteAutoSnapshot"] = self.deleteAutoSnapshot!
        }
        if self.deleteWithInstance != nil {
            map["DeleteWithInstance"] = self.deleteWithInstance!
        }
        if self.diskChargeType != nil {
            map["DiskChargeType"] = self.diskChargeType!
        }
        if self.diskIds != nil {
            map["DiskIds"] = self.diskIds!
        }
        if self.diskName != nil {
            map["DiskName"] = self.diskName!
        }
        if self.diskType != nil {
            map["DiskType"] = self.diskType!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.enableAutoSnapshot != nil {
            map["EnableAutoSnapshot"] = self.enableAutoSnapshot!
        }
        if self.enableAutomatedSnapshotPolicy != nil {
            map["EnableAutomatedSnapshotPolicy"] = self.enableAutomatedSnapshotPolicy!
        }
        if self.enableShared != nil {
            map["EnableShared"] = self.enableShared!
        }
        if self.encrypted != nil {
            map["Encrypted"] = self.encrypted!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.KMSKeyId != nil {
            map["KMSKeyId"] = self.KMSKeyId!
        }
        if self.lockReason != nil {
            map["LockReason"] = self.lockReason!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.multiAttach != nil {
            map["MultiAttach"] = self.multiAttach!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.portable != nil {
            map["Portable"] = self.portable!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Filter"] as? [Any?] {
            var tmp : [DescribeDisksRequest.Filter] = []
            for v in value {
                if v != nil {
                    var model = DescribeDisksRequest.Filter()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.filter = tmp
        }
        if let value = dict["AdditionalAttributes"] as? [String] {
            self.additionalAttributes = value
        }
        if let value = dict["AutoSnapshotPolicyId"] as? String {
            self.autoSnapshotPolicyId = value
        }
        if let value = dict["Category"] as? String {
            self.category = value
        }
        if let value = dict["DeleteAutoSnapshot"] as? Bool {
            self.deleteAutoSnapshot = value
        }
        if let value = dict["DeleteWithInstance"] as? Bool {
            self.deleteWithInstance = value
        }
        if let value = dict["DiskChargeType"] as? String {
            self.diskChargeType = value
        }
        if let value = dict["DiskIds"] as? String {
            self.diskIds = value
        }
        if let value = dict["DiskName"] as? String {
            self.diskName = value
        }
        if let value = dict["DiskType"] as? String {
            self.diskType = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["EnableAutoSnapshot"] as? Bool {
            self.enableAutoSnapshot = value
        }
        if let value = dict["EnableAutomatedSnapshotPolicy"] as? Bool {
            self.enableAutomatedSnapshotPolicy = value
        }
        if let value = dict["EnableShared"] as? Bool {
            self.enableShared = value
        }
        if let value = dict["Encrypted"] as? Bool {
            self.encrypted = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["KMSKeyId"] as? String {
            self.KMSKeyId = value
        }
        if let value = dict["LockReason"] as? String {
            self.lockReason = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["MultiAttach"] as? String {
            self.multiAttach = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Portable"] as? Bool {
            self.portable = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SnapshotId"] as? String {
            self.snapshotId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeDisksRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeDisksRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribeDisksResponseBody : Tea.TeaModel {
    public class Disks : Tea.TeaModel {
        public class Disk : Tea.TeaModel {
            public class Attachments : Tea.TeaModel {
                public class Attachment : Tea.TeaModel {
                    public var attachedTime: String?

                    public var device: String?

                    public var instanceId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.attachedTime != nil {
                            map["AttachedTime"] = self.attachedTime!
                        }
                        if self.device != nil {
                            map["Device"] = self.device!
                        }
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AttachedTime"] as? String {
                            self.attachedTime = value
                        }
                        if let value = dict["Device"] as? String {
                            self.device = value
                        }
                        if let value = dict["InstanceId"] as? String {
                            self.instanceId = value
                        }
                    }
                }
                public var attachment: [DescribeDisksResponseBody.Disks.Disk.Attachments.Attachment]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.attachment != nil {
                        var tmp : [Any] = []
                        for k in self.attachment! {
                            tmp.append(k.toMap())
                        }
                        map["Attachment"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Attachment"] as? [Any?] {
                        var tmp : [DescribeDisksResponseBody.Disks.Disk.Attachments.Attachment] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDisksResponseBody.Disks.Disk.Attachments.Attachment()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.attachment = tmp
                    }
                }
            }
            public class MountInstances : Tea.TeaModel {
                public class MountInstance : Tea.TeaModel {
                    public var attachedTime: String?

                    public var device: String?

                    public var instanceId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.attachedTime != nil {
                            map["AttachedTime"] = self.attachedTime!
                        }
                        if self.device != nil {
                            map["Device"] = self.device!
                        }
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AttachedTime"] as? String {
                            self.attachedTime = value
                        }
                        if let value = dict["Device"] as? String {
                            self.device = value
                        }
                        if let value = dict["InstanceId"] as? String {
                            self.instanceId = value
                        }
                    }
                }
                public var mountInstance: [DescribeDisksResponseBody.Disks.Disk.MountInstances.MountInstance]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.mountInstance != nil {
                        var tmp : [Any] = []
                        for k in self.mountInstance! {
                            tmp.append(k.toMap())
                        }
                        map["MountInstance"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MountInstance"] as? [Any?] {
                        var tmp : [DescribeDisksResponseBody.Disks.Disk.MountInstances.MountInstance] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDisksResponseBody.Disks.Disk.MountInstances.MountInstance()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.mountInstance = tmp
                    }
                }
            }
            public class OperationLocks : Tea.TeaModel {
                public class OperationLock : Tea.TeaModel {
                    public var lockReason: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.lockReason != nil {
                            map["LockReason"] = self.lockReason!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["LockReason"] as? String {
                            self.lockReason = value
                        }
                    }
                }
                public var operationLock: [DescribeDisksResponseBody.Disks.Disk.OperationLocks.OperationLock]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.operationLock != nil {
                        var tmp : [Any] = []
                        for k in self.operationLock! {
                            tmp.append(k.toMap())
                        }
                        map["OperationLock"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["OperationLock"] as? [Any?] {
                        var tmp : [DescribeDisksResponseBody.Disks.Disk.OperationLocks.OperationLock] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDisksResponseBody.Disks.Disk.OperationLocks.OperationLock()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.operationLock = tmp
                    }
                }
            }
            public class Placement : Tea.TeaModel {
                public var zoneIds: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.zoneIds != nil {
                        map["ZoneIds"] = self.zoneIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ZoneIds"] as? String {
                        self.zoneIds = value
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["TagKey"] as? String {
                            self.tagKey = value
                        }
                        if let value = dict["TagValue"] as? String {
                            self.tagValue = value
                        }
                    }
                }
                public var tag: [DescribeDisksResponseBody.Disks.Disk.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeDisksResponseBody.Disks.Disk.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDisksResponseBody.Disks.Disk.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var attachedTime: String?

            public var attachments: DescribeDisksResponseBody.Disks.Disk.Attachments?

            public var autoSnapshotPolicyId: String?

            public var bdfId: String?

            public var burstingEnabled: Bool?

            public var category: String?

            public var creationTime: String?

            public var deleteAutoSnapshot: Bool?

            public var deleteWithInstance: Bool?

            public var description_: String?

            public var detachedTime: String?

            public var device: String?

            public var diskChargeType: String?

            public var diskId: String?

            public var diskName: String?

            public var enableAutoSnapshot: Bool?

            public var enableAutomatedSnapshotPolicy: Bool?

            public var encrypted: Bool?

            public var expiredTime: String?

            public var IOPS: Int32?

            public var IOPSRead: Int32?

            public var IOPSWrite: Int32?

            public var imageId: String?

            public var instanceId: String?

            public var KMSKeyId: String?

            public var mountInstanceNum: Int32?

            public var mountInstances: DescribeDisksResponseBody.Disks.Disk.MountInstances?

            public var multiAttach: String?

            public var operationLocks: DescribeDisksResponseBody.Disks.Disk.OperationLocks?

            public var performanceLevel: String?

            public var placement: DescribeDisksResponseBody.Disks.Disk.Placement?

            public var portable: Bool?

            public var productCode: String?

            public var provisionedIops: Int64?

            public var regionId: String?

            public var resourceGroupId: String?

            public var serialNumber: String?

            public var size: Int32?

            public var sourceSnapshotId: String?

            public var status: String?

            public var storageClusterId: String?

            public var storageSetId: String?

            public var storageSetPartitionNumber: Int32?

            public var tags: DescribeDisksResponseBody.Disks.Disk.Tags?

            public var throughput: Int32?

            public var throughputRead: Int32?

            public var throughputWrite: Int32?

            public var type: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.attachments?.validate()
                try self.mountInstances?.validate()
                try self.operationLocks?.validate()
                try self.placement?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.attachedTime != nil {
                    map["AttachedTime"] = self.attachedTime!
                }
                if self.attachments != nil {
                    map["Attachments"] = self.attachments?.toMap()
                }
                if self.autoSnapshotPolicyId != nil {
                    map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
                }
                if self.bdfId != nil {
                    map["BdfId"] = self.bdfId!
                }
                if self.burstingEnabled != nil {
                    map["BurstingEnabled"] = self.burstingEnabled!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.deleteAutoSnapshot != nil {
                    map["DeleteAutoSnapshot"] = self.deleteAutoSnapshot!
                }
                if self.deleteWithInstance != nil {
                    map["DeleteWithInstance"] = self.deleteWithInstance!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.detachedTime != nil {
                    map["DetachedTime"] = self.detachedTime!
                }
                if self.device != nil {
                    map["Device"] = self.device!
                }
                if self.diskChargeType != nil {
                    map["DiskChargeType"] = self.diskChargeType!
                }
                if self.diskId != nil {
                    map["DiskId"] = self.diskId!
                }
                if self.diskName != nil {
                    map["DiskName"] = self.diskName!
                }
                if self.enableAutoSnapshot != nil {
                    map["EnableAutoSnapshot"] = self.enableAutoSnapshot!
                }
                if self.enableAutomatedSnapshotPolicy != nil {
                    map["EnableAutomatedSnapshotPolicy"] = self.enableAutomatedSnapshotPolicy!
                }
                if self.encrypted != nil {
                    map["Encrypted"] = self.encrypted!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.IOPS != nil {
                    map["IOPS"] = self.IOPS!
                }
                if self.IOPSRead != nil {
                    map["IOPSRead"] = self.IOPSRead!
                }
                if self.IOPSWrite != nil {
                    map["IOPSWrite"] = self.IOPSWrite!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.KMSKeyId != nil {
                    map["KMSKeyId"] = self.KMSKeyId!
                }
                if self.mountInstanceNum != nil {
                    map["MountInstanceNum"] = self.mountInstanceNum!
                }
                if self.mountInstances != nil {
                    map["MountInstances"] = self.mountInstances?.toMap()
                }
                if self.multiAttach != nil {
                    map["MultiAttach"] = self.multiAttach!
                }
                if self.operationLocks != nil {
                    map["OperationLocks"] = self.operationLocks?.toMap()
                }
                if self.performanceLevel != nil {
                    map["PerformanceLevel"] = self.performanceLevel!
                }
                if self.placement != nil {
                    map["Placement"] = self.placement?.toMap()
                }
                if self.portable != nil {
                    map["Portable"] = self.portable!
                }
                if self.productCode != nil {
                    map["ProductCode"] = self.productCode!
                }
                if self.provisionedIops != nil {
                    map["ProvisionedIops"] = self.provisionedIops!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.serialNumber != nil {
                    map["SerialNumber"] = self.serialNumber!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.sourceSnapshotId != nil {
                    map["SourceSnapshotId"] = self.sourceSnapshotId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.storageClusterId != nil {
                    map["StorageClusterId"] = self.storageClusterId!
                }
                if self.storageSetId != nil {
                    map["StorageSetId"] = self.storageSetId!
                }
                if self.storageSetPartitionNumber != nil {
                    map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.throughput != nil {
                    map["Throughput"] = self.throughput!
                }
                if self.throughputRead != nil {
                    map["ThroughputRead"] = self.throughputRead!
                }
                if self.throughputWrite != nil {
                    map["ThroughputWrite"] = self.throughputWrite!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AttachedTime"] as? String {
                    self.attachedTime = value
                }
                if let value = dict["Attachments"] as? [String: Any?] {
                    var model = DescribeDisksResponseBody.Disks.Disk.Attachments()
                    model.fromMap(value)
                    self.attachments = model
                }
                if let value = dict["AutoSnapshotPolicyId"] as? String {
                    self.autoSnapshotPolicyId = value
                }
                if let value = dict["BdfId"] as? String {
                    self.bdfId = value
                }
                if let value = dict["BurstingEnabled"] as? Bool {
                    self.burstingEnabled = value
                }
                if let value = dict["Category"] as? String {
                    self.category = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["DeleteAutoSnapshot"] as? Bool {
                    self.deleteAutoSnapshot = value
                }
                if let value = dict["DeleteWithInstance"] as? Bool {
                    self.deleteWithInstance = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["DetachedTime"] as? String {
                    self.detachedTime = value
                }
                if let value = dict["Device"] as? String {
                    self.device = value
                }
                if let value = dict["DiskChargeType"] as? String {
                    self.diskChargeType = value
                }
                if let value = dict["DiskId"] as? String {
                    self.diskId = value
                }
                if let value = dict["DiskName"] as? String {
                    self.diskName = value
                }
                if let value = dict["EnableAutoSnapshot"] as? Bool {
                    self.enableAutoSnapshot = value
                }
                if let value = dict["EnableAutomatedSnapshotPolicy"] as? Bool {
                    self.enableAutomatedSnapshotPolicy = value
                }
                if let value = dict["Encrypted"] as? Bool {
                    self.encrypted = value
                }
                if let value = dict["ExpiredTime"] as? String {
                    self.expiredTime = value
                }
                if let value = dict["IOPS"] as? Int32 {
                    self.IOPS = value
                }
                if let value = dict["IOPSRead"] as? Int32 {
                    self.IOPSRead = value
                }
                if let value = dict["IOPSWrite"] as? Int32 {
                    self.IOPSWrite = value
                }
                if let value = dict["ImageId"] as? String {
                    self.imageId = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["KMSKeyId"] as? String {
                    self.KMSKeyId = value
                }
                if let value = dict["MountInstanceNum"] as? Int32 {
                    self.mountInstanceNum = value
                }
                if let value = dict["MountInstances"] as? [String: Any?] {
                    var model = DescribeDisksResponseBody.Disks.Disk.MountInstances()
                    model.fromMap(value)
                    self.mountInstances = model
                }
                if let value = dict["MultiAttach"] as? String {
                    self.multiAttach = value
                }
                if let value = dict["OperationLocks"] as? [String: Any?] {
                    var model = DescribeDisksResponseBody.Disks.Disk.OperationLocks()
                    model.fromMap(value)
                    self.operationLocks = model
                }
                if let value = dict["PerformanceLevel"] as? String {
                    self.performanceLevel = value
                }
                if let value = dict["Placement"] as? [String: Any?] {
                    var model = DescribeDisksResponseBody.Disks.Disk.Placement()
                    model.fromMap(value)
                    self.placement = model
                }
                if let value = dict["Portable"] as? Bool {
                    self.portable = value
                }
                if let value = dict["ProductCode"] as? String {
                    self.productCode = value
                }
                if let value = dict["ProvisionedIops"] as? Int64 {
                    self.provisionedIops = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["SerialNumber"] as? String {
                    self.serialNumber = value
                }
                if let value = dict["Size"] as? Int32 {
                    self.size = value
                }
                if let value = dict["SourceSnapshotId"] as? String {
                    self.sourceSnapshotId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["StorageClusterId"] as? String {
                    self.storageClusterId = value
                }
                if let value = dict["StorageSetId"] as? String {
                    self.storageSetId = value
                }
                if let value = dict["StorageSetPartitionNumber"] as? Int32 {
                    self.storageSetPartitionNumber = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeDisksResponseBody.Disks.Disk.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["Throughput"] as? Int32 {
                    self.throughput = value
                }
                if let value = dict["ThroughputRead"] as? Int32 {
                    self.throughputRead = value
                }
                if let value = dict["ThroughputWrite"] as? Int32 {
                    self.throughputWrite = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var disk: [DescribeDisksResponseBody.Disks.Disk]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.disk != nil {
                var tmp : [Any] = []
                for k in self.disk! {
                    tmp.append(k.toMap())
                }
                map["Disk"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Disk"] as? [Any?] {
                var tmp : [DescribeDisksResponseBody.Disks.Disk] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDisksResponseBody.Disks.Disk()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.disk = tmp
            }
        }
    }
    public var disks: DescribeDisksResponseBody.Disks?

    public var nextToken: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.disks?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.disks != nil {
            map["Disks"] = self.disks?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Disks"] as? [String: Any?] {
            var model = DescribeDisksResponseBody.Disks()
            model.fromMap(value)
            self.disks = model
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeDisksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDisksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDisksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDisksFullStatusRequest : Tea.TeaModel {
    public class EventTime : Tea.TeaModel {
        public var end: String?

        public var start: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.end != nil {
                map["End"] = self.end!
            }
            if self.start != nil {
                map["Start"] = self.start!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["End"] as? String {
                self.end = value
            }
            if let value = dict["Start"] as? String {
                self.start = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var eventTime: DescribeDisksFullStatusRequest.EventTime?

    public var diskId: [String]?

    public var eventId: [String]?

    public var eventType: String?

    public var healthStatus: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public var tag: [DescribeDisksFullStatusRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eventTime?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventTime != nil {
            map["EventTime"] = self.eventTime?.toMap()
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.eventType != nil {
            map["EventType"] = self.eventType!
        }
        if self.healthStatus != nil {
            map["HealthStatus"] = self.healthStatus!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EventTime"] as? [String: Any?] {
            var model = DescribeDisksFullStatusRequest.EventTime()
            model.fromMap(value)
            self.eventTime = model
        }
        if let value = dict["DiskId"] as? [String] {
            self.diskId = value
        }
        if let value = dict["EventId"] as? [String] {
            self.eventId = value
        }
        if let value = dict["EventType"] as? String {
            self.eventType = value
        }
        if let value = dict["HealthStatus"] as? String {
            self.healthStatus = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeDisksFullStatusRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeDisksFullStatusRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribeDisksFullStatusResponseBody : Tea.TeaModel {
    public class DiskFullStatusSet : Tea.TeaModel {
        public class DiskFullStatusType : Tea.TeaModel {
            public class DiskEventSet : Tea.TeaModel {
                public class DiskEventType : Tea.TeaModel {
                    public class EventType : Tea.TeaModel {
                        public var code: Int32?

                        public var name: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.code != nil {
                                map["Code"] = self.code!
                            }
                            if self.name != nil {
                                map["Name"] = self.name!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Code"] as? Int32 {
                                self.code = value
                            }
                            if let value = dict["Name"] as? String {
                                self.name = value
                            }
                        }
                    }
                    public var eventEndTime: String?

                    public var eventId: String?

                    public var eventTime: String?

                    public var eventType: DescribeDisksFullStatusResponseBody.DiskFullStatusSet.DiskFullStatusType.DiskEventSet.DiskEventType.EventType?

                    public var impactLevel: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.eventType?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.eventEndTime != nil {
                            map["EventEndTime"] = self.eventEndTime!
                        }
                        if self.eventId != nil {
                            map["EventId"] = self.eventId!
                        }
                        if self.eventTime != nil {
                            map["EventTime"] = self.eventTime!
                        }
                        if self.eventType != nil {
                            map["EventType"] = self.eventType?.toMap()
                        }
                        if self.impactLevel != nil {
                            map["ImpactLevel"] = self.impactLevel!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["EventEndTime"] as? String {
                            self.eventEndTime = value
                        }
                        if let value = dict["EventId"] as? String {
                            self.eventId = value
                        }
                        if let value = dict["EventTime"] as? String {
                            self.eventTime = value
                        }
                        if let value = dict["EventType"] as? [String: Any?] {
                            var model = DescribeDisksFullStatusResponseBody.DiskFullStatusSet.DiskFullStatusType.DiskEventSet.DiskEventType.EventType()
                            model.fromMap(value)
                            self.eventType = model
                        }
                        if let value = dict["ImpactLevel"] as? String {
                            self.impactLevel = value
                        }
                    }
                }
                public var diskEventType: [DescribeDisksFullStatusResponseBody.DiskFullStatusSet.DiskFullStatusType.DiskEventSet.DiskEventType]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.diskEventType != nil {
                        var tmp : [Any] = []
                        for k in self.diskEventType! {
                            tmp.append(k.toMap())
                        }
                        map["DiskEventType"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DiskEventType"] as? [Any?] {
                        var tmp : [DescribeDisksFullStatusResponseBody.DiskFullStatusSet.DiskFullStatusType.DiskEventSet.DiskEventType] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDisksFullStatusResponseBody.DiskFullStatusSet.DiskFullStatusType.DiskEventSet.DiskEventType()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.diskEventType = tmp
                    }
                }
            }
            public class HealthStatus : Tea.TeaModel {
                public var code: Int32?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Code"] as? Int32 {
                        self.code = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                }
            }
            public class Status : Tea.TeaModel {
                public var code: Int32?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Code"] as? Int32 {
                        self.code = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                }
            }
            public var device: String?

            public var diskEventSet: DescribeDisksFullStatusResponseBody.DiskFullStatusSet.DiskFullStatusType.DiskEventSet?

            public var diskId: String?

            public var healthStatus: DescribeDisksFullStatusResponseBody.DiskFullStatusSet.DiskFullStatusType.HealthStatus?

            public var instanceId: String?

            public var status: DescribeDisksFullStatusResponseBody.DiskFullStatusSet.DiskFullStatusType.Status?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.diskEventSet?.validate()
                try self.healthStatus?.validate()
                try self.status?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.device != nil {
                    map["Device"] = self.device!
                }
                if self.diskEventSet != nil {
                    map["DiskEventSet"] = self.diskEventSet?.toMap()
                }
                if self.diskId != nil {
                    map["DiskId"] = self.diskId!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.status != nil {
                    map["Status"] = self.status?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Device"] as? String {
                    self.device = value
                }
                if let value = dict["DiskEventSet"] as? [String: Any?] {
                    var model = DescribeDisksFullStatusResponseBody.DiskFullStatusSet.DiskFullStatusType.DiskEventSet()
                    model.fromMap(value)
                    self.diskEventSet = model
                }
                if let value = dict["DiskId"] as? String {
                    self.diskId = value
                }
                if let value = dict["HealthStatus"] as? [String: Any?] {
                    var model = DescribeDisksFullStatusResponseBody.DiskFullStatusSet.DiskFullStatusType.HealthStatus()
                    model.fromMap(value)
                    self.healthStatus = model
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["Status"] as? [String: Any?] {
                    var model = DescribeDisksFullStatusResponseBody.DiskFullStatusSet.DiskFullStatusType.Status()
                    model.fromMap(value)
                    self.status = model
                }
            }
        }
        public var diskFullStatusType: [DescribeDisksFullStatusResponseBody.DiskFullStatusSet.DiskFullStatusType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diskFullStatusType != nil {
                var tmp : [Any] = []
                for k in self.diskFullStatusType! {
                    tmp.append(k.toMap())
                }
                map["DiskFullStatusType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DiskFullStatusType"] as? [Any?] {
                var tmp : [DescribeDisksFullStatusResponseBody.DiskFullStatusSet.DiskFullStatusType] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDisksFullStatusResponseBody.DiskFullStatusSet.DiskFullStatusType()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.diskFullStatusType = tmp
            }
        }
    }
    public var diskFullStatusSet: DescribeDisksFullStatusResponseBody.DiskFullStatusSet?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.diskFullStatusSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskFullStatusSet != nil {
            map["DiskFullStatusSet"] = self.diskFullStatusSet?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DiskFullStatusSet"] as? [String: Any?] {
            var model = DescribeDisksFullStatusResponseBody.DiskFullStatusSet()
            model.fromMap(value)
            self.diskFullStatusSet = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeDisksFullStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDisksFullStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDisksFullStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeEipAddressesRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var filter: [DescribeEipAddressesRequest.Filter]?

    public var allocationId: String?

    public var associatedInstanceId: String?

    public var associatedInstanceType: String?

    public var chargeType: String?

    public var eipAddress: String?

    public var ISP: String?

    public var lockReason: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.associatedInstanceId != nil {
            map["AssociatedInstanceId"] = self.associatedInstanceId!
        }
        if self.associatedInstanceType != nil {
            map["AssociatedInstanceType"] = self.associatedInstanceType!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.eipAddress != nil {
            map["EipAddress"] = self.eipAddress!
        }
        if self.ISP != nil {
            map["ISP"] = self.ISP!
        }
        if self.lockReason != nil {
            map["LockReason"] = self.lockReason!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Filter"] as? [Any?] {
            var tmp : [DescribeEipAddressesRequest.Filter] = []
            for v in value {
                if v != nil {
                    var model = DescribeEipAddressesRequest.Filter()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.filter = tmp
        }
        if let value = dict["AllocationId"] as? String {
            self.allocationId = value
        }
        if let value = dict["AssociatedInstanceId"] as? String {
            self.associatedInstanceId = value
        }
        if let value = dict["AssociatedInstanceType"] as? String {
            self.associatedInstanceType = value
        }
        if let value = dict["ChargeType"] as? String {
            self.chargeType = value
        }
        if let value = dict["EipAddress"] as? String {
            self.eipAddress = value
        }
        if let value = dict["ISP"] as? String {
            self.ISP = value
        }
        if let value = dict["LockReason"] as? String {
            self.lockReason = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class DescribeEipAddressesResponseBody : Tea.TeaModel {
    public class EipAddresses : Tea.TeaModel {
        public class EipAddress : Tea.TeaModel {
            public class OperationLocks : Tea.TeaModel {
                public class LockReason : Tea.TeaModel {
                    public var lockReason: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.lockReason != nil {
                            map["LockReason"] = self.lockReason!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["LockReason"] as? String {
                            self.lockReason = value
                        }
                    }
                }
                public var lockReason: [DescribeEipAddressesResponseBody.EipAddresses.EipAddress.OperationLocks.LockReason]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.lockReason != nil {
                        var tmp : [Any] = []
                        for k in self.lockReason! {
                            tmp.append(k.toMap())
                        }
                        map["LockReason"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["LockReason"] as? [Any?] {
                        var tmp : [DescribeEipAddressesResponseBody.EipAddresses.EipAddress.OperationLocks.LockReason] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeEipAddressesResponseBody.EipAddresses.EipAddress.OperationLocks.LockReason()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.lockReason = tmp
                    }
                }
            }
            public var allocationId: String?

            public var allocationTime: String?

            public var bandwidth: String?

            public var chargeType: String?

            public var eipBandwidth: String?

            public var expiredTime: String?

            public var instanceId: String?

            public var instanceType: String?

            public var internetChargeType: String?

            public var ipAddress: String?

            public var operationLocks: DescribeEipAddressesResponseBody.EipAddresses.EipAddress.OperationLocks?

            public var regionId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.operationLocks?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allocationId != nil {
                    map["AllocationId"] = self.allocationId!
                }
                if self.allocationTime != nil {
                    map["AllocationTime"] = self.allocationTime!
                }
                if self.bandwidth != nil {
                    map["Bandwidth"] = self.bandwidth!
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.eipBandwidth != nil {
                    map["EipBandwidth"] = self.eipBandwidth!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.internetChargeType != nil {
                    map["InternetChargeType"] = self.internetChargeType!
                }
                if self.ipAddress != nil {
                    map["IpAddress"] = self.ipAddress!
                }
                if self.operationLocks != nil {
                    map["OperationLocks"] = self.operationLocks?.toMap()
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AllocationId"] as? String {
                    self.allocationId = value
                }
                if let value = dict["AllocationTime"] as? String {
                    self.allocationTime = value
                }
                if let value = dict["Bandwidth"] as? String {
                    self.bandwidth = value
                }
                if let value = dict["ChargeType"] as? String {
                    self.chargeType = value
                }
                if let value = dict["EipBandwidth"] as? String {
                    self.eipBandwidth = value
                }
                if let value = dict["ExpiredTime"] as? String {
                    self.expiredTime = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["InstanceType"] as? String {
                    self.instanceType = value
                }
                if let value = dict["InternetChargeType"] as? String {
                    self.internetChargeType = value
                }
                if let value = dict["IpAddress"] as? String {
                    self.ipAddress = value
                }
                if let value = dict["OperationLocks"] as? [String: Any?] {
                    var model = DescribeEipAddressesResponseBody.EipAddresses.EipAddress.OperationLocks()
                    model.fromMap(value)
                    self.operationLocks = model
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var eipAddress: [DescribeEipAddressesResponseBody.EipAddresses.EipAddress]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eipAddress != nil {
                var tmp : [Any] = []
                for k in self.eipAddress! {
                    tmp.append(k.toMap())
                }
                map["EipAddress"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EipAddress"] as? [Any?] {
                var tmp : [DescribeEipAddressesResponseBody.EipAddresses.EipAddress] = []
                for v in value {
                    if v != nil {
                        var model = DescribeEipAddressesResponseBody.EipAddresses.EipAddress()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.eipAddress = tmp
            }
        }
    }
    public var eipAddresses: DescribeEipAddressesResponseBody.EipAddresses?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eipAddresses?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eipAddresses != nil {
            map["EipAddresses"] = self.eipAddresses?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EipAddresses"] as? [String: Any?] {
            var model = DescribeEipAddressesResponseBody.EipAddresses()
            model.fromMap(value)
            self.eipAddresses = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeEipAddressesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEipAddressesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeEipAddressesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeEipMonitorDataRequest : Tea.TeaModel {
    public var allocationId: String?

    public var endTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AllocationId"] as? String {
            self.allocationId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeEipMonitorDataResponseBody : Tea.TeaModel {
    public class EipMonitorDatas : Tea.TeaModel {
        public class EipMonitorData : Tea.TeaModel {
            public var eipBandwidth: Int32?

            public var eipFlow: Int32?

            public var eipPackets: Int32?

            public var eipRX: Int32?

            public var eipTX: Int32?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eipBandwidth != nil {
                    map["EipBandwidth"] = self.eipBandwidth!
                }
                if self.eipFlow != nil {
                    map["EipFlow"] = self.eipFlow!
                }
                if self.eipPackets != nil {
                    map["EipPackets"] = self.eipPackets!
                }
                if self.eipRX != nil {
                    map["EipRX"] = self.eipRX!
                }
                if self.eipTX != nil {
                    map["EipTX"] = self.eipTX!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["EipBandwidth"] as? Int32 {
                    self.eipBandwidth = value
                }
                if let value = dict["EipFlow"] as? Int32 {
                    self.eipFlow = value
                }
                if let value = dict["EipPackets"] as? Int32 {
                    self.eipPackets = value
                }
                if let value = dict["EipRX"] as? Int32 {
                    self.eipRX = value
                }
                if let value = dict["EipTX"] as? Int32 {
                    self.eipTX = value
                }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
            }
        }
        public var eipMonitorData: [DescribeEipMonitorDataResponseBody.EipMonitorDatas.EipMonitorData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eipMonitorData != nil {
                var tmp : [Any] = []
                for k in self.eipMonitorData! {
                    tmp.append(k.toMap())
                }
                map["EipMonitorData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EipMonitorData"] as? [Any?] {
                var tmp : [DescribeEipMonitorDataResponseBody.EipMonitorDatas.EipMonitorData] = []
                for v in value {
                    if v != nil {
                        var model = DescribeEipMonitorDataResponseBody.EipMonitorDatas.EipMonitorData()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.eipMonitorData = tmp
            }
        }
    }
    public var eipMonitorDatas: DescribeEipMonitorDataResponseBody.EipMonitorDatas?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eipMonitorDatas?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eipMonitorDatas != nil {
            map["EipMonitorDatas"] = self.eipMonitorDatas?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EipMonitorDatas"] as? [String: Any?] {
            var model = DescribeEipMonitorDataResponseBody.EipMonitorDatas()
            model.fromMap(value)
            self.eipMonitorDatas = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeEipMonitorDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEipMonitorDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeEipMonitorDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeElasticityAssuranceAutoRenewAttributeRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Id"] as? [String] {
                self.id = value
            }
        }
    }
    public var privatePoolOptions: DescribeElasticityAssuranceAutoRenewAttributeRequest.PrivatePoolOptions?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PrivatePoolOptions"] as? [String: Any?] {
            var model = DescribeElasticityAssuranceAutoRenewAttributeRequest.PrivatePoolOptions()
            model.fromMap(value)
            self.privatePoolOptions = model
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeElasticityAssuranceAutoRenewAttributeResponseBody : Tea.TeaModel {
    public class ElasticityAssuranceRenewAttributes : Tea.TeaModel {
        public class ElasticityAssuranceRenewAttribute : Tea.TeaModel {
            public var period: Int32?

            public var periodUnit: String?

            public var privatePoolOptionsId: String?

            public var renewalStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.period != nil {
                    map["Period"] = self.period!
                }
                if self.periodUnit != nil {
                    map["PeriodUnit"] = self.periodUnit!
                }
                if self.privatePoolOptionsId != nil {
                    map["PrivatePoolOptionsId"] = self.privatePoolOptionsId!
                }
                if self.renewalStatus != nil {
                    map["RenewalStatus"] = self.renewalStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Period"] as? Int32 {
                    self.period = value
                }
                if let value = dict["PeriodUnit"] as? String {
                    self.periodUnit = value
                }
                if let value = dict["PrivatePoolOptionsId"] as? String {
                    self.privatePoolOptionsId = value
                }
                if let value = dict["RenewalStatus"] as? String {
                    self.renewalStatus = value
                }
            }
        }
        public var elasticityAssuranceRenewAttribute: [DescribeElasticityAssuranceAutoRenewAttributeResponseBody.ElasticityAssuranceRenewAttributes.ElasticityAssuranceRenewAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.elasticityAssuranceRenewAttribute != nil {
                var tmp : [Any] = []
                for k in self.elasticityAssuranceRenewAttribute! {
                    tmp.append(k.toMap())
                }
                map["ElasticityAssuranceRenewAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ElasticityAssuranceRenewAttribute"] as? [Any?] {
                var tmp : [DescribeElasticityAssuranceAutoRenewAttributeResponseBody.ElasticityAssuranceRenewAttributes.ElasticityAssuranceRenewAttribute] = []
                for v in value {
                    if v != nil {
                        var model = DescribeElasticityAssuranceAutoRenewAttributeResponseBody.ElasticityAssuranceRenewAttributes.ElasticityAssuranceRenewAttribute()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.elasticityAssuranceRenewAttribute = tmp
            }
        }
    }
    public var elasticityAssuranceRenewAttributes: DescribeElasticityAssuranceAutoRenewAttributeResponseBody.ElasticityAssuranceRenewAttributes?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.elasticityAssuranceRenewAttributes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.elasticityAssuranceRenewAttributes != nil {
            map["ElasticityAssuranceRenewAttributes"] = self.elasticityAssuranceRenewAttributes?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ElasticityAssuranceRenewAttributes"] as? [String: Any?] {
            var model = DescribeElasticityAssuranceAutoRenewAttributeResponseBody.ElasticityAssuranceRenewAttributes()
            model.fromMap(value)
            self.elasticityAssuranceRenewAttributes = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeElasticityAssuranceAutoRenewAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeElasticityAssuranceAutoRenewAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeElasticityAssuranceAutoRenewAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeElasticityAssuranceInstancesRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Id"] as? String {
                self.id = value
            }
        }
    }
    public var privatePoolOptions: DescribeElasticityAssuranceInstancesRequest.PrivatePoolOptions?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PrivatePoolOptions"] as? [String: Any?] {
            var model = DescribeElasticityAssuranceInstancesRequest.PrivatePoolOptions()
            model.fromMap(value)
            self.privatePoolOptions = model
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeElasticityAssuranceInstancesResponseBody : Tea.TeaModel {
    public class ElasticityAssuranceItem : Tea.TeaModel {
        public class InstanceIdSet : Tea.TeaModel {
            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
            }
        }
        public var instanceIdSet: [DescribeElasticityAssuranceInstancesResponseBody.ElasticityAssuranceItem.InstanceIdSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceIdSet != nil {
                var tmp : [Any] = []
                for k in self.instanceIdSet! {
                    tmp.append(k.toMap())
                }
                map["InstanceIdSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceIdSet"] as? [Any?] {
                var tmp : [DescribeElasticityAssuranceInstancesResponseBody.ElasticityAssuranceItem.InstanceIdSet] = []
                for v in value {
                    if v != nil {
                        var model = DescribeElasticityAssuranceInstancesResponseBody.ElasticityAssuranceItem.InstanceIdSet()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instanceIdSet = tmp
            }
        }
    }
    public var elasticityAssuranceItem: DescribeElasticityAssuranceInstancesResponseBody.ElasticityAssuranceItem?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.elasticityAssuranceItem?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.elasticityAssuranceItem != nil {
            map["ElasticityAssuranceItem"] = self.elasticityAssuranceItem?.toMap()
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ElasticityAssuranceItem"] as? [String: Any?] {
            var model = DescribeElasticityAssuranceInstancesResponseBody.ElasticityAssuranceItem()
            model.fromMap(value)
            self.elasticityAssuranceItem = model
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeElasticityAssuranceInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeElasticityAssuranceInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeElasticityAssuranceInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeElasticityAssurancesRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var ids: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ids != nil {
                map["Ids"] = self.ids!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Ids"] as? String {
                self.ids = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var privatePoolOptions: DescribeElasticityAssurancesRequest.PrivatePoolOptions?

    public var instanceChargeType: String?

    public var instanceType: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var packageType: String?

    public var platform: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public var tag: [DescribeElasticityAssurancesRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.packageType != nil {
            map["PackageType"] = self.packageType!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PrivatePoolOptions"] as? [String: Any?] {
            var model = DescribeElasticityAssurancesRequest.PrivatePoolOptions()
            model.fromMap(value)
            self.privatePoolOptions = model
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PackageType"] as? String {
            self.packageType = value
        }
        if let value = dict["Platform"] as? String {
            self.platform = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeElasticityAssurancesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeElasticityAssurancesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribeElasticityAssurancesResponseBody : Tea.TeaModel {
    public class ElasticityAssuranceSet : Tea.TeaModel {
        public class ElasticityAssuranceItem : Tea.TeaModel {
            public class AllocatedResources : Tea.TeaModel {
                public class AllocatedResource : Tea.TeaModel {
                    public class ElasticityAssuranceUsages : Tea.TeaModel {
                        public class ElasticityAssuranceUsage : Tea.TeaModel {
                            public var accountId: String?

                            public var serviceName: String?

                            public var usedAmount: Int32?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.accountId != nil {
                                    map["AccountId"] = self.accountId!
                                }
                                if self.serviceName != nil {
                                    map["ServiceName"] = self.serviceName!
                                }
                                if self.usedAmount != nil {
                                    map["UsedAmount"] = self.usedAmount!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["AccountId"] as? String {
                                    self.accountId = value
                                }
                                if let value = dict["ServiceName"] as? String {
                                    self.serviceName = value
                                }
                                if let value = dict["UsedAmount"] as? Int32 {
                                    self.usedAmount = value
                                }
                            }
                        }
                        public var elasticityAssuranceUsage: [DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.AllocatedResources.AllocatedResource.ElasticityAssuranceUsages.ElasticityAssuranceUsage]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.elasticityAssuranceUsage != nil {
                                var tmp : [Any] = []
                                for k in self.elasticityAssuranceUsage! {
                                    tmp.append(k.toMap())
                                }
                                map["ElasticityAssuranceUsage"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["ElasticityAssuranceUsage"] as? [Any?] {
                                var tmp : [DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.AllocatedResources.AllocatedResource.ElasticityAssuranceUsages.ElasticityAssuranceUsage] = []
                                for v in value {
                                    if v != nil {
                                        var model = DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.AllocatedResources.AllocatedResource.ElasticityAssuranceUsages.ElasticityAssuranceUsage()
                                        if v != nil {
                                            model.fromMap(v as? [String: Any?])
                                        }
                                        tmp.append(model)
                                    }
                                }
                                self.elasticityAssuranceUsage = tmp
                            }
                        }
                    }
                    public var availableAmount: Int32?

                    public var elasticityAssuranceUsages: DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.AllocatedResources.AllocatedResource.ElasticityAssuranceUsages?

                    public var instanceType: String?

                    public var totalAmount: Int32?

                    public var usedAmount: Int32?

                    public var zoneId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.elasticityAssuranceUsages?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.availableAmount != nil {
                            map["AvailableAmount"] = self.availableAmount!
                        }
                        if self.elasticityAssuranceUsages != nil {
                            map["ElasticityAssuranceUsages"] = self.elasticityAssuranceUsages?.toMap()
                        }
                        if self.instanceType != nil {
                            map["InstanceType"] = self.instanceType!
                        }
                        if self.totalAmount != nil {
                            map["TotalAmount"] = self.totalAmount!
                        }
                        if self.usedAmount != nil {
                            map["UsedAmount"] = self.usedAmount!
                        }
                        if self.zoneId != nil {
                            map["zoneId"] = self.zoneId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AvailableAmount"] as? Int32 {
                            self.availableAmount = value
                        }
                        if let value = dict["ElasticityAssuranceUsages"] as? [String: Any?] {
                            var model = DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.AllocatedResources.AllocatedResource.ElasticityAssuranceUsages()
                            model.fromMap(value)
                            self.elasticityAssuranceUsages = model
                        }
                        if let value = dict["InstanceType"] as? String {
                            self.instanceType = value
                        }
                        if let value = dict["TotalAmount"] as? Int32 {
                            self.totalAmount = value
                        }
                        if let value = dict["UsedAmount"] as? Int32 {
                            self.usedAmount = value
                        }
                        if let value = dict["zoneId"] as? String {
                            self.zoneId = value
                        }
                    }
                }
                public var allocatedResource: [DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.AllocatedResources.AllocatedResource]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.allocatedResource != nil {
                        var tmp : [Any] = []
                        for k in self.allocatedResource! {
                            tmp.append(k.toMap())
                        }
                        map["AllocatedResource"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AllocatedResource"] as? [Any?] {
                        var tmp : [DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.AllocatedResources.AllocatedResource] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.AllocatedResources.AllocatedResource()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.allocatedResource = tmp
                    }
                }
            }
            public class RecurrenceRules : Tea.TeaModel {
                public class RecurrenceRule : Tea.TeaModel {
                    public var endHour: Int32?

                    public var recurrenceType: String?

                    public var recurrenceValue: String?

                    public var startHour: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.endHour != nil {
                            map["EndHour"] = self.endHour!
                        }
                        if self.recurrenceType != nil {
                            map["RecurrenceType"] = self.recurrenceType!
                        }
                        if self.recurrenceValue != nil {
                            map["RecurrenceValue"] = self.recurrenceValue!
                        }
                        if self.startHour != nil {
                            map["StartHour"] = self.startHour!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["EndHour"] as? Int32 {
                            self.endHour = value
                        }
                        if let value = dict["RecurrenceType"] as? String {
                            self.recurrenceType = value
                        }
                        if let value = dict["RecurrenceValue"] as? String {
                            self.recurrenceValue = value
                        }
                        if let value = dict["StartHour"] as? Int32 {
                            self.startHour = value
                        }
                    }
                }
                public var recurrenceRule: [DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.RecurrenceRules.RecurrenceRule]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.recurrenceRule != nil {
                        var tmp : [Any] = []
                        for k in self.recurrenceRule! {
                            tmp.append(k.toMap())
                        }
                        map["RecurrenceRule"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RecurrenceRule"] as? [Any?] {
                        var tmp : [DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.RecurrenceRules.RecurrenceRule] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.RecurrenceRules.RecurrenceRule()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.recurrenceRule = tmp
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["TagKey"] as? String {
                            self.tagKey = value
                        }
                        if let value = dict["TagValue"] as? String {
                            self.tagValue = value
                        }
                    }
                }
                public var tag: [DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var allocatedResources: DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.AllocatedResources?

            public var description_: String?

            public var elasticityAssuranceOwnerId: String?

            public var endTime: String?

            public var instanceChargeType: String?

            public var latestStartTime: String?

            public var packageType: String?

            public var privatePoolOptionsId: String?

            public var privatePoolOptionsMatchCriteria: String?

            public var privatePoolOptionsName: String?

            public var recurrenceRules: DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.RecurrenceRules?

            public var regionId: String?

            public var resourceGroupId: String?

            public var startTime: String?

            public var startTimeType: String?

            public var status: String?

            public var tags: DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.Tags?

            public var totalAssuranceTimes: String?

            public var usedAssuranceTimes: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.allocatedResources?.validate()
                try self.recurrenceRules?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allocatedResources != nil {
                    map["AllocatedResources"] = self.allocatedResources?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.elasticityAssuranceOwnerId != nil {
                    map["ElasticityAssuranceOwnerId"] = self.elasticityAssuranceOwnerId!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.instanceChargeType != nil {
                    map["InstanceChargeType"] = self.instanceChargeType!
                }
                if self.latestStartTime != nil {
                    map["LatestStartTime"] = self.latestStartTime!
                }
                if self.packageType != nil {
                    map["PackageType"] = self.packageType!
                }
                if self.privatePoolOptionsId != nil {
                    map["PrivatePoolOptionsId"] = self.privatePoolOptionsId!
                }
                if self.privatePoolOptionsMatchCriteria != nil {
                    map["PrivatePoolOptionsMatchCriteria"] = self.privatePoolOptionsMatchCriteria!
                }
                if self.privatePoolOptionsName != nil {
                    map["PrivatePoolOptionsName"] = self.privatePoolOptionsName!
                }
                if self.recurrenceRules != nil {
                    map["RecurrenceRules"] = self.recurrenceRules?.toMap()
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.startTimeType != nil {
                    map["StartTimeType"] = self.startTimeType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.totalAssuranceTimes != nil {
                    map["TotalAssuranceTimes"] = self.totalAssuranceTimes!
                }
                if self.usedAssuranceTimes != nil {
                    map["UsedAssuranceTimes"] = self.usedAssuranceTimes!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AllocatedResources"] as? [String: Any?] {
                    var model = DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.AllocatedResources()
                    model.fromMap(value)
                    self.allocatedResources = model
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["ElasticityAssuranceOwnerId"] as? String {
                    self.elasticityAssuranceOwnerId = value
                }
                if let value = dict["EndTime"] as? String {
                    self.endTime = value
                }
                if let value = dict["InstanceChargeType"] as? String {
                    self.instanceChargeType = value
                }
                if let value = dict["LatestStartTime"] as? String {
                    self.latestStartTime = value
                }
                if let value = dict["PackageType"] as? String {
                    self.packageType = value
                }
                if let value = dict["PrivatePoolOptionsId"] as? String {
                    self.privatePoolOptionsId = value
                }
                if let value = dict["PrivatePoolOptionsMatchCriteria"] as? String {
                    self.privatePoolOptionsMatchCriteria = value
                }
                if let value = dict["PrivatePoolOptionsName"] as? String {
                    self.privatePoolOptionsName = value
                }
                if let value = dict["RecurrenceRules"] as? [String: Any?] {
                    var model = DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.RecurrenceRules()
                    model.fromMap(value)
                    self.recurrenceRules = model
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["StartTime"] as? String {
                    self.startTime = value
                }
                if let value = dict["StartTimeType"] as? String {
                    self.startTimeType = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["TotalAssuranceTimes"] as? String {
                    self.totalAssuranceTimes = value
                }
                if let value = dict["UsedAssuranceTimes"] as? Int32 {
                    self.usedAssuranceTimes = value
                }
            }
        }
        public var elasticityAssuranceItem: [DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.elasticityAssuranceItem != nil {
                var tmp : [Any] = []
                for k in self.elasticityAssuranceItem! {
                    tmp.append(k.toMap())
                }
                map["ElasticityAssuranceItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ElasticityAssuranceItem"] as? [Any?] {
                var tmp : [DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem] = []
                for v in value {
                    if v != nil {
                        var model = DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.elasticityAssuranceItem = tmp
            }
        }
    }
    public var elasticityAssuranceSet: DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.elasticityAssuranceSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.elasticityAssuranceSet != nil {
            map["ElasticityAssuranceSet"] = self.elasticityAssuranceSet?.toMap()
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ElasticityAssuranceSet"] as? [String: Any?] {
            var model = DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet()
            model.fromMap(value)
            self.elasticityAssuranceSet = model
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeElasticityAssurancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeElasticityAssurancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeElasticityAssurancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeEniMonitorDataRequest : Tea.TeaModel {
    public var endTime: String?

    public var eniId: String?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.eniId != nil {
            map["EniId"] = self.eniId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["EniId"] as? String {
            self.eniId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeEniMonitorDataResponseBody : Tea.TeaModel {
    public class MonitorData : Tea.TeaModel {
        public class EniMonitorData : Tea.TeaModel {
            public var dropPacketRx: String?

            public var dropPacketTx: String?

            public var eniId: String?

            public var intranetRx: String?

            public var intranetTx: String?

            public var packetRx: String?

            public var packetTx: String?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dropPacketRx != nil {
                    map["DropPacketRx"] = self.dropPacketRx!
                }
                if self.dropPacketTx != nil {
                    map["DropPacketTx"] = self.dropPacketTx!
                }
                if self.eniId != nil {
                    map["EniId"] = self.eniId!
                }
                if self.intranetRx != nil {
                    map["IntranetRx"] = self.intranetRx!
                }
                if self.intranetTx != nil {
                    map["IntranetTx"] = self.intranetTx!
                }
                if self.packetRx != nil {
                    map["PacketRx"] = self.packetRx!
                }
                if self.packetTx != nil {
                    map["PacketTx"] = self.packetTx!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DropPacketRx"] as? String {
                    self.dropPacketRx = value
                }
                if let value = dict["DropPacketTx"] as? String {
                    self.dropPacketTx = value
                }
                if let value = dict["EniId"] as? String {
                    self.eniId = value
                }
                if let value = dict["IntranetRx"] as? String {
                    self.intranetRx = value
                }
                if let value = dict["IntranetTx"] as? String {
                    self.intranetTx = value
                }
                if let value = dict["PacketRx"] as? String {
                    self.packetRx = value
                }
                if let value = dict["PacketTx"] as? String {
                    self.packetTx = value
                }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
            }
        }
        public var eniMonitorData: [DescribeEniMonitorDataResponseBody.MonitorData.EniMonitorData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eniMonitorData != nil {
                var tmp : [Any] = []
                for k in self.eniMonitorData! {
                    tmp.append(k.toMap())
                }
                map["EniMonitorData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EniMonitorData"] as? [Any?] {
                var tmp : [DescribeEniMonitorDataResponseBody.MonitorData.EniMonitorData] = []
                for v in value {
                    if v != nil {
                        var model = DescribeEniMonitorDataResponseBody.MonitorData.EniMonitorData()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.eniMonitorData = tmp
            }
        }
    }
    public var monitorData: DescribeEniMonitorDataResponseBody.MonitorData?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.monitorData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorData != nil {
            map["MonitorData"] = self.monitorData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MonitorData"] as? [String: Any?] {
            var model = DescribeEniMonitorDataResponseBody.MonitorData()
            model.fromMap(value)
            self.monitorData = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeEniMonitorDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEniMonitorDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeEniMonitorDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeForwardTableEntriesRequest : Tea.TeaModel {
    public var forwardEntryId: String?

    public var forwardTableId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forwardEntryId != nil {
            map["ForwardEntryId"] = self.forwardEntryId!
        }
        if self.forwardTableId != nil {
            map["ForwardTableId"] = self.forwardTableId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ForwardEntryId"] as? String {
            self.forwardEntryId = value
        }
        if let value = dict["ForwardTableId"] as? String {
            self.forwardTableId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeForwardTableEntriesResponseBody : Tea.TeaModel {
    public class ForwardTableEntries : Tea.TeaModel {
        public class ForwardTableEntry : Tea.TeaModel {
            public var externalIp: String?

            public var externalPort: String?

            public var forwardEntryId: String?

            public var forwardTableId: String?

            public var internalIp: String?

            public var internalPort: String?

            public var ipProtocol: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.externalIp != nil {
                    map["ExternalIp"] = self.externalIp!
                }
                if self.externalPort != nil {
                    map["ExternalPort"] = self.externalPort!
                }
                if self.forwardEntryId != nil {
                    map["ForwardEntryId"] = self.forwardEntryId!
                }
                if self.forwardTableId != nil {
                    map["ForwardTableId"] = self.forwardTableId!
                }
                if self.internalIp != nil {
                    map["InternalIp"] = self.internalIp!
                }
                if self.internalPort != nil {
                    map["InternalPort"] = self.internalPort!
                }
                if self.ipProtocol != nil {
                    map["IpProtocol"] = self.ipProtocol!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ExternalIp"] as? String {
                    self.externalIp = value
                }
                if let value = dict["ExternalPort"] as? String {
                    self.externalPort = value
                }
                if let value = dict["ForwardEntryId"] as? String {
                    self.forwardEntryId = value
                }
                if let value = dict["ForwardTableId"] as? String {
                    self.forwardTableId = value
                }
                if let value = dict["InternalIp"] as? String {
                    self.internalIp = value
                }
                if let value = dict["InternalPort"] as? String {
                    self.internalPort = value
                }
                if let value = dict["IpProtocol"] as? String {
                    self.ipProtocol = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var forwardTableEntry: [DescribeForwardTableEntriesResponseBody.ForwardTableEntries.ForwardTableEntry]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.forwardTableEntry != nil {
                var tmp : [Any] = []
                for k in self.forwardTableEntry! {
                    tmp.append(k.toMap())
                }
                map["ForwardTableEntry"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ForwardTableEntry"] as? [Any?] {
                var tmp : [DescribeForwardTableEntriesResponseBody.ForwardTableEntries.ForwardTableEntry] = []
                for v in value {
                    if v != nil {
                        var model = DescribeForwardTableEntriesResponseBody.ForwardTableEntries.ForwardTableEntry()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.forwardTableEntry = tmp
            }
        }
    }
    public var forwardTableEntries: DescribeForwardTableEntriesResponseBody.ForwardTableEntries?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.forwardTableEntries?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forwardTableEntries != nil {
            map["ForwardTableEntries"] = self.forwardTableEntries?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ForwardTableEntries"] as? [String: Any?] {
            var model = DescribeForwardTableEntriesResponseBody.ForwardTableEntries()
            model.fromMap(value)
            self.forwardTableEntries = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeForwardTableEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeForwardTableEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeForwardTableEntriesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeHaVipsRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? [String] {
                self.value = value
            }
        }
    }
    public var filter: [DescribeHaVipsRequest.Filter]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Filter"] as? [Any?] {
            var tmp : [DescribeHaVipsRequest.Filter] = []
            for v in value {
                if v != nil {
                    var model = DescribeHaVipsRequest.Filter()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.filter = tmp
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeHaVipsResponseBody : Tea.TeaModel {
    public class HaVips : Tea.TeaModel {
        public class HaVip : Tea.TeaModel {
            public class AssociatedEipAddresses : Tea.TeaModel {
                public var associatedEipAddresse: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.associatedEipAddresse != nil {
                        map["associatedEipAddresse"] = self.associatedEipAddresse!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["associatedEipAddresse"] as? [String] {
                        self.associatedEipAddresse = value
                    }
                }
            }
            public class AssociatedInstances : Tea.TeaModel {
                public var associatedInstance: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.associatedInstance != nil {
                        map["associatedInstance"] = self.associatedInstance!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["associatedInstance"] as? [String] {
                        self.associatedInstance = value
                    }
                }
            }
            public var associatedEipAddresses: DescribeHaVipsResponseBody.HaVips.HaVip.AssociatedEipAddresses?

            public var associatedInstances: DescribeHaVipsResponseBody.HaVips.HaVip.AssociatedInstances?

            public var createTime: String?

            public var description_: String?

            public var haVipId: String?

            public var ipAddress: String?

            public var masterInstanceId: String?

            public var regionId: String?

            public var status: String?

            public var vSwitchId: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.associatedEipAddresses?.validate()
                try self.associatedInstances?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.associatedEipAddresses != nil {
                    map["AssociatedEipAddresses"] = self.associatedEipAddresses?.toMap()
                }
                if self.associatedInstances != nil {
                    map["AssociatedInstances"] = self.associatedInstances?.toMap()
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.haVipId != nil {
                    map["HaVipId"] = self.haVipId!
                }
                if self.ipAddress != nil {
                    map["IpAddress"] = self.ipAddress!
                }
                if self.masterInstanceId != nil {
                    map["MasterInstanceId"] = self.masterInstanceId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AssociatedEipAddresses"] as? [String: Any?] {
                    var model = DescribeHaVipsResponseBody.HaVips.HaVip.AssociatedEipAddresses()
                    model.fromMap(value)
                    self.associatedEipAddresses = model
                }
                if let value = dict["AssociatedInstances"] as? [String: Any?] {
                    var model = DescribeHaVipsResponseBody.HaVips.HaVip.AssociatedInstances()
                    model.fromMap(value)
                    self.associatedInstances = model
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["HaVipId"] as? String {
                    self.haVipId = value
                }
                if let value = dict["IpAddress"] as? String {
                    self.ipAddress = value
                }
                if let value = dict["MasterInstanceId"] as? String {
                    self.masterInstanceId = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["VSwitchId"] as? String {
                    self.vSwitchId = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
            }
        }
        public var haVip: [DescribeHaVipsResponseBody.HaVips.HaVip]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.haVip != nil {
                var tmp : [Any] = []
                for k in self.haVip! {
                    tmp.append(k.toMap())
                }
                map["HaVip"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["HaVip"] as? [Any?] {
                var tmp : [DescribeHaVipsResponseBody.HaVips.HaVip] = []
                for v in value {
                    if v != nil {
                        var model = DescribeHaVipsResponseBody.HaVips.HaVip()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.haVip = tmp
            }
        }
    }
    public var haVips: DescribeHaVipsResponseBody.HaVips?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.haVips?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.haVips != nil {
            map["HaVips"] = self.haVips?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["HaVips"] as? [String: Any?] {
            var model = DescribeHaVipsResponseBody.HaVips()
            model.fromMap(value)
            self.haVips = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeHaVipsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHaVipsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeHaVipsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeHpcClustersRequest : Tea.TeaModel {
    public var clientToken: String?

    public var hpcClusterIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.hpcClusterIds != nil {
            map["HpcClusterIds"] = self.hpcClusterIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["HpcClusterIds"] as? String {
            self.hpcClusterIds = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeHpcClustersResponseBody : Tea.TeaModel {
    public class HpcClusters : Tea.TeaModel {
        public class HpcCluster : Tea.TeaModel {
            public var description_: String?

            public var hpcClusterId: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.hpcClusterId != nil {
                    map["HpcClusterId"] = self.hpcClusterId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["HpcClusterId"] as? String {
                    self.hpcClusterId = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
            }
        }
        public var hpcCluster: [DescribeHpcClustersResponseBody.HpcClusters.HpcCluster]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hpcCluster != nil {
                var tmp : [Any] = []
                for k in self.hpcCluster! {
                    tmp.append(k.toMap())
                }
                map["HpcCluster"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["HpcCluster"] as? [Any?] {
                var tmp : [DescribeHpcClustersResponseBody.HpcClusters.HpcCluster] = []
                for v in value {
                    if v != nil {
                        var model = DescribeHpcClustersResponseBody.HpcClusters.HpcCluster()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.hpcCluster = tmp
            }
        }
    }
    public var hpcClusters: DescribeHpcClustersResponseBody.HpcClusters?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.hpcClusters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hpcClusters != nil {
            map["HpcClusters"] = self.hpcClusters?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["HpcClusters"] as? [String: Any?] {
            var model = DescribeHpcClustersResponseBody.HpcClusters()
            model.fromMap(value)
            self.hpcClusters = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeHpcClustersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHpcClustersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeHpcClustersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeImageComponentsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var componentType: String?

    public var componentVersion: String?

    public var imageComponentId: [String]?

    public var maxResults: Int32?

    public var name: String?

    public var nextToken: String?

    public var owner: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var systemType: String?

    public var tag: [DescribeImageComponentsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.componentType != nil {
            map["ComponentType"] = self.componentType!
        }
        if self.componentVersion != nil {
            map["ComponentVersion"] = self.componentVersion!
        }
        if self.imageComponentId != nil {
            map["ImageComponentId"] = self.imageComponentId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.systemType != nil {
            map["SystemType"] = self.systemType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ComponentType"] as? String {
            self.componentType = value
        }
        if let value = dict["ComponentVersion"] as? String {
            self.componentVersion = value
        }
        if let value = dict["ImageComponentId"] as? [String] {
            self.imageComponentId = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SystemType"] as? String {
            self.systemType = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeImageComponentsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeImageComponentsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribeImageComponentsResponseBody : Tea.TeaModel {
    public class ImageComponent : Tea.TeaModel {
        public class ImageComponentSet : Tea.TeaModel {
            public class Parameters : Tea.TeaModel {
                public class Parameter : Tea.TeaModel {
                    public var defaultValue: String?

                    public var name: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.defaultValue != nil {
                            map["DefaultValue"] = self.defaultValue!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["DefaultValue"] as? String {
                            self.defaultValue = value
                        }
                        if let value = dict["Name"] as? String {
                            self.name = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                    }
                }
                public var parameter: [DescribeImageComponentsResponseBody.ImageComponent.ImageComponentSet.Parameters.Parameter]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.parameter != nil {
                        var tmp : [Any] = []
                        for k in self.parameter! {
                            tmp.append(k.toMap())
                        }
                        map["Parameter"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Parameter"] as? [Any?] {
                        var tmp : [DescribeImageComponentsResponseBody.ImageComponent.ImageComponentSet.Parameters.Parameter] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeImageComponentsResponseBody.ImageComponent.ImageComponentSet.Parameters.Parameter()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.parameter = tmp
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["TagKey"] as? String {
                            self.tagKey = value
                        }
                        if let value = dict["TagValue"] as? String {
                            self.tagValue = value
                        }
                    }
                }
                public var tag: [DescribeImageComponentsResponseBody.ImageComponent.ImageComponentSet.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeImageComponentsResponseBody.ImageComponent.ImageComponentSet.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeImageComponentsResponseBody.ImageComponent.ImageComponentSet.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var componentType: String?

            public var componentVersion: String?

            public var content: String?

            public var creationTime: String?

            public var description_: String?

            public var imageComponentId: String?

            public var name: String?

            public var owner: String?

            public var parameters: DescribeImageComponentsResponseBody.ImageComponent.ImageComponentSet.Parameters?

            public var resourceGroupId: String?

            public var systemType: String?

            public var tags: DescribeImageComponentsResponseBody.ImageComponent.ImageComponentSet.Tags?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.parameters?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.componentType != nil {
                    map["ComponentType"] = self.componentType!
                }
                if self.componentVersion != nil {
                    map["ComponentVersion"] = self.componentVersion!
                }
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.imageComponentId != nil {
                    map["ImageComponentId"] = self.imageComponentId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.parameters != nil {
                    map["Parameters"] = self.parameters?.toMap()
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.systemType != nil {
                    map["SystemType"] = self.systemType!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ComponentType"] as? String {
                    self.componentType = value
                }
                if let value = dict["ComponentVersion"] as? String {
                    self.componentVersion = value
                }
                if let value = dict["Content"] as? String {
                    self.content = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["ImageComponentId"] as? String {
                    self.imageComponentId = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["Parameters"] as? [String: Any?] {
                    var model = DescribeImageComponentsResponseBody.ImageComponent.ImageComponentSet.Parameters()
                    model.fromMap(value)
                    self.parameters = model
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["SystemType"] as? String {
                    self.systemType = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeImageComponentsResponseBody.ImageComponent.ImageComponentSet.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
            }
        }
        public var imageComponentSet: [DescribeImageComponentsResponseBody.ImageComponent.ImageComponentSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.imageComponentSet != nil {
                var tmp : [Any] = []
                for k in self.imageComponentSet! {
                    tmp.append(k.toMap())
                }
                map["ImageComponentSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ImageComponentSet"] as? [Any?] {
                var tmp : [DescribeImageComponentsResponseBody.ImageComponent.ImageComponentSet] = []
                for v in value {
                    if v != nil {
                        var model = DescribeImageComponentsResponseBody.ImageComponent.ImageComponentSet()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.imageComponentSet = tmp
            }
        }
    }
    public var imageComponent: DescribeImageComponentsResponseBody.ImageComponent?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.imageComponent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageComponent != nil {
            map["ImageComponent"] = self.imageComponent?.toMap()
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ImageComponent"] as? [String: Any?] {
            var model = DescribeImageComponentsResponseBody.ImageComponent()
            model.fromMap(value)
            self.imageComponent = model
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeImageComponentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageComponentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeImageComponentsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeImageFromFamilyRequest : Tea.TeaModel {
    public var imageFamily: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ImageFamily"] as? String {
            self.imageFamily = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeImageFromFamilyResponseBody : Tea.TeaModel {
    public class Image : Tea.TeaModel {
        public class DiskDeviceMappings : Tea.TeaModel {
            public class DiskDeviceMapping : Tea.TeaModel {
                public var device: String?

                public var format: String?

                public var importOSSBucket: String?

                public var importOSSObject: String?

                public var size: String?

                public var snapshotId: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.device != nil {
                        map["Device"] = self.device!
                    }
                    if self.format != nil {
                        map["Format"] = self.format!
                    }
                    if self.importOSSBucket != nil {
                        map["ImportOSSBucket"] = self.importOSSBucket!
                    }
                    if self.importOSSObject != nil {
                        map["ImportOSSObject"] = self.importOSSObject!
                    }
                    if self.size != nil {
                        map["Size"] = self.size!
                    }
                    if self.snapshotId != nil {
                        map["SnapshotId"] = self.snapshotId!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Device"] as? String {
                        self.device = value
                    }
                    if let value = dict["Format"] as? String {
                        self.format = value
                    }
                    if let value = dict["ImportOSSBucket"] as? String {
                        self.importOSSBucket = value
                    }
                    if let value = dict["ImportOSSObject"] as? String {
                        self.importOSSObject = value
                    }
                    if let value = dict["Size"] as? String {
                        self.size = value
                    }
                    if let value = dict["SnapshotId"] as? String {
                        self.snapshotId = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var diskDeviceMapping: [DescribeImageFromFamilyResponseBody.Image.DiskDeviceMappings.DiskDeviceMapping]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskDeviceMapping != nil {
                    var tmp : [Any] = []
                    for k in self.diskDeviceMapping! {
                        tmp.append(k.toMap())
                    }
                    map["DiskDeviceMapping"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DiskDeviceMapping"] as? [Any?] {
                    var tmp : [DescribeImageFromFamilyResponseBody.Image.DiskDeviceMappings.DiskDeviceMapping] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeImageFromFamilyResponseBody.Image.DiskDeviceMappings.DiskDeviceMapping()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.diskDeviceMapping = tmp
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public class Tag : Tea.TeaModel {
                public var tagKey: String?

                public var tagValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tagKey != nil {
                        map["TagKey"] = self.tagKey!
                    }
                    if self.tagValue != nil {
                        map["TagValue"] = self.tagValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["TagKey"] as? String {
                        self.tagKey = value
                    }
                    if let value = dict["TagValue"] as? String {
                        self.tagValue = value
                    }
                }
            }
            public var tag: [DescribeImageFromFamilyResponseBody.Image.Tags.Tag]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tag != nil {
                    var tmp : [Any] = []
                    for k in self.tag! {
                        tmp.append(k.toMap())
                    }
                    map["Tag"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Tag"] as? [Any?] {
                    var tmp : [DescribeImageFromFamilyResponseBody.Image.Tags.Tag] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeImageFromFamilyResponseBody.Image.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.tag = tmp
                }
            }
        }
        public var architecture: String?

        public var creationTime: String?

        public var description_: String?

        public var diskDeviceMappings: DescribeImageFromFamilyResponseBody.Image.DiskDeviceMappings?

        public var imageFamily: String?

        public var imageId: String?

        public var imageName: String?

        public var imageOwnerAlias: String?

        public var imageVersion: String?

        public var isCopied: Bool?

        public var isSelfShared: String?

        public var isSubscribed: Bool?

        public var isSupportCloudinit: Bool?

        public var isSupportIoOptimized: Bool?

        public var OSName: String?

        public var OSType: String?

        public var platform: String?

        public var productCode: String?

        public var progress: String?

        public var size: Int32?

        public var status: String?

        public var tags: DescribeImageFromFamilyResponseBody.Image.Tags?

        public var usage: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.diskDeviceMappings?.validate()
            try self.tags?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.architecture != nil {
                map["Architecture"] = self.architecture!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.diskDeviceMappings != nil {
                map["DiskDeviceMappings"] = self.diskDeviceMappings?.toMap()
            }
            if self.imageFamily != nil {
                map["ImageFamily"] = self.imageFamily!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.imageName != nil {
                map["ImageName"] = self.imageName!
            }
            if self.imageOwnerAlias != nil {
                map["ImageOwnerAlias"] = self.imageOwnerAlias!
            }
            if self.imageVersion != nil {
                map["ImageVersion"] = self.imageVersion!
            }
            if self.isCopied != nil {
                map["IsCopied"] = self.isCopied!
            }
            if self.isSelfShared != nil {
                map["IsSelfShared"] = self.isSelfShared!
            }
            if self.isSubscribed != nil {
                map["IsSubscribed"] = self.isSubscribed!
            }
            if self.isSupportCloudinit != nil {
                map["IsSupportCloudinit"] = self.isSupportCloudinit!
            }
            if self.isSupportIoOptimized != nil {
                map["IsSupportIoOptimized"] = self.isSupportIoOptimized!
            }
            if self.OSName != nil {
                map["OSName"] = self.OSName!
            }
            if self.OSType != nil {
                map["OSType"] = self.OSType!
            }
            if self.platform != nil {
                map["Platform"] = self.platform!
            }
            if self.productCode != nil {
                map["ProductCode"] = self.productCode!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                map["Tags"] = self.tags?.toMap()
            }
            if self.usage != nil {
                map["Usage"] = self.usage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Architecture"] as? String {
                self.architecture = value
            }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DiskDeviceMappings"] as? [String: Any?] {
                var model = DescribeImageFromFamilyResponseBody.Image.DiskDeviceMappings()
                model.fromMap(value)
                self.diskDeviceMappings = model
            }
            if let value = dict["ImageFamily"] as? String {
                self.imageFamily = value
            }
            if let value = dict["ImageId"] as? String {
                self.imageId = value
            }
            if let value = dict["ImageName"] as? String {
                self.imageName = value
            }
            if let value = dict["ImageOwnerAlias"] as? String {
                self.imageOwnerAlias = value
            }
            if let value = dict["ImageVersion"] as? String {
                self.imageVersion = value
            }
            if let value = dict["IsCopied"] as? Bool {
                self.isCopied = value
            }
            if let value = dict["IsSelfShared"] as? String {
                self.isSelfShared = value
            }
            if let value = dict["IsSubscribed"] as? Bool {
                self.isSubscribed = value
            }
            if let value = dict["IsSupportCloudinit"] as? Bool {
                self.isSupportCloudinit = value
            }
            if let value = dict["IsSupportIoOptimized"] as? Bool {
                self.isSupportIoOptimized = value
            }
            if let value = dict["OSName"] as? String {
                self.OSName = value
            }
            if let value = dict["OSType"] as? String {
                self.OSType = value
            }
            if let value = dict["Platform"] as? String {
                self.platform = value
            }
            if let value = dict["ProductCode"] as? String {
                self.productCode = value
            }
            if let value = dict["Progress"] as? String {
                self.progress = value
            }
            if let value = dict["Size"] as? Int32 {
                self.size = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["Tags"] as? [String: Any?] {
                var model = DescribeImageFromFamilyResponseBody.Image.Tags()
                model.fromMap(value)
                self.tags = model
            }
            if let value = dict["Usage"] as? String {
                self.usage = value
            }
        }
    }
    public var image: DescribeImageFromFamilyResponseBody.Image?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.image?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.image != nil {
            map["Image"] = self.image?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Image"] as? [String: Any?] {
            var model = DescribeImageFromFamilyResponseBody.Image()
            model.fromMap(value)
            self.image = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeImageFromFamilyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageFromFamilyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeImageFromFamilyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeImagePipelineExecutionsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var executionId: String?

    public var imagePipelineId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public var tag: [DescribeImagePipelineExecutionsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.executionId != nil {
            map["ExecutionId"] = self.executionId!
        }
        if self.imagePipelineId != nil {
            map["ImagePipelineId"] = self.imagePipelineId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ExecutionId"] as? String {
            self.executionId = value
        }
        if let value = dict["ImagePipelineId"] as? String {
            self.imagePipelineId = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeImagePipelineExecutionsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeImagePipelineExecutionsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribeImagePipelineExecutionsResponseBody : Tea.TeaModel {
    public class ImagePipelineExecution : Tea.TeaModel {
        public class ImagePipelineExecutionSet : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["TagKey"] as? String {
                            self.tagKey = value
                        }
                        if let value = dict["TagValue"] as? String {
                            self.tagValue = value
                        }
                    }
                }
                public var tag: [DescribeImagePipelineExecutionsResponseBody.ImagePipelineExecution.ImagePipelineExecutionSet.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeImagePipelineExecutionsResponseBody.ImagePipelineExecution.ImagePipelineExecutionSet.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeImagePipelineExecutionsResponseBody.ImagePipelineExecution.ImagePipelineExecutionSet.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var creationTime: String?

            public var executionId: String?

            public var imageId: String?

            public var imagePipelineId: String?

            public var message: String?

            public var modifiedTime: String?

            public var resourceGroupId: String?

            public var status: String?

            public var tags: DescribeImagePipelineExecutionsResponseBody.ImagePipelineExecution.ImagePipelineExecutionSet.Tags?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.executionId != nil {
                    map["ExecutionId"] = self.executionId!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.imagePipelineId != nil {
                    map["ImagePipelineId"] = self.imagePipelineId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["ExecutionId"] as? String {
                    self.executionId = value
                }
                if let value = dict["ImageId"] as? String {
                    self.imageId = value
                }
                if let value = dict["ImagePipelineId"] as? String {
                    self.imagePipelineId = value
                }
                if let value = dict["Message"] as? String {
                    self.message = value
                }
                if let value = dict["ModifiedTime"] as? String {
                    self.modifiedTime = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeImagePipelineExecutionsResponseBody.ImagePipelineExecution.ImagePipelineExecutionSet.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
            }
        }
        public var imagePipelineExecutionSet: [DescribeImagePipelineExecutionsResponseBody.ImagePipelineExecution.ImagePipelineExecutionSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.imagePipelineExecutionSet != nil {
                var tmp : [Any] = []
                for k in self.imagePipelineExecutionSet! {
                    tmp.append(k.toMap())
                }
                map["ImagePipelineExecutionSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ImagePipelineExecutionSet"] as? [Any?] {
                var tmp : [DescribeImagePipelineExecutionsResponseBody.ImagePipelineExecution.ImagePipelineExecutionSet] = []
                for v in value {
                    if v != nil {
                        var model = DescribeImagePipelineExecutionsResponseBody.ImagePipelineExecution.ImagePipelineExecutionSet()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.imagePipelineExecutionSet = tmp
            }
        }
    }
    public var imagePipelineExecution: DescribeImagePipelineExecutionsResponseBody.ImagePipelineExecution?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.imagePipelineExecution?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imagePipelineExecution != nil {
            map["ImagePipelineExecution"] = self.imagePipelineExecution?.toMap()
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ImagePipelineExecution"] as? [String: Any?] {
            var model = DescribeImagePipelineExecutionsResponseBody.ImagePipelineExecution()
            model.fromMap(value)
            self.imagePipelineExecution = model
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeImagePipelineExecutionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImagePipelineExecutionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeImagePipelineExecutionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeImagePipelinesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var imagePipelineId: [String]?

    public var maxResults: Int32?

    public var name: String?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeImagePipelinesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imagePipelineId != nil {
            map["ImagePipelineId"] = self.imagePipelineId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ImagePipelineId"] as? [String] {
            self.imagePipelineId = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeImagePipelinesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeImagePipelinesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribeImagePipelinesResponseBody : Tea.TeaModel {
    public class ImagePipeline : Tea.TeaModel {
        public class ImagePipelineSet : Tea.TeaModel {
            public class AddAccounts : Tea.TeaModel {
                public var addAccount: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.addAccount != nil {
                        map["AddAccount"] = self.addAccount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AddAccount"] as? [String] {
                        self.addAccount = value
                    }
                }
            }
            public class AdvancedOptions : Tea.TeaModel {
                public var imageNameSuffix: String?

                public var retainCloudAssistant: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.imageNameSuffix != nil {
                        map["ImageNameSuffix"] = self.imageNameSuffix!
                    }
                    if self.retainCloudAssistant != nil {
                        map["RetainCloudAssistant"] = self.retainCloudAssistant!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ImageNameSuffix"] as? String {
                        self.imageNameSuffix = value
                    }
                    if let value = dict["RetainCloudAssistant"] as? Bool {
                        self.retainCloudAssistant = value
                    }
                }
            }
            public class ImageOptions : Tea.TeaModel {
                public class ImageFeatures : Tea.TeaModel {
                    public var nvmeSupport: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.nvmeSupport != nil {
                            map["NvmeSupport"] = self.nvmeSupport!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["NvmeSupport"] as? String {
                            self.nvmeSupport = value
                        }
                    }
                }
                public class ImageTags : Tea.TeaModel {
                    public class ImageTag : Tea.TeaModel {
                        public var tagKey: String?

                        public var tagValue: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.tagKey != nil {
                                map["TagKey"] = self.tagKey!
                            }
                            if self.tagValue != nil {
                                map["TagValue"] = self.tagValue!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["TagKey"] as? String {
                                self.tagKey = value
                            }
                            if let value = dict["TagValue"] as? String {
                                self.tagValue = value
                            }
                        }
                    }
                    public var imageTag: [DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.ImageOptions.ImageTags.ImageTag]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.imageTag != nil {
                            var tmp : [Any] = []
                            for k in self.imageTag! {
                                tmp.append(k.toMap())
                            }
                            map["ImageTag"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ImageTag"] as? [Any?] {
                            var tmp : [DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.ImageOptions.ImageTags.ImageTag] = []
                            for v in value {
                                if v != nil {
                                    var model = DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.ImageOptions.ImageTags.ImageTag()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.imageTag = tmp
                        }
                    }
                }
                public var description_: String?

                public var imageFamily: String?

                public var imageFeatures: DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.ImageOptions.ImageFeatures?

                public var imageName: String?

                public var imageTags: DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.ImageOptions.ImageTags?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.imageFeatures?.validate()
                    try self.imageTags?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.imageFamily != nil {
                        map["ImageFamily"] = self.imageFamily!
                    }
                    if self.imageFeatures != nil {
                        map["ImageFeatures"] = self.imageFeatures?.toMap()
                    }
                    if self.imageName != nil {
                        map["ImageName"] = self.imageName!
                    }
                    if self.imageTags != nil {
                        map["ImageTags"] = self.imageTags?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Description"] as? String {
                        self.description_ = value
                    }
                    if let value = dict["ImageFamily"] as? String {
                        self.imageFamily = value
                    }
                    if let value = dict["ImageFeatures"] as? [String: Any?] {
                        var model = DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.ImageOptions.ImageFeatures()
                        model.fromMap(value)
                        self.imageFeatures = model
                    }
                    if let value = dict["ImageName"] as? String {
                        self.imageName = value
                    }
                    if let value = dict["ImageTags"] as? [String: Any?] {
                        var model = DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.ImageOptions.ImageTags()
                        model.fromMap(value)
                        self.imageTags = model
                    }
                }
            }
            public class ImportImageOptions : Tea.TeaModel {
                public class DiskDeviceMappings : Tea.TeaModel {
                    public class DiskDeviceMapping : Tea.TeaModel {
                        public var diskImageSize: Int32?

                        public var format: String?

                        public var OSSBucket: String?

                        public var OSSObject: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.diskImageSize != nil {
                                map["DiskImageSize"] = self.diskImageSize!
                            }
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            if self.OSSBucket != nil {
                                map["OSSBucket"] = self.OSSBucket!
                            }
                            if self.OSSObject != nil {
                                map["OSSObject"] = self.OSSObject!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["DiskImageSize"] as? Int32 {
                                self.diskImageSize = value
                            }
                            if let value = dict["Format"] as? String {
                                self.format = value
                            }
                            if let value = dict["OSSBucket"] as? String {
                                self.OSSBucket = value
                            }
                            if let value = dict["OSSObject"] as? String {
                                self.OSSObject = value
                            }
                        }
                    }
                    public var diskDeviceMapping: [DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.ImportImageOptions.DiskDeviceMappings.DiskDeviceMapping]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.diskDeviceMapping != nil {
                            var tmp : [Any] = []
                            for k in self.diskDeviceMapping! {
                                tmp.append(k.toMap())
                            }
                            map["DiskDeviceMapping"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["DiskDeviceMapping"] as? [Any?] {
                            var tmp : [DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.ImportImageOptions.DiskDeviceMappings.DiskDeviceMapping] = []
                            for v in value {
                                if v != nil {
                                    var model = DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.ImportImageOptions.DiskDeviceMappings.DiskDeviceMapping()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.diskDeviceMapping = tmp
                        }
                    }
                }
                public class Features : Tea.TeaModel {
                    public var nvmeSupport: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.nvmeSupport != nil {
                            map["NvmeSupport"] = self.nvmeSupport!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["NvmeSupport"] as? String {
                            self.nvmeSupport = value
                        }
                    }
                }
                public var architecture: String?

                public var bootMode: String?

                public var diskDeviceMappings: DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.ImportImageOptions.DiskDeviceMappings?

                public var features: DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.ImportImageOptions.Features?

                public var licenseType: String?

                public var OSType: String?

                public var platform: String?

                public var retainImportedImage: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.diskDeviceMappings?.validate()
                    try self.features?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.architecture != nil {
                        map["Architecture"] = self.architecture!
                    }
                    if self.bootMode != nil {
                        map["BootMode"] = self.bootMode!
                    }
                    if self.diskDeviceMappings != nil {
                        map["DiskDeviceMappings"] = self.diskDeviceMappings?.toMap()
                    }
                    if self.features != nil {
                        map["Features"] = self.features?.toMap()
                    }
                    if self.licenseType != nil {
                        map["LicenseType"] = self.licenseType!
                    }
                    if self.OSType != nil {
                        map["OSType"] = self.OSType!
                    }
                    if self.platform != nil {
                        map["Platform"] = self.platform!
                    }
                    if self.retainImportedImage != nil {
                        map["RetainImportedImage"] = self.retainImportedImage!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Architecture"] as? String {
                        self.architecture = value
                    }
                    if let value = dict["BootMode"] as? String {
                        self.bootMode = value
                    }
                    if let value = dict["DiskDeviceMappings"] as? [String: Any?] {
                        var model = DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.ImportImageOptions.DiskDeviceMappings()
                        model.fromMap(value)
                        self.diskDeviceMappings = model
                    }
                    if let value = dict["Features"] as? [String: Any?] {
                        var model = DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.ImportImageOptions.Features()
                        model.fromMap(value)
                        self.features = model
                    }
                    if let value = dict["LicenseType"] as? String {
                        self.licenseType = value
                    }
                    if let value = dict["OSType"] as? String {
                        self.OSType = value
                    }
                    if let value = dict["Platform"] as? String {
                        self.platform = value
                    }
                    if let value = dict["RetainImportedImage"] as? Bool {
                        self.retainImportedImage = value
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["TagKey"] as? String {
                            self.tagKey = value
                        }
                        if let value = dict["TagValue"] as? String {
                            self.tagValue = value
                        }
                    }
                }
                public var tag: [DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public class ToRegionIds : Tea.TeaModel {
                public var toRegionId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.toRegionId != nil {
                        map["ToRegionId"] = self.toRegionId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ToRegionId"] as? [String] {
                        self.toRegionId = value
                    }
                }
            }
            public var addAccounts: DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.AddAccounts?

            public var advancedOptions: DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.AdvancedOptions?

            public var baseImage: String?

            public var baseImageType: String?

            public var buildContent: String?

            public var creationTime: String?

            public var deleteInstanceOnFailure: Bool?

            public var description_: String?

            public var imageFamily: String?

            public var imageName: String?

            public var imageOptions: DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.ImageOptions?

            public var imagePipelineId: String?

            public var importImageOptions: DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.ImportImageOptions?

            public var instanceType: String?

            public var internetMaxBandwidthOut: Int32?

            public var name: String?

            public var nvmeSupport: String?

            public var repairMode: String?

            public var resourceGroupId: String?

            public var systemDiskSize: Int32?

            public var tags: DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.Tags?

            public var testContent: String?

            public var toRegionIds: DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.ToRegionIds?

            public var vSwitchId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.addAccounts?.validate()
                try self.advancedOptions?.validate()
                try self.imageOptions?.validate()
                try self.importImageOptions?.validate()
                try self.tags?.validate()
                try self.toRegionIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addAccounts != nil {
                    map["AddAccounts"] = self.addAccounts?.toMap()
                }
                if self.advancedOptions != nil {
                    map["AdvancedOptions"] = self.advancedOptions?.toMap()
                }
                if self.baseImage != nil {
                    map["BaseImage"] = self.baseImage!
                }
                if self.baseImageType != nil {
                    map["BaseImageType"] = self.baseImageType!
                }
                if self.buildContent != nil {
                    map["BuildContent"] = self.buildContent!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.deleteInstanceOnFailure != nil {
                    map["DeleteInstanceOnFailure"] = self.deleteInstanceOnFailure!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.imageFamily != nil {
                    map["ImageFamily"] = self.imageFamily!
                }
                if self.imageName != nil {
                    map["ImageName"] = self.imageName!
                }
                if self.imageOptions != nil {
                    map["ImageOptions"] = self.imageOptions?.toMap()
                }
                if self.imagePipelineId != nil {
                    map["ImagePipelineId"] = self.imagePipelineId!
                }
                if self.importImageOptions != nil {
                    map["ImportImageOptions"] = self.importImageOptions?.toMap()
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.internetMaxBandwidthOut != nil {
                    map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.nvmeSupport != nil {
                    map["NvmeSupport"] = self.nvmeSupport!
                }
                if self.repairMode != nil {
                    map["RepairMode"] = self.repairMode!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.systemDiskSize != nil {
                    map["SystemDiskSize"] = self.systemDiskSize!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.testContent != nil {
                    map["TestContent"] = self.testContent!
                }
                if self.toRegionIds != nil {
                    map["ToRegionIds"] = self.toRegionIds?.toMap()
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AddAccounts"] as? [String: Any?] {
                    var model = DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.AddAccounts()
                    model.fromMap(value)
                    self.addAccounts = model
                }
                if let value = dict["AdvancedOptions"] as? [String: Any?] {
                    var model = DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.AdvancedOptions()
                    model.fromMap(value)
                    self.advancedOptions = model
                }
                if let value = dict["BaseImage"] as? String {
                    self.baseImage = value
                }
                if let value = dict["BaseImageType"] as? String {
                    self.baseImageType = value
                }
                if let value = dict["BuildContent"] as? String {
                    self.buildContent = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["DeleteInstanceOnFailure"] as? Bool {
                    self.deleteInstanceOnFailure = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["ImageFamily"] as? String {
                    self.imageFamily = value
                }
                if let value = dict["ImageName"] as? String {
                    self.imageName = value
                }
                if let value = dict["ImageOptions"] as? [String: Any?] {
                    var model = DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.ImageOptions()
                    model.fromMap(value)
                    self.imageOptions = model
                }
                if let value = dict["ImagePipelineId"] as? String {
                    self.imagePipelineId = value
                }
                if let value = dict["ImportImageOptions"] as? [String: Any?] {
                    var model = DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.ImportImageOptions()
                    model.fromMap(value)
                    self.importImageOptions = model
                }
                if let value = dict["InstanceType"] as? String {
                    self.instanceType = value
                }
                if let value = dict["InternetMaxBandwidthOut"] as? Int32 {
                    self.internetMaxBandwidthOut = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["NvmeSupport"] as? String {
                    self.nvmeSupport = value
                }
                if let value = dict["RepairMode"] as? String {
                    self.repairMode = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["SystemDiskSize"] as? Int32 {
                    self.systemDiskSize = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["TestContent"] as? String {
                    self.testContent = value
                }
                if let value = dict["ToRegionIds"] as? [String: Any?] {
                    var model = DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.ToRegionIds()
                    model.fromMap(value)
                    self.toRegionIds = model
                }
                if let value = dict["VSwitchId"] as? String {
                    self.vSwitchId = value
                }
            }
        }
        public var imagePipelineSet: [DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.imagePipelineSet != nil {
                var tmp : [Any] = []
                for k in self.imagePipelineSet! {
                    tmp.append(k.toMap())
                }
                map["ImagePipelineSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ImagePipelineSet"] as? [Any?] {
                var tmp : [DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet] = []
                for v in value {
                    if v != nil {
                        var model = DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.imagePipelineSet = tmp
            }
        }
    }
    public var imagePipeline: DescribeImagePipelinesResponseBody.ImagePipeline?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.imagePipeline?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imagePipeline != nil {
            map["ImagePipeline"] = self.imagePipeline?.toMap()
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ImagePipeline"] as? [String: Any?] {
            var model = DescribeImagePipelinesResponseBody.ImagePipeline()
            model.fromMap(value)
            self.imagePipeline = model
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeImagePipelinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImagePipelinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeImagePipelinesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeImageSharePermissionRequest : Tea.TeaModel {
    public var imageId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeImageSharePermissionResponseBody : Tea.TeaModel {
    public class Accounts : Tea.TeaModel {
        public class Account : Tea.TeaModel {
            public var aliyunId: String?

            public var sharedTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliyunId != nil {
                    map["AliyunId"] = self.aliyunId!
                }
                if self.sharedTime != nil {
                    map["SharedTime"] = self.sharedTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AliyunId"] as? String {
                    self.aliyunId = value
                }
                if let value = dict["SharedTime"] as? String {
                    self.sharedTime = value
                }
            }
        }
        public var account: [DescribeImageSharePermissionResponseBody.Accounts.Account]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.account != nil {
                var tmp : [Any] = []
                for k in self.account! {
                    tmp.append(k.toMap())
                }
                map["Account"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Account"] as? [Any?] {
                var tmp : [DescribeImageSharePermissionResponseBody.Accounts.Account] = []
                for v in value {
                    if v != nil {
                        var model = DescribeImageSharePermissionResponseBody.Accounts.Account()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.account = tmp
            }
        }
    }
    public class ShareGroups : Tea.TeaModel {
        public class ShareGroup : Tea.TeaModel {
            public var group: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.group != nil {
                    map["Group"] = self.group!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Group"] as? String {
                    self.group = value
                }
            }
        }
        public var shareGroup: [DescribeImageSharePermissionResponseBody.ShareGroups.ShareGroup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.shareGroup != nil {
                var tmp : [Any] = []
                for k in self.shareGroup! {
                    tmp.append(k.toMap())
                }
                map["ShareGroup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ShareGroup"] as? [Any?] {
                var tmp : [DescribeImageSharePermissionResponseBody.ShareGroups.ShareGroup] = []
                for v in value {
                    if v != nil {
                        var model = DescribeImageSharePermissionResponseBody.ShareGroups.ShareGroup()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.shareGroup = tmp
            }
        }
    }
    public var accounts: DescribeImageSharePermissionResponseBody.Accounts?

    public var imageId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestId: String?

    public var shareGroups: DescribeImageSharePermissionResponseBody.ShareGroups?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accounts?.validate()
        try self.shareGroups?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accounts != nil {
            map["Accounts"] = self.accounts?.toMap()
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.shareGroups != nil {
            map["ShareGroups"] = self.shareGroups?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Accounts"] as? [String: Any?] {
            var model = DescribeImageSharePermissionResponseBody.Accounts()
            model.fromMap(value)
            self.accounts = model
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ShareGroups"] as? [String: Any?] {
            var model = DescribeImageSharePermissionResponseBody.ShareGroups()
            model.fromMap(value)
            self.shareGroups = model
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeImageSharePermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageSharePermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeImageSharePermissionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeImageSupportInstanceTypesRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var actionType: String?

    public var filter: [DescribeImageSupportInstanceTypesRequest.Filter]?

    public var imageId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionType != nil {
            map["ActionType"] = self.actionType!
        }
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ActionType"] as? String {
            self.actionType = value
        }
        if let value = dict["Filter"] as? [Any?] {
            var tmp : [DescribeImageSupportInstanceTypesRequest.Filter] = []
            for v in value {
                if v != nil {
                    var model = DescribeImageSupportInstanceTypesRequest.Filter()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.filter = tmp
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeImageSupportInstanceTypesResponseBody : Tea.TeaModel {
    public class InstanceTypes : Tea.TeaModel {
        public class InstanceType : Tea.TeaModel {
            public var cpuCoreCount: Int32?

            public var instanceTypeFamily: String?

            public var instanceTypeId: String?

            public var memorySize: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpuCoreCount != nil {
                    map["CpuCoreCount"] = self.cpuCoreCount!
                }
                if self.instanceTypeFamily != nil {
                    map["InstanceTypeFamily"] = self.instanceTypeFamily!
                }
                if self.instanceTypeId != nil {
                    map["InstanceTypeId"] = self.instanceTypeId!
                }
                if self.memorySize != nil {
                    map["MemorySize"] = self.memorySize!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CpuCoreCount"] as? Int32 {
                    self.cpuCoreCount = value
                }
                if let value = dict["InstanceTypeFamily"] as? String {
                    self.instanceTypeFamily = value
                }
                if let value = dict["InstanceTypeId"] as? String {
                    self.instanceTypeId = value
                }
                if let value = dict["MemorySize"] as? Double {
                    self.memorySize = value
                }
            }
        }
        public var instanceType: [DescribeImageSupportInstanceTypesResponseBody.InstanceTypes.InstanceType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                var tmp : [Any] = []
                for k in self.instanceType! {
                    tmp.append(k.toMap())
                }
                map["InstanceType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceType"] as? [Any?] {
                var tmp : [DescribeImageSupportInstanceTypesResponseBody.InstanceTypes.InstanceType] = []
                for v in value {
                    if v != nil {
                        var model = DescribeImageSupportInstanceTypesResponseBody.InstanceTypes.InstanceType()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instanceType = tmp
            }
        }
    }
    public var imageId: String?

    public var instanceTypes: DescribeImageSupportInstanceTypesResponseBody.InstanceTypes?

    public var regionId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceTypes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["InstanceTypes"] as? [String: Any?] {
            var model = DescribeImageSupportInstanceTypesResponseBody.InstanceTypes()
            model.fromMap(value)
            self.instanceTypes = model
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeImageSupportInstanceTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageSupportInstanceTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeImageSupportInstanceTypesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeImagesRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var actionType: String?

    public var architecture: String?

    public var dryRun: Bool?

    public var filter: [DescribeImagesRequest.Filter]?

    public var imageFamily: String?

    public var imageId: String?

    public var imageName: String?

    public var imageOwnerAlias: String?

    public var imageOwnerId: Int64?

    public var instanceType: String?

    public var isPublic: Bool?

    public var isSupportCloudinit: Bool?

    public var isSupportIoOptimized: Bool?

    public var OSType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var showExpired: Bool?

    public var snapshotId: String?

    public var status: String?

    public var tag: [DescribeImagesRequest.Tag]?

    public var usage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionType != nil {
            map["ActionType"] = self.actionType!
        }
        if self.architecture != nil {
            map["Architecture"] = self.architecture!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.imageOwnerAlias != nil {
            map["ImageOwnerAlias"] = self.imageOwnerAlias!
        }
        if self.imageOwnerId != nil {
            map["ImageOwnerId"] = self.imageOwnerId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.isPublic != nil {
            map["IsPublic"] = self.isPublic!
        }
        if self.isSupportCloudinit != nil {
            map["IsSupportCloudinit"] = self.isSupportCloudinit!
        }
        if self.isSupportIoOptimized != nil {
            map["IsSupportIoOptimized"] = self.isSupportIoOptimized!
        }
        if self.OSType != nil {
            map["OSType"] = self.OSType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.showExpired != nil {
            map["ShowExpired"] = self.showExpired!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.usage != nil {
            map["Usage"] = self.usage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ActionType"] as? String {
            self.actionType = value
        }
        if let value = dict["Architecture"] as? String {
            self.architecture = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Filter"] as? [Any?] {
            var tmp : [DescribeImagesRequest.Filter] = []
            for v in value {
                if v != nil {
                    var model = DescribeImagesRequest.Filter()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.filter = tmp
        }
        if let value = dict["ImageFamily"] as? String {
            self.imageFamily = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["ImageName"] as? String {
            self.imageName = value
        }
        if let value = dict["ImageOwnerAlias"] as? String {
            self.imageOwnerAlias = value
        }
        if let value = dict["ImageOwnerId"] as? Int64 {
            self.imageOwnerId = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["IsPublic"] as? Bool {
            self.isPublic = value
        }
        if let value = dict["IsSupportCloudinit"] as? Bool {
            self.isSupportCloudinit = value
        }
        if let value = dict["IsSupportIoOptimized"] as? Bool {
            self.isSupportIoOptimized = value
        }
        if let value = dict["OSType"] as? String {
            self.OSType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ShowExpired"] as? Bool {
            self.showExpired = value
        }
        if let value = dict["SnapshotId"] as? String {
            self.snapshotId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeImagesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeImagesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["Usage"] as? String {
            self.usage = value
        }
    }
}

public class DescribeImagesResponseBody : Tea.TeaModel {
    public class Images : Tea.TeaModel {
        public class Image : Tea.TeaModel {
            public class DetectionOptions : Tea.TeaModel {
                public class Items : Tea.TeaModel {
                    public class Item : Tea.TeaModel {
                        public var name: String?

                        public var riskCode: String?

                        public var riskLevel: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.name != nil {
                                map["Name"] = self.name!
                            }
                            if self.riskCode != nil {
                                map["RiskCode"] = self.riskCode!
                            }
                            if self.riskLevel != nil {
                                map["RiskLevel"] = self.riskLevel!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Name"] as? String {
                                self.name = value
                            }
                            if let value = dict["RiskCode"] as? String {
                                self.riskCode = value
                            }
                            if let value = dict["RiskLevel"] as? String {
                                self.riskLevel = value
                            }
                            if let value = dict["Value"] as? String {
                                self.value = value
                            }
                        }
                    }
                    public var item: [DescribeImagesResponseBody.Images.Image.DetectionOptions.Items.Item]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.item != nil {
                            var tmp : [Any] = []
                            for k in self.item! {
                                tmp.append(k.toMap())
                            }
                            map["Item"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Item"] as? [Any?] {
                            var tmp : [DescribeImagesResponseBody.Images.Image.DetectionOptions.Items.Item] = []
                            for v in value {
                                if v != nil {
                                    var model = DescribeImagesResponseBody.Images.Image.DetectionOptions.Items.Item()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.item = tmp
                        }
                    }
                }
                public var items: DescribeImagesResponseBody.Images.Image.DetectionOptions.Items?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.items?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.items != nil {
                        map["Items"] = self.items?.toMap()
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Items"] as? [String: Any?] {
                        var model = DescribeImagesResponseBody.Images.Image.DetectionOptions.Items()
                        model.fromMap(value)
                        self.items = model
                    }
                    if let value = dict["Status"] as? String {
                        self.status = value
                    }
                }
            }
            public class DiskDeviceMappings : Tea.TeaModel {
                public class DiskDeviceMapping : Tea.TeaModel {
                    public var device: String?

                    public var encrypted: Bool?

                    public var format: String?

                    public var importOSSBucket: String?

                    public var importOSSObject: String?

                    public var progress: String?

                    public var remainTime: Int32?

                    public var size: String?

                    public var snapshotId: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.device != nil {
                            map["Device"] = self.device!
                        }
                        if self.encrypted != nil {
                            map["Encrypted"] = self.encrypted!
                        }
                        if self.format != nil {
                            map["Format"] = self.format!
                        }
                        if self.importOSSBucket != nil {
                            map["ImportOSSBucket"] = self.importOSSBucket!
                        }
                        if self.importOSSObject != nil {
                            map["ImportOSSObject"] = self.importOSSObject!
                        }
                        if self.progress != nil {
                            map["Progress"] = self.progress!
                        }
                        if self.remainTime != nil {
                            map["RemainTime"] = self.remainTime!
                        }
                        if self.size != nil {
                            map["Size"] = self.size!
                        }
                        if self.snapshotId != nil {
                            map["SnapshotId"] = self.snapshotId!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Device"] as? String {
                            self.device = value
                        }
                        if let value = dict["Encrypted"] as? Bool {
                            self.encrypted = value
                        }
                        if let value = dict["Format"] as? String {
                            self.format = value
                        }
                        if let value = dict["ImportOSSBucket"] as? String {
                            self.importOSSBucket = value
                        }
                        if let value = dict["ImportOSSObject"] as? String {
                            self.importOSSObject = value
                        }
                        if let value = dict["Progress"] as? String {
                            self.progress = value
                        }
                        if let value = dict["RemainTime"] as? Int32 {
                            self.remainTime = value
                        }
                        if let value = dict["Size"] as? String {
                            self.size = value
                        }
                        if let value = dict["SnapshotId"] as? String {
                            self.snapshotId = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                    }
                }
                public var diskDeviceMapping: [DescribeImagesResponseBody.Images.Image.DiskDeviceMappings.DiskDeviceMapping]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.diskDeviceMapping != nil {
                        var tmp : [Any] = []
                        for k in self.diskDeviceMapping! {
                            tmp.append(k.toMap())
                        }
                        map["DiskDeviceMapping"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DiskDeviceMapping"] as? [Any?] {
                        var tmp : [DescribeImagesResponseBody.Images.Image.DiskDeviceMappings.DiskDeviceMapping] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeImagesResponseBody.Images.Image.DiskDeviceMappings.DiskDeviceMapping()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.diskDeviceMapping = tmp
                    }
                }
            }
            public class Features : Tea.TeaModel {
                public var cpuOnlineDowngrade: String?

                public var cpuOnlineUpgrade: String?

                public var imdsSupport: String?

                public var memoryOnlineDowngrade: String?

                public var memoryOnlineUpgrade: String?

                public var nvmeSupport: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cpuOnlineDowngrade != nil {
                        map["CpuOnlineDowngrade"] = self.cpuOnlineDowngrade!
                    }
                    if self.cpuOnlineUpgrade != nil {
                        map["CpuOnlineUpgrade"] = self.cpuOnlineUpgrade!
                    }
                    if self.imdsSupport != nil {
                        map["ImdsSupport"] = self.imdsSupport!
                    }
                    if self.memoryOnlineDowngrade != nil {
                        map["MemoryOnlineDowngrade"] = self.memoryOnlineDowngrade!
                    }
                    if self.memoryOnlineUpgrade != nil {
                        map["MemoryOnlineUpgrade"] = self.memoryOnlineUpgrade!
                    }
                    if self.nvmeSupport != nil {
                        map["NvmeSupport"] = self.nvmeSupport!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["CpuOnlineDowngrade"] as? String {
                        self.cpuOnlineDowngrade = value
                    }
                    if let value = dict["CpuOnlineUpgrade"] as? String {
                        self.cpuOnlineUpgrade = value
                    }
                    if let value = dict["ImdsSupport"] as? String {
                        self.imdsSupport = value
                    }
                    if let value = dict["MemoryOnlineDowngrade"] as? String {
                        self.memoryOnlineDowngrade = value
                    }
                    if let value = dict["MemoryOnlineUpgrade"] as? String {
                        self.memoryOnlineUpgrade = value
                    }
                    if let value = dict["NvmeSupport"] as? String {
                        self.nvmeSupport = value
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["TagKey"] as? String {
                            self.tagKey = value
                        }
                        if let value = dict["TagValue"] as? String {
                            self.tagValue = value
                        }
                    }
                }
                public var tag: [DescribeImagesResponseBody.Images.Image.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeImagesResponseBody.Images.Image.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeImagesResponseBody.Images.Image.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var architecture: String?

            public var bootMode: String?

            public var creationTime: String?

            public var description_: String?

            public var detectionOptions: DescribeImagesResponseBody.Images.Image.DetectionOptions?

            public var diskDeviceMappings: DescribeImagesResponseBody.Images.Image.DiskDeviceMappings?

            public var features: DescribeImagesResponseBody.Images.Image.Features?

            public var imageFamily: String?

            public var imageId: String?

            public var imageName: String?

            public var imageOwnerAlias: String?

            public var imageOwnerId: Int64?

            public var imageVersion: String?

            public var isCopied: Bool?

            public var isPublic: Bool?

            public var isSelfShared: String?

            public var isSubscribed: Bool?

            public var isSupportCloudinit: Bool?

            public var isSupportIoOptimized: Bool?

            public var loginAsNonRootSupported: Bool?

            public var OSName: String?

            public var OSNameEn: String?

            public var OSType: String?

            public var platform: String?

            public var productCode: String?

            public var progress: String?

            public var resourceGroupId: String?

            public var size: Int32?

            public var status: String?

            public var supplierName: String?

            public var tags: DescribeImagesResponseBody.Images.Image.Tags?

            public var usage: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.detectionOptions?.validate()
                try self.diskDeviceMappings?.validate()
                try self.features?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.architecture != nil {
                    map["Architecture"] = self.architecture!
                }
                if self.bootMode != nil {
                    map["BootMode"] = self.bootMode!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.detectionOptions != nil {
                    map["DetectionOptions"] = self.detectionOptions?.toMap()
                }
                if self.diskDeviceMappings != nil {
                    map["DiskDeviceMappings"] = self.diskDeviceMappings?.toMap()
                }
                if self.features != nil {
                    map["Features"] = self.features?.toMap()
                }
                if self.imageFamily != nil {
                    map["ImageFamily"] = self.imageFamily!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.imageName != nil {
                    map["ImageName"] = self.imageName!
                }
                if self.imageOwnerAlias != nil {
                    map["ImageOwnerAlias"] = self.imageOwnerAlias!
                }
                if self.imageOwnerId != nil {
                    map["ImageOwnerId"] = self.imageOwnerId!
                }
                if self.imageVersion != nil {
                    map["ImageVersion"] = self.imageVersion!
                }
                if self.isCopied != nil {
                    map["IsCopied"] = self.isCopied!
                }
                if self.isPublic != nil {
                    map["IsPublic"] = self.isPublic!
                }
                if self.isSelfShared != nil {
                    map["IsSelfShared"] = self.isSelfShared!
                }
                if self.isSubscribed != nil {
                    map["IsSubscribed"] = self.isSubscribed!
                }
                if self.isSupportCloudinit != nil {
                    map["IsSupportCloudinit"] = self.isSupportCloudinit!
                }
                if self.isSupportIoOptimized != nil {
                    map["IsSupportIoOptimized"] = self.isSupportIoOptimized!
                }
                if self.loginAsNonRootSupported != nil {
                    map["LoginAsNonRootSupported"] = self.loginAsNonRootSupported!
                }
                if self.OSName != nil {
                    map["OSName"] = self.OSName!
                }
                if self.OSNameEn != nil {
                    map["OSNameEn"] = self.OSNameEn!
                }
                if self.OSType != nil {
                    map["OSType"] = self.OSType!
                }
                if self.platform != nil {
                    map["Platform"] = self.platform!
                }
                if self.productCode != nil {
                    map["ProductCode"] = self.productCode!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.supplierName != nil {
                    map["SupplierName"] = self.supplierName!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.usage != nil {
                    map["Usage"] = self.usage!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Architecture"] as? String {
                    self.architecture = value
                }
                if let value = dict["BootMode"] as? String {
                    self.bootMode = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["DetectionOptions"] as? [String: Any?] {
                    var model = DescribeImagesResponseBody.Images.Image.DetectionOptions()
                    model.fromMap(value)
                    self.detectionOptions = model
                }
                if let value = dict["DiskDeviceMappings"] as? [String: Any?] {
                    var model = DescribeImagesResponseBody.Images.Image.DiskDeviceMappings()
                    model.fromMap(value)
                    self.diskDeviceMappings = model
                }
                if let value = dict["Features"] as? [String: Any?] {
                    var model = DescribeImagesResponseBody.Images.Image.Features()
                    model.fromMap(value)
                    self.features = model
                }
                if let value = dict["ImageFamily"] as? String {
                    self.imageFamily = value
                }
                if let value = dict["ImageId"] as? String {
                    self.imageId = value
                }
                if let value = dict["ImageName"] as? String {
                    self.imageName = value
                }
                if let value = dict["ImageOwnerAlias"] as? String {
                    self.imageOwnerAlias = value
                }
                if let value = dict["ImageOwnerId"] as? Int64 {
                    self.imageOwnerId = value
                }
                if let value = dict["ImageVersion"] as? String {
                    self.imageVersion = value
                }
                if let value = dict["IsCopied"] as? Bool {
                    self.isCopied = value
                }
                if let value = dict["IsPublic"] as? Bool {
                    self.isPublic = value
                }
                if let value = dict["IsSelfShared"] as? String {
                    self.isSelfShared = value
                }
                if let value = dict["IsSubscribed"] as? Bool {
                    self.isSubscribed = value
                }
                if let value = dict["IsSupportCloudinit"] as? Bool {
                    self.isSupportCloudinit = value
                }
                if let value = dict["IsSupportIoOptimized"] as? Bool {
                    self.isSupportIoOptimized = value
                }
                if let value = dict["LoginAsNonRootSupported"] as? Bool {
                    self.loginAsNonRootSupported = value
                }
                if let value = dict["OSName"] as? String {
                    self.OSName = value
                }
                if let value = dict["OSNameEn"] as? String {
                    self.OSNameEn = value
                }
                if let value = dict["OSType"] as? String {
                    self.OSType = value
                }
                if let value = dict["Platform"] as? String {
                    self.platform = value
                }
                if let value = dict["ProductCode"] as? String {
                    self.productCode = value
                }
                if let value = dict["Progress"] as? String {
                    self.progress = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["Size"] as? Int32 {
                    self.size = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["SupplierName"] as? String {
                    self.supplierName = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeImagesResponseBody.Images.Image.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["Usage"] as? String {
                    self.usage = value
                }
            }
        }
        public var image: [DescribeImagesResponseBody.Images.Image]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.image != nil {
                var tmp : [Any] = []
                for k in self.image! {
                    tmp.append(k.toMap())
                }
                map["Image"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Image"] as? [Any?] {
                var tmp : [DescribeImagesResponseBody.Images.Image] = []
                for v in value {
                    if v != nil {
                        var model = DescribeImagesResponseBody.Images.Image()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.image = tmp
            }
        }
    }
    public var images: DescribeImagesResponseBody.Images?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.images?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.images != nil {
            map["Images"] = self.images?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Images"] as? [String: Any?] {
            var model = DescribeImagesResponseBody.Images()
            model.fromMap(value)
            self.images = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeImagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeImagesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInstanceAttachmentAttributesRequest : Tea.TeaModel {
    public var instanceIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeInstanceAttachmentAttributesResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public class Instance : Tea.TeaModel {
            public var instanceId: String?

            public var privatePoolOptionsId: String?

            public var privatePoolOptionsMatchCriteria: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.privatePoolOptionsId != nil {
                    map["PrivatePoolOptionsId"] = self.privatePoolOptionsId!
                }
                if self.privatePoolOptionsMatchCriteria != nil {
                    map["PrivatePoolOptionsMatchCriteria"] = self.privatePoolOptionsMatchCriteria!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["PrivatePoolOptionsId"] as? String {
                    self.privatePoolOptionsId = value
                }
                if let value = dict["PrivatePoolOptionsMatchCriteria"] as? String {
                    self.privatePoolOptionsMatchCriteria = value
                }
            }
        }
        public var instance: [DescribeInstanceAttachmentAttributesResponseBody.Instances.Instance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instance != nil {
                var tmp : [Any] = []
                for k in self.instance! {
                    tmp.append(k.toMap())
                }
                map["Instance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Instance"] as? [Any?] {
                var tmp : [DescribeInstanceAttachmentAttributesResponseBody.Instances.Instance] = []
                for v in value {
                    if v != nil {
                        var model = DescribeInstanceAttachmentAttributesResponseBody.Instances.Instance()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instance = tmp
            }
        }
    }
    public var instances: DescribeInstanceAttachmentAttributesResponseBody.Instances?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            map["Instances"] = self.instances?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Instances"] as? [String: Any?] {
            var model = DescribeInstanceAttachmentAttributesResponseBody.Instances()
            model.fromMap(value)
            self.instances = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeInstanceAttachmentAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceAttachmentAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInstanceAttachmentAttributesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInstanceAttributeRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeInstanceAttributeResponseBody : Tea.TeaModel {
    public class DedicatedHostAttribute : Tea.TeaModel {
        public var dedicatedHostId: String?

        public var dedicatedHostName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dedicatedHostId != nil {
                map["DedicatedHostId"] = self.dedicatedHostId!
            }
            if self.dedicatedHostName != nil {
                map["DedicatedHostName"] = self.dedicatedHostName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DedicatedHostId"] as? String {
                self.dedicatedHostId = value
            }
            if let value = dict["DedicatedHostName"] as? String {
                self.dedicatedHostName = value
            }
        }
    }
    public class EipAddress : Tea.TeaModel {
        public var allocationId: String?

        public var bandwidth: Int32?

        public var internetChargeType: String?

        public var ipAddress: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allocationId != nil {
                map["AllocationId"] = self.allocationId!
            }
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth!
            }
            if self.internetChargeType != nil {
                map["InternetChargeType"] = self.internetChargeType!
            }
            if self.ipAddress != nil {
                map["IpAddress"] = self.ipAddress!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AllocationId"] as? String {
                self.allocationId = value
            }
            if let value = dict["Bandwidth"] as? Int32 {
                self.bandwidth = value
            }
            if let value = dict["InternetChargeType"] as? String {
                self.internetChargeType = value
            }
            if let value = dict["IpAddress"] as? String {
                self.ipAddress = value
            }
        }
    }
    public class InnerIpAddress : Tea.TeaModel {
        public var ipAddress: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipAddress != nil {
                map["IpAddress"] = self.ipAddress!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IpAddress"] as? [String] {
                self.ipAddress = value
            }
        }
    }
    public class OperationLocks : Tea.TeaModel {
        public class LockReason : Tea.TeaModel {
            public var lockReason: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.lockReason != nil {
                    map["LockReason"] = self.lockReason!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LockReason"] as? String {
                    self.lockReason = value
                }
            }
        }
        public var lockReason: [DescribeInstanceAttributeResponseBody.OperationLocks.LockReason]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lockReason != nil {
                var tmp : [Any] = []
                for k in self.lockReason! {
                    tmp.append(k.toMap())
                }
                map["LockReason"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LockReason"] as? [Any?] {
                var tmp : [DescribeInstanceAttributeResponseBody.OperationLocks.LockReason] = []
                for v in value {
                    if v != nil {
                        var model = DescribeInstanceAttributeResponseBody.OperationLocks.LockReason()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.lockReason = tmp
            }
        }
    }
    public class PublicIpAddress : Tea.TeaModel {
        public var ipAddress: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipAddress != nil {
                map["IpAddress"] = self.ipAddress!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IpAddress"] as? [String] {
                self.ipAddress = value
            }
        }
    }
    public class SecurityGroupIds : Tea.TeaModel {
        public var securityGroupId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SecurityGroupId"] as? [String] {
                self.securityGroupId = value
            }
        }
    }
    public class VpcAttributes : Tea.TeaModel {
        public class PrivateIpAddress : Tea.TeaModel {
            public var ipAddress: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipAddress != nil {
                    map["IpAddress"] = self.ipAddress!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IpAddress"] as? [String] {
                    self.ipAddress = value
                }
            }
        }
        public var natIpAddress: String?

        public var privateIpAddress: DescribeInstanceAttributeResponseBody.VpcAttributes.PrivateIpAddress?

        public var vSwitchId: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.privateIpAddress?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.natIpAddress != nil {
                map["NatIpAddress"] = self.natIpAddress!
            }
            if self.privateIpAddress != nil {
                map["PrivateIpAddress"] = self.privateIpAddress?.toMap()
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["NatIpAddress"] as? String {
                self.natIpAddress = value
            }
            if let value = dict["PrivateIpAddress"] as? [String: Any?] {
                var model = DescribeInstanceAttributeResponseBody.VpcAttributes.PrivateIpAddress()
                model.fromMap(value)
                self.privateIpAddress = model
            }
            if let value = dict["VSwitchId"] as? String {
                self.vSwitchId = value
            }
            if let value = dict["VpcId"] as? String {
                self.vpcId = value
            }
        }
    }
    public var clusterId: String?

    public var cpu: Int32?

    public var creationTime: String?

    public var creditSpecification: String?

    public var dedicatedHostAttribute: DescribeInstanceAttributeResponseBody.DedicatedHostAttribute?

    public var description_: String?

    public var eipAddress: DescribeInstanceAttributeResponseBody.EipAddress?

    public var enableJumboFrame: Bool?

    public var enableNetworkEncryption: Bool?

    public var expiredTime: String?

    public var hostName: String?

    public var imageId: String?

    public var innerIpAddress: DescribeInstanceAttributeResponseBody.InnerIpAddress?

    public var instanceChargeType: String?

    public var instanceId: String?

    public var instanceName: String?

    public var instanceNetworkType: String?

    public var instanceType: String?

    public var internetChargeType: String?

    public var internetMaxBandwidthIn: Int32?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var memory: Int32?

    public var operationLocks: DescribeInstanceAttributeResponseBody.OperationLocks?

    public var publicIpAddress: DescribeInstanceAttributeResponseBody.PublicIpAddress?

    public var regionId: String?

    public var requestId: String?

    public var securityGroupIds: DescribeInstanceAttributeResponseBody.SecurityGroupIds?

    public var serialNumber: String?

    public var status: String?

    public var stoppedMode: String?

    public var vlanId: String?

    public var vpcAttributes: DescribeInstanceAttributeResponseBody.VpcAttributes?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dedicatedHostAttribute?.validate()
        try self.eipAddress?.validate()
        try self.innerIpAddress?.validate()
        try self.operationLocks?.validate()
        try self.publicIpAddress?.validate()
        try self.securityGroupIds?.validate()
        try self.vpcAttributes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.creditSpecification != nil {
            map["CreditSpecification"] = self.creditSpecification!
        }
        if self.dedicatedHostAttribute != nil {
            map["DedicatedHostAttribute"] = self.dedicatedHostAttribute?.toMap()
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eipAddress != nil {
            map["EipAddress"] = self.eipAddress?.toMap()
        }
        if self.enableJumboFrame != nil {
            map["EnableJumboFrame"] = self.enableJumboFrame!
        }
        if self.enableNetworkEncryption != nil {
            map["EnableNetworkEncryption"] = self.enableNetworkEncryption!
        }
        if self.expiredTime != nil {
            map["ExpiredTime"] = self.expiredTime!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.innerIpAddress != nil {
            map["InnerIpAddress"] = self.innerIpAddress?.toMap()
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceNetworkType != nil {
            map["InstanceNetworkType"] = self.instanceNetworkType!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthIn != nil {
            map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.operationLocks != nil {
            map["OperationLocks"] = self.operationLocks?.toMap()
        }
        if self.publicIpAddress != nil {
            map["PublicIpAddress"] = self.publicIpAddress?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds?.toMap()
        }
        if self.serialNumber != nil {
            map["SerialNumber"] = self.serialNumber!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.stoppedMode != nil {
            map["StoppedMode"] = self.stoppedMode!
        }
        if self.vlanId != nil {
            map["VlanId"] = self.vlanId!
        }
        if self.vpcAttributes != nil {
            map["VpcAttributes"] = self.vpcAttributes?.toMap()
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["Cpu"] as? Int32 {
            self.cpu = value
        }
        if let value = dict["CreationTime"] as? String {
            self.creationTime = value
        }
        if let value = dict["CreditSpecification"] as? String {
            self.creditSpecification = value
        }
        if let value = dict["DedicatedHostAttribute"] as? [String: Any?] {
            var model = DescribeInstanceAttributeResponseBody.DedicatedHostAttribute()
            model.fromMap(value)
            self.dedicatedHostAttribute = model
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EipAddress"] as? [String: Any?] {
            var model = DescribeInstanceAttributeResponseBody.EipAddress()
            model.fromMap(value)
            self.eipAddress = model
        }
        if let value = dict["EnableJumboFrame"] as? Bool {
            self.enableJumboFrame = value
        }
        if let value = dict["EnableNetworkEncryption"] as? Bool {
            self.enableNetworkEncryption = value
        }
        if let value = dict["ExpiredTime"] as? String {
            self.expiredTime = value
        }
        if let value = dict["HostName"] as? String {
            self.hostName = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["InnerIpAddress"] as? [String: Any?] {
            var model = DescribeInstanceAttributeResponseBody.InnerIpAddress()
            model.fromMap(value)
            self.innerIpAddress = model
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["InstanceNetworkType"] as? String {
            self.instanceNetworkType = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["InternetChargeType"] as? String {
            self.internetChargeType = value
        }
        if let value = dict["InternetMaxBandwidthIn"] as? Int32 {
            self.internetMaxBandwidthIn = value
        }
        if let value = dict["InternetMaxBandwidthOut"] as? Int32 {
            self.internetMaxBandwidthOut = value
        }
        if let value = dict["IoOptimized"] as? String {
            self.ioOptimized = value
        }
        if let value = dict["Memory"] as? Int32 {
            self.memory = value
        }
        if let value = dict["OperationLocks"] as? [String: Any?] {
            var model = DescribeInstanceAttributeResponseBody.OperationLocks()
            model.fromMap(value)
            self.operationLocks = model
        }
        if let value = dict["PublicIpAddress"] as? [String: Any?] {
            var model = DescribeInstanceAttributeResponseBody.PublicIpAddress()
            model.fromMap(value)
            self.publicIpAddress = model
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SecurityGroupIds"] as? [String: Any?] {
            var model = DescribeInstanceAttributeResponseBody.SecurityGroupIds()
            model.fromMap(value)
            self.securityGroupIds = model
        }
        if let value = dict["SerialNumber"] as? String {
            self.serialNumber = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["StoppedMode"] as? String {
            self.stoppedMode = value
        }
        if let value = dict["VlanId"] as? String {
            self.vlanId = value
        }
        if let value = dict["VpcAttributes"] as? [String: Any?] {
            var model = DescribeInstanceAttributeResponseBody.VpcAttributes()
            model.fromMap(value)
            self.vpcAttributes = model
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribeInstanceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInstanceAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInstanceAutoRenewAttributeRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: String?

    public var pageSize: String?

    public var regionId: String?

    public var renewalStatus: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.renewalStatus != nil {
            map["RenewalStatus"] = self.renewalStatus!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? String {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RenewalStatus"] as? String {
            self.renewalStatus = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeInstanceAutoRenewAttributeResponseBody : Tea.TeaModel {
    public class InstanceRenewAttributes : Tea.TeaModel {
        public class InstanceRenewAttribute : Tea.TeaModel {
            public var autoRenewEnabled: Bool?

            public var duration: Int32?

            public var instanceId: String?

            public var periodUnit: String?

            public var renewalStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoRenewEnabled != nil {
                    map["AutoRenewEnabled"] = self.autoRenewEnabled!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.periodUnit != nil {
                    map["PeriodUnit"] = self.periodUnit!
                }
                if self.renewalStatus != nil {
                    map["RenewalStatus"] = self.renewalStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AutoRenewEnabled"] as? Bool {
                    self.autoRenewEnabled = value
                }
                if let value = dict["Duration"] as? Int32 {
                    self.duration = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["PeriodUnit"] as? String {
                    self.periodUnit = value
                }
                if let value = dict["RenewalStatus"] as? String {
                    self.renewalStatus = value
                }
            }
        }
        public var instanceRenewAttribute: [DescribeInstanceAutoRenewAttributeResponseBody.InstanceRenewAttributes.InstanceRenewAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceRenewAttribute != nil {
                var tmp : [Any] = []
                for k in self.instanceRenewAttribute! {
                    tmp.append(k.toMap())
                }
                map["InstanceRenewAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceRenewAttribute"] as? [Any?] {
                var tmp : [DescribeInstanceAutoRenewAttributeResponseBody.InstanceRenewAttributes.InstanceRenewAttribute] = []
                for v in value {
                    if v != nil {
                        var model = DescribeInstanceAutoRenewAttributeResponseBody.InstanceRenewAttributes.InstanceRenewAttribute()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instanceRenewAttribute = tmp
            }
        }
    }
    public var instanceRenewAttributes: DescribeInstanceAutoRenewAttributeResponseBody.InstanceRenewAttributes?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceRenewAttributes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceRenewAttributes != nil {
            map["InstanceRenewAttributes"] = self.instanceRenewAttributes?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceRenewAttributes"] as? [String: Any?] {
            var model = DescribeInstanceAutoRenewAttributeResponseBody.InstanceRenewAttributes()
            model.fromMap(value)
            self.instanceRenewAttributes = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeInstanceAutoRenewAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceAutoRenewAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInstanceAutoRenewAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInstanceHistoryEventsRequest : Tea.TeaModel {
    public class EventPublishTime : Tea.TeaModel {
        public var end: String?

        public var start: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.end != nil {
                map["End"] = self.end!
            }
            if self.start != nil {
                map["Start"] = self.start!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["End"] as? String {
                self.end = value
            }
            if let value = dict["Start"] as? String {
                self.start = value
            }
        }
    }
    public class NotBefore : Tea.TeaModel {
        public var end: String?

        public var start: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.end != nil {
                map["End"] = self.end!
            }
            if self.start != nil {
                map["Start"] = self.start!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["End"] as? String {
                self.end = value
            }
            if let value = dict["Start"] as? String {
                self.start = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var eventPublishTime: DescribeInstanceHistoryEventsRequest.EventPublishTime?

    public var notBefore: DescribeInstanceHistoryEventsRequest.NotBefore?

    public var eventCycleStatus: String?

    public var eventId: [String]?

    public var eventType: String?

    public var impactLevel: String?

    public var instanceEventCycleStatus: [String]?

    public var instanceEventType: [String]?

    public var instanceId: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tag: [DescribeInstanceHistoryEventsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eventPublishTime?.validate()
        try self.notBefore?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventPublishTime != nil {
            map["EventPublishTime"] = self.eventPublishTime?.toMap()
        }
        if self.notBefore != nil {
            map["NotBefore"] = self.notBefore?.toMap()
        }
        if self.eventCycleStatus != nil {
            map["EventCycleStatus"] = self.eventCycleStatus!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.eventType != nil {
            map["EventType"] = self.eventType!
        }
        if self.impactLevel != nil {
            map["ImpactLevel"] = self.impactLevel!
        }
        if self.instanceEventCycleStatus != nil {
            map["InstanceEventCycleStatus"] = self.instanceEventCycleStatus!
        }
        if self.instanceEventType != nil {
            map["InstanceEventType"] = self.instanceEventType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EventPublishTime"] as? [String: Any?] {
            var model = DescribeInstanceHistoryEventsRequest.EventPublishTime()
            model.fromMap(value)
            self.eventPublishTime = model
        }
        if let value = dict["NotBefore"] as? [String: Any?] {
            var model = DescribeInstanceHistoryEventsRequest.NotBefore()
            model.fromMap(value)
            self.notBefore = model
        }
        if let value = dict["EventCycleStatus"] as? String {
            self.eventCycleStatus = value
        }
        if let value = dict["EventId"] as? [String] {
            self.eventId = value
        }
        if let value = dict["EventType"] as? String {
            self.eventType = value
        }
        if let value = dict["ImpactLevel"] as? String {
            self.impactLevel = value
        }
        if let value = dict["InstanceEventCycleStatus"] as? [String] {
            self.instanceEventCycleStatus = value
        }
        if let value = dict["InstanceEventType"] as? [String] {
            self.instanceEventType = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["MaxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeInstanceHistoryEventsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeInstanceHistoryEventsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribeInstanceHistoryEventsResponseBody : Tea.TeaModel {
    public class InstanceSystemEventSet : Tea.TeaModel {
        public class InstanceSystemEventType : Tea.TeaModel {
            public class EventCycleStatus : Tea.TeaModel {
                public var code: Int32?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Code"] as? Int32 {
                        self.code = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                }
            }
            public class EventType : Tea.TeaModel {
                public var code: Int32?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Code"] as? Int32 {
                        self.code = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                }
            }
            public class ExtendedAttribute : Tea.TeaModel {
                public class InactiveDisks : Tea.TeaModel {
                    public class InactiveDisk : Tea.TeaModel {
                        public var creationTime: String?

                        public var deviceCategory: String?

                        public var deviceSize: String?

                        public var deviceType: String?

                        public var releaseTime: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.creationTime != nil {
                                map["CreationTime"] = self.creationTime!
                            }
                            if self.deviceCategory != nil {
                                map["DeviceCategory"] = self.deviceCategory!
                            }
                            if self.deviceSize != nil {
                                map["DeviceSize"] = self.deviceSize!
                            }
                            if self.deviceType != nil {
                                map["DeviceType"] = self.deviceType!
                            }
                            if self.releaseTime != nil {
                                map["ReleaseTime"] = self.releaseTime!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["CreationTime"] as? String {
                                self.creationTime = value
                            }
                            if let value = dict["DeviceCategory"] as? String {
                                self.deviceCategory = value
                            }
                            if let value = dict["DeviceSize"] as? String {
                                self.deviceSize = value
                            }
                            if let value = dict["DeviceType"] as? String {
                                self.deviceType = value
                            }
                            if let value = dict["ReleaseTime"] as? String {
                                self.releaseTime = value
                            }
                        }
                    }
                    public var inactiveDisk: [DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType.ExtendedAttribute.InactiveDisks.InactiveDisk]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.inactiveDisk != nil {
                            var tmp : [Any] = []
                            for k in self.inactiveDisk! {
                                tmp.append(k.toMap())
                            }
                            map["InactiveDisk"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["InactiveDisk"] as? [Any?] {
                            var tmp : [DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType.ExtendedAttribute.InactiveDisks.InactiveDisk] = []
                            for v in value {
                                if v != nil {
                                    var model = DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType.ExtendedAttribute.InactiveDisks.InactiveDisk()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.inactiveDisk = tmp
                        }
                    }
                }
                public class MigrationOptions : Tea.TeaModel {
                    public var migrationOption: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.migrationOption != nil {
                            map["MigrationOption"] = self.migrationOption!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["MigrationOption"] as? [String] {
                            self.migrationOption = value
                        }
                    }
                }
                public var canAccept: String?

                public var code: String?

                public var device: String?

                public var diskId: String?

                public var hostId: String?

                public var hostType: String?

                public var inactiveDisks: DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType.ExtendedAttribute.InactiveDisks?

                public var migrationOptions: DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType.ExtendedAttribute.MigrationOptions?

                public var onlineRepairPolicy: String?

                public var punishDomain: String?

                public var punishType: String?

                public var punishUrl: String?

                public var rack: String?

                public var responseResult: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.inactiveDisks?.validate()
                    try self.migrationOptions?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.canAccept != nil {
                        map["CanAccept"] = self.canAccept!
                    }
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.device != nil {
                        map["Device"] = self.device!
                    }
                    if self.diskId != nil {
                        map["DiskId"] = self.diskId!
                    }
                    if self.hostId != nil {
                        map["HostId"] = self.hostId!
                    }
                    if self.hostType != nil {
                        map["HostType"] = self.hostType!
                    }
                    if self.inactiveDisks != nil {
                        map["InactiveDisks"] = self.inactiveDisks?.toMap()
                    }
                    if self.migrationOptions != nil {
                        map["MigrationOptions"] = self.migrationOptions?.toMap()
                    }
                    if self.onlineRepairPolicy != nil {
                        map["OnlineRepairPolicy"] = self.onlineRepairPolicy!
                    }
                    if self.punishDomain != nil {
                        map["PunishDomain"] = self.punishDomain!
                    }
                    if self.punishType != nil {
                        map["PunishType"] = self.punishType!
                    }
                    if self.punishUrl != nil {
                        map["PunishUrl"] = self.punishUrl!
                    }
                    if self.rack != nil {
                        map["Rack"] = self.rack!
                    }
                    if self.responseResult != nil {
                        map["ResponseResult"] = self.responseResult!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["CanAccept"] as? String {
                        self.canAccept = value
                    }
                    if let value = dict["Code"] as? String {
                        self.code = value
                    }
                    if let value = dict["Device"] as? String {
                        self.device = value
                    }
                    if let value = dict["DiskId"] as? String {
                        self.diskId = value
                    }
                    if let value = dict["HostId"] as? String {
                        self.hostId = value
                    }
                    if let value = dict["HostType"] as? String {
                        self.hostType = value
                    }
                    if let value = dict["InactiveDisks"] as? [String: Any?] {
                        var model = DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType.ExtendedAttribute.InactiveDisks()
                        model.fromMap(value)
                        self.inactiveDisks = model
                    }
                    if let value = dict["MigrationOptions"] as? [String: Any?] {
                        var model = DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType.ExtendedAttribute.MigrationOptions()
                        model.fromMap(value)
                        self.migrationOptions = model
                    }
                    if let value = dict["OnlineRepairPolicy"] as? String {
                        self.onlineRepairPolicy = value
                    }
                    if let value = dict["PunishDomain"] as? String {
                        self.punishDomain = value
                    }
                    if let value = dict["PunishType"] as? String {
                        self.punishType = value
                    }
                    if let value = dict["PunishUrl"] as? String {
                        self.punishUrl = value
                    }
                    if let value = dict["Rack"] as? String {
                        self.rack = value
                    }
                    if let value = dict["ResponseResult"] as? String {
                        self.responseResult = value
                    }
                }
            }
            public var eventCycleStatus: DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType.EventCycleStatus?

            public var eventFinishTime: String?

            public var eventId: String?

            public var eventPublishTime: String?

            public var eventType: DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType.EventType?

            public var extendedAttribute: DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType.ExtendedAttribute?

            public var impactLevel: String?

            public var instanceId: String?

            public var notBefore: String?

            public var reason: String?

            public var reasonCode: String?

            public var resourceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.eventCycleStatus?.validate()
                try self.eventType?.validate()
                try self.extendedAttribute?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eventCycleStatus != nil {
                    map["EventCycleStatus"] = self.eventCycleStatus?.toMap()
                }
                if self.eventFinishTime != nil {
                    map["EventFinishTime"] = self.eventFinishTime!
                }
                if self.eventId != nil {
                    map["EventId"] = self.eventId!
                }
                if self.eventPublishTime != nil {
                    map["EventPublishTime"] = self.eventPublishTime!
                }
                if self.eventType != nil {
                    map["EventType"] = self.eventType?.toMap()
                }
                if self.extendedAttribute != nil {
                    map["ExtendedAttribute"] = self.extendedAttribute?.toMap()
                }
                if self.impactLevel != nil {
                    map["ImpactLevel"] = self.impactLevel!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.notBefore != nil {
                    map["NotBefore"] = self.notBefore!
                }
                if self.reason != nil {
                    map["Reason"] = self.reason!
                }
                if self.reasonCode != nil {
                    map["ReasonCode"] = self.reasonCode!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["EventCycleStatus"] as? [String: Any?] {
                    var model = DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType.EventCycleStatus()
                    model.fromMap(value)
                    self.eventCycleStatus = model
                }
                if let value = dict["EventFinishTime"] as? String {
                    self.eventFinishTime = value
                }
                if let value = dict["EventId"] as? String {
                    self.eventId = value
                }
                if let value = dict["EventPublishTime"] as? String {
                    self.eventPublishTime = value
                }
                if let value = dict["EventType"] as? [String: Any?] {
                    var model = DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType.EventType()
                    model.fromMap(value)
                    self.eventType = model
                }
                if let value = dict["ExtendedAttribute"] as? [String: Any?] {
                    var model = DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType.ExtendedAttribute()
                    model.fromMap(value)
                    self.extendedAttribute = model
                }
                if let value = dict["ImpactLevel"] as? String {
                    self.impactLevel = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["NotBefore"] as? String {
                    self.notBefore = value
                }
                if let value = dict["Reason"] as? String {
                    self.reason = value
                }
                if let value = dict["ReasonCode"] as? String {
                    self.reasonCode = value
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
            }
        }
        public var instanceSystemEventType: [DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceSystemEventType != nil {
                var tmp : [Any] = []
                for k in self.instanceSystemEventType! {
                    tmp.append(k.toMap())
                }
                map["InstanceSystemEventType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceSystemEventType"] as? [Any?] {
                var tmp : [DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType] = []
                for v in value {
                    if v != nil {
                        var model = DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instanceSystemEventType = tmp
            }
        }
    }
    public var instanceSystemEventSet: DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet?

    public var nextToken: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceSystemEventSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceSystemEventSet != nil {
            map["InstanceSystemEventSet"] = self.instanceSystemEventSet?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceSystemEventSet"] as? [String: Any?] {
            var model = DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet()
            model.fromMap(value)
            self.instanceSystemEventSet = model
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeInstanceHistoryEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceHistoryEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInstanceHistoryEventsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInstanceMaintenanceAttributesRequest : Tea.TeaModel {
    public var instanceId: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? [String] {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeInstanceMaintenanceAttributesResponseBody : Tea.TeaModel {
    public class MaintenanceAttributes : Tea.TeaModel {
        public class MaintenanceAttribute : Tea.TeaModel {
            public class ActionOnMaintenance : Tea.TeaModel {
                public class SupportedValues : Tea.TeaModel {
                    public var supportedValue: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.supportedValue != nil {
                            map["SupportedValue"] = self.supportedValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["SupportedValue"] as? [String] {
                            self.supportedValue = value
                        }
                    }
                }
                public var defaultValue: String?

                public var supportedValues: DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute.ActionOnMaintenance.SupportedValues?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.supportedValues?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.defaultValue != nil {
                        map["DefaultValue"] = self.defaultValue!
                    }
                    if self.supportedValues != nil {
                        map["SupportedValues"] = self.supportedValues?.toMap()
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DefaultValue"] as? String {
                        self.defaultValue = value
                    }
                    if let value = dict["SupportedValues"] as? [String: Any?] {
                        var model = DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute.ActionOnMaintenance.SupportedValues()
                        model.fromMap(value)
                        self.supportedValues = model
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public class MaintenanceWindows : Tea.TeaModel {
                public class MaintenanceWindow : Tea.TeaModel {
                    public var endTime: String?

                    public var startTime: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.endTime != nil {
                            map["EndTime"] = self.endTime!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["EndTime"] as? String {
                            self.endTime = value
                        }
                        if let value = dict["StartTime"] as? String {
                            self.startTime = value
                        }
                    }
                }
                public var maintenanceWindow: [DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute.MaintenanceWindows.MaintenanceWindow]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maintenanceWindow != nil {
                        var tmp : [Any] = []
                        for k in self.maintenanceWindow! {
                            tmp.append(k.toMap())
                        }
                        map["MaintenanceWindow"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MaintenanceWindow"] as? [Any?] {
                        var tmp : [DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute.MaintenanceWindows.MaintenanceWindow] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute.MaintenanceWindows.MaintenanceWindow()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.maintenanceWindow = tmp
                    }
                }
            }
            public var actionOnMaintenance: DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute.ActionOnMaintenance?

            public var instanceId: String?

            public var maintenanceWindows: DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute.MaintenanceWindows?

            public var notifyOnMaintenance: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.actionOnMaintenance?.validate()
                try self.maintenanceWindows?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actionOnMaintenance != nil {
                    map["ActionOnMaintenance"] = self.actionOnMaintenance?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.maintenanceWindows != nil {
                    map["MaintenanceWindows"] = self.maintenanceWindows?.toMap()
                }
                if self.notifyOnMaintenance != nil {
                    map["NotifyOnMaintenance"] = self.notifyOnMaintenance!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ActionOnMaintenance"] as? [String: Any?] {
                    var model = DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute.ActionOnMaintenance()
                    model.fromMap(value)
                    self.actionOnMaintenance = model
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["MaintenanceWindows"] as? [String: Any?] {
                    var model = DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute.MaintenanceWindows()
                    model.fromMap(value)
                    self.maintenanceWindows = model
                }
                if let value = dict["NotifyOnMaintenance"] as? Bool {
                    self.notifyOnMaintenance = value
                }
            }
        }
        public var maintenanceAttribute: [DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.maintenanceAttribute != nil {
                var tmp : [Any] = []
                for k in self.maintenanceAttribute! {
                    tmp.append(k.toMap())
                }
                map["MaintenanceAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MaintenanceAttribute"] as? [Any?] {
                var tmp : [DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute] = []
                for v in value {
                    if v != nil {
                        var model = DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.maintenanceAttribute = tmp
            }
        }
    }
    public var maintenanceAttributes: DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.maintenanceAttributes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maintenanceAttributes != nil {
            map["MaintenanceAttributes"] = self.maintenanceAttributes?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaintenanceAttributes"] as? [String: Any?] {
            var model = DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes()
            model.fromMap(value)
            self.maintenanceAttributes = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeInstanceMaintenanceAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceMaintenanceAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInstanceMaintenanceAttributesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInstanceModificationPriceRequest : Tea.TeaModel {
    public class SystemDisk : Tea.TeaModel {
        public var category: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Category"] as? String {
                self.category = value
            }
        }
    }
    public class DataDisk : Tea.TeaModel {
        public var category: String?

        public var performanceLevel: String?

        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["PerformanceLevel"] as? String {
                self.performanceLevel = value
            }
            if let value = dict["Size"] as? Int32 {
                self.size = value
            }
        }
    }
    public var systemDisk: DescribeInstanceModificationPriceRequest.SystemDisk?

    public var dataDisk: [DescribeInstanceModificationPriceRequest.DataDisk]?

    public var instanceId: String?

    public var instanceType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.dataDisk != nil {
            var tmp : [Any] = []
            for k in self.dataDisk! {
                tmp.append(k.toMap())
            }
            map["DataDisk"] = tmp
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["SystemDisk"] as? [String: Any?] {
            var model = DescribeInstanceModificationPriceRequest.SystemDisk()
            model.fromMap(value)
            self.systemDisk = model
        }
        if let value = dict["DataDisk"] as? [Any?] {
            var tmp : [DescribeInstanceModificationPriceRequest.DataDisk] = []
            for v in value {
                if v != nil {
                    var model = DescribeInstanceModificationPriceRequest.DataDisk()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.dataDisk = tmp
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeInstanceModificationPriceResponseBody : Tea.TeaModel {
    public class PriceInfo : Tea.TeaModel {
        public class Price : Tea.TeaModel {
            public class DetailInfos : Tea.TeaModel {
                public class DetailInfo : Tea.TeaModel {
                    public class SubRules : Tea.TeaModel {
                        public class Rule : Tea.TeaModel {
                            public var description_: String?

                            public var ruleId: Int64?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.description_ != nil {
                                    map["Description"] = self.description_!
                                }
                                if self.ruleId != nil {
                                    map["RuleId"] = self.ruleId!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["Description"] as? String {
                                    self.description_ = value
                                }
                                if let value = dict["RuleId"] as? Int64 {
                                    self.ruleId = value
                                }
                            }
                        }
                        public var rule: [DescribeInstanceModificationPriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo.SubRules.Rule]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.rule != nil {
                                var tmp : [Any] = []
                                for k in self.rule! {
                                    tmp.append(k.toMap())
                                }
                                map["Rule"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Rule"] as? [Any?] {
                                var tmp : [DescribeInstanceModificationPriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo.SubRules.Rule] = []
                                for v in value {
                                    if v != nil {
                                        var model = DescribeInstanceModificationPriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo.SubRules.Rule()
                                        if v != nil {
                                            model.fromMap(v as? [String: Any?])
                                        }
                                        tmp.append(model)
                                    }
                                }
                                self.rule = tmp
                            }
                        }
                    }
                    public var discountPrice: Double?

                    public var originalPrice: Double?

                    public var resource: String?

                    public var subRules: DescribeInstanceModificationPriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo.SubRules?

                    public var tradePrice: Double?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.subRules?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.discountPrice != nil {
                            map["DiscountPrice"] = self.discountPrice!
                        }
                        if self.originalPrice != nil {
                            map["OriginalPrice"] = self.originalPrice!
                        }
                        if self.resource != nil {
                            map["Resource"] = self.resource!
                        }
                        if self.subRules != nil {
                            map["SubRules"] = self.subRules?.toMap()
                        }
                        if self.tradePrice != nil {
                            map["TradePrice"] = self.tradePrice!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["DiscountPrice"] as? Double {
                            self.discountPrice = value
                        }
                        if let value = dict["OriginalPrice"] as? Double {
                            self.originalPrice = value
                        }
                        if let value = dict["Resource"] as? String {
                            self.resource = value
                        }
                        if let value = dict["SubRules"] as? [String: Any?] {
                            var model = DescribeInstanceModificationPriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo.SubRules()
                            model.fromMap(value)
                            self.subRules = model
                        }
                        if let value = dict["TradePrice"] as? Double {
                            self.tradePrice = value
                        }
                    }
                }
                public var detailInfo: [DescribeInstanceModificationPriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.detailInfo != nil {
                        var tmp : [Any] = []
                        for k in self.detailInfo! {
                            tmp.append(k.toMap())
                        }
                        map["DetailInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DetailInfo"] as? [Any?] {
                        var tmp : [DescribeInstanceModificationPriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeInstanceModificationPriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.detailInfo = tmp
                    }
                }
            }
            public var currency: String?

            public var detailInfos: DescribeInstanceModificationPriceResponseBody.PriceInfo.Price.DetailInfos?

            public var discountPrice: Double?

            public var originalPrice: Double?

            public var tradePrice: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.detailInfos?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.currency != nil {
                    map["Currency"] = self.currency!
                }
                if self.detailInfos != nil {
                    map["DetailInfos"] = self.detailInfos?.toMap()
                }
                if self.discountPrice != nil {
                    map["DiscountPrice"] = self.discountPrice!
                }
                if self.originalPrice != nil {
                    map["OriginalPrice"] = self.originalPrice!
                }
                if self.tradePrice != nil {
                    map["TradePrice"] = self.tradePrice!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Currency"] as? String {
                    self.currency = value
                }
                if let value = dict["DetailInfos"] as? [String: Any?] {
                    var model = DescribeInstanceModificationPriceResponseBody.PriceInfo.Price.DetailInfos()
                    model.fromMap(value)
                    self.detailInfos = model
                }
                if let value = dict["DiscountPrice"] as? Double {
                    self.discountPrice = value
                }
                if let value = dict["OriginalPrice"] as? Double {
                    self.originalPrice = value
                }
                if let value = dict["TradePrice"] as? Double {
                    self.tradePrice = value
                }
            }
        }
        public class Rules : Tea.TeaModel {
            public class Rule : Tea.TeaModel {
                public var description_: String?

                public var ruleId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.ruleId != nil {
                        map["RuleId"] = self.ruleId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Description"] as? String {
                        self.description_ = value
                    }
                    if let value = dict["RuleId"] as? Int64 {
                        self.ruleId = value
                    }
                }
            }
            public var rule: [DescribeInstanceModificationPriceResponseBody.PriceInfo.Rules.Rule]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.rule != nil {
                    var tmp : [Any] = []
                    for k in self.rule! {
                        tmp.append(k.toMap())
                    }
                    map["Rule"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Rule"] as? [Any?] {
                    var tmp : [DescribeInstanceModificationPriceResponseBody.PriceInfo.Rules.Rule] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeInstanceModificationPriceResponseBody.PriceInfo.Rules.Rule()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.rule = tmp
                }
            }
        }
        public var price: DescribeInstanceModificationPriceResponseBody.PriceInfo.Price?

        public var rules: DescribeInstanceModificationPriceResponseBody.PriceInfo.Rules?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.price?.validate()
            try self.rules?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.price != nil {
                map["Price"] = self.price?.toMap()
            }
            if self.rules != nil {
                map["Rules"] = self.rules?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Price"] as? [String: Any?] {
                var model = DescribeInstanceModificationPriceResponseBody.PriceInfo.Price()
                model.fromMap(value)
                self.price = model
            }
            if let value = dict["Rules"] as? [String: Any?] {
                var model = DescribeInstanceModificationPriceResponseBody.PriceInfo.Rules()
                model.fromMap(value)
                self.rules = model
            }
        }
    }
    public var priceInfo: DescribeInstanceModificationPriceResponseBody.PriceInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.priceInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.priceInfo != nil {
            map["PriceInfo"] = self.priceInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PriceInfo"] as? [String: Any?] {
            var model = DescribeInstanceModificationPriceResponseBody.PriceInfo()
            model.fromMap(value)
            self.priceInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeInstanceModificationPriceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceModificationPriceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInstanceModificationPriceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInstanceMonitorDataRequest : Tea.TeaModel {
    public var endTime: String?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeInstanceMonitorDataResponseBody : Tea.TeaModel {
    public class MonitorData : Tea.TeaModel {
        public class InstanceMonitorData : Tea.TeaModel {
            public var BPSRead: Int32?

            public var BPSWrite: Int32?

            public var CPU: Int32?

            public var CPUAdvanceCreditBalance: Double?

            public var CPUCreditBalance: Double?

            public var CPUCreditUsage: Double?

            public var CPUNotpaidSurplusCreditUsage: Double?

            public var IOPSRead: Int32?

            public var IOPSWrite: Int32?

            public var instanceId: String?

            public var internetBandwidth: Int32?

            public var internetRX: Int32?

            public var internetTX: Int32?

            public var intranetBandwidth: Int32?

            public var intranetRX: Int32?

            public var intranetTX: Int32?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.BPSRead != nil {
                    map["BPSRead"] = self.BPSRead!
                }
                if self.BPSWrite != nil {
                    map["BPSWrite"] = self.BPSWrite!
                }
                if self.CPU != nil {
                    map["CPU"] = self.CPU!
                }
                if self.CPUAdvanceCreditBalance != nil {
                    map["CPUAdvanceCreditBalance"] = self.CPUAdvanceCreditBalance!
                }
                if self.CPUCreditBalance != nil {
                    map["CPUCreditBalance"] = self.CPUCreditBalance!
                }
                if self.CPUCreditUsage != nil {
                    map["CPUCreditUsage"] = self.CPUCreditUsage!
                }
                if self.CPUNotpaidSurplusCreditUsage != nil {
                    map["CPUNotpaidSurplusCreditUsage"] = self.CPUNotpaidSurplusCreditUsage!
                }
                if self.IOPSRead != nil {
                    map["IOPSRead"] = self.IOPSRead!
                }
                if self.IOPSWrite != nil {
                    map["IOPSWrite"] = self.IOPSWrite!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.internetBandwidth != nil {
                    map["InternetBandwidth"] = self.internetBandwidth!
                }
                if self.internetRX != nil {
                    map["InternetRX"] = self.internetRX!
                }
                if self.internetTX != nil {
                    map["InternetTX"] = self.internetTX!
                }
                if self.intranetBandwidth != nil {
                    map["IntranetBandwidth"] = self.intranetBandwidth!
                }
                if self.intranetRX != nil {
                    map["IntranetRX"] = self.intranetRX!
                }
                if self.intranetTX != nil {
                    map["IntranetTX"] = self.intranetTX!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BPSRead"] as? Int32 {
                    self.BPSRead = value
                }
                if let value = dict["BPSWrite"] as? Int32 {
                    self.BPSWrite = value
                }
                if let value = dict["CPU"] as? Int32 {
                    self.CPU = value
                }
                if let value = dict["CPUAdvanceCreditBalance"] as? Double {
                    self.CPUAdvanceCreditBalance = value
                }
                if let value = dict["CPUCreditBalance"] as? Double {
                    self.CPUCreditBalance = value
                }
                if let value = dict["CPUCreditUsage"] as? Double {
                    self.CPUCreditUsage = value
                }
                if let value = dict["CPUNotpaidSurplusCreditUsage"] as? Double {
                    self.CPUNotpaidSurplusCreditUsage = value
                }
                if let value = dict["IOPSRead"] as? Int32 {
                    self.IOPSRead = value
                }
                if let value = dict["IOPSWrite"] as? Int32 {
                    self.IOPSWrite = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["InternetBandwidth"] as? Int32 {
                    self.internetBandwidth = value
                }
                if let value = dict["InternetRX"] as? Int32 {
                    self.internetRX = value
                }
                if let value = dict["InternetTX"] as? Int32 {
                    self.internetTX = value
                }
                if let value = dict["IntranetBandwidth"] as? Int32 {
                    self.intranetBandwidth = value
                }
                if let value = dict["IntranetRX"] as? Int32 {
                    self.intranetRX = value
                }
                if let value = dict["IntranetTX"] as? Int32 {
                    self.intranetTX = value
                }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
            }
        }
        public var instanceMonitorData: [DescribeInstanceMonitorDataResponseBody.MonitorData.InstanceMonitorData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceMonitorData != nil {
                var tmp : [Any] = []
                for k in self.instanceMonitorData! {
                    tmp.append(k.toMap())
                }
                map["InstanceMonitorData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceMonitorData"] as? [Any?] {
                var tmp : [DescribeInstanceMonitorDataResponseBody.MonitorData.InstanceMonitorData] = []
                for v in value {
                    if v != nil {
                        var model = DescribeInstanceMonitorDataResponseBody.MonitorData.InstanceMonitorData()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instanceMonitorData = tmp
            }
        }
    }
    public var monitorData: DescribeInstanceMonitorDataResponseBody.MonitorData?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.monitorData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorData != nil {
            map["MonitorData"] = self.monitorData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MonitorData"] as? [String: Any?] {
            var model = DescribeInstanceMonitorDataResponseBody.MonitorData()
            model.fromMap(value)
            self.monitorData = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeInstanceMonitorDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceMonitorDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInstanceMonitorDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInstanceRamRoleRequest : Tea.TeaModel {
    public var instanceIds: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var ramRoleName: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RamRoleName"] as? String {
            self.ramRoleName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeInstanceRamRoleResponseBody : Tea.TeaModel {
    public class InstanceRamRoleSets : Tea.TeaModel {
        public class InstanceRamRoleSet : Tea.TeaModel {
            public var instanceId: String?

            public var ramRoleName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.ramRoleName != nil {
                    map["RamRoleName"] = self.ramRoleName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["RamRoleName"] as? String {
                    self.ramRoleName = value
                }
            }
        }
        public var instanceRamRoleSet: [DescribeInstanceRamRoleResponseBody.InstanceRamRoleSets.InstanceRamRoleSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceRamRoleSet != nil {
                var tmp : [Any] = []
                for k in self.instanceRamRoleSet! {
                    tmp.append(k.toMap())
                }
                map["InstanceRamRoleSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceRamRoleSet"] as? [Any?] {
                var tmp : [DescribeInstanceRamRoleResponseBody.InstanceRamRoleSets.InstanceRamRoleSet] = []
                for v in value {
                    if v != nil {
                        var model = DescribeInstanceRamRoleResponseBody.InstanceRamRoleSets.InstanceRamRoleSet()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instanceRamRoleSet = tmp
            }
        }
    }
    public var instanceRamRoleSets: DescribeInstanceRamRoleResponseBody.InstanceRamRoleSets?

    public var regionId: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceRamRoleSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceRamRoleSets != nil {
            map["InstanceRamRoleSets"] = self.instanceRamRoleSets?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceRamRoleSets"] as? [String: Any?] {
            var model = DescribeInstanceRamRoleResponseBody.InstanceRamRoleSets()
            model.fromMap(value)
            self.instanceRamRoleSets = model
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeInstanceRamRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceRamRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInstanceRamRoleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInstanceStatusRequest : Tea.TeaModel {
    public var clusterId: String?

    public var instanceId: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["InstanceId"] as? [String] {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribeInstanceStatusResponseBody : Tea.TeaModel {
    public class InstanceStatuses : Tea.TeaModel {
        public class InstanceStatus : Tea.TeaModel {
            public var instanceId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var instanceStatus: [DescribeInstanceStatusResponseBody.InstanceStatuses.InstanceStatus]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceStatus != nil {
                var tmp : [Any] = []
                for k in self.instanceStatus! {
                    tmp.append(k.toMap())
                }
                map["InstanceStatus"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceStatus"] as? [Any?] {
                var tmp : [DescribeInstanceStatusResponseBody.InstanceStatuses.InstanceStatus] = []
                for v in value {
                    if v != nil {
                        var model = DescribeInstanceStatusResponseBody.InstanceStatuses.InstanceStatus()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instanceStatus = tmp
            }
        }
    }
    public var instanceStatuses: DescribeInstanceStatusResponseBody.InstanceStatuses?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceStatuses?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceStatuses != nil {
            map["InstanceStatuses"] = self.instanceStatuses?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceStatuses"] as? [String: Any?] {
            var model = DescribeInstanceStatusResponseBody.InstanceStatuses()
            model.fromMap(value)
            self.instanceStatuses = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeInstanceStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInstanceStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInstanceTopologyRequest : Tea.TeaModel {
    public var instanceIds: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeInstanceTopologyResponseBody : Tea.TeaModel {
    public class Topologys : Tea.TeaModel {
        public class Topology : Tea.TeaModel {
            public var hostId: String?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hostId != nil {
                    map["HostId"] = self.hostId!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["HostId"] as? String {
                    self.hostId = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
            }
        }
        public var topology: [DescribeInstanceTopologyResponseBody.Topologys.Topology]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.topology != nil {
                var tmp : [Any] = []
                for k in self.topology! {
                    tmp.append(k.toMap())
                }
                map["Topology"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Topology"] as? [Any?] {
                var tmp : [DescribeInstanceTopologyResponseBody.Topologys.Topology] = []
                for v in value {
                    if v != nil {
                        var model = DescribeInstanceTopologyResponseBody.Topologys.Topology()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.topology = tmp
            }
        }
    }
    public var requestId: String?

    public var topologys: DescribeInstanceTopologyResponseBody.Topologys?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.topologys?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.topologys != nil {
            map["Topologys"] = self.topologys?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Topologys"] as? [String: Any?] {
            var model = DescribeInstanceTopologyResponseBody.Topologys()
            model.fromMap(value)
            self.topologys = model
        }
    }
}

public class DescribeInstanceTopologyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceTopologyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInstanceTopologyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInstanceTypeFamiliesRequest : Tea.TeaModel {
    public var generation: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.generation != nil {
            map["Generation"] = self.generation!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Generation"] as? String {
            self.generation = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeInstanceTypeFamiliesResponseBody : Tea.TeaModel {
    public class InstanceTypeFamilies : Tea.TeaModel {
        public class InstanceTypeFamily : Tea.TeaModel {
            public var generation: String?

            public var instanceTypeFamilyId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.generation != nil {
                    map["Generation"] = self.generation!
                }
                if self.instanceTypeFamilyId != nil {
                    map["InstanceTypeFamilyId"] = self.instanceTypeFamilyId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Generation"] as? String {
                    self.generation = value
                }
                if let value = dict["InstanceTypeFamilyId"] as? String {
                    self.instanceTypeFamilyId = value
                }
            }
        }
        public var instanceTypeFamily: [DescribeInstanceTypeFamiliesResponseBody.InstanceTypeFamilies.InstanceTypeFamily]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceTypeFamily != nil {
                var tmp : [Any] = []
                for k in self.instanceTypeFamily! {
                    tmp.append(k.toMap())
                }
                map["InstanceTypeFamily"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceTypeFamily"] as? [Any?] {
                var tmp : [DescribeInstanceTypeFamiliesResponseBody.InstanceTypeFamilies.InstanceTypeFamily] = []
                for v in value {
                    if v != nil {
                        var model = DescribeInstanceTypeFamiliesResponseBody.InstanceTypeFamilies.InstanceTypeFamily()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instanceTypeFamily = tmp
            }
        }
    }
    public var instanceTypeFamilies: DescribeInstanceTypeFamiliesResponseBody.InstanceTypeFamilies?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceTypeFamilies?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceTypeFamilies != nil {
            map["InstanceTypeFamilies"] = self.instanceTypeFamilies?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceTypeFamilies"] as? [String: Any?] {
            var model = DescribeInstanceTypeFamiliesResponseBody.InstanceTypeFamilies()
            model.fromMap(value)
            self.instanceTypeFamilies = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeInstanceTypeFamiliesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceTypeFamiliesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInstanceTypeFamiliesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInstanceTypesRequest : Tea.TeaModel {
    public var cpuArchitecture: String?

    public var cpuArchitectures: [String]?

    public var GPUSpec: String?

    public var gpuSpecs: [String]?

    public var instanceCategories: [String]?

    public var instanceCategory: String?

    public var instanceFamilyLevel: String?

    public var instanceTypeFamilies: [String]?

    public var instanceTypeFamily: String?

    public var instanceTypes: [String]?

    public var localStorageCategories: [String]?

    public var localStorageCategory: String?

    public var maxResults: Int64?

    public var maximumCpuCoreCount: Int32?

    public var maximumCpuSpeedFrequency: Double?

    public var maximumCpuTurboFrequency: Double?

    public var maximumGPUAmount: Int32?

    public var maximumMemorySize: Double?

    public var minimumBaselineCredit: Int32?

    public var minimumCpuCoreCount: Int32?

    public var minimumCpuSpeedFrequency: Double?

    public var minimumCpuTurboFrequency: Double?

    public var minimumDiskQuantity: Int32?

    public var minimumEniIpv6AddressQuantity: Int32?

    public var minimumEniPrivateIpAddressQuantity: Int32?

    public var minimumEniQuantity: Int32?

    public var minimumEriQuantity: Int32?

    public var minimumGPUAmount: Int32?

    public var minimumInitialCredit: Int32?

    public var minimumInstanceBandwidthRx: Int32?

    public var minimumInstanceBandwidthTx: Int32?

    public var minimumInstancePpsRx: Int64?

    public var minimumInstancePpsTx: Int64?

    public var minimumLocalStorageAmount: Int32?

    public var minimumLocalStorageCapacity: Int64?

    public var minimumMemorySize: Double?

    public var minimumPrimaryEniQueueNumber: Int32?

    public var minimumQueuePairNumber: Int32?

    public var minimumSecondaryEniQueueNumber: Int32?

    public var nextToken: String?

    public var nvmeSupport: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var physicalProcessorModel: String?

    public var physicalProcessorModels: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cpuArchitecture != nil {
            map["CpuArchitecture"] = self.cpuArchitecture!
        }
        if self.cpuArchitectures != nil {
            map["CpuArchitectures"] = self.cpuArchitectures!
        }
        if self.GPUSpec != nil {
            map["GPUSpec"] = self.GPUSpec!
        }
        if self.gpuSpecs != nil {
            map["GpuSpecs"] = self.gpuSpecs!
        }
        if self.instanceCategories != nil {
            map["InstanceCategories"] = self.instanceCategories!
        }
        if self.instanceCategory != nil {
            map["InstanceCategory"] = self.instanceCategory!
        }
        if self.instanceFamilyLevel != nil {
            map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
        }
        if self.instanceTypeFamilies != nil {
            map["InstanceTypeFamilies"] = self.instanceTypeFamilies!
        }
        if self.instanceTypeFamily != nil {
            map["InstanceTypeFamily"] = self.instanceTypeFamily!
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.localStorageCategories != nil {
            map["LocalStorageCategories"] = self.localStorageCategories!
        }
        if self.localStorageCategory != nil {
            map["LocalStorageCategory"] = self.localStorageCategory!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.maximumCpuCoreCount != nil {
            map["MaximumCpuCoreCount"] = self.maximumCpuCoreCount!
        }
        if self.maximumCpuSpeedFrequency != nil {
            map["MaximumCpuSpeedFrequency"] = self.maximumCpuSpeedFrequency!
        }
        if self.maximumCpuTurboFrequency != nil {
            map["MaximumCpuTurboFrequency"] = self.maximumCpuTurboFrequency!
        }
        if self.maximumGPUAmount != nil {
            map["MaximumGPUAmount"] = self.maximumGPUAmount!
        }
        if self.maximumMemorySize != nil {
            map["MaximumMemorySize"] = self.maximumMemorySize!
        }
        if self.minimumBaselineCredit != nil {
            map["MinimumBaselineCredit"] = self.minimumBaselineCredit!
        }
        if self.minimumCpuCoreCount != nil {
            map["MinimumCpuCoreCount"] = self.minimumCpuCoreCount!
        }
        if self.minimumCpuSpeedFrequency != nil {
            map["MinimumCpuSpeedFrequency"] = self.minimumCpuSpeedFrequency!
        }
        if self.minimumCpuTurboFrequency != nil {
            map["MinimumCpuTurboFrequency"] = self.minimumCpuTurboFrequency!
        }
        if self.minimumDiskQuantity != nil {
            map["MinimumDiskQuantity"] = self.minimumDiskQuantity!
        }
        if self.minimumEniIpv6AddressQuantity != nil {
            map["MinimumEniIpv6AddressQuantity"] = self.minimumEniIpv6AddressQuantity!
        }
        if self.minimumEniPrivateIpAddressQuantity != nil {
            map["MinimumEniPrivateIpAddressQuantity"] = self.minimumEniPrivateIpAddressQuantity!
        }
        if self.minimumEniQuantity != nil {
            map["MinimumEniQuantity"] = self.minimumEniQuantity!
        }
        if self.minimumEriQuantity != nil {
            map["MinimumEriQuantity"] = self.minimumEriQuantity!
        }
        if self.minimumGPUAmount != nil {
            map["MinimumGPUAmount"] = self.minimumGPUAmount!
        }
        if self.minimumInitialCredit != nil {
            map["MinimumInitialCredit"] = self.minimumInitialCredit!
        }
        if self.minimumInstanceBandwidthRx != nil {
            map["MinimumInstanceBandwidthRx"] = self.minimumInstanceBandwidthRx!
        }
        if self.minimumInstanceBandwidthTx != nil {
            map["MinimumInstanceBandwidthTx"] = self.minimumInstanceBandwidthTx!
        }
        if self.minimumInstancePpsRx != nil {
            map["MinimumInstancePpsRx"] = self.minimumInstancePpsRx!
        }
        if self.minimumInstancePpsTx != nil {
            map["MinimumInstancePpsTx"] = self.minimumInstancePpsTx!
        }
        if self.minimumLocalStorageAmount != nil {
            map["MinimumLocalStorageAmount"] = self.minimumLocalStorageAmount!
        }
        if self.minimumLocalStorageCapacity != nil {
            map["MinimumLocalStorageCapacity"] = self.minimumLocalStorageCapacity!
        }
        if self.minimumMemorySize != nil {
            map["MinimumMemorySize"] = self.minimumMemorySize!
        }
        if self.minimumPrimaryEniQueueNumber != nil {
            map["MinimumPrimaryEniQueueNumber"] = self.minimumPrimaryEniQueueNumber!
        }
        if self.minimumQueuePairNumber != nil {
            map["MinimumQueuePairNumber"] = self.minimumQueuePairNumber!
        }
        if self.minimumSecondaryEniQueueNumber != nil {
            map["MinimumSecondaryEniQueueNumber"] = self.minimumSecondaryEniQueueNumber!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.nvmeSupport != nil {
            map["NvmeSupport"] = self.nvmeSupport!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.physicalProcessorModel != nil {
            map["PhysicalProcessorModel"] = self.physicalProcessorModel!
        }
        if self.physicalProcessorModels != nil {
            map["PhysicalProcessorModels"] = self.physicalProcessorModels!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CpuArchitecture"] as? String {
            self.cpuArchitecture = value
        }
        if let value = dict["CpuArchitectures"] as? [String] {
            self.cpuArchitectures = value
        }
        if let value = dict["GPUSpec"] as? String {
            self.GPUSpec = value
        }
        if let value = dict["GpuSpecs"] as? [String] {
            self.gpuSpecs = value
        }
        if let value = dict["InstanceCategories"] as? [String] {
            self.instanceCategories = value
        }
        if let value = dict["InstanceCategory"] as? String {
            self.instanceCategory = value
        }
        if let value = dict["InstanceFamilyLevel"] as? String {
            self.instanceFamilyLevel = value
        }
        if let value = dict["InstanceTypeFamilies"] as? [String] {
            self.instanceTypeFamilies = value
        }
        if let value = dict["InstanceTypeFamily"] as? String {
            self.instanceTypeFamily = value
        }
        if let value = dict["InstanceTypes"] as? [String] {
            self.instanceTypes = value
        }
        if let value = dict["LocalStorageCategories"] as? [String] {
            self.localStorageCategories = value
        }
        if let value = dict["LocalStorageCategory"] as? String {
            self.localStorageCategory = value
        }
        if let value = dict["MaxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["MaximumCpuCoreCount"] as? Int32 {
            self.maximumCpuCoreCount = value
        }
        if let value = dict["MaximumCpuSpeedFrequency"] as? Double {
            self.maximumCpuSpeedFrequency = value
        }
        if let value = dict["MaximumCpuTurboFrequency"] as? Double {
            self.maximumCpuTurboFrequency = value
        }
        if let value = dict["MaximumGPUAmount"] as? Int32 {
            self.maximumGPUAmount = value
        }
        if let value = dict["MaximumMemorySize"] as? Double {
            self.maximumMemorySize = value
        }
        if let value = dict["MinimumBaselineCredit"] as? Int32 {
            self.minimumBaselineCredit = value
        }
        if let value = dict["MinimumCpuCoreCount"] as? Int32 {
            self.minimumCpuCoreCount = value
        }
        if let value = dict["MinimumCpuSpeedFrequency"] as? Double {
            self.minimumCpuSpeedFrequency = value
        }
        if let value = dict["MinimumCpuTurboFrequency"] as? Double {
            self.minimumCpuTurboFrequency = value
        }
        if let value = dict["MinimumDiskQuantity"] as? Int32 {
            self.minimumDiskQuantity = value
        }
        if let value = dict["MinimumEniIpv6AddressQuantity"] as? Int32 {
            self.minimumEniIpv6AddressQuantity = value
        }
        if let value = dict["MinimumEniPrivateIpAddressQuantity"] as? Int32 {
            self.minimumEniPrivateIpAddressQuantity = value
        }
        if let value = dict["MinimumEniQuantity"] as? Int32 {
            self.minimumEniQuantity = value
        }
        if let value = dict["MinimumEriQuantity"] as? Int32 {
            self.minimumEriQuantity = value
        }
        if let value = dict["MinimumGPUAmount"] as? Int32 {
            self.minimumGPUAmount = value
        }
        if let value = dict["MinimumInitialCredit"] as? Int32 {
            self.minimumInitialCredit = value
        }
        if let value = dict["MinimumInstanceBandwidthRx"] as? Int32 {
            self.minimumInstanceBandwidthRx = value
        }
        if let value = dict["MinimumInstanceBandwidthTx"] as? Int32 {
            self.minimumInstanceBandwidthTx = value
        }
        if let value = dict["MinimumInstancePpsRx"] as? Int64 {
            self.minimumInstancePpsRx = value
        }
        if let value = dict["MinimumInstancePpsTx"] as? Int64 {
            self.minimumInstancePpsTx = value
        }
        if let value = dict["MinimumLocalStorageAmount"] as? Int32 {
            self.minimumLocalStorageAmount = value
        }
        if let value = dict["MinimumLocalStorageCapacity"] as? Int64 {
            self.minimumLocalStorageCapacity = value
        }
        if let value = dict["MinimumMemorySize"] as? Double {
            self.minimumMemorySize = value
        }
        if let value = dict["MinimumPrimaryEniQueueNumber"] as? Int32 {
            self.minimumPrimaryEniQueueNumber = value
        }
        if let value = dict["MinimumQueuePairNumber"] as? Int32 {
            self.minimumQueuePairNumber = value
        }
        if let value = dict["MinimumSecondaryEniQueueNumber"] as? Int32 {
            self.minimumSecondaryEniQueueNumber = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["NvmeSupport"] as? String {
            self.nvmeSupport = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PhysicalProcessorModel"] as? String {
            self.physicalProcessorModel = value
        }
        if let value = dict["PhysicalProcessorModels"] as? [String] {
            self.physicalProcessorModels = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeInstanceTypesResponseBody : Tea.TeaModel {
    public class InstanceTypes : Tea.TeaModel {
        public class InstanceType : Tea.TeaModel {
            public class Attributes : Tea.TeaModel {
                public class Attribute : Tea.TeaModel {
                    public var name: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Name"] as? String {
                            self.name = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var attribute: [DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.Attributes.Attribute]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.attribute != nil {
                        var tmp : [Any] = []
                        for k in self.attribute! {
                            tmp.append(k.toMap())
                        }
                        map["Attribute"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Attribute"] as? [Any?] {
                        var tmp : [DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.Attributes.Attribute] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.Attributes.Attribute()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.attribute = tmp
                    }
                }
            }
            public class Clock : Tea.TeaModel {
                public var ptpSupport: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ptpSupport != nil {
                        map["PtpSupport"] = self.ptpSupport!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["PtpSupport"] as? String {
                        self.ptpSupport = value
                    }
                }
            }
            public class CpuOptions : Tea.TeaModel {
                public class SupportedTopologyTypes : Tea.TeaModel {
                    public var supportedTopologyType: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.supportedTopologyType != nil {
                            map["SupportedTopologyType"] = self.supportedTopologyType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["SupportedTopologyType"] as? [String] {
                            self.supportedTopologyType = value
                        }
                    }
                }
                public var core: Int32?

                public var coreFactor: Int32?

                public var hyperThreadingAdjustable: Bool?

                public var supportedTopologyTypes: DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.CpuOptions.SupportedTopologyTypes?

                public var threadsPerCore: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.supportedTopologyTypes?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.core != nil {
                        map["Core"] = self.core!
                    }
                    if self.coreFactor != nil {
                        map["CoreFactor"] = self.coreFactor!
                    }
                    if self.hyperThreadingAdjustable != nil {
                        map["HyperThreadingAdjustable"] = self.hyperThreadingAdjustable!
                    }
                    if self.supportedTopologyTypes != nil {
                        map["SupportedTopologyTypes"] = self.supportedTopologyTypes?.toMap()
                    }
                    if self.threadsPerCore != nil {
                        map["ThreadsPerCore"] = self.threadsPerCore!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Core"] as? Int32 {
                        self.core = value
                    }
                    if let value = dict["CoreFactor"] as? Int32 {
                        self.coreFactor = value
                    }
                    if let value = dict["HyperThreadingAdjustable"] as? Bool {
                        self.hyperThreadingAdjustable = value
                    }
                    if let value = dict["SupportedTopologyTypes"] as? [String: Any?] {
                        var model = DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.CpuOptions.SupportedTopologyTypes()
                        model.fromMap(value)
                        self.supportedTopologyTypes = model
                    }
                    if let value = dict["ThreadsPerCore"] as? Int32 {
                        self.threadsPerCore = value
                    }
                }
            }
            public class EnhancedNetwork : Tea.TeaModel {
                public var rssSupport: Bool?

                public var sriovSupport: Bool?

                public var vfQueueNumberPerEni: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.rssSupport != nil {
                        map["RssSupport"] = self.rssSupport!
                    }
                    if self.sriovSupport != nil {
                        map["SriovSupport"] = self.sriovSupport!
                    }
                    if self.vfQueueNumberPerEni != nil {
                        map["VfQueueNumberPerEni"] = self.vfQueueNumberPerEni!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RssSupport"] as? Bool {
                        self.rssSupport = value
                    }
                    if let value = dict["SriovSupport"] as? Bool {
                        self.sriovSupport = value
                    }
                    if let value = dict["VfQueueNumberPerEni"] as? Int32 {
                        self.vfQueueNumberPerEni = value
                    }
                }
            }
            public class NetworkCards : Tea.TeaModel {
                public class NetworkCardInfo : Tea.TeaModel {
                    public var networkCardIndex: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.networkCardIndex != nil {
                            map["NetworkCardIndex"] = self.networkCardIndex!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["NetworkCardIndex"] as? Int32 {
                            self.networkCardIndex = value
                        }
                    }
                }
                public var networkCardInfo: [DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.NetworkCards.NetworkCardInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.networkCardInfo != nil {
                        var tmp : [Any] = []
                        for k in self.networkCardInfo! {
                            tmp.append(k.toMap())
                        }
                        map["NetworkCardInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["NetworkCardInfo"] as? [Any?] {
                        var tmp : [DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.NetworkCards.NetworkCardInfo] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.NetworkCards.NetworkCardInfo()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.networkCardInfo = tmp
                    }
                }
            }
            public class SupportedBootModes : Tea.TeaModel {
                public var supportedBootMode: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.supportedBootMode != nil {
                        map["SupportedBootMode"] = self.supportedBootMode!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["SupportedBootMode"] as? [String] {
                        self.supportedBootMode = value
                    }
                }
            }
            public var attributes: DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.Attributes?

            public var baselineCredit: Int32?

            public var clock: DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.Clock?

            public var cpuArchitecture: String?

            public var cpuCoreCount: Int32?

            public var cpuOptions: DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.CpuOptions?

            public var cpuSpeedFrequency: Double?

            public var cpuTurboFrequency: Double?

            public var diskQuantity: Int32?

            public var enhancedNetwork: DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.EnhancedNetwork?

            public var eniIpv6AddressQuantity: Int32?

            public var eniPrivateIpAddressQuantity: Int32?

            public var eniQuantity: Int32?

            public var eniTotalQuantity: Int32?

            public var eniTrunkSupported: Bool?

            public var eriQuantity: Int32?

            public var GPUAmount: Int32?

            public var GPUMemorySize: Double?

            public var GPUSpec: String?

            public var initialCredit: Int32?

            public var instanceBandwidthRx: Int32?

            public var instanceBandwidthTx: Int32?

            public var instanceCategory: String?

            public var instanceFamilyLevel: String?

            public var instancePpsRx: Int64?

            public var instancePpsTx: Int64?

            public var instanceTypeFamily: String?

            public var instanceTypeId: String?

            public var jumboFrameSupport: Bool?

            public var localStorageAmount: Int32?

            public var localStorageCapacity: Int64?

            public var localStorageCategory: String?

            public var maximumQueueNumberPerEni: Int32?

            public var memorySize: Double?

            public var networkCardQuantity: Int32?

            public var networkCards: DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.NetworkCards?

            public var networkEncryptionSupport: Bool?

            public var nvmeSupport: String?

            public var physicalProcessorModel: String?

            public var primaryEniQueueNumber: Int32?

            public var queuePairNumber: Int32?

            public var secondaryEniQueueNumber: Int32?

            public var supportedBootModes: DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.SupportedBootModes?

            public var totalEniQueueQuantity: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.attributes?.validate()
                try self.clock?.validate()
                try self.cpuOptions?.validate()
                try self.enhancedNetwork?.validate()
                try self.networkCards?.validate()
                try self.supportedBootModes?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.attributes != nil {
                    map["Attributes"] = self.attributes?.toMap()
                }
                if self.baselineCredit != nil {
                    map["BaselineCredit"] = self.baselineCredit!
                }
                if self.clock != nil {
                    map["Clock"] = self.clock?.toMap()
                }
                if self.cpuArchitecture != nil {
                    map["CpuArchitecture"] = self.cpuArchitecture!
                }
                if self.cpuCoreCount != nil {
                    map["CpuCoreCount"] = self.cpuCoreCount!
                }
                if self.cpuOptions != nil {
                    map["CpuOptions"] = self.cpuOptions?.toMap()
                }
                if self.cpuSpeedFrequency != nil {
                    map["CpuSpeedFrequency"] = self.cpuSpeedFrequency!
                }
                if self.cpuTurboFrequency != nil {
                    map["CpuTurboFrequency"] = self.cpuTurboFrequency!
                }
                if self.diskQuantity != nil {
                    map["DiskQuantity"] = self.diskQuantity!
                }
                if self.enhancedNetwork != nil {
                    map["EnhancedNetwork"] = self.enhancedNetwork?.toMap()
                }
                if self.eniIpv6AddressQuantity != nil {
                    map["EniIpv6AddressQuantity"] = self.eniIpv6AddressQuantity!
                }
                if self.eniPrivateIpAddressQuantity != nil {
                    map["EniPrivateIpAddressQuantity"] = self.eniPrivateIpAddressQuantity!
                }
                if self.eniQuantity != nil {
                    map["EniQuantity"] = self.eniQuantity!
                }
                if self.eniTotalQuantity != nil {
                    map["EniTotalQuantity"] = self.eniTotalQuantity!
                }
                if self.eniTrunkSupported != nil {
                    map["EniTrunkSupported"] = self.eniTrunkSupported!
                }
                if self.eriQuantity != nil {
                    map["EriQuantity"] = self.eriQuantity!
                }
                if self.GPUAmount != nil {
                    map["GPUAmount"] = self.GPUAmount!
                }
                if self.GPUMemorySize != nil {
                    map["GPUMemorySize"] = self.GPUMemorySize!
                }
                if self.GPUSpec != nil {
                    map["GPUSpec"] = self.GPUSpec!
                }
                if self.initialCredit != nil {
                    map["InitialCredit"] = self.initialCredit!
                }
                if self.instanceBandwidthRx != nil {
                    map["InstanceBandwidthRx"] = self.instanceBandwidthRx!
                }
                if self.instanceBandwidthTx != nil {
                    map["InstanceBandwidthTx"] = self.instanceBandwidthTx!
                }
                if self.instanceCategory != nil {
                    map["InstanceCategory"] = self.instanceCategory!
                }
                if self.instanceFamilyLevel != nil {
                    map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
                }
                if self.instancePpsRx != nil {
                    map["InstancePpsRx"] = self.instancePpsRx!
                }
                if self.instancePpsTx != nil {
                    map["InstancePpsTx"] = self.instancePpsTx!
                }
                if self.instanceTypeFamily != nil {
                    map["InstanceTypeFamily"] = self.instanceTypeFamily!
                }
                if self.instanceTypeId != nil {
                    map["InstanceTypeId"] = self.instanceTypeId!
                }
                if self.jumboFrameSupport != nil {
                    map["JumboFrameSupport"] = self.jumboFrameSupport!
                }
                if self.localStorageAmount != nil {
                    map["LocalStorageAmount"] = self.localStorageAmount!
                }
                if self.localStorageCapacity != nil {
                    map["LocalStorageCapacity"] = self.localStorageCapacity!
                }
                if self.localStorageCategory != nil {
                    map["LocalStorageCategory"] = self.localStorageCategory!
                }
                if self.maximumQueueNumberPerEni != nil {
                    map["MaximumQueueNumberPerEni"] = self.maximumQueueNumberPerEni!
                }
                if self.memorySize != nil {
                    map["MemorySize"] = self.memorySize!
                }
                if self.networkCardQuantity != nil {
                    map["NetworkCardQuantity"] = self.networkCardQuantity!
                }
                if self.networkCards != nil {
                    map["NetworkCards"] = self.networkCards?.toMap()
                }
                if self.networkEncryptionSupport != nil {
                    map["NetworkEncryptionSupport"] = self.networkEncryptionSupport!
                }
                if self.nvmeSupport != nil {
                    map["NvmeSupport"] = self.nvmeSupport!
                }
                if self.physicalProcessorModel != nil {
                    map["PhysicalProcessorModel"] = self.physicalProcessorModel!
                }
                if self.primaryEniQueueNumber != nil {
                    map["PrimaryEniQueueNumber"] = self.primaryEniQueueNumber!
                }
                if self.queuePairNumber != nil {
                    map["QueuePairNumber"] = self.queuePairNumber!
                }
                if self.secondaryEniQueueNumber != nil {
                    map["SecondaryEniQueueNumber"] = self.secondaryEniQueueNumber!
                }
                if self.supportedBootModes != nil {
                    map["SupportedBootModes"] = self.supportedBootModes?.toMap()
                }
                if self.totalEniQueueQuantity != nil {
                    map["TotalEniQueueQuantity"] = self.totalEniQueueQuantity!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Attributes"] as? [String: Any?] {
                    var model = DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.Attributes()
                    model.fromMap(value)
                    self.attributes = model
                }
                if let value = dict["BaselineCredit"] as? Int32 {
                    self.baselineCredit = value
                }
                if let value = dict["Clock"] as? [String: Any?] {
                    var model = DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.Clock()
                    model.fromMap(value)
                    self.clock = model
                }
                if let value = dict["CpuArchitecture"] as? String {
                    self.cpuArchitecture = value
                }
                if let value = dict["CpuCoreCount"] as? Int32 {
                    self.cpuCoreCount = value
                }
                if let value = dict["CpuOptions"] as? [String: Any?] {
                    var model = DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.CpuOptions()
                    model.fromMap(value)
                    self.cpuOptions = model
                }
                if let value = dict["CpuSpeedFrequency"] as? Double {
                    self.cpuSpeedFrequency = value
                }
                if let value = dict["CpuTurboFrequency"] as? Double {
                    self.cpuTurboFrequency = value
                }
                if let value = dict["DiskQuantity"] as? Int32 {
                    self.diskQuantity = value
                }
                if let value = dict["EnhancedNetwork"] as? [String: Any?] {
                    var model = DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.EnhancedNetwork()
                    model.fromMap(value)
                    self.enhancedNetwork = model
                }
                if let value = dict["EniIpv6AddressQuantity"] as? Int32 {
                    self.eniIpv6AddressQuantity = value
                }
                if let value = dict["EniPrivateIpAddressQuantity"] as? Int32 {
                    self.eniPrivateIpAddressQuantity = value
                }
                if let value = dict["EniQuantity"] as? Int32 {
                    self.eniQuantity = value
                }
                if let value = dict["EniTotalQuantity"] as? Int32 {
                    self.eniTotalQuantity = value
                }
                if let value = dict["EniTrunkSupported"] as? Bool {
                    self.eniTrunkSupported = value
                }
                if let value = dict["EriQuantity"] as? Int32 {
                    self.eriQuantity = value
                }
                if let value = dict["GPUAmount"] as? Int32 {
                    self.GPUAmount = value
                }
                if let value = dict["GPUMemorySize"] as? Double {
                    self.GPUMemorySize = value
                }
                if let value = dict["GPUSpec"] as? String {
                    self.GPUSpec = value
                }
                if let value = dict["InitialCredit"] as? Int32 {
                    self.initialCredit = value
                }
                if let value = dict["InstanceBandwidthRx"] as? Int32 {
                    self.instanceBandwidthRx = value
                }
                if let value = dict["InstanceBandwidthTx"] as? Int32 {
                    self.instanceBandwidthTx = value
                }
                if let value = dict["InstanceCategory"] as? String {
                    self.instanceCategory = value
                }
                if let value = dict["InstanceFamilyLevel"] as? String {
                    self.instanceFamilyLevel = value
                }
                if let value = dict["InstancePpsRx"] as? Int64 {
                    self.instancePpsRx = value
                }
                if let value = dict["InstancePpsTx"] as? Int64 {
                    self.instancePpsTx = value
                }
                if let value = dict["InstanceTypeFamily"] as? String {
                    self.instanceTypeFamily = value
                }
                if let value = dict["InstanceTypeId"] as? String {
                    self.instanceTypeId = value
                }
                if let value = dict["JumboFrameSupport"] as? Bool {
                    self.jumboFrameSupport = value
                }
                if let value = dict["LocalStorageAmount"] as? Int32 {
                    self.localStorageAmount = value
                }
                if let value = dict["LocalStorageCapacity"] as? Int64 {
                    self.localStorageCapacity = value
                }
                if let value = dict["LocalStorageCategory"] as? String {
                    self.localStorageCategory = value
                }
                if let value = dict["MaximumQueueNumberPerEni"] as? Int32 {
                    self.maximumQueueNumberPerEni = value
                }
                if let value = dict["MemorySize"] as? Double {
                    self.memorySize = value
                }
                if let value = dict["NetworkCardQuantity"] as? Int32 {
                    self.networkCardQuantity = value
                }
                if let value = dict["NetworkCards"] as? [String: Any?] {
                    var model = DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.NetworkCards()
                    model.fromMap(value)
                    self.networkCards = model
                }
                if let value = dict["NetworkEncryptionSupport"] as? Bool {
                    self.networkEncryptionSupport = value
                }
                if let value = dict["NvmeSupport"] as? String {
                    self.nvmeSupport = value
                }
                if let value = dict["PhysicalProcessorModel"] as? String {
                    self.physicalProcessorModel = value
                }
                if let value = dict["PrimaryEniQueueNumber"] as? Int32 {
                    self.primaryEniQueueNumber = value
                }
                if let value = dict["QueuePairNumber"] as? Int32 {
                    self.queuePairNumber = value
                }
                if let value = dict["SecondaryEniQueueNumber"] as? Int32 {
                    self.secondaryEniQueueNumber = value
                }
                if let value = dict["SupportedBootModes"] as? [String: Any?] {
                    var model = DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.SupportedBootModes()
                    model.fromMap(value)
                    self.supportedBootModes = model
                }
                if let value = dict["TotalEniQueueQuantity"] as? Int32 {
                    self.totalEniQueueQuantity = value
                }
            }
        }
        public var instanceType: [DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                var tmp : [Any] = []
                for k in self.instanceType! {
                    tmp.append(k.toMap())
                }
                map["InstanceType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceType"] as? [Any?] {
                var tmp : [DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType] = []
                for v in value {
                    if v != nil {
                        var model = DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instanceType = tmp
            }
        }
    }
    public var instanceTypes: DescribeInstanceTypesResponseBody.InstanceTypes?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceTypes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceTypes"] as? [String: Any?] {
            var model = DescribeInstanceTypesResponseBody.InstanceTypes()
            model.fromMap(value)
            self.instanceTypes = model
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeInstanceTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInstanceTypesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInstanceVncUrlRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeInstanceVncUrlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vncUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vncUrl != nil {
            map["VncUrl"] = self.vncUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["VncUrl"] as? String {
            self.vncUrl = value
        }
    }
}

public class DescribeInstanceVncUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceVncUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInstanceVncUrlResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInstancesRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var filter: [DescribeInstancesRequest.Filter]?

    public var additionalAttributes: [String]?

    public var deviceAvailable: Bool?

    public var dryRun: Bool?

    public var eipAddresses: String?

    public var hpcClusterId: String?

    public var httpEndpoint: String?

    public var httpPutResponseHopLimit: Int32?

    public var httpTokens: String?

    public var imageId: String?

    public var innerIpAddresses: String?

    public var instanceChargeType: String?

    public var instanceIds: String?

    public var instanceName: String?

    public var instanceNetworkType: String?

    public var instanceType: String?

    public var instanceTypeFamily: String?

    public var internetChargeType: String?

    public var ioOptimized: Bool?

    public var ipv6Address: [String]?

    public var keyPairName: String?

    public var lockReason: String?

    public var maxResults: Int32?

    public var needSaleCycle: Bool?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var privateIpAddresses: String?

    public var publicIpAddresses: String?

    public var rdmaIpAddresses: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public var status: String?

    public var tag: [DescribeInstancesRequest.Tag]?

    public var vSwitchId: String?

    public var vpcId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.additionalAttributes != nil {
            map["AdditionalAttributes"] = self.additionalAttributes!
        }
        if self.deviceAvailable != nil {
            map["DeviceAvailable"] = self.deviceAvailable!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.eipAddresses != nil {
            map["EipAddresses"] = self.eipAddresses!
        }
        if self.hpcClusterId != nil {
            map["HpcClusterId"] = self.hpcClusterId!
        }
        if self.httpEndpoint != nil {
            map["HttpEndpoint"] = self.httpEndpoint!
        }
        if self.httpPutResponseHopLimit != nil {
            map["HttpPutResponseHopLimit"] = self.httpPutResponseHopLimit!
        }
        if self.httpTokens != nil {
            map["HttpTokens"] = self.httpTokens!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.innerIpAddresses != nil {
            map["InnerIpAddresses"] = self.innerIpAddresses!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceNetworkType != nil {
            map["InstanceNetworkType"] = self.instanceNetworkType!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.instanceTypeFamily != nil {
            map["InstanceTypeFamily"] = self.instanceTypeFamily!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.ipv6Address != nil {
            map["Ipv6Address"] = self.ipv6Address!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.lockReason != nil {
            map["LockReason"] = self.lockReason!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.needSaleCycle != nil {
            map["NeedSaleCycle"] = self.needSaleCycle!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.privateIpAddresses != nil {
            map["PrivateIpAddresses"] = self.privateIpAddresses!
        }
        if self.publicIpAddresses != nil {
            map["PublicIpAddresses"] = self.publicIpAddresses!
        }
        if self.rdmaIpAddresses != nil {
            map["RdmaIpAddresses"] = self.rdmaIpAddresses!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Filter"] as? [Any?] {
            var tmp : [DescribeInstancesRequest.Filter] = []
            for v in value {
                if v != nil {
                    var model = DescribeInstancesRequest.Filter()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.filter = tmp
        }
        if let value = dict["AdditionalAttributes"] as? [String] {
            self.additionalAttributes = value
        }
        if let value = dict["DeviceAvailable"] as? Bool {
            self.deviceAvailable = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["EipAddresses"] as? String {
            self.eipAddresses = value
        }
        if let value = dict["HpcClusterId"] as? String {
            self.hpcClusterId = value
        }
        if let value = dict["HttpEndpoint"] as? String {
            self.httpEndpoint = value
        }
        if let value = dict["HttpPutResponseHopLimit"] as? Int32 {
            self.httpPutResponseHopLimit = value
        }
        if let value = dict["HttpTokens"] as? String {
            self.httpTokens = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["InnerIpAddresses"] as? String {
            self.innerIpAddresses = value
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["InstanceNetworkType"] as? String {
            self.instanceNetworkType = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["InstanceTypeFamily"] as? String {
            self.instanceTypeFamily = value
        }
        if let value = dict["InternetChargeType"] as? String {
            self.internetChargeType = value
        }
        if let value = dict["IoOptimized"] as? Bool {
            self.ioOptimized = value
        }
        if let value = dict["Ipv6Address"] as? [String] {
            self.ipv6Address = value
        }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["LockReason"] as? String {
            self.lockReason = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NeedSaleCycle"] as? Bool {
            self.needSaleCycle = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["PrivateIpAddresses"] as? String {
            self.privateIpAddresses = value
        }
        if let value = dict["PublicIpAddresses"] as? String {
            self.publicIpAddresses = value
        }
        if let value = dict["RdmaIpAddresses"] as? String {
            self.rdmaIpAddresses = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeInstancesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeInstancesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribeInstancesResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public class Instance : Tea.TeaModel {
            public class AdditionalInfo : Tea.TeaModel {
                public var enableHighDensityMode: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.enableHighDensityMode != nil {
                        map["EnableHighDensityMode"] = self.enableHighDensityMode!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["EnableHighDensityMode"] as? Bool {
                        self.enableHighDensityMode = value
                    }
                }
            }
            public class CpuOptions : Tea.TeaModel {
                public var coreCount: Int32?

                public var enableVISST: Bool?

                public var enableVRDT: Bool?

                public var numa: String?

                public var threadsPerCore: Int32?

                public var topologyType: String?

                public var turboMode: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.coreCount != nil {
                        map["CoreCount"] = self.coreCount!
                    }
                    if self.enableVISST != nil {
                        map["EnableVISST"] = self.enableVISST!
                    }
                    if self.enableVRDT != nil {
                        map["EnableVRDT"] = self.enableVRDT!
                    }
                    if self.numa != nil {
                        map["Numa"] = self.numa!
                    }
                    if self.threadsPerCore != nil {
                        map["ThreadsPerCore"] = self.threadsPerCore!
                    }
                    if self.topologyType != nil {
                        map["TopologyType"] = self.topologyType!
                    }
                    if self.turboMode != nil {
                        map["TurboMode"] = self.turboMode!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["CoreCount"] as? Int32 {
                        self.coreCount = value
                    }
                    if let value = dict["EnableVISST"] as? Bool {
                        self.enableVISST = value
                    }
                    if let value = dict["EnableVRDT"] as? Bool {
                        self.enableVRDT = value
                    }
                    if let value = dict["Numa"] as? String {
                        self.numa = value
                    }
                    if let value = dict["ThreadsPerCore"] as? Int32 {
                        self.threadsPerCore = value
                    }
                    if let value = dict["TopologyType"] as? String {
                        self.topologyType = value
                    }
                    if let value = dict["TurboMode"] as? String {
                        self.turboMode = value
                    }
                }
            }
            public class DedicatedHostAttribute : Tea.TeaModel {
                public var dedicatedHostClusterId: String?

                public var dedicatedHostId: String?

                public var dedicatedHostName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dedicatedHostClusterId != nil {
                        map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
                    }
                    if self.dedicatedHostId != nil {
                        map["DedicatedHostId"] = self.dedicatedHostId!
                    }
                    if self.dedicatedHostName != nil {
                        map["DedicatedHostName"] = self.dedicatedHostName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DedicatedHostClusterId"] as? String {
                        self.dedicatedHostClusterId = value
                    }
                    if let value = dict["DedicatedHostId"] as? String {
                        self.dedicatedHostId = value
                    }
                    if let value = dict["DedicatedHostName"] as? String {
                        self.dedicatedHostName = value
                    }
                }
            }
            public class DedicatedInstanceAttribute : Tea.TeaModel {
                public var affinity: String?

                public var tenancy: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.affinity != nil {
                        map["Affinity"] = self.affinity!
                    }
                    if self.tenancy != nil {
                        map["Tenancy"] = self.tenancy!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Affinity"] as? String {
                        self.affinity = value
                    }
                    if let value = dict["Tenancy"] as? String {
                        self.tenancy = value
                    }
                }
            }
            public class EcsCapacityReservationAttr : Tea.TeaModel {
                public var capacityReservationId: String?

                public var capacityReservationPreference: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.capacityReservationId != nil {
                        map["CapacityReservationId"] = self.capacityReservationId!
                    }
                    if self.capacityReservationPreference != nil {
                        map["CapacityReservationPreference"] = self.capacityReservationPreference!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["CapacityReservationId"] as? String {
                        self.capacityReservationId = value
                    }
                    if let value = dict["CapacityReservationPreference"] as? String {
                        self.capacityReservationPreference = value
                    }
                }
            }
            public class EipAddress : Tea.TeaModel {
                public var allocationId: String?

                public var bandwidth: Int32?

                public var internetChargeType: String?

                public var ipAddress: String?

                public var isSupportUnassociate: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.allocationId != nil {
                        map["AllocationId"] = self.allocationId!
                    }
                    if self.bandwidth != nil {
                        map["Bandwidth"] = self.bandwidth!
                    }
                    if self.internetChargeType != nil {
                        map["InternetChargeType"] = self.internetChargeType!
                    }
                    if self.ipAddress != nil {
                        map["IpAddress"] = self.ipAddress!
                    }
                    if self.isSupportUnassociate != nil {
                        map["IsSupportUnassociate"] = self.isSupportUnassociate!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AllocationId"] as? String {
                        self.allocationId = value
                    }
                    if let value = dict["Bandwidth"] as? Int32 {
                        self.bandwidth = value
                    }
                    if let value = dict["InternetChargeType"] as? String {
                        self.internetChargeType = value
                    }
                    if let value = dict["IpAddress"] as? String {
                        self.ipAddress = value
                    }
                    if let value = dict["IsSupportUnassociate"] as? Bool {
                        self.isSupportUnassociate = value
                    }
                }
            }
            public class HibernationOptions : Tea.TeaModel {
                public var configured: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.configured != nil {
                        map["Configured"] = self.configured!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Configured"] as? Bool {
                        self.configured = value
                    }
                }
            }
            public class ImageOptions : Tea.TeaModel {
                public var currentOSNVMeSupported: Bool?

                public var loginAsNonRoot: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.currentOSNVMeSupported != nil {
                        map["CurrentOSNVMeSupported"] = self.currentOSNVMeSupported!
                    }
                    if self.loginAsNonRoot != nil {
                        map["LoginAsNonRoot"] = self.loginAsNonRoot!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["CurrentOSNVMeSupported"] as? Bool {
                        self.currentOSNVMeSupported = value
                    }
                    if let value = dict["LoginAsNonRoot"] as? Bool {
                        self.loginAsNonRoot = value
                    }
                }
            }
            public class InnerIpAddress : Tea.TeaModel {
                public var ipAddress: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipAddress != nil {
                        map["IpAddress"] = self.ipAddress!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["IpAddress"] as? [String] {
                        self.ipAddress = value
                    }
                }
            }
            public class MetadataOptions : Tea.TeaModel {
                public var httpEndpoint: String?

                public var httpPutResponseHopLimit: Int32?

                public var httpTokens: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.httpEndpoint != nil {
                        map["HttpEndpoint"] = self.httpEndpoint!
                    }
                    if self.httpPutResponseHopLimit != nil {
                        map["HttpPutResponseHopLimit"] = self.httpPutResponseHopLimit!
                    }
                    if self.httpTokens != nil {
                        map["HttpTokens"] = self.httpTokens!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["HttpEndpoint"] as? String {
                        self.httpEndpoint = value
                    }
                    if let value = dict["HttpPutResponseHopLimit"] as? Int32 {
                        self.httpPutResponseHopLimit = value
                    }
                    if let value = dict["HttpTokens"] as? String {
                        self.httpTokens = value
                    }
                }
            }
            public class NetworkInterfaces : Tea.TeaModel {
                public class NetworkInterface : Tea.TeaModel {
                    public class Ipv4PrefixSets : Tea.TeaModel {
                        public class Ipv4PrefixSet : Tea.TeaModel {
                            public var ipv4Prefix: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.ipv4Prefix != nil {
                                    map["Ipv4Prefix"] = self.ipv4Prefix!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["Ipv4Prefix"] as? String {
                                    self.ipv4Prefix = value
                                }
                            }
                        }
                        public var ipv4PrefixSet: [DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv4PrefixSets.Ipv4PrefixSet]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.ipv4PrefixSet != nil {
                                var tmp : [Any] = []
                                for k in self.ipv4PrefixSet! {
                                    tmp.append(k.toMap())
                                }
                                map["Ipv4PrefixSet"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Ipv4PrefixSet"] as? [Any?] {
                                var tmp : [DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv4PrefixSets.Ipv4PrefixSet] = []
                                for v in value {
                                    if v != nil {
                                        var model = DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv4PrefixSets.Ipv4PrefixSet()
                                        if v != nil {
                                            model.fromMap(v as? [String: Any?])
                                        }
                                        tmp.append(model)
                                    }
                                }
                                self.ipv4PrefixSet = tmp
                            }
                        }
                    }
                    public class Ipv6PrefixSets : Tea.TeaModel {
                        public class Ipv6PrefixSet : Tea.TeaModel {
                            public var ipv6Prefix: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.ipv6Prefix != nil {
                                    map["Ipv6Prefix"] = self.ipv6Prefix!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["Ipv6Prefix"] as? String {
                                    self.ipv6Prefix = value
                                }
                            }
                        }
                        public var ipv6PrefixSet: [DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv6PrefixSets.Ipv6PrefixSet]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.ipv6PrefixSet != nil {
                                var tmp : [Any] = []
                                for k in self.ipv6PrefixSet! {
                                    tmp.append(k.toMap())
                                }
                                map["Ipv6PrefixSet"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Ipv6PrefixSet"] as? [Any?] {
                                var tmp : [DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv6PrefixSets.Ipv6PrefixSet] = []
                                for v in value {
                                    if v != nil {
                                        var model = DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv6PrefixSets.Ipv6PrefixSet()
                                        if v != nil {
                                            model.fromMap(v as? [String: Any?])
                                        }
                                        tmp.append(model)
                                    }
                                }
                                self.ipv6PrefixSet = tmp
                            }
                        }
                    }
                    public class Ipv6Sets : Tea.TeaModel {
                        public class Ipv6Set : Tea.TeaModel {
                            public var ipv6Address: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.ipv6Address != nil {
                                    map["Ipv6Address"] = self.ipv6Address!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["Ipv6Address"] as? String {
                                    self.ipv6Address = value
                                }
                            }
                        }
                        public var ipv6Set: [DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv6Sets.Ipv6Set]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.ipv6Set != nil {
                                var tmp : [Any] = []
                                for k in self.ipv6Set! {
                                    tmp.append(k.toMap())
                                }
                                map["Ipv6Set"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Ipv6Set"] as? [Any?] {
                                var tmp : [DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv6Sets.Ipv6Set] = []
                                for v in value {
                                    if v != nil {
                                        var model = DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv6Sets.Ipv6Set()
                                        if v != nil {
                                            model.fromMap(v as? [String: Any?])
                                        }
                                        tmp.append(model)
                                    }
                                }
                                self.ipv6Set = tmp
                            }
                        }
                    }
                    public class PrivateIpSets : Tea.TeaModel {
                        public class PrivateIpSet : Tea.TeaModel {
                            public var primary: Bool?

                            public var privateDnsName: String?

                            public var privateIpAddress: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.primary != nil {
                                    map["Primary"] = self.primary!
                                }
                                if self.privateDnsName != nil {
                                    map["PrivateDnsName"] = self.privateDnsName!
                                }
                                if self.privateIpAddress != nil {
                                    map["PrivateIpAddress"] = self.privateIpAddress!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["Primary"] as? Bool {
                                    self.primary = value
                                }
                                if let value = dict["PrivateDnsName"] as? String {
                                    self.privateDnsName = value
                                }
                                if let value = dict["PrivateIpAddress"] as? String {
                                    self.privateIpAddress = value
                                }
                            }
                        }
                        public var privateIpSet: [DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.PrivateIpSets.PrivateIpSet]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.privateIpSet != nil {
                                var tmp : [Any] = []
                                for k in self.privateIpSet! {
                                    tmp.append(k.toMap())
                                }
                                map["PrivateIpSet"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["PrivateIpSet"] as? [Any?] {
                                var tmp : [DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.PrivateIpSets.PrivateIpSet] = []
                                for v in value {
                                    if v != nil {
                                        var model = DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.PrivateIpSets.PrivateIpSet()
                                        if v != nil {
                                            model.fromMap(v as? [String: Any?])
                                        }
                                        tmp.append(model)
                                    }
                                }
                                self.privateIpSet = tmp
                            }
                        }
                    }
                    public var ipv4PrefixSets: DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv4PrefixSets?

                    public var ipv6PrefixSets: DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv6PrefixSets?

                    public var ipv6Sets: DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv6Sets?

                    public var macAddress: String?

                    public var networkInterfaceId: String?

                    public var primaryIpAddress: String?

                    public var privateIpSets: DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.PrivateIpSets?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.ipv4PrefixSets?.validate()
                        try self.ipv6PrefixSets?.validate()
                        try self.ipv6Sets?.validate()
                        try self.privateIpSets?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ipv4PrefixSets != nil {
                            map["Ipv4PrefixSets"] = self.ipv4PrefixSets?.toMap()
                        }
                        if self.ipv6PrefixSets != nil {
                            map["Ipv6PrefixSets"] = self.ipv6PrefixSets?.toMap()
                        }
                        if self.ipv6Sets != nil {
                            map["Ipv6Sets"] = self.ipv6Sets?.toMap()
                        }
                        if self.macAddress != nil {
                            map["MacAddress"] = self.macAddress!
                        }
                        if self.networkInterfaceId != nil {
                            map["NetworkInterfaceId"] = self.networkInterfaceId!
                        }
                        if self.primaryIpAddress != nil {
                            map["PrimaryIpAddress"] = self.primaryIpAddress!
                        }
                        if self.privateIpSets != nil {
                            map["PrivateIpSets"] = self.privateIpSets?.toMap()
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Ipv4PrefixSets"] as? [String: Any?] {
                            var model = DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv4PrefixSets()
                            model.fromMap(value)
                            self.ipv4PrefixSets = model
                        }
                        if let value = dict["Ipv6PrefixSets"] as? [String: Any?] {
                            var model = DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv6PrefixSets()
                            model.fromMap(value)
                            self.ipv6PrefixSets = model
                        }
                        if let value = dict["Ipv6Sets"] as? [String: Any?] {
                            var model = DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv6Sets()
                            model.fromMap(value)
                            self.ipv6Sets = model
                        }
                        if let value = dict["MacAddress"] as? String {
                            self.macAddress = value
                        }
                        if let value = dict["NetworkInterfaceId"] as? String {
                            self.networkInterfaceId = value
                        }
                        if let value = dict["PrimaryIpAddress"] as? String {
                            self.primaryIpAddress = value
                        }
                        if let value = dict["PrivateIpSets"] as? [String: Any?] {
                            var model = DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.PrivateIpSets()
                            model.fromMap(value)
                            self.privateIpSets = model
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                    }
                }
                public var networkInterface: [DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.networkInterface != nil {
                        var tmp : [Any] = []
                        for k in self.networkInterface! {
                            tmp.append(k.toMap())
                        }
                        map["NetworkInterface"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["NetworkInterface"] as? [Any?] {
                        var tmp : [DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.networkInterface = tmp
                    }
                }
            }
            public class OperationLocks : Tea.TeaModel {
                public class LockReason : Tea.TeaModel {
                    public var lockMsg: String?

                    public var lockReason: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.lockMsg != nil {
                            map["LockMsg"] = self.lockMsg!
                        }
                        if self.lockReason != nil {
                            map["LockReason"] = self.lockReason!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["LockMsg"] as? String {
                            self.lockMsg = value
                        }
                        if let value = dict["LockReason"] as? String {
                            self.lockReason = value
                        }
                    }
                }
                public var lockReason: [DescribeInstancesResponseBody.Instances.Instance.OperationLocks.LockReason]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.lockReason != nil {
                        var tmp : [Any] = []
                        for k in self.lockReason! {
                            tmp.append(k.toMap())
                        }
                        map["LockReason"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["LockReason"] as? [Any?] {
                        var tmp : [DescribeInstancesResponseBody.Instances.Instance.OperationLocks.LockReason] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeInstancesResponseBody.Instances.Instance.OperationLocks.LockReason()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.lockReason = tmp
                    }
                }
            }
            public class PrivateDnsNameOptions : Tea.TeaModel {
                public var enableInstanceIdDnsAAAARecord: Bool?

                public var enableInstanceIdDnsARecord: Bool?

                public var enableIpDnsARecord: Bool?

                public var enableIpDnsPtrRecord: Bool?

                public var hostnameType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.enableInstanceIdDnsAAAARecord != nil {
                        map["EnableInstanceIdDnsAAAARecord"] = self.enableInstanceIdDnsAAAARecord!
                    }
                    if self.enableInstanceIdDnsARecord != nil {
                        map["EnableInstanceIdDnsARecord"] = self.enableInstanceIdDnsARecord!
                    }
                    if self.enableIpDnsARecord != nil {
                        map["EnableIpDnsARecord"] = self.enableIpDnsARecord!
                    }
                    if self.enableIpDnsPtrRecord != nil {
                        map["EnableIpDnsPtrRecord"] = self.enableIpDnsPtrRecord!
                    }
                    if self.hostnameType != nil {
                        map["HostnameType"] = self.hostnameType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["EnableInstanceIdDnsAAAARecord"] as? Bool {
                        self.enableInstanceIdDnsAAAARecord = value
                    }
                    if let value = dict["EnableInstanceIdDnsARecord"] as? Bool {
                        self.enableInstanceIdDnsARecord = value
                    }
                    if let value = dict["EnableIpDnsARecord"] as? Bool {
                        self.enableIpDnsARecord = value
                    }
                    if let value = dict["EnableIpDnsPtrRecord"] as? Bool {
                        self.enableIpDnsPtrRecord = value
                    }
                    if let value = dict["HostnameType"] as? String {
                        self.hostnameType = value
                    }
                }
            }
            public class PublicIpAddress : Tea.TeaModel {
                public var ipAddress: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipAddress != nil {
                        map["IpAddress"] = self.ipAddress!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["IpAddress"] as? [String] {
                        self.ipAddress = value
                    }
                }
            }
            public class RdmaIpAddress : Tea.TeaModel {
                public var ipAddress: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipAddress != nil {
                        map["IpAddress"] = self.ipAddress!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["IpAddress"] as? [String] {
                        self.ipAddress = value
                    }
                }
            }
            public class SecurityGroupIds : Tea.TeaModel {
                public var securityGroupId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.securityGroupId != nil {
                        map["SecurityGroupId"] = self.securityGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["SecurityGroupId"] as? [String] {
                        self.securityGroupId = value
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["TagKey"] as? String {
                            self.tagKey = value
                        }
                        if let value = dict["TagValue"] as? String {
                            self.tagValue = value
                        }
                    }
                }
                public var tag: [DescribeInstancesResponseBody.Instances.Instance.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeInstancesResponseBody.Instances.Instance.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeInstancesResponseBody.Instances.Instance.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public class VpcAttributes : Tea.TeaModel {
                public class PrivateIpAddress : Tea.TeaModel {
                    public var ipAddress: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ipAddress != nil {
                            map["IpAddress"] = self.ipAddress!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["IpAddress"] as? [String] {
                            self.ipAddress = value
                        }
                    }
                }
                public var natIpAddress: String?

                public var privateIpAddress: DescribeInstancesResponseBody.Instances.Instance.VpcAttributes.PrivateIpAddress?

                public var vSwitchId: String?

                public var vpcId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.privateIpAddress?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.natIpAddress != nil {
                        map["NatIpAddress"] = self.natIpAddress!
                    }
                    if self.privateIpAddress != nil {
                        map["PrivateIpAddress"] = self.privateIpAddress?.toMap()
                    }
                    if self.vSwitchId != nil {
                        map["VSwitchId"] = self.vSwitchId!
                    }
                    if self.vpcId != nil {
                        map["VpcId"] = self.vpcId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["NatIpAddress"] as? String {
                        self.natIpAddress = value
                    }
                    if let value = dict["PrivateIpAddress"] as? [String: Any?] {
                        var model = DescribeInstancesResponseBody.Instances.Instance.VpcAttributes.PrivateIpAddress()
                        model.fromMap(value)
                        self.privateIpAddress = model
                    }
                    if let value = dict["VSwitchId"] as? String {
                        self.vSwitchId = value
                    }
                    if let value = dict["VpcId"] as? String {
                        self.vpcId = value
                    }
                }
            }
            public var additionalInfo: DescribeInstancesResponseBody.Instances.Instance.AdditionalInfo?

            public var autoReleaseTime: String?

            public var clusterId: String?

            public var cpu: Int32?

            public var cpuOptions: DescribeInstancesResponseBody.Instances.Instance.CpuOptions?

            public var creationTime: String?

            public var creditSpecification: String?

            public var dedicatedHostAttribute: DescribeInstancesResponseBody.Instances.Instance.DedicatedHostAttribute?

            public var dedicatedInstanceAttribute: DescribeInstancesResponseBody.Instances.Instance.DedicatedInstanceAttribute?

            public var deletionProtection: Bool?

            public var deploymentSetGroupNo: Int32?

            public var deploymentSetId: String?

            public var description_: String?

            public var deviceAvailable: Bool?

            public var ecsCapacityReservationAttr: DescribeInstancesResponseBody.Instances.Instance.EcsCapacityReservationAttr?

            public var eipAddress: DescribeInstancesResponseBody.Instances.Instance.EipAddress?

            public var enableNVS: Bool?

            public var expiredTime: String?

            public var GPUAmount: Int32?

            public var GPUSpec: String?

            public var hibernationOptions: DescribeInstancesResponseBody.Instances.Instance.HibernationOptions?

            public var hostName: String?

            public var hpcClusterId: String?

            public var ISP: String?

            public var imageId: String?

            public var imageOptions: DescribeInstancesResponseBody.Instances.Instance.ImageOptions?

            public var innerIpAddress: DescribeInstancesResponseBody.Instances.Instance.InnerIpAddress?

            public var instanceChargeType: String?

            public var instanceId: String?

            public var instanceName: String?

            public var instanceNetworkType: String?

            public var instanceType: String?

            public var instanceTypeFamily: String?

            public var internetChargeType: String?

            public var internetMaxBandwidthIn: Int32?

            public var internetMaxBandwidthOut: Int32?

            public var ioOptimized: Bool?

            public var keyPairName: String?

            public var localStorageAmount: Int32?

            public var localStorageCapacity: Int64?

            public var memory: Int32?

            public var metadataOptions: DescribeInstancesResponseBody.Instances.Instance.MetadataOptions?

            public var networkInterfaces: DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces?

            public var OSName: String?

            public var OSNameEn: String?

            public var OSType: String?

            public var operationLocks: DescribeInstancesResponseBody.Instances.Instance.OperationLocks?

            public var privateDnsNameOptions: DescribeInstancesResponseBody.Instances.Instance.PrivateDnsNameOptions?

            public var publicIpAddress: DescribeInstancesResponseBody.Instances.Instance.PublicIpAddress?

            public var rdmaIpAddress: DescribeInstancesResponseBody.Instances.Instance.RdmaIpAddress?

            public var recyclable: Bool?

            public var regionId: String?

            public var resourceGroupId: String?

            public var saleCycle: String?

            public var securityGroupIds: DescribeInstancesResponseBody.Instances.Instance.SecurityGroupIds?

            public var serialNumber: String?

            public var spotDuration: Int32?

            public var spotInterruptionBehavior: String?

            public var spotPriceLimit: Double?

            public var spotStrategy: String?

            public var startTime: String?

            public var status: String?

            public var stoppedMode: String?

            public var tags: DescribeInstancesResponseBody.Instances.Instance.Tags?

            public var vlanId: String?

            public var vpcAttributes: DescribeInstancesResponseBody.Instances.Instance.VpcAttributes?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.additionalInfo?.validate()
                try self.cpuOptions?.validate()
                try self.dedicatedHostAttribute?.validate()
                try self.dedicatedInstanceAttribute?.validate()
                try self.ecsCapacityReservationAttr?.validate()
                try self.eipAddress?.validate()
                try self.hibernationOptions?.validate()
                try self.imageOptions?.validate()
                try self.innerIpAddress?.validate()
                try self.metadataOptions?.validate()
                try self.networkInterfaces?.validate()
                try self.operationLocks?.validate()
                try self.privateDnsNameOptions?.validate()
                try self.publicIpAddress?.validate()
                try self.rdmaIpAddress?.validate()
                try self.securityGroupIds?.validate()
                try self.tags?.validate()
                try self.vpcAttributes?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.additionalInfo != nil {
                    map["AdditionalInfo"] = self.additionalInfo?.toMap()
                }
                if self.autoReleaseTime != nil {
                    map["AutoReleaseTime"] = self.autoReleaseTime!
                }
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.cpuOptions != nil {
                    map["CpuOptions"] = self.cpuOptions?.toMap()
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.creditSpecification != nil {
                    map["CreditSpecification"] = self.creditSpecification!
                }
                if self.dedicatedHostAttribute != nil {
                    map["DedicatedHostAttribute"] = self.dedicatedHostAttribute?.toMap()
                }
                if self.dedicatedInstanceAttribute != nil {
                    map["DedicatedInstanceAttribute"] = self.dedicatedInstanceAttribute?.toMap()
                }
                if self.deletionProtection != nil {
                    map["DeletionProtection"] = self.deletionProtection!
                }
                if self.deploymentSetGroupNo != nil {
                    map["DeploymentSetGroupNo"] = self.deploymentSetGroupNo!
                }
                if self.deploymentSetId != nil {
                    map["DeploymentSetId"] = self.deploymentSetId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.deviceAvailable != nil {
                    map["DeviceAvailable"] = self.deviceAvailable!
                }
                if self.ecsCapacityReservationAttr != nil {
                    map["EcsCapacityReservationAttr"] = self.ecsCapacityReservationAttr?.toMap()
                }
                if self.eipAddress != nil {
                    map["EipAddress"] = self.eipAddress?.toMap()
                }
                if self.enableNVS != nil {
                    map["EnableNVS"] = self.enableNVS!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.GPUAmount != nil {
                    map["GPUAmount"] = self.GPUAmount!
                }
                if self.GPUSpec != nil {
                    map["GPUSpec"] = self.GPUSpec!
                }
                if self.hibernationOptions != nil {
                    map["HibernationOptions"] = self.hibernationOptions?.toMap()
                }
                if self.hostName != nil {
                    map["HostName"] = self.hostName!
                }
                if self.hpcClusterId != nil {
                    map["HpcClusterId"] = self.hpcClusterId!
                }
                if self.ISP != nil {
                    map["ISP"] = self.ISP!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.imageOptions != nil {
                    map["ImageOptions"] = self.imageOptions?.toMap()
                }
                if self.innerIpAddress != nil {
                    map["InnerIpAddress"] = self.innerIpAddress?.toMap()
                }
                if self.instanceChargeType != nil {
                    map["InstanceChargeType"] = self.instanceChargeType!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.instanceNetworkType != nil {
                    map["InstanceNetworkType"] = self.instanceNetworkType!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.instanceTypeFamily != nil {
                    map["InstanceTypeFamily"] = self.instanceTypeFamily!
                }
                if self.internetChargeType != nil {
                    map["InternetChargeType"] = self.internetChargeType!
                }
                if self.internetMaxBandwidthIn != nil {
                    map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
                }
                if self.internetMaxBandwidthOut != nil {
                    map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
                }
                if self.ioOptimized != nil {
                    map["IoOptimized"] = self.ioOptimized!
                }
                if self.keyPairName != nil {
                    map["KeyPairName"] = self.keyPairName!
                }
                if self.localStorageAmount != nil {
                    map["LocalStorageAmount"] = self.localStorageAmount!
                }
                if self.localStorageCapacity != nil {
                    map["LocalStorageCapacity"] = self.localStorageCapacity!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.metadataOptions != nil {
                    map["MetadataOptions"] = self.metadataOptions?.toMap()
                }
                if self.networkInterfaces != nil {
                    map["NetworkInterfaces"] = self.networkInterfaces?.toMap()
                }
                if self.OSName != nil {
                    map["OSName"] = self.OSName!
                }
                if self.OSNameEn != nil {
                    map["OSNameEn"] = self.OSNameEn!
                }
                if self.OSType != nil {
                    map["OSType"] = self.OSType!
                }
                if self.operationLocks != nil {
                    map["OperationLocks"] = self.operationLocks?.toMap()
                }
                if self.privateDnsNameOptions != nil {
                    map["PrivateDnsNameOptions"] = self.privateDnsNameOptions?.toMap()
                }
                if self.publicIpAddress != nil {
                    map["PublicIpAddress"] = self.publicIpAddress?.toMap()
                }
                if self.rdmaIpAddress != nil {
                    map["RdmaIpAddress"] = self.rdmaIpAddress?.toMap()
                }
                if self.recyclable != nil {
                    map["Recyclable"] = self.recyclable!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.saleCycle != nil {
                    map["SaleCycle"] = self.saleCycle!
                }
                if self.securityGroupIds != nil {
                    map["SecurityGroupIds"] = self.securityGroupIds?.toMap()
                }
                if self.serialNumber != nil {
                    map["SerialNumber"] = self.serialNumber!
                }
                if self.spotDuration != nil {
                    map["SpotDuration"] = self.spotDuration!
                }
                if self.spotInterruptionBehavior != nil {
                    map["SpotInterruptionBehavior"] = self.spotInterruptionBehavior!
                }
                if self.spotPriceLimit != nil {
                    map["SpotPriceLimit"] = self.spotPriceLimit!
                }
                if self.spotStrategy != nil {
                    map["SpotStrategy"] = self.spotStrategy!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.stoppedMode != nil {
                    map["StoppedMode"] = self.stoppedMode!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.vlanId != nil {
                    map["VlanId"] = self.vlanId!
                }
                if self.vpcAttributes != nil {
                    map["VpcAttributes"] = self.vpcAttributes?.toMap()
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AdditionalInfo"] as? [String: Any?] {
                    var model = DescribeInstancesResponseBody.Instances.Instance.AdditionalInfo()
                    model.fromMap(value)
                    self.additionalInfo = model
                }
                if let value = dict["AutoReleaseTime"] as? String {
                    self.autoReleaseTime = value
                }
                if let value = dict["ClusterId"] as? String {
                    self.clusterId = value
                }
                if let value = dict["Cpu"] as? Int32 {
                    self.cpu = value
                }
                if let value = dict["CpuOptions"] as? [String: Any?] {
                    var model = DescribeInstancesResponseBody.Instances.Instance.CpuOptions()
                    model.fromMap(value)
                    self.cpuOptions = model
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["CreditSpecification"] as? String {
                    self.creditSpecification = value
                }
                if let value = dict["DedicatedHostAttribute"] as? [String: Any?] {
                    var model = DescribeInstancesResponseBody.Instances.Instance.DedicatedHostAttribute()
                    model.fromMap(value)
                    self.dedicatedHostAttribute = model
                }
                if let value = dict["DedicatedInstanceAttribute"] as? [String: Any?] {
                    var model = DescribeInstancesResponseBody.Instances.Instance.DedicatedInstanceAttribute()
                    model.fromMap(value)
                    self.dedicatedInstanceAttribute = model
                }
                if let value = dict["DeletionProtection"] as? Bool {
                    self.deletionProtection = value
                }
                if let value = dict["DeploymentSetGroupNo"] as? Int32 {
                    self.deploymentSetGroupNo = value
                }
                if let value = dict["DeploymentSetId"] as? String {
                    self.deploymentSetId = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["DeviceAvailable"] as? Bool {
                    self.deviceAvailable = value
                }
                if let value = dict["EcsCapacityReservationAttr"] as? [String: Any?] {
                    var model = DescribeInstancesResponseBody.Instances.Instance.EcsCapacityReservationAttr()
                    model.fromMap(value)
                    self.ecsCapacityReservationAttr = model
                }
                if let value = dict["EipAddress"] as? [String: Any?] {
                    var model = DescribeInstancesResponseBody.Instances.Instance.EipAddress()
                    model.fromMap(value)
                    self.eipAddress = model
                }
                if let value = dict["EnableNVS"] as? Bool {
                    self.enableNVS = value
                }
                if let value = dict["ExpiredTime"] as? String {
                    self.expiredTime = value
                }
                if let value = dict["GPUAmount"] as? Int32 {
                    self.GPUAmount = value
                }
                if let value = dict["GPUSpec"] as? String {
                    self.GPUSpec = value
                }
                if let value = dict["HibernationOptions"] as? [String: Any?] {
                    var model = DescribeInstancesResponseBody.Instances.Instance.HibernationOptions()
                    model.fromMap(value)
                    self.hibernationOptions = model
                }
                if let value = dict["HostName"] as? String {
                    self.hostName = value
                }
                if let value = dict["HpcClusterId"] as? String {
                    self.hpcClusterId = value
                }
                if let value = dict["ISP"] as? String {
                    self.ISP = value
                }
                if let value = dict["ImageId"] as? String {
                    self.imageId = value
                }
                if let value = dict["ImageOptions"] as? [String: Any?] {
                    var model = DescribeInstancesResponseBody.Instances.Instance.ImageOptions()
                    model.fromMap(value)
                    self.imageOptions = model
                }
                if let value = dict["InnerIpAddress"] as? [String: Any?] {
                    var model = DescribeInstancesResponseBody.Instances.Instance.InnerIpAddress()
                    model.fromMap(value)
                    self.innerIpAddress = model
                }
                if let value = dict["InstanceChargeType"] as? String {
                    self.instanceChargeType = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["InstanceName"] as? String {
                    self.instanceName = value
                }
                if let value = dict["InstanceNetworkType"] as? String {
                    self.instanceNetworkType = value
                }
                if let value = dict["InstanceType"] as? String {
                    self.instanceType = value
                }
                if let value = dict["InstanceTypeFamily"] as? String {
                    self.instanceTypeFamily = value
                }
                if let value = dict["InternetChargeType"] as? String {
                    self.internetChargeType = value
                }
                if let value = dict["InternetMaxBandwidthIn"] as? Int32 {
                    self.internetMaxBandwidthIn = value
                }
                if let value = dict["InternetMaxBandwidthOut"] as? Int32 {
                    self.internetMaxBandwidthOut = value
                }
                if let value = dict["IoOptimized"] as? Bool {
                    self.ioOptimized = value
                }
                if let value = dict["KeyPairName"] as? String {
                    self.keyPairName = value
                }
                if let value = dict["LocalStorageAmount"] as? Int32 {
                    self.localStorageAmount = value
                }
                if let value = dict["LocalStorageCapacity"] as? Int64 {
                    self.localStorageCapacity = value
                }
                if let value = dict["Memory"] as? Int32 {
                    self.memory = value
                }
                if let value = dict["MetadataOptions"] as? [String: Any?] {
                    var model = DescribeInstancesResponseBody.Instances.Instance.MetadataOptions()
                    model.fromMap(value)
                    self.metadataOptions = model
                }
                if let value = dict["NetworkInterfaces"] as? [String: Any?] {
                    var model = DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces()
                    model.fromMap(value)
                    self.networkInterfaces = model
                }
                if let value = dict["OSName"] as? String {
                    self.OSName = value
                }
                if let value = dict["OSNameEn"] as? String {
                    self.OSNameEn = value
                }
                if let value = dict["OSType"] as? String {
                    self.OSType = value
                }
                if let value = dict["OperationLocks"] as? [String: Any?] {
                    var model = DescribeInstancesResponseBody.Instances.Instance.OperationLocks()
                    model.fromMap(value)
                    self.operationLocks = model
                }
                if let value = dict["PrivateDnsNameOptions"] as? [String: Any?] {
                    var model = DescribeInstancesResponseBody.Instances.Instance.PrivateDnsNameOptions()
                    model.fromMap(value)
                    self.privateDnsNameOptions = model
                }
                if let value = dict["PublicIpAddress"] as? [String: Any?] {
                    var model = DescribeInstancesResponseBody.Instances.Instance.PublicIpAddress()
                    model.fromMap(value)
                    self.publicIpAddress = model
                }
                if let value = dict["RdmaIpAddress"] as? [String: Any?] {
                    var model = DescribeInstancesResponseBody.Instances.Instance.RdmaIpAddress()
                    model.fromMap(value)
                    self.rdmaIpAddress = model
                }
                if let value = dict["Recyclable"] as? Bool {
                    self.recyclable = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["SaleCycle"] as? String {
                    self.saleCycle = value
                }
                if let value = dict["SecurityGroupIds"] as? [String: Any?] {
                    var model = DescribeInstancesResponseBody.Instances.Instance.SecurityGroupIds()
                    model.fromMap(value)
                    self.securityGroupIds = model
                }
                if let value = dict["SerialNumber"] as? String {
                    self.serialNumber = value
                }
                if let value = dict["SpotDuration"] as? Int32 {
                    self.spotDuration = value
                }
                if let value = dict["SpotInterruptionBehavior"] as? String {
                    self.spotInterruptionBehavior = value
                }
                if let value = dict["SpotPriceLimit"] as? Double {
                    self.spotPriceLimit = value
                }
                if let value = dict["SpotStrategy"] as? String {
                    self.spotStrategy = value
                }
                if let value = dict["StartTime"] as? String {
                    self.startTime = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["StoppedMode"] as? String {
                    self.stoppedMode = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeInstancesResponseBody.Instances.Instance.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["VlanId"] as? String {
                    self.vlanId = value
                }
                if let value = dict["VpcAttributes"] as? [String: Any?] {
                    var model = DescribeInstancesResponseBody.Instances.Instance.VpcAttributes()
                    model.fromMap(value)
                    self.vpcAttributes = model
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var instance: [DescribeInstancesResponseBody.Instances.Instance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instance != nil {
                var tmp : [Any] = []
                for k in self.instance! {
                    tmp.append(k.toMap())
                }
                map["Instance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Instance"] as? [Any?] {
                var tmp : [DescribeInstancesResponseBody.Instances.Instance] = []
                for v in value {
                    if v != nil {
                        var model = DescribeInstancesResponseBody.Instances.Instance()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instance = tmp
            }
        }
    }
    public var instances: DescribeInstancesResponseBody.Instances?

    public var nextToken: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            map["Instances"] = self.instances?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Instances"] as? [String: Any?] {
            var model = DescribeInstancesResponseBody.Instances()
            model.fromMap(value)
            self.instances = model
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInstancesFullStatusRequest : Tea.TeaModel {
    public class EventPublishTime : Tea.TeaModel {
        public var end: String?

        public var start: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.end != nil {
                map["End"] = self.end!
            }
            if self.start != nil {
                map["Start"] = self.start!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["End"] as? String {
                self.end = value
            }
            if let value = dict["Start"] as? String {
                self.start = value
            }
        }
    }
    public class NotBefore : Tea.TeaModel {
        public var end: String?

        public var start: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.end != nil {
                map["End"] = self.end!
            }
            if self.start != nil {
                map["Start"] = self.start!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["End"] as? String {
                self.end = value
            }
            if let value = dict["Start"] as? String {
                self.start = value
            }
        }
    }
    public var eventPublishTime: DescribeInstancesFullStatusRequest.EventPublishTime?

    public var notBefore: DescribeInstancesFullStatusRequest.NotBefore?

    public var eventId: [String]?

    public var eventType: String?

    public var healthStatus: String?

    public var instanceEventType: [String]?

    public var instanceId: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eventPublishTime?.validate()
        try self.notBefore?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventPublishTime != nil {
            map["EventPublishTime"] = self.eventPublishTime?.toMap()
        }
        if self.notBefore != nil {
            map["NotBefore"] = self.notBefore?.toMap()
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.eventType != nil {
            map["EventType"] = self.eventType!
        }
        if self.healthStatus != nil {
            map["HealthStatus"] = self.healthStatus!
        }
        if self.instanceEventType != nil {
            map["InstanceEventType"] = self.instanceEventType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EventPublishTime"] as? [String: Any?] {
            var model = DescribeInstancesFullStatusRequest.EventPublishTime()
            model.fromMap(value)
            self.eventPublishTime = model
        }
        if let value = dict["NotBefore"] as? [String: Any?] {
            var model = DescribeInstancesFullStatusRequest.NotBefore()
            model.fromMap(value)
            self.notBefore = model
        }
        if let value = dict["EventId"] as? [String] {
            self.eventId = value
        }
        if let value = dict["EventType"] as? String {
            self.eventType = value
        }
        if let value = dict["HealthStatus"] as? String {
            self.healthStatus = value
        }
        if let value = dict["InstanceEventType"] as? [String] {
            self.instanceEventType = value
        }
        if let value = dict["InstanceId"] as? [String] {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class DescribeInstancesFullStatusResponseBody : Tea.TeaModel {
    public class InstanceFullStatusSet : Tea.TeaModel {
        public class InstanceFullStatusType : Tea.TeaModel {
            public class HealthStatus : Tea.TeaModel {
                public var code: Int32?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Code"] as? Int32 {
                        self.code = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                }
            }
            public class ScheduledSystemEventSet : Tea.TeaModel {
                public class ScheduledSystemEventType : Tea.TeaModel {
                    public class EventCycleStatus : Tea.TeaModel {
                        public var code: Int32?

                        public var name: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.code != nil {
                                map["Code"] = self.code!
                            }
                            if self.name != nil {
                                map["Name"] = self.name!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Code"] as? Int32 {
                                self.code = value
                            }
                            if let value = dict["Name"] as? String {
                                self.name = value
                            }
                        }
                    }
                    public class EventType : Tea.TeaModel {
                        public var code: Int32?

                        public var name: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.code != nil {
                                map["Code"] = self.code!
                            }
                            if self.name != nil {
                                map["Name"] = self.name!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Code"] as? Int32 {
                                self.code = value
                            }
                            if let value = dict["Name"] as? String {
                                self.name = value
                            }
                        }
                    }
                    public class ExtendedAttribute : Tea.TeaModel {
                        public class InactiveDisks : Tea.TeaModel {
                            public class InactiveDisk : Tea.TeaModel {
                                public var creationTime: String?

                                public var deviceCategory: String?

                                public var deviceSize: String?

                                public var deviceType: String?

                                public var releaseTime: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.creationTime != nil {
                                        map["CreationTime"] = self.creationTime!
                                    }
                                    if self.deviceCategory != nil {
                                        map["DeviceCategory"] = self.deviceCategory!
                                    }
                                    if self.deviceSize != nil {
                                        map["DeviceSize"] = self.deviceSize!
                                    }
                                    if self.deviceType != nil {
                                        map["DeviceType"] = self.deviceType!
                                    }
                                    if self.releaseTime != nil {
                                        map["ReleaseTime"] = self.releaseTime!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                    guard let dict else { return }
                                    if let value = dict["CreationTime"] as? String {
                                        self.creationTime = value
                                    }
                                    if let value = dict["DeviceCategory"] as? String {
                                        self.deviceCategory = value
                                    }
                                    if let value = dict["DeviceSize"] as? String {
                                        self.deviceSize = value
                                    }
                                    if let value = dict["DeviceType"] as? String {
                                        self.deviceType = value
                                    }
                                    if let value = dict["ReleaseTime"] as? String {
                                        self.releaseTime = value
                                    }
                                }
                            }
                            public var inactiveDisk: [DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet.ScheduledSystemEventType.ExtendedAttribute.InactiveDisks.InactiveDisk]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.inactiveDisk != nil {
                                    var tmp : [Any] = []
                                    for k in self.inactiveDisk! {
                                        tmp.append(k.toMap())
                                    }
                                    map["InactiveDisk"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["InactiveDisk"] as? [Any?] {
                                    var tmp : [DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet.ScheduledSystemEventType.ExtendedAttribute.InactiveDisks.InactiveDisk] = []
                                    for v in value {
                                        if v != nil {
                                            var model = DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet.ScheduledSystemEventType.ExtendedAttribute.InactiveDisks.InactiveDisk()
                                            if v != nil {
                                                model.fromMap(v as? [String: Any?])
                                            }
                                            tmp.append(model)
                                        }
                                    }
                                    self.inactiveDisk = tmp
                                }
                            }
                        }
                        public var device: String?

                        public var diskId: String?

                        public var inactiveDisks: DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet.ScheduledSystemEventType.ExtendedAttribute.InactiveDisks?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.inactiveDisks?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.device != nil {
                                map["Device"] = self.device!
                            }
                            if self.diskId != nil {
                                map["DiskId"] = self.diskId!
                            }
                            if self.inactiveDisks != nil {
                                map["InactiveDisks"] = self.inactiveDisks?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Device"] as? String {
                                self.device = value
                            }
                            if let value = dict["DiskId"] as? String {
                                self.diskId = value
                            }
                            if let value = dict["InactiveDisks"] as? [String: Any?] {
                                var model = DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet.ScheduledSystemEventType.ExtendedAttribute.InactiveDisks()
                                model.fromMap(value)
                                self.inactiveDisks = model
                            }
                        }
                    }
                    public var eventCycleStatus: DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet.ScheduledSystemEventType.EventCycleStatus?

                    public var eventId: String?

                    public var eventPublishTime: String?

                    public var eventType: DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet.ScheduledSystemEventType.EventType?

                    public var extendedAttribute: DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet.ScheduledSystemEventType.ExtendedAttribute?

                    public var impactLevel: String?

                    public var notBefore: String?

                    public var reason: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.eventCycleStatus?.validate()
                        try self.eventType?.validate()
                        try self.extendedAttribute?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.eventCycleStatus != nil {
                            map["EventCycleStatus"] = self.eventCycleStatus?.toMap()
                        }
                        if self.eventId != nil {
                            map["EventId"] = self.eventId!
                        }
                        if self.eventPublishTime != nil {
                            map["EventPublishTime"] = self.eventPublishTime!
                        }
                        if self.eventType != nil {
                            map["EventType"] = self.eventType?.toMap()
                        }
                        if self.extendedAttribute != nil {
                            map["ExtendedAttribute"] = self.extendedAttribute?.toMap()
                        }
                        if self.impactLevel != nil {
                            map["ImpactLevel"] = self.impactLevel!
                        }
                        if self.notBefore != nil {
                            map["NotBefore"] = self.notBefore!
                        }
                        if self.reason != nil {
                            map["Reason"] = self.reason!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["EventCycleStatus"] as? [String: Any?] {
                            var model = DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet.ScheduledSystemEventType.EventCycleStatus()
                            model.fromMap(value)
                            self.eventCycleStatus = model
                        }
                        if let value = dict["EventId"] as? String {
                            self.eventId = value
                        }
                        if let value = dict["EventPublishTime"] as? String {
                            self.eventPublishTime = value
                        }
                        if let value = dict["EventType"] as? [String: Any?] {
                            var model = DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet.ScheduledSystemEventType.EventType()
                            model.fromMap(value)
                            self.eventType = model
                        }
                        if let value = dict["ExtendedAttribute"] as? [String: Any?] {
                            var model = DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet.ScheduledSystemEventType.ExtendedAttribute()
                            model.fromMap(value)
                            self.extendedAttribute = model
                        }
                        if let value = dict["ImpactLevel"] as? String {
                            self.impactLevel = value
                        }
                        if let value = dict["NotBefore"] as? String {
                            self.notBefore = value
                        }
                        if let value = dict["Reason"] as? String {
                            self.reason = value
                        }
                    }
                }
                public var scheduledSystemEventType: [DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet.ScheduledSystemEventType]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.scheduledSystemEventType != nil {
                        var tmp : [Any] = []
                        for k in self.scheduledSystemEventType! {
                            tmp.append(k.toMap())
                        }
                        map["ScheduledSystemEventType"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ScheduledSystemEventType"] as? [Any?] {
                        var tmp : [DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet.ScheduledSystemEventType] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet.ScheduledSystemEventType()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.scheduledSystemEventType = tmp
                    }
                }
            }
            public class Status : Tea.TeaModel {
                public var code: Int32?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Code"] as? Int32 {
                        self.code = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                }
            }
            public var healthStatus: DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.HealthStatus?

            public var instanceId: String?

            public var scheduledSystemEventSet: DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet?

            public var status: DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.Status?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.healthStatus?.validate()
                try self.scheduledSystemEventSet?.validate()
                try self.status?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.scheduledSystemEventSet != nil {
                    map["ScheduledSystemEventSet"] = self.scheduledSystemEventSet?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["HealthStatus"] as? [String: Any?] {
                    var model = DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.HealthStatus()
                    model.fromMap(value)
                    self.healthStatus = model
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["ScheduledSystemEventSet"] as? [String: Any?] {
                    var model = DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet()
                    model.fromMap(value)
                    self.scheduledSystemEventSet = model
                }
                if let value = dict["Status"] as? [String: Any?] {
                    var model = DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.Status()
                    model.fromMap(value)
                    self.status = model
                }
            }
        }
        public var instanceFullStatusType: [DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceFullStatusType != nil {
                var tmp : [Any] = []
                for k in self.instanceFullStatusType! {
                    tmp.append(k.toMap())
                }
                map["InstanceFullStatusType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceFullStatusType"] as? [Any?] {
                var tmp : [DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType] = []
                for v in value {
                    if v != nil {
                        var model = DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instanceFullStatusType = tmp
            }
        }
    }
    public var instanceFullStatusSet: DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceFullStatusSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceFullStatusSet != nil {
            map["InstanceFullStatusSet"] = self.instanceFullStatusSet?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceFullStatusSet"] as? [String: Any?] {
            var model = DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet()
            model.fromMap(value)
            self.instanceFullStatusSet = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeInstancesFullStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstancesFullStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInstancesFullStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInvocationResultsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var commandId: String?

    public var contentEncoding: String?

    public var includeHistory: Bool?

    public var instanceId: String?

    public var invokeId: String?

    public var invokeRecordStatus: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeInvocationResultsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandId != nil {
            map["CommandId"] = self.commandId!
        }
        if self.contentEncoding != nil {
            map["ContentEncoding"] = self.contentEncoding!
        }
        if self.includeHistory != nil {
            map["IncludeHistory"] = self.includeHistory!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.invokeId != nil {
            map["InvokeId"] = self.invokeId!
        }
        if self.invokeRecordStatus != nil {
            map["InvokeRecordStatus"] = self.invokeRecordStatus!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CommandId"] as? String {
            self.commandId = value
        }
        if let value = dict["ContentEncoding"] as? String {
            self.contentEncoding = value
        }
        if let value = dict["IncludeHistory"] as? Bool {
            self.includeHistory = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InvokeId"] as? String {
            self.invokeId = value
        }
        if let value = dict["InvokeRecordStatus"] as? String {
            self.invokeRecordStatus = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeInvocationResultsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeInvocationResultsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribeInvocationResultsResponseBody : Tea.TeaModel {
    public class Invocation : Tea.TeaModel {
        public class InvocationResults : Tea.TeaModel {
            public class InvocationResult : Tea.TeaModel {
                public class Tags : Tea.TeaModel {
                    public class Tag : Tea.TeaModel {
                        public var tagKey: String?

                        public var tagValue: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.tagKey != nil {
                                map["TagKey"] = self.tagKey!
                            }
                            if self.tagValue != nil {
                                map["TagValue"] = self.tagValue!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["TagKey"] as? String {
                                self.tagKey = value
                            }
                            if let value = dict["TagValue"] as? String {
                                self.tagValue = value
                            }
                        }
                    }
                    public var tag: [DescribeInvocationResultsResponseBody.Invocation.InvocationResults.InvocationResult.Tags.Tag]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tag != nil {
                            var tmp : [Any] = []
                            for k in self.tag! {
                                tmp.append(k.toMap())
                            }
                            map["Tag"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Tag"] as? [Any?] {
                            var tmp : [DescribeInvocationResultsResponseBody.Invocation.InvocationResults.InvocationResult.Tags.Tag] = []
                            for v in value {
                                if v != nil {
                                    var model = DescribeInvocationResultsResponseBody.Invocation.InvocationResults.InvocationResult.Tags.Tag()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.tag = tmp
                        }
                    }
                }
                public var commandId: String?

                public var containerId: String?

                public var containerName: String?

                public var dropped: Int32?

                public var errorCode: String?

                public var errorInfo: String?

                public var exitCode: Int64?

                public var finishedTime: String?

                public var instanceId: String?

                public var invocationStatus: String?

                public var invokeId: String?

                public var invokeRecordStatus: String?

                public var launcher: String?

                public var output: String?

                public var repeats: Int32?

                public var startTime: String?

                public var stopTime: String?

                public var tags: DescribeInvocationResultsResponseBody.Invocation.InvocationResults.InvocationResult.Tags?

                public var terminationMode: String?

                public var username: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.tags?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.commandId != nil {
                        map["CommandId"] = self.commandId!
                    }
                    if self.containerId != nil {
                        map["ContainerId"] = self.containerId!
                    }
                    if self.containerName != nil {
                        map["ContainerName"] = self.containerName!
                    }
                    if self.dropped != nil {
                        map["Dropped"] = self.dropped!
                    }
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorInfo != nil {
                        map["ErrorInfo"] = self.errorInfo!
                    }
                    if self.exitCode != nil {
                        map["ExitCode"] = self.exitCode!
                    }
                    if self.finishedTime != nil {
                        map["FinishedTime"] = self.finishedTime!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.invocationStatus != nil {
                        map["InvocationStatus"] = self.invocationStatus!
                    }
                    if self.invokeId != nil {
                        map["InvokeId"] = self.invokeId!
                    }
                    if self.invokeRecordStatus != nil {
                        map["InvokeRecordStatus"] = self.invokeRecordStatus!
                    }
                    if self.launcher != nil {
                        map["Launcher"] = self.launcher!
                    }
                    if self.output != nil {
                        map["Output"] = self.output!
                    }
                    if self.repeats != nil {
                        map["Repeats"] = self.repeats!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.stopTime != nil {
                        map["StopTime"] = self.stopTime!
                    }
                    if self.tags != nil {
                        map["Tags"] = self.tags?.toMap()
                    }
                    if self.terminationMode != nil {
                        map["TerminationMode"] = self.terminationMode!
                    }
                    if self.username != nil {
                        map["Username"] = self.username!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["CommandId"] as? String {
                        self.commandId = value
                    }
                    if let value = dict["ContainerId"] as? String {
                        self.containerId = value
                    }
                    if let value = dict["ContainerName"] as? String {
                        self.containerName = value
                    }
                    if let value = dict["Dropped"] as? Int32 {
                        self.dropped = value
                    }
                    if let value = dict["ErrorCode"] as? String {
                        self.errorCode = value
                    }
                    if let value = dict["ErrorInfo"] as? String {
                        self.errorInfo = value
                    }
                    if let value = dict["ExitCode"] as? Int64 {
                        self.exitCode = value
                    }
                    if let value = dict["FinishedTime"] as? String {
                        self.finishedTime = value
                    }
                    if let value = dict["InstanceId"] as? String {
                        self.instanceId = value
                    }
                    if let value = dict["InvocationStatus"] as? String {
                        self.invocationStatus = value
                    }
                    if let value = dict["InvokeId"] as? String {
                        self.invokeId = value
                    }
                    if let value = dict["InvokeRecordStatus"] as? String {
                        self.invokeRecordStatus = value
                    }
                    if let value = dict["Launcher"] as? String {
                        self.launcher = value
                    }
                    if let value = dict["Output"] as? String {
                        self.output = value
                    }
                    if let value = dict["Repeats"] as? Int32 {
                        self.repeats = value
                    }
                    if let value = dict["StartTime"] as? String {
                        self.startTime = value
                    }
                    if let value = dict["StopTime"] as? String {
                        self.stopTime = value
                    }
                    if let value = dict["Tags"] as? [String: Any?] {
                        var model = DescribeInvocationResultsResponseBody.Invocation.InvocationResults.InvocationResult.Tags()
                        model.fromMap(value)
                        self.tags = model
                    }
                    if let value = dict["TerminationMode"] as? String {
                        self.terminationMode = value
                    }
                    if let value = dict["Username"] as? String {
                        self.username = value
                    }
                }
            }
            public var invocationResult: [DescribeInvocationResultsResponseBody.Invocation.InvocationResults.InvocationResult]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.invocationResult != nil {
                    var tmp : [Any] = []
                    for k in self.invocationResult! {
                        tmp.append(k.toMap())
                    }
                    map["InvocationResult"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["InvocationResult"] as? [Any?] {
                    var tmp : [DescribeInvocationResultsResponseBody.Invocation.InvocationResults.InvocationResult] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeInvocationResultsResponseBody.Invocation.InvocationResults.InvocationResult()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.invocationResult = tmp
                }
            }
        }
        public var invocationResults: DescribeInvocationResultsResponseBody.Invocation.InvocationResults?

        public var nextToken: String?

        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.invocationResults?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.invocationResults != nil {
                map["InvocationResults"] = self.invocationResults?.toMap()
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InvocationResults"] as? [String: Any?] {
                var model = DescribeInvocationResultsResponseBody.Invocation.InvocationResults()
                model.fromMap(value)
                self.invocationResults = model
            }
            if let value = dict["NextToken"] as? String {
                self.nextToken = value
            }
            if let value = dict["PageNumber"] as? Int64 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int64 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var invocation: DescribeInvocationResultsResponseBody.Invocation?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.invocation?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.invocation != nil {
            map["Invocation"] = self.invocation?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Invocation"] as? [String: Any?] {
            var model = DescribeInvocationResultsResponseBody.Invocation()
            model.fromMap(value)
            self.invocation = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeInvocationResultsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInvocationResultsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInvocationResultsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInvocationsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var commandId: String?

    public var commandName: String?

    public var commandType: String?

    public var contentEncoding: String?

    public var includeOutput: Bool?

    public var instanceId: String?

    public var invokeId: String?

    public var invokeStatus: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var repeatMode: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeInvocationsRequest.Tag]?

    public var timed: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandId != nil {
            map["CommandId"] = self.commandId!
        }
        if self.commandName != nil {
            map["CommandName"] = self.commandName!
        }
        if self.commandType != nil {
            map["CommandType"] = self.commandType!
        }
        if self.contentEncoding != nil {
            map["ContentEncoding"] = self.contentEncoding!
        }
        if self.includeOutput != nil {
            map["IncludeOutput"] = self.includeOutput!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.invokeId != nil {
            map["InvokeId"] = self.invokeId!
        }
        if self.invokeStatus != nil {
            map["InvokeStatus"] = self.invokeStatus!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.repeatMode != nil {
            map["RepeatMode"] = self.repeatMode!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.timed != nil {
            map["Timed"] = self.timed!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CommandId"] as? String {
            self.commandId = value
        }
        if let value = dict["CommandName"] as? String {
            self.commandName = value
        }
        if let value = dict["CommandType"] as? String {
            self.commandType = value
        }
        if let value = dict["ContentEncoding"] as? String {
            self.contentEncoding = value
        }
        if let value = dict["IncludeOutput"] as? Bool {
            self.includeOutput = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InvokeId"] as? String {
            self.invokeId = value
        }
        if let value = dict["InvokeStatus"] as? String {
            self.invokeStatus = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RepeatMode"] as? String {
            self.repeatMode = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeInvocationsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeInvocationsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["Timed"] as? Bool {
            self.timed = value
        }
    }
}

public class DescribeInvocationsResponseBody : Tea.TeaModel {
    public class Invocations : Tea.TeaModel {
        public class Invocation : Tea.TeaModel {
            public class InvokeInstances : Tea.TeaModel {
                public class InvokeInstance : Tea.TeaModel {
                    public var creationTime: String?

                    public var dropped: Int32?

                    public var errorCode: String?

                    public var errorInfo: String?

                    public var exitCode: Int64?

                    public var finishTime: String?

                    public var instanceId: String?

                    public var instanceInvokeStatus: String?

                    public var invocationStatus: String?

                    public var output: String?

                    public var repeats: Int32?

                    public var startTime: String?

                    public var stopTime: String?

                    public var timed: Bool?

                    public var updateTime: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.creationTime != nil {
                            map["CreationTime"] = self.creationTime!
                        }
                        if self.dropped != nil {
                            map["Dropped"] = self.dropped!
                        }
                        if self.errorCode != nil {
                            map["ErrorCode"] = self.errorCode!
                        }
                        if self.errorInfo != nil {
                            map["ErrorInfo"] = self.errorInfo!
                        }
                        if self.exitCode != nil {
                            map["ExitCode"] = self.exitCode!
                        }
                        if self.finishTime != nil {
                            map["FinishTime"] = self.finishTime!
                        }
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.instanceInvokeStatus != nil {
                            map["InstanceInvokeStatus"] = self.instanceInvokeStatus!
                        }
                        if self.invocationStatus != nil {
                            map["InvocationStatus"] = self.invocationStatus!
                        }
                        if self.output != nil {
                            map["Output"] = self.output!
                        }
                        if self.repeats != nil {
                            map["Repeats"] = self.repeats!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        if self.stopTime != nil {
                            map["StopTime"] = self.stopTime!
                        }
                        if self.timed != nil {
                            map["Timed"] = self.timed!
                        }
                        if self.updateTime != nil {
                            map["UpdateTime"] = self.updateTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["CreationTime"] as? String {
                            self.creationTime = value
                        }
                        if let value = dict["Dropped"] as? Int32 {
                            self.dropped = value
                        }
                        if let value = dict["ErrorCode"] as? String {
                            self.errorCode = value
                        }
                        if let value = dict["ErrorInfo"] as? String {
                            self.errorInfo = value
                        }
                        if let value = dict["ExitCode"] as? Int64 {
                            self.exitCode = value
                        }
                        if let value = dict["FinishTime"] as? String {
                            self.finishTime = value
                        }
                        if let value = dict["InstanceId"] as? String {
                            self.instanceId = value
                        }
                        if let value = dict["InstanceInvokeStatus"] as? String {
                            self.instanceInvokeStatus = value
                        }
                        if let value = dict["InvocationStatus"] as? String {
                            self.invocationStatus = value
                        }
                        if let value = dict["Output"] as? String {
                            self.output = value
                        }
                        if let value = dict["Repeats"] as? Int32 {
                            self.repeats = value
                        }
                        if let value = dict["StartTime"] as? String {
                            self.startTime = value
                        }
                        if let value = dict["StopTime"] as? String {
                            self.stopTime = value
                        }
                        if let value = dict["Timed"] as? Bool {
                            self.timed = value
                        }
                        if let value = dict["UpdateTime"] as? String {
                            self.updateTime = value
                        }
                    }
                }
                public var invokeInstance: [DescribeInvocationsResponseBody.Invocations.Invocation.InvokeInstances.InvokeInstance]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.invokeInstance != nil {
                        var tmp : [Any] = []
                        for k in self.invokeInstance! {
                            tmp.append(k.toMap())
                        }
                        map["InvokeInstance"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["InvokeInstance"] as? [Any?] {
                        var tmp : [DescribeInvocationsResponseBody.Invocations.Invocation.InvokeInstances.InvokeInstance] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeInvocationsResponseBody.Invocations.Invocation.InvokeInstances.InvokeInstance()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.invokeInstance = tmp
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["TagKey"] as? String {
                            self.tagKey = value
                        }
                        if let value = dict["TagValue"] as? String {
                            self.tagValue = value
                        }
                    }
                }
                public var tag: [DescribeInvocationsResponseBody.Invocations.Invocation.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeInvocationsResponseBody.Invocations.Invocation.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeInvocationsResponseBody.Invocations.Invocation.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var commandContent: String?

            public var commandDescription: String?

            public var commandId: String?

            public var commandName: String?

            public var commandType: String?

            public var containerId: String?

            public var containerName: String?

            public var creationTime: String?

            public var frequency: String?

            public var invocationStatus: String?

            public var invokeId: String?

            public var invokeInstances: DescribeInvocationsResponseBody.Invocations.Invocation.InvokeInstances?

            public var invokeStatus: String?

            public var launcher: String?

            public var parameters: String?

            public var repeatMode: String?

            public var tags: DescribeInvocationsResponseBody.Invocations.Invocation.Tags?

            public var terminationMode: String?

            public var timed: Bool?

            public var timeout: Int64?

            public var username: String?

            public var workingDir: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.invokeInstances?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.commandContent != nil {
                    map["CommandContent"] = self.commandContent!
                }
                if self.commandDescription != nil {
                    map["CommandDescription"] = self.commandDescription!
                }
                if self.commandId != nil {
                    map["CommandId"] = self.commandId!
                }
                if self.commandName != nil {
                    map["CommandName"] = self.commandName!
                }
                if self.commandType != nil {
                    map["CommandType"] = self.commandType!
                }
                if self.containerId != nil {
                    map["ContainerId"] = self.containerId!
                }
                if self.containerName != nil {
                    map["ContainerName"] = self.containerName!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.frequency != nil {
                    map["Frequency"] = self.frequency!
                }
                if self.invocationStatus != nil {
                    map["InvocationStatus"] = self.invocationStatus!
                }
                if self.invokeId != nil {
                    map["InvokeId"] = self.invokeId!
                }
                if self.invokeInstances != nil {
                    map["InvokeInstances"] = self.invokeInstances?.toMap()
                }
                if self.invokeStatus != nil {
                    map["InvokeStatus"] = self.invokeStatus!
                }
                if self.launcher != nil {
                    map["Launcher"] = self.launcher!
                }
                if self.parameters != nil {
                    map["Parameters"] = self.parameters!
                }
                if self.repeatMode != nil {
                    map["RepeatMode"] = self.repeatMode!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.terminationMode != nil {
                    map["TerminationMode"] = self.terminationMode!
                }
                if self.timed != nil {
                    map["Timed"] = self.timed!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.username != nil {
                    map["Username"] = self.username!
                }
                if self.workingDir != nil {
                    map["WorkingDir"] = self.workingDir!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CommandContent"] as? String {
                    self.commandContent = value
                }
                if let value = dict["CommandDescription"] as? String {
                    self.commandDescription = value
                }
                if let value = dict["CommandId"] as? String {
                    self.commandId = value
                }
                if let value = dict["CommandName"] as? String {
                    self.commandName = value
                }
                if let value = dict["CommandType"] as? String {
                    self.commandType = value
                }
                if let value = dict["ContainerId"] as? String {
                    self.containerId = value
                }
                if let value = dict["ContainerName"] as? String {
                    self.containerName = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Frequency"] as? String {
                    self.frequency = value
                }
                if let value = dict["InvocationStatus"] as? String {
                    self.invocationStatus = value
                }
                if let value = dict["InvokeId"] as? String {
                    self.invokeId = value
                }
                if let value = dict["InvokeInstances"] as? [String: Any?] {
                    var model = DescribeInvocationsResponseBody.Invocations.Invocation.InvokeInstances()
                    model.fromMap(value)
                    self.invokeInstances = model
                }
                if let value = dict["InvokeStatus"] as? String {
                    self.invokeStatus = value
                }
                if let value = dict["Launcher"] as? String {
                    self.launcher = value
                }
                if let value = dict["Parameters"] as? String {
                    self.parameters = value
                }
                if let value = dict["RepeatMode"] as? String {
                    self.repeatMode = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeInvocationsResponseBody.Invocations.Invocation.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["TerminationMode"] as? String {
                    self.terminationMode = value
                }
                if let value = dict["Timed"] as? Bool {
                    self.timed = value
                }
                if let value = dict["Timeout"] as? Int64 {
                    self.timeout = value
                }
                if let value = dict["Username"] as? String {
                    self.username = value
                }
                if let value = dict["WorkingDir"] as? String {
                    self.workingDir = value
                }
            }
        }
        public var invocation: [DescribeInvocationsResponseBody.Invocations.Invocation]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.invocation != nil {
                var tmp : [Any] = []
                for k in self.invocation! {
                    tmp.append(k.toMap())
                }
                map["Invocation"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Invocation"] as? [Any?] {
                var tmp : [DescribeInvocationsResponseBody.Invocations.Invocation] = []
                for v in value {
                    if v != nil {
                        var model = DescribeInvocationsResponseBody.Invocations.Invocation()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.invocation = tmp
            }
        }
    }
    public var invocations: DescribeInvocationsResponseBody.Invocations?

    public var nextToken: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.invocations?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.invocations != nil {
            map["Invocations"] = self.invocations?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Invocations"] as? [String: Any?] {
            var model = DescribeInvocationsResponseBody.Invocations()
            model.fromMap(value)
            self.invocations = model
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribeInvocationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInvocationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInvocationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeKeyPairsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var includePublicKey: Bool?

    public var keyPairFingerPrint: String?

    public var keyPairName: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeKeyPairsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.includePublicKey != nil {
            map["IncludePublicKey"] = self.includePublicKey!
        }
        if self.keyPairFingerPrint != nil {
            map["KeyPairFingerPrint"] = self.keyPairFingerPrint!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IncludePublicKey"] as? Bool {
            self.includePublicKey = value
        }
        if let value = dict["KeyPairFingerPrint"] as? String {
            self.keyPairFingerPrint = value
        }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeKeyPairsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeKeyPairsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribeKeyPairsResponseBody : Tea.TeaModel {
    public class KeyPairs : Tea.TeaModel {
        public class KeyPair : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["TagKey"] as? String {
                            self.tagKey = value
                        }
                        if let value = dict["TagValue"] as? String {
                            self.tagValue = value
                        }
                    }
                }
                public var tag: [DescribeKeyPairsResponseBody.KeyPairs.KeyPair.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeKeyPairsResponseBody.KeyPairs.KeyPair.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeKeyPairsResponseBody.KeyPairs.KeyPair.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var creationTime: String?

            public var keyPairFingerPrint: String?

            public var keyPairName: String?

            public var publicKey: String?

            public var resourceGroupId: String?

            public var tags: DescribeKeyPairsResponseBody.KeyPairs.KeyPair.Tags?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.keyPairFingerPrint != nil {
                    map["KeyPairFingerPrint"] = self.keyPairFingerPrint!
                }
                if self.keyPairName != nil {
                    map["KeyPairName"] = self.keyPairName!
                }
                if self.publicKey != nil {
                    map["PublicKey"] = self.publicKey!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["KeyPairFingerPrint"] as? String {
                    self.keyPairFingerPrint = value
                }
                if let value = dict["KeyPairName"] as? String {
                    self.keyPairName = value
                }
                if let value = dict["PublicKey"] as? String {
                    self.publicKey = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeKeyPairsResponseBody.KeyPairs.KeyPair.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
            }
        }
        public var keyPair: [DescribeKeyPairsResponseBody.KeyPairs.KeyPair]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.keyPair != nil {
                var tmp : [Any] = []
                for k in self.keyPair! {
                    tmp.append(k.toMap())
                }
                map["KeyPair"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["KeyPair"] as? [Any?] {
                var tmp : [DescribeKeyPairsResponseBody.KeyPairs.KeyPair] = []
                for v in value {
                    if v != nil {
                        var model = DescribeKeyPairsResponseBody.KeyPairs.KeyPair()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.keyPair = tmp
            }
        }
    }
    public var keyPairs: DescribeKeyPairsResponseBody.KeyPairs?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.keyPairs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyPairs != nil {
            map["KeyPairs"] = self.keyPairs?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["KeyPairs"] as? [String: Any?] {
            var model = DescribeKeyPairsResponseBody.KeyPairs()
            model.fromMap(value)
            self.keyPairs = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeKeyPairsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeKeyPairsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeKeyPairsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLaunchTemplateVersionsRequest : Tea.TeaModel {
    public var defaultVersion: Bool?

    public var detailFlag: Bool?

    public var launchTemplateId: String?

    public var launchTemplateName: String?

    public var launchTemplateVersion: [Int64]?

    public var maxVersion: Int64?

    public var minVersion: Int64?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.defaultVersion != nil {
            map["DefaultVersion"] = self.defaultVersion!
        }
        if self.detailFlag != nil {
            map["DetailFlag"] = self.detailFlag!
        }
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateName != nil {
            map["LaunchTemplateName"] = self.launchTemplateName!
        }
        if self.launchTemplateVersion != nil {
            map["LaunchTemplateVersion"] = self.launchTemplateVersion!
        }
        if self.maxVersion != nil {
            map["MaxVersion"] = self.maxVersion!
        }
        if self.minVersion != nil {
            map["MinVersion"] = self.minVersion!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DefaultVersion"] as? Bool {
            self.defaultVersion = value
        }
        if let value = dict["DetailFlag"] as? Bool {
            self.detailFlag = value
        }
        if let value = dict["LaunchTemplateId"] as? String {
            self.launchTemplateId = value
        }
        if let value = dict["LaunchTemplateName"] as? String {
            self.launchTemplateName = value
        }
        if let value = dict["LaunchTemplateVersion"] as? [Int64] {
            self.launchTemplateVersion = value
        }
        if let value = dict["MaxVersion"] as? Int64 {
            self.maxVersion = value
        }
        if let value = dict["MinVersion"] as? Int64 {
            self.minVersion = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeLaunchTemplateVersionsResponseBody : Tea.TeaModel {
    public class LaunchTemplateVersionSets : Tea.TeaModel {
        public class LaunchTemplateVersionSet : Tea.TeaModel {
            public class LaunchTemplateData : Tea.TeaModel {
                public class SystemDisk : Tea.TeaModel {
                    public var autoSnapshotPolicyId: String?

                    public var burstingEnabled: Bool?

                    public var category: String?

                    public var deleteWithInstance: Bool?

                    public var description_: String?

                    public var diskName: String?

                    public var encrypted: String?

                    public var iops: Int32?

                    public var KMSKeyId: String?

                    public var performanceLevel: String?

                    public var provisionedIops: Int64?

                    public var size: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.autoSnapshotPolicyId != nil {
                            map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
                        }
                        if self.burstingEnabled != nil {
                            map["BurstingEnabled"] = self.burstingEnabled!
                        }
                        if self.category != nil {
                            map["Category"] = self.category!
                        }
                        if self.deleteWithInstance != nil {
                            map["DeleteWithInstance"] = self.deleteWithInstance!
                        }
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.diskName != nil {
                            map["DiskName"] = self.diskName!
                        }
                        if self.encrypted != nil {
                            map["Encrypted"] = self.encrypted!
                        }
                        if self.iops != nil {
                            map["Iops"] = self.iops!
                        }
                        if self.KMSKeyId != nil {
                            map["KMSKeyId"] = self.KMSKeyId!
                        }
                        if self.performanceLevel != nil {
                            map["PerformanceLevel"] = self.performanceLevel!
                        }
                        if self.provisionedIops != nil {
                            map["ProvisionedIops"] = self.provisionedIops!
                        }
                        if self.size != nil {
                            map["Size"] = self.size!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AutoSnapshotPolicyId"] as? String {
                            self.autoSnapshotPolicyId = value
                        }
                        if let value = dict["BurstingEnabled"] as? Bool {
                            self.burstingEnabled = value
                        }
                        if let value = dict["Category"] as? String {
                            self.category = value
                        }
                        if let value = dict["DeleteWithInstance"] as? Bool {
                            self.deleteWithInstance = value
                        }
                        if let value = dict["Description"] as? String {
                            self.description_ = value
                        }
                        if let value = dict["DiskName"] as? String {
                            self.diskName = value
                        }
                        if let value = dict["Encrypted"] as? String {
                            self.encrypted = value
                        }
                        if let value = dict["Iops"] as? Int32 {
                            self.iops = value
                        }
                        if let value = dict["KMSKeyId"] as? String {
                            self.KMSKeyId = value
                        }
                        if let value = dict["PerformanceLevel"] as? String {
                            self.performanceLevel = value
                        }
                        if let value = dict["ProvisionedIops"] as? Int64 {
                            self.provisionedIops = value
                        }
                        if let value = dict["Size"] as? Int32 {
                            self.size = value
                        }
                    }
                }
                public class DataDisks : Tea.TeaModel {
                    public class DataDisk : Tea.TeaModel {
                        public var autoSnapshotPolicyId: String?

                        public var burstingEnabled: Bool?

                        public var category: String?

                        public var deleteWithInstance: Bool?

                        public var description_: String?

                        public var device: String?

                        public var diskName: String?

                        public var encrypted: String?

                        public var KMSKeyId: String?

                        public var performanceLevel: String?

                        public var provisionedIops: Int64?

                        public var size: Int32?

                        public var snapshotId: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.autoSnapshotPolicyId != nil {
                                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
                            }
                            if self.burstingEnabled != nil {
                                map["BurstingEnabled"] = self.burstingEnabled!
                            }
                            if self.category != nil {
                                map["Category"] = self.category!
                            }
                            if self.deleteWithInstance != nil {
                                map["DeleteWithInstance"] = self.deleteWithInstance!
                            }
                            if self.description_ != nil {
                                map["Description"] = self.description_!
                            }
                            if self.device != nil {
                                map["Device"] = self.device!
                            }
                            if self.diskName != nil {
                                map["DiskName"] = self.diskName!
                            }
                            if self.encrypted != nil {
                                map["Encrypted"] = self.encrypted!
                            }
                            if self.KMSKeyId != nil {
                                map["KMSKeyId"] = self.KMSKeyId!
                            }
                            if self.performanceLevel != nil {
                                map["PerformanceLevel"] = self.performanceLevel!
                            }
                            if self.provisionedIops != nil {
                                map["ProvisionedIops"] = self.provisionedIops!
                            }
                            if self.size != nil {
                                map["Size"] = self.size!
                            }
                            if self.snapshotId != nil {
                                map["SnapshotId"] = self.snapshotId!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["AutoSnapshotPolicyId"] as? String {
                                self.autoSnapshotPolicyId = value
                            }
                            if let value = dict["BurstingEnabled"] as? Bool {
                                self.burstingEnabled = value
                            }
                            if let value = dict["Category"] as? String {
                                self.category = value
                            }
                            if let value = dict["DeleteWithInstance"] as? Bool {
                                self.deleteWithInstance = value
                            }
                            if let value = dict["Description"] as? String {
                                self.description_ = value
                            }
                            if let value = dict["Device"] as? String {
                                self.device = value
                            }
                            if let value = dict["DiskName"] as? String {
                                self.diskName = value
                            }
                            if let value = dict["Encrypted"] as? String {
                                self.encrypted = value
                            }
                            if let value = dict["KMSKeyId"] as? String {
                                self.KMSKeyId = value
                            }
                            if let value = dict["PerformanceLevel"] as? String {
                                self.performanceLevel = value
                            }
                            if let value = dict["ProvisionedIops"] as? Int64 {
                                self.provisionedIops = value
                            }
                            if let value = dict["Size"] as? Int32 {
                                self.size = value
                            }
                            if let value = dict["SnapshotId"] as? String {
                                self.snapshotId = value
                            }
                        }
                    }
                    public var dataDisk: [DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.DataDisks.DataDisk]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.dataDisk != nil {
                            var tmp : [Any] = []
                            for k in self.dataDisk! {
                                tmp.append(k.toMap())
                            }
                            map["DataDisk"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["DataDisk"] as? [Any?] {
                            var tmp : [DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.DataDisks.DataDisk] = []
                            for v in value {
                                if v != nil {
                                    var model = DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.DataDisks.DataDisk()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.dataDisk = tmp
                        }
                    }
                }
                public class NetworkInterfaces : Tea.TeaModel {
                    public class NetworkInterface : Tea.TeaModel {
                        public class SecurityGroupIds : Tea.TeaModel {
                            public var securityGroupId: [String]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.securityGroupId != nil {
                                    map["SecurityGroupId"] = self.securityGroupId!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["SecurityGroupId"] as? [String] {
                                    self.securityGroupId = value
                                }
                            }
                        }
                        public var deleteOnRelease: Bool?

                        public var description_: String?

                        public var instanceType: String?

                        public var networkInterfaceName: String?

                        public var networkInterfaceTrafficMode: String?

                        public var primaryIpAddress: String?

                        public var securityGroupId: String?

                        public var securityGroupIds: DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.NetworkInterfaces.NetworkInterface.SecurityGroupIds?

                        public var vSwitchId: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.securityGroupIds?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.deleteOnRelease != nil {
                                map["DeleteOnRelease"] = self.deleteOnRelease!
                            }
                            if self.description_ != nil {
                                map["Description"] = self.description_!
                            }
                            if self.instanceType != nil {
                                map["InstanceType"] = self.instanceType!
                            }
                            if self.networkInterfaceName != nil {
                                map["NetworkInterfaceName"] = self.networkInterfaceName!
                            }
                            if self.networkInterfaceTrafficMode != nil {
                                map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
                            }
                            if self.primaryIpAddress != nil {
                                map["PrimaryIpAddress"] = self.primaryIpAddress!
                            }
                            if self.securityGroupId != nil {
                                map["SecurityGroupId"] = self.securityGroupId!
                            }
                            if self.securityGroupIds != nil {
                                map["SecurityGroupIds"] = self.securityGroupIds?.toMap()
                            }
                            if self.vSwitchId != nil {
                                map["VSwitchId"] = self.vSwitchId!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["DeleteOnRelease"] as? Bool {
                                self.deleteOnRelease = value
                            }
                            if let value = dict["Description"] as? String {
                                self.description_ = value
                            }
                            if let value = dict["InstanceType"] as? String {
                                self.instanceType = value
                            }
                            if let value = dict["NetworkInterfaceName"] as? String {
                                self.networkInterfaceName = value
                            }
                            if let value = dict["NetworkInterfaceTrafficMode"] as? String {
                                self.networkInterfaceTrafficMode = value
                            }
                            if let value = dict["PrimaryIpAddress"] as? String {
                                self.primaryIpAddress = value
                            }
                            if let value = dict["SecurityGroupId"] as? String {
                                self.securityGroupId = value
                            }
                            if let value = dict["SecurityGroupIds"] as? [String: Any?] {
                                var model = DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.NetworkInterfaces.NetworkInterface.SecurityGroupIds()
                                model.fromMap(value)
                                self.securityGroupIds = model
                            }
                            if let value = dict["VSwitchId"] as? String {
                                self.vSwitchId = value
                            }
                        }
                    }
                    public var networkInterface: [DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.NetworkInterfaces.NetworkInterface]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.networkInterface != nil {
                            var tmp : [Any] = []
                            for k in self.networkInterface! {
                                tmp.append(k.toMap())
                            }
                            map["NetworkInterface"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["NetworkInterface"] as? [Any?] {
                            var tmp : [DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.NetworkInterfaces.NetworkInterface] = []
                            for v in value {
                                if v != nil {
                                    var model = DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.NetworkInterfaces.NetworkInterface()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.networkInterface = tmp
                        }
                    }
                }
                public class SecurityGroupIds : Tea.TeaModel {
                    public var securityGroupId: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.securityGroupId != nil {
                            map["SecurityGroupId"] = self.securityGroupId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["SecurityGroupId"] as? [String] {
                            self.securityGroupId = value
                        }
                    }
                }
                public class Tags : Tea.TeaModel {
                    public class InstanceTag : Tea.TeaModel {
                        public var key: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.key != nil {
                                map["Key"] = self.key!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Key"] as? String {
                                self.key = value
                            }
                            if let value = dict["Value"] as? String {
                                self.value = value
                            }
                        }
                    }
                    public var instanceTag: [DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.Tags.InstanceTag]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.instanceTag != nil {
                            var tmp : [Any] = []
                            for k in self.instanceTag! {
                                tmp.append(k.toMap())
                            }
                            map["InstanceTag"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["InstanceTag"] as? [Any?] {
                            var tmp : [DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.Tags.InstanceTag] = []
                            for v in value {
                                if v != nil {
                                    var model = DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.Tags.InstanceTag()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.instanceTag = tmp
                        }
                    }
                }
                public var systemDisk: DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.SystemDisk?

                public var autoReleaseTime: String?

                public var autoRenew: Bool?

                public var autoRenewPeriod: Int32?

                public var creditSpecification: String?

                public var dataDisks: DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.DataDisks?

                public var deletionProtection: Bool?

                public var deploymentSetId: String?

                public var description_: String?

                public var enableVmOsConfig: Bool?

                public var hostName: String?

                public var httpEndpoint: String?

                public var httpPutResponseHopLimit: Int32?

                public var httpTokens: String?

                public var imageId: String?

                public var imageOwnerAlias: String?

                public var instanceChargeType: String?

                public var instanceName: String?

                public var instanceType: String?

                public var internetChargeType: String?

                public var internetMaxBandwidthIn: Int32?

                public var internetMaxBandwidthOut: Int32?

                public var ioOptimized: String?

                public var ipv6AddressCount: Int32?

                public var keyPairName: String?

                public var networkInterfaces: DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.NetworkInterfaces?

                public var networkType: String?

                public var passwordInherit: Bool?

                public var period: Int32?

                public var periodUnit: String?

                public var privateIpAddress: String?

                public var ramRoleName: String?

                public var resourceGroupId: String?

                public var securityEnhancementStrategy: String?

                public var securityGroupId: String?

                public var securityGroupIds: DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.SecurityGroupIds?

                public var spotDuration: Int32?

                public var spotPriceLimit: Double?

                public var spotStrategy: String?

                public var tags: DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.Tags?

                public var userData: String?

                public var vSwitchId: String?

                public var vpcId: String?

                public var zoneId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.systemDisk?.validate()
                    try self.dataDisks?.validate()
                    try self.networkInterfaces?.validate()
                    try self.securityGroupIds?.validate()
                    try self.tags?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.systemDisk != nil {
                        map["SystemDisk"] = self.systemDisk?.toMap()
                    }
                    if self.autoReleaseTime != nil {
                        map["AutoReleaseTime"] = self.autoReleaseTime!
                    }
                    if self.autoRenew != nil {
                        map["AutoRenew"] = self.autoRenew!
                    }
                    if self.autoRenewPeriod != nil {
                        map["AutoRenewPeriod"] = self.autoRenewPeriod!
                    }
                    if self.creditSpecification != nil {
                        map["CreditSpecification"] = self.creditSpecification!
                    }
                    if self.dataDisks != nil {
                        map["DataDisks"] = self.dataDisks?.toMap()
                    }
                    if self.deletionProtection != nil {
                        map["DeletionProtection"] = self.deletionProtection!
                    }
                    if self.deploymentSetId != nil {
                        map["DeploymentSetId"] = self.deploymentSetId!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.enableVmOsConfig != nil {
                        map["EnableVmOsConfig"] = self.enableVmOsConfig!
                    }
                    if self.hostName != nil {
                        map["HostName"] = self.hostName!
                    }
                    if self.httpEndpoint != nil {
                        map["HttpEndpoint"] = self.httpEndpoint!
                    }
                    if self.httpPutResponseHopLimit != nil {
                        map["HttpPutResponseHopLimit"] = self.httpPutResponseHopLimit!
                    }
                    if self.httpTokens != nil {
                        map["HttpTokens"] = self.httpTokens!
                    }
                    if self.imageId != nil {
                        map["ImageId"] = self.imageId!
                    }
                    if self.imageOwnerAlias != nil {
                        map["ImageOwnerAlias"] = self.imageOwnerAlias!
                    }
                    if self.instanceChargeType != nil {
                        map["InstanceChargeType"] = self.instanceChargeType!
                    }
                    if self.instanceName != nil {
                        map["InstanceName"] = self.instanceName!
                    }
                    if self.instanceType != nil {
                        map["InstanceType"] = self.instanceType!
                    }
                    if self.internetChargeType != nil {
                        map["InternetChargeType"] = self.internetChargeType!
                    }
                    if self.internetMaxBandwidthIn != nil {
                        map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
                    }
                    if self.internetMaxBandwidthOut != nil {
                        map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
                    }
                    if self.ioOptimized != nil {
                        map["IoOptimized"] = self.ioOptimized!
                    }
                    if self.ipv6AddressCount != nil {
                        map["Ipv6AddressCount"] = self.ipv6AddressCount!
                    }
                    if self.keyPairName != nil {
                        map["KeyPairName"] = self.keyPairName!
                    }
                    if self.networkInterfaces != nil {
                        map["NetworkInterfaces"] = self.networkInterfaces?.toMap()
                    }
                    if self.networkType != nil {
                        map["NetworkType"] = self.networkType!
                    }
                    if self.passwordInherit != nil {
                        map["PasswordInherit"] = self.passwordInherit!
                    }
                    if self.period != nil {
                        map["Period"] = self.period!
                    }
                    if self.periodUnit != nil {
                        map["PeriodUnit"] = self.periodUnit!
                    }
                    if self.privateIpAddress != nil {
                        map["PrivateIpAddress"] = self.privateIpAddress!
                    }
                    if self.ramRoleName != nil {
                        map["RamRoleName"] = self.ramRoleName!
                    }
                    if self.resourceGroupId != nil {
                        map["ResourceGroupId"] = self.resourceGroupId!
                    }
                    if self.securityEnhancementStrategy != nil {
                        map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
                    }
                    if self.securityGroupId != nil {
                        map["SecurityGroupId"] = self.securityGroupId!
                    }
                    if self.securityGroupIds != nil {
                        map["SecurityGroupIds"] = self.securityGroupIds?.toMap()
                    }
                    if self.spotDuration != nil {
                        map["SpotDuration"] = self.spotDuration!
                    }
                    if self.spotPriceLimit != nil {
                        map["SpotPriceLimit"] = self.spotPriceLimit!
                    }
                    if self.spotStrategy != nil {
                        map["SpotStrategy"] = self.spotStrategy!
                    }
                    if self.tags != nil {
                        map["Tags"] = self.tags?.toMap()
                    }
                    if self.userData != nil {
                        map["UserData"] = self.userData!
                    }
                    if self.vSwitchId != nil {
                        map["VSwitchId"] = self.vSwitchId!
                    }
                    if self.vpcId != nil {
                        map["VpcId"] = self.vpcId!
                    }
                    if self.zoneId != nil {
                        map["ZoneId"] = self.zoneId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["SystemDisk"] as? [String: Any?] {
                        var model = DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.SystemDisk()
                        model.fromMap(value)
                        self.systemDisk = model
                    }
                    if let value = dict["AutoReleaseTime"] as? String {
                        self.autoReleaseTime = value
                    }
                    if let value = dict["AutoRenew"] as? Bool {
                        self.autoRenew = value
                    }
                    if let value = dict["AutoRenewPeriod"] as? Int32 {
                        self.autoRenewPeriod = value
                    }
                    if let value = dict["CreditSpecification"] as? String {
                        self.creditSpecification = value
                    }
                    if let value = dict["DataDisks"] as? [String: Any?] {
                        var model = DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.DataDisks()
                        model.fromMap(value)
                        self.dataDisks = model
                    }
                    if let value = dict["DeletionProtection"] as? Bool {
                        self.deletionProtection = value
                    }
                    if let value = dict["DeploymentSetId"] as? String {
                        self.deploymentSetId = value
                    }
                    if let value = dict["Description"] as? String {
                        self.description_ = value
                    }
                    if let value = dict["EnableVmOsConfig"] as? Bool {
                        self.enableVmOsConfig = value
                    }
                    if let value = dict["HostName"] as? String {
                        self.hostName = value
                    }
                    if let value = dict["HttpEndpoint"] as? String {
                        self.httpEndpoint = value
                    }
                    if let value = dict["HttpPutResponseHopLimit"] as? Int32 {
                        self.httpPutResponseHopLimit = value
                    }
                    if let value = dict["HttpTokens"] as? String {
                        self.httpTokens = value
                    }
                    if let value = dict["ImageId"] as? String {
                        self.imageId = value
                    }
                    if let value = dict["ImageOwnerAlias"] as? String {
                        self.imageOwnerAlias = value
                    }
                    if let value = dict["InstanceChargeType"] as? String {
                        self.instanceChargeType = value
                    }
                    if let value = dict["InstanceName"] as? String {
                        self.instanceName = value
                    }
                    if let value = dict["InstanceType"] as? String {
                        self.instanceType = value
                    }
                    if let value = dict["InternetChargeType"] as? String {
                        self.internetChargeType = value
                    }
                    if let value = dict["InternetMaxBandwidthIn"] as? Int32 {
                        self.internetMaxBandwidthIn = value
                    }
                    if let value = dict["InternetMaxBandwidthOut"] as? Int32 {
                        self.internetMaxBandwidthOut = value
                    }
                    if let value = dict["IoOptimized"] as? String {
                        self.ioOptimized = value
                    }
                    if let value = dict["Ipv6AddressCount"] as? Int32 {
                        self.ipv6AddressCount = value
                    }
                    if let value = dict["KeyPairName"] as? String {
                        self.keyPairName = value
                    }
                    if let value = dict["NetworkInterfaces"] as? [String: Any?] {
                        var model = DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.NetworkInterfaces()
                        model.fromMap(value)
                        self.networkInterfaces = model
                    }
                    if let value = dict["NetworkType"] as? String {
                        self.networkType = value
                    }
                    if let value = dict["PasswordInherit"] as? Bool {
                        self.passwordInherit = value
                    }
                    if let value = dict["Period"] as? Int32 {
                        self.period = value
                    }
                    if let value = dict["PeriodUnit"] as? String {
                        self.periodUnit = value
                    }
                    if let value = dict["PrivateIpAddress"] as? String {
                        self.privateIpAddress = value
                    }
                    if let value = dict["RamRoleName"] as? String {
                        self.ramRoleName = value
                    }
                    if let value = dict["ResourceGroupId"] as? String {
                        self.resourceGroupId = value
                    }
                    if let value = dict["SecurityEnhancementStrategy"] as? String {
                        self.securityEnhancementStrategy = value
                    }
                    if let value = dict["SecurityGroupId"] as? String {
                        self.securityGroupId = value
                    }
                    if let value = dict["SecurityGroupIds"] as? [String: Any?] {
                        var model = DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.SecurityGroupIds()
                        model.fromMap(value)
                        self.securityGroupIds = model
                    }
                    if let value = dict["SpotDuration"] as? Int32 {
                        self.spotDuration = value
                    }
                    if let value = dict["SpotPriceLimit"] as? Double {
                        self.spotPriceLimit = value
                    }
                    if let value = dict["SpotStrategy"] as? String {
                        self.spotStrategy = value
                    }
                    if let value = dict["Tags"] as? [String: Any?] {
                        var model = DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.Tags()
                        model.fromMap(value)
                        self.tags = model
                    }
                    if let value = dict["UserData"] as? String {
                        self.userData = value
                    }
                    if let value = dict["VSwitchId"] as? String {
                        self.vSwitchId = value
                    }
                    if let value = dict["VpcId"] as? String {
                        self.vpcId = value
                    }
                    if let value = dict["ZoneId"] as? String {
                        self.zoneId = value
                    }
                }
            }
            public var createTime: String?

            public var createdBy: String?

            public var defaultVersion: Bool?

            public var launchTemplateData: DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData?

            public var launchTemplateId: String?

            public var launchTemplateName: String?

            public var modifiedTime: String?

            public var versionDescription: String?

            public var versionNumber: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.launchTemplateData?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createdBy != nil {
                    map["CreatedBy"] = self.createdBy!
                }
                if self.defaultVersion != nil {
                    map["DefaultVersion"] = self.defaultVersion!
                }
                if self.launchTemplateData != nil {
                    map["LaunchTemplateData"] = self.launchTemplateData?.toMap()
                }
                if self.launchTemplateId != nil {
                    map["LaunchTemplateId"] = self.launchTemplateId!
                }
                if self.launchTemplateName != nil {
                    map["LaunchTemplateName"] = self.launchTemplateName!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.versionDescription != nil {
                    map["VersionDescription"] = self.versionDescription!
                }
                if self.versionNumber != nil {
                    map["VersionNumber"] = self.versionNumber!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreatedBy"] as? String {
                    self.createdBy = value
                }
                if let value = dict["DefaultVersion"] as? Bool {
                    self.defaultVersion = value
                }
                if let value = dict["LaunchTemplateData"] as? [String: Any?] {
                    var model = DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData()
                    model.fromMap(value)
                    self.launchTemplateData = model
                }
                if let value = dict["LaunchTemplateId"] as? String {
                    self.launchTemplateId = value
                }
                if let value = dict["LaunchTemplateName"] as? String {
                    self.launchTemplateName = value
                }
                if let value = dict["ModifiedTime"] as? String {
                    self.modifiedTime = value
                }
                if let value = dict["VersionDescription"] as? String {
                    self.versionDescription = value
                }
                if let value = dict["VersionNumber"] as? Int64 {
                    self.versionNumber = value
                }
            }
        }
        public var launchTemplateVersionSet: [DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.launchTemplateVersionSet != nil {
                var tmp : [Any] = []
                for k in self.launchTemplateVersionSet! {
                    tmp.append(k.toMap())
                }
                map["LaunchTemplateVersionSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LaunchTemplateVersionSet"] as? [Any?] {
                var tmp : [DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.launchTemplateVersionSet = tmp
            }
        }
    }
    public var launchTemplateVersionSets: DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.launchTemplateVersionSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.launchTemplateVersionSets != nil {
            map["LaunchTemplateVersionSets"] = self.launchTemplateVersionSets?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LaunchTemplateVersionSets"] as? [String: Any?] {
            var model = DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets()
            model.fromMap(value)
            self.launchTemplateVersionSets = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeLaunchTemplateVersionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLaunchTemplateVersionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLaunchTemplateVersionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLaunchTemplatesRequest : Tea.TeaModel {
    public class TemplateTag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var launchTemplateId: [String]?

    public var launchTemplateName: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var templateResourceGroupId: String?

    public var templateTag: [DescribeLaunchTemplatesRequest.TemplateTag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateName != nil {
            map["LaunchTemplateName"] = self.launchTemplateName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.templateResourceGroupId != nil {
            map["TemplateResourceGroupId"] = self.templateResourceGroupId!
        }
        if self.templateTag != nil {
            var tmp : [Any] = []
            for k in self.templateTag! {
                tmp.append(k.toMap())
            }
            map["TemplateTag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LaunchTemplateId"] as? [String] {
            self.launchTemplateId = value
        }
        if let value = dict["LaunchTemplateName"] as? [String] {
            self.launchTemplateName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TemplateResourceGroupId"] as? String {
            self.templateResourceGroupId = value
        }
        if let value = dict["TemplateTag"] as? [Any?] {
            var tmp : [DescribeLaunchTemplatesRequest.TemplateTag] = []
            for v in value {
                if v != nil {
                    var model = DescribeLaunchTemplatesRequest.TemplateTag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.templateTag = tmp
        }
    }
}

public class DescribeLaunchTemplatesResponseBody : Tea.TeaModel {
    public class LaunchTemplateSets : Tea.TeaModel {
        public class LaunchTemplateSet : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["TagKey"] as? String {
                            self.tagKey = value
                        }
                        if let value = dict["TagValue"] as? String {
                            self.tagValue = value
                        }
                    }
                }
                public var tag: [DescribeLaunchTemplatesResponseBody.LaunchTemplateSets.LaunchTemplateSet.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeLaunchTemplatesResponseBody.LaunchTemplateSets.LaunchTemplateSet.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeLaunchTemplatesResponseBody.LaunchTemplateSets.LaunchTemplateSet.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var createTime: String?

            public var createdBy: String?

            public var defaultVersionNumber: Int64?

            public var latestVersionNumber: Int64?

            public var launchTemplateId: String?

            public var launchTemplateName: String?

            public var modifiedTime: String?

            public var resourceGroupId: String?

            public var tags: DescribeLaunchTemplatesResponseBody.LaunchTemplateSets.LaunchTemplateSet.Tags?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createdBy != nil {
                    map["CreatedBy"] = self.createdBy!
                }
                if self.defaultVersionNumber != nil {
                    map["DefaultVersionNumber"] = self.defaultVersionNumber!
                }
                if self.latestVersionNumber != nil {
                    map["LatestVersionNumber"] = self.latestVersionNumber!
                }
                if self.launchTemplateId != nil {
                    map["LaunchTemplateId"] = self.launchTemplateId!
                }
                if self.launchTemplateName != nil {
                    map["LaunchTemplateName"] = self.launchTemplateName!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreatedBy"] as? String {
                    self.createdBy = value
                }
                if let value = dict["DefaultVersionNumber"] as? Int64 {
                    self.defaultVersionNumber = value
                }
                if let value = dict["LatestVersionNumber"] as? Int64 {
                    self.latestVersionNumber = value
                }
                if let value = dict["LaunchTemplateId"] as? String {
                    self.launchTemplateId = value
                }
                if let value = dict["LaunchTemplateName"] as? String {
                    self.launchTemplateName = value
                }
                if let value = dict["ModifiedTime"] as? String {
                    self.modifiedTime = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeLaunchTemplatesResponseBody.LaunchTemplateSets.LaunchTemplateSet.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
            }
        }
        public var launchTemplateSet: [DescribeLaunchTemplatesResponseBody.LaunchTemplateSets.LaunchTemplateSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.launchTemplateSet != nil {
                var tmp : [Any] = []
                for k in self.launchTemplateSet! {
                    tmp.append(k.toMap())
                }
                map["LaunchTemplateSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LaunchTemplateSet"] as? [Any?] {
                var tmp : [DescribeLaunchTemplatesResponseBody.LaunchTemplateSets.LaunchTemplateSet] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLaunchTemplatesResponseBody.LaunchTemplateSets.LaunchTemplateSet()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.launchTemplateSet = tmp
            }
        }
    }
    public var launchTemplateSets: DescribeLaunchTemplatesResponseBody.LaunchTemplateSets?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.launchTemplateSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.launchTemplateSets != nil {
            map["LaunchTemplateSets"] = self.launchTemplateSets?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LaunchTemplateSets"] as? [String: Any?] {
            var model = DescribeLaunchTemplatesResponseBody.LaunchTemplateSets()
            model.fromMap(value)
            self.launchTemplateSets = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeLaunchTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLaunchTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLaunchTemplatesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLimitationRequest : Tea.TeaModel {
    public var limitation: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.limitation != nil {
            map["Limitation"] = self.limitation!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Limitation"] as? String {
            self.limitation = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeLimitationResponseBody : Tea.TeaModel {
    public var limitation: String?

    public var requestId: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.limitation != nil {
            map["Limitation"] = self.limitation!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Limitation"] as? String {
            self.limitation = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Value"] as? String {
            self.value = value
        }
    }
}

public class DescribeLimitationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLimitationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLimitationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeManagedInstancesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var activationId: String?

    public var instanceId: [String]?

    public var instanceIp: String?

    public var instanceName: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var osType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeManagedInstancesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activationId != nil {
            map["ActivationId"] = self.activationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceIp != nil {
            map["InstanceIp"] = self.instanceIp!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.osType != nil {
            map["OsType"] = self.osType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ActivationId"] as? String {
            self.activationId = value
        }
        if let value = dict["InstanceId"] as? [String] {
            self.instanceId = value
        }
        if let value = dict["InstanceIp"] as? String {
            self.instanceIp = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OsType"] as? String {
            self.osType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeManagedInstancesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeManagedInstancesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribeManagedInstancesResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public var activationId: String?

        public var agentVersion: String?

        public var connected: Bool?

        public var hostname: String?

        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var invocationCount: Int64?

        public var lastInvokedTime: String?

        public var machineId: String?

        public var osType: String?

        public var osVersion: String?

        public var registrationTime: String?

        public var resourceGroupId: String?

        public var tags: [DescribeManagedInstancesResponseBody.Instances.Tags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activationId != nil {
                map["ActivationId"] = self.activationId!
            }
            if self.agentVersion != nil {
                map["AgentVersion"] = self.agentVersion!
            }
            if self.connected != nil {
                map["Connected"] = self.connected!
            }
            if self.hostname != nil {
                map["Hostname"] = self.hostname!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.invocationCount != nil {
                map["InvocationCount"] = self.invocationCount!
            }
            if self.lastInvokedTime != nil {
                map["LastInvokedTime"] = self.lastInvokedTime!
            }
            if self.machineId != nil {
                map["MachineId"] = self.machineId!
            }
            if self.osType != nil {
                map["OsType"] = self.osType!
            }
            if self.osVersion != nil {
                map["OsVersion"] = self.osVersion!
            }
            if self.registrationTime != nil {
                map["RegistrationTime"] = self.registrationTime!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ActivationId"] as? String {
                self.activationId = value
            }
            if let value = dict["AgentVersion"] as? String {
                self.agentVersion = value
            }
            if let value = dict["Connected"] as? Bool {
                self.connected = value
            }
            if let value = dict["Hostname"] as? String {
                self.hostname = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["InstanceName"] as? String {
                self.instanceName = value
            }
            if let value = dict["InternetIp"] as? String {
                self.internetIp = value
            }
            if let value = dict["IntranetIp"] as? String {
                self.intranetIp = value
            }
            if let value = dict["InvocationCount"] as? Int64 {
                self.invocationCount = value
            }
            if let value = dict["LastInvokedTime"] as? String {
                self.lastInvokedTime = value
            }
            if let value = dict["MachineId"] as? String {
                self.machineId = value
            }
            if let value = dict["OsType"] as? String {
                self.osType = value
            }
            if let value = dict["OsVersion"] as? String {
                self.osVersion = value
            }
            if let value = dict["RegistrationTime"] as? String {
                self.registrationTime = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [DescribeManagedInstancesResponseBody.Instances.Tags] = []
                for v in value {
                    if v != nil {
                        var model = DescribeManagedInstancesResponseBody.Instances.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
        }
    }
    public var instances: [DescribeManagedInstancesResponseBody.Instances]?

    public var nextToken: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            var tmp : [Any] = []
            for k in self.instances! {
                tmp.append(k.toMap())
            }
            map["Instances"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Instances"] as? [Any?] {
            var tmp : [DescribeManagedInstancesResponseBody.Instances] = []
            for v in value {
                if v != nil {
                    var model = DescribeManagedInstancesResponseBody.Instances()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.instances = tmp
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribeManagedInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeManagedInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeManagedInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeNatGatewaysRequest : Tea.TeaModel {
    public var natGatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NatGatewayId"] as? String {
            self.natGatewayId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class DescribeNatGatewaysResponseBody : Tea.TeaModel {
    public class NatGateways : Tea.TeaModel {
        public class NatGateway : Tea.TeaModel {
            public class BandwidthPackageIds : Tea.TeaModel {
                public var bandwidthPackageId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bandwidthPackageId != nil {
                        map["BandwidthPackageId"] = self.bandwidthPackageId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["BandwidthPackageId"] as? [String] {
                        self.bandwidthPackageId = value
                    }
                }
            }
            public class ForwardTableIds : Tea.TeaModel {
                public var forwardTableId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.forwardTableId != nil {
                        map["ForwardTableId"] = self.forwardTableId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ForwardTableId"] as? [String] {
                        self.forwardTableId = value
                    }
                }
            }
            public var bandwidthPackageIds: DescribeNatGatewaysResponseBody.NatGateways.NatGateway.BandwidthPackageIds?

            public var businessStatus: String?

            public var creationTime: String?

            public var description_: String?

            public var forwardTableIds: DescribeNatGatewaysResponseBody.NatGateways.NatGateway.ForwardTableIds?

            public var instanceChargeType: String?

            public var name: String?

            public var natGatewayId: String?

            public var regionId: String?

            public var spec: String?

            public var status: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.bandwidthPackageIds?.validate()
                try self.forwardTableIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bandwidthPackageIds != nil {
                    map["BandwidthPackageIds"] = self.bandwidthPackageIds?.toMap()
                }
                if self.businessStatus != nil {
                    map["BusinessStatus"] = self.businessStatus!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.forwardTableIds != nil {
                    map["ForwardTableIds"] = self.forwardTableIds?.toMap()
                }
                if self.instanceChargeType != nil {
                    map["InstanceChargeType"] = self.instanceChargeType!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.natGatewayId != nil {
                    map["NatGatewayId"] = self.natGatewayId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.spec != nil {
                    map["Spec"] = self.spec!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BandwidthPackageIds"] as? [String: Any?] {
                    var model = DescribeNatGatewaysResponseBody.NatGateways.NatGateway.BandwidthPackageIds()
                    model.fromMap(value)
                    self.bandwidthPackageIds = model
                }
                if let value = dict["BusinessStatus"] as? String {
                    self.businessStatus = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["ForwardTableIds"] as? [String: Any?] {
                    var model = DescribeNatGatewaysResponseBody.NatGateways.NatGateway.ForwardTableIds()
                    model.fromMap(value)
                    self.forwardTableIds = model
                }
                if let value = dict["InstanceChargeType"] as? String {
                    self.instanceChargeType = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["NatGatewayId"] as? String {
                    self.natGatewayId = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["Spec"] as? String {
                    self.spec = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
            }
        }
        public var natGateway: [DescribeNatGatewaysResponseBody.NatGateways.NatGateway]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.natGateway != nil {
                var tmp : [Any] = []
                for k in self.natGateway! {
                    tmp.append(k.toMap())
                }
                map["NatGateway"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["NatGateway"] as? [Any?] {
                var tmp : [DescribeNatGatewaysResponseBody.NatGateways.NatGateway] = []
                for v in value {
                    if v != nil {
                        var model = DescribeNatGatewaysResponseBody.NatGateways.NatGateway()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.natGateway = tmp
            }
        }
    }
    public var natGateways: DescribeNatGatewaysResponseBody.NatGateways?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.natGateways?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.natGateways != nil {
            map["NatGateways"] = self.natGateways?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NatGateways"] as? [String: Any?] {
            var model = DescribeNatGatewaysResponseBody.NatGateways()
            model.fromMap(value)
            self.natGateways = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeNatGatewaysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNatGatewaysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeNatGatewaysResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeNetworkInterfaceAttributeRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var attribute: String?

    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeNetworkInterfaceAttributeRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attribute != nil {
            map["Attribute"] = self.attribute!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Attribute"] as? String {
            self.attribute = value
        }
        if let value = dict["NetworkInterfaceId"] as? String {
            self.networkInterfaceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeNetworkInterfaceAttributeRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeNetworkInterfaceAttributeRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribeNetworkInterfaceAttributeResponseBody : Tea.TeaModel {
    public class AssociatedPublicIp : Tea.TeaModel {
        public var allocationId: String?

        public var publicIpAddress: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allocationId != nil {
                map["AllocationId"] = self.allocationId!
            }
            if self.publicIpAddress != nil {
                map["PublicIpAddress"] = self.publicIpAddress!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AllocationId"] as? String {
                self.allocationId = value
            }
            if let value = dict["PublicIpAddress"] as? String {
                self.publicIpAddress = value
            }
        }
    }
    public class Attachment : Tea.TeaModel {
        public class MemberNetworkInterfaceIds : Tea.TeaModel {
            public var memberNetworkInterfaceId: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.memberNetworkInterfaceId != nil {
                    map["MemberNetworkInterfaceId"] = self.memberNetworkInterfaceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["MemberNetworkInterfaceId"] as? [String] {
                    self.memberNetworkInterfaceId = value
                }
            }
        }
        public var deviceIndex: Int32?

        public var instanceId: String?

        public var memberNetworkInterfaceIds: DescribeNetworkInterfaceAttributeResponseBody.Attachment.MemberNetworkInterfaceIds?

        public var networkCardIndex: Int32?

        public var trunkNetworkInterfaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.memberNetworkInterfaceIds?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deviceIndex != nil {
                map["DeviceIndex"] = self.deviceIndex!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.memberNetworkInterfaceIds != nil {
                map["MemberNetworkInterfaceIds"] = self.memberNetworkInterfaceIds?.toMap()
            }
            if self.networkCardIndex != nil {
                map["NetworkCardIndex"] = self.networkCardIndex!
            }
            if self.trunkNetworkInterfaceId != nil {
                map["TrunkNetworkInterfaceId"] = self.trunkNetworkInterfaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DeviceIndex"] as? Int32 {
                self.deviceIndex = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["MemberNetworkInterfaceIds"] as? [String: Any?] {
                var model = DescribeNetworkInterfaceAttributeResponseBody.Attachment.MemberNetworkInterfaceIds()
                model.fromMap(value)
                self.memberNetworkInterfaceIds = model
            }
            if let value = dict["NetworkCardIndex"] as? Int32 {
                self.networkCardIndex = value
            }
            if let value = dict["TrunkNetworkInterfaceId"] as? String {
                self.trunkNetworkInterfaceId = value
            }
        }
    }
    public class BondInterfaceSpecification : Tea.TeaModel {
        public class SlaveInterfaceSpecification : Tea.TeaModel {
            public class SlaveInterfaceSpecificationSet : Tea.TeaModel {
                public var bondNetworkInterfaceId: String?

                public var slaveNetworkInterfaceId: String?

                public var workState: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bondNetworkInterfaceId != nil {
                        map["BondNetworkInterfaceId"] = self.bondNetworkInterfaceId!
                    }
                    if self.slaveNetworkInterfaceId != nil {
                        map["SlaveNetworkInterfaceId"] = self.slaveNetworkInterfaceId!
                    }
                    if self.workState != nil {
                        map["WorkState"] = self.workState!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["BondNetworkInterfaceId"] as? String {
                        self.bondNetworkInterfaceId = value
                    }
                    if let value = dict["SlaveNetworkInterfaceId"] as? String {
                        self.slaveNetworkInterfaceId = value
                    }
                    if let value = dict["WorkState"] as? String {
                        self.workState = value
                    }
                }
            }
            public var slaveInterfaceSpecificationSet: [DescribeNetworkInterfaceAttributeResponseBody.BondInterfaceSpecification.SlaveInterfaceSpecification.SlaveInterfaceSpecificationSet]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.slaveInterfaceSpecificationSet != nil {
                    var tmp : [Any] = []
                    for k in self.slaveInterfaceSpecificationSet! {
                        tmp.append(k.toMap())
                    }
                    map["SlaveInterfaceSpecificationSet"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["SlaveInterfaceSpecificationSet"] as? [Any?] {
                    var tmp : [DescribeNetworkInterfaceAttributeResponseBody.BondInterfaceSpecification.SlaveInterfaceSpecification.SlaveInterfaceSpecificationSet] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeNetworkInterfaceAttributeResponseBody.BondInterfaceSpecification.SlaveInterfaceSpecification.SlaveInterfaceSpecificationSet()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.slaveInterfaceSpecificationSet = tmp
                }
            }
        }
        public var bondMode: String?

        public var slaveInterfaceSpecification: DescribeNetworkInterfaceAttributeResponseBody.BondInterfaceSpecification.SlaveInterfaceSpecification?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.slaveInterfaceSpecification?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bondMode != nil {
                map["BondMode"] = self.bondMode!
            }
            if self.slaveInterfaceSpecification != nil {
                map["SlaveInterfaceSpecification"] = self.slaveInterfaceSpecification?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BondMode"] as? String {
                self.bondMode = value
            }
            if let value = dict["SlaveInterfaceSpecification"] as? [String: Any?] {
                var model = DescribeNetworkInterfaceAttributeResponseBody.BondInterfaceSpecification.SlaveInterfaceSpecification()
                model.fromMap(value)
                self.slaveInterfaceSpecification = model
            }
        }
    }
    public class ConnectionTrackingConfiguration : Tea.TeaModel {
        public var tcpClosedAndTimeWaitTimeout: Int32?

        public var tcpEstablishedTimeout: Int32?

        public var udpTimeout: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tcpClosedAndTimeWaitTimeout != nil {
                map["TcpClosedAndTimeWaitTimeout"] = self.tcpClosedAndTimeWaitTimeout!
            }
            if self.tcpEstablishedTimeout != nil {
                map["TcpEstablishedTimeout"] = self.tcpEstablishedTimeout!
            }
            if self.udpTimeout != nil {
                map["UdpTimeout"] = self.udpTimeout!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TcpClosedAndTimeWaitTimeout"] as? Int32 {
                self.tcpClosedAndTimeWaitTimeout = value
            }
            if let value = dict["TcpEstablishedTimeout"] as? Int32 {
                self.tcpEstablishedTimeout = value
            }
            if let value = dict["UdpTimeout"] as? Int32 {
                self.udpTimeout = value
            }
        }
    }
    public class EnhancedNetwork : Tea.TeaModel {
        public var enableRss: Bool?

        public var enableSriov: Bool?

        public var virtualFunctionQuantity: Int32?

        public var virtualFunctionTotalQueueNumber: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableRss != nil {
                map["EnableRss"] = self.enableRss!
            }
            if self.enableSriov != nil {
                map["EnableSriov"] = self.enableSriov!
            }
            if self.virtualFunctionQuantity != nil {
                map["VirtualFunctionQuantity"] = self.virtualFunctionQuantity!
            }
            if self.virtualFunctionTotalQueueNumber != nil {
                map["VirtualFunctionTotalQueueNumber"] = self.virtualFunctionTotalQueueNumber!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EnableRss"] as? Bool {
                self.enableRss = value
            }
            if let value = dict["EnableSriov"] as? Bool {
                self.enableSriov = value
            }
            if let value = dict["VirtualFunctionQuantity"] as? Int32 {
                self.virtualFunctionQuantity = value
            }
            if let value = dict["VirtualFunctionTotalQueueNumber"] as? Int32 {
                self.virtualFunctionTotalQueueNumber = value
            }
        }
    }
    public class Ipv4PrefixSets : Tea.TeaModel {
        public class Ipv4PrefixSet : Tea.TeaModel {
            public var ipv4Prefix: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipv4Prefix != nil {
                    map["Ipv4Prefix"] = self.ipv4Prefix!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Ipv4Prefix"] as? String {
                    self.ipv4Prefix = value
                }
            }
        }
        public var ipv4PrefixSet: [DescribeNetworkInterfaceAttributeResponseBody.Ipv4PrefixSets.Ipv4PrefixSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv4PrefixSet != nil {
                var tmp : [Any] = []
                for k in self.ipv4PrefixSet! {
                    tmp.append(k.toMap())
                }
                map["Ipv4PrefixSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Ipv4PrefixSet"] as? [Any?] {
                var tmp : [DescribeNetworkInterfaceAttributeResponseBody.Ipv4PrefixSets.Ipv4PrefixSet] = []
                for v in value {
                    if v != nil {
                        var model = DescribeNetworkInterfaceAttributeResponseBody.Ipv4PrefixSets.Ipv4PrefixSet()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ipv4PrefixSet = tmp
            }
        }
    }
    public class Ipv6PrefixSets : Tea.TeaModel {
        public class Ipv6PrefixSet : Tea.TeaModel {
            public var ipv6Prefix: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipv6Prefix != nil {
                    map["Ipv6Prefix"] = self.ipv6Prefix!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Ipv6Prefix"] as? String {
                    self.ipv6Prefix = value
                }
            }
        }
        public var ipv6PrefixSet: [DescribeNetworkInterfaceAttributeResponseBody.Ipv6PrefixSets.Ipv6PrefixSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6PrefixSet != nil {
                var tmp : [Any] = []
                for k in self.ipv6PrefixSet! {
                    tmp.append(k.toMap())
                }
                map["Ipv6PrefixSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Ipv6PrefixSet"] as? [Any?] {
                var tmp : [DescribeNetworkInterfaceAttributeResponseBody.Ipv6PrefixSets.Ipv6PrefixSet] = []
                for v in value {
                    if v != nil {
                        var model = DescribeNetworkInterfaceAttributeResponseBody.Ipv6PrefixSets.Ipv6PrefixSet()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ipv6PrefixSet = tmp
            }
        }
    }
    public class Ipv6Sets : Tea.TeaModel {
        public class Ipv6Set : Tea.TeaModel {
            public var ipv6Address: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipv6Address != nil {
                    map["Ipv6Address"] = self.ipv6Address!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Ipv6Address"] as? String {
                    self.ipv6Address = value
                }
            }
        }
        public var ipv6Set: [DescribeNetworkInterfaceAttributeResponseBody.Ipv6Sets.Ipv6Set]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6Set != nil {
                var tmp : [Any] = []
                for k in self.ipv6Set! {
                    tmp.append(k.toMap())
                }
                map["Ipv6Set"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Ipv6Set"] as? [Any?] {
                var tmp : [DescribeNetworkInterfaceAttributeResponseBody.Ipv6Sets.Ipv6Set] = []
                for v in value {
                    if v != nil {
                        var model = DescribeNetworkInterfaceAttributeResponseBody.Ipv6Sets.Ipv6Set()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ipv6Set = tmp
            }
        }
    }
    public class NetworkInterfaceTrafficConfig : Tea.TeaModel {
        public var networkInterfaceTrafficMode: String?

        public var queueNumber: Int32?

        public var queuePairNumber: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.networkInterfaceTrafficMode != nil {
                map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
            }
            if self.queueNumber != nil {
                map["QueueNumber"] = self.queueNumber!
            }
            if self.queuePairNumber != nil {
                map["QueuePairNumber"] = self.queuePairNumber!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["NetworkInterfaceTrafficMode"] as? String {
                self.networkInterfaceTrafficMode = value
            }
            if let value = dict["QueueNumber"] as? Int32 {
                self.queueNumber = value
            }
            if let value = dict["QueuePairNumber"] as? Int32 {
                self.queuePairNumber = value
            }
        }
    }
    public class PrivateIpSets : Tea.TeaModel {
        public class PrivateIpSet : Tea.TeaModel {
            public class AssociatedPublicIp : Tea.TeaModel {
                public var allocationId: String?

                public var publicIpAddress: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.allocationId != nil {
                        map["AllocationId"] = self.allocationId!
                    }
                    if self.publicIpAddress != nil {
                        map["PublicIpAddress"] = self.publicIpAddress!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AllocationId"] as? String {
                        self.allocationId = value
                    }
                    if let value = dict["PublicIpAddress"] as? String {
                        self.publicIpAddress = value
                    }
                }
            }
            public var associatedPublicIp: DescribeNetworkInterfaceAttributeResponseBody.PrivateIpSets.PrivateIpSet.AssociatedPublicIp?

            public var primary: Bool?

            public var privateIpAddress: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.associatedPublicIp?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.associatedPublicIp != nil {
                    map["AssociatedPublicIp"] = self.associatedPublicIp?.toMap()
                }
                if self.primary != nil {
                    map["Primary"] = self.primary!
                }
                if self.privateIpAddress != nil {
                    map["PrivateIpAddress"] = self.privateIpAddress!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AssociatedPublicIp"] as? [String: Any?] {
                    var model = DescribeNetworkInterfaceAttributeResponseBody.PrivateIpSets.PrivateIpSet.AssociatedPublicIp()
                    model.fromMap(value)
                    self.associatedPublicIp = model
                }
                if let value = dict["Primary"] as? Bool {
                    self.primary = value
                }
                if let value = dict["PrivateIpAddress"] as? String {
                    self.privateIpAddress = value
                }
            }
        }
        public var privateIpSet: [DescribeNetworkInterfaceAttributeResponseBody.PrivateIpSets.PrivateIpSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.privateIpSet != nil {
                var tmp : [Any] = []
                for k in self.privateIpSet! {
                    tmp.append(k.toMap())
                }
                map["PrivateIpSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PrivateIpSet"] as? [Any?] {
                var tmp : [DescribeNetworkInterfaceAttributeResponseBody.PrivateIpSets.PrivateIpSet] = []
                for v in value {
                    if v != nil {
                        var model = DescribeNetworkInterfaceAttributeResponseBody.PrivateIpSets.PrivateIpSet()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.privateIpSet = tmp
            }
        }
    }
    public class SecurityGroupIds : Tea.TeaModel {
        public var securityGroupId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SecurityGroupId"] as? [String] {
                self.securityGroupId = value
            }
        }
    }
    public class SlaveInterfaceSpecification : Tea.TeaModel {
        public var bondNetworkInterfaceId: String?

        public var slaveNetworkInterfaceId: String?

        public var workState: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bondNetworkInterfaceId != nil {
                map["BondNetworkInterfaceId"] = self.bondNetworkInterfaceId!
            }
            if self.slaveNetworkInterfaceId != nil {
                map["SlaveNetworkInterfaceId"] = self.slaveNetworkInterfaceId!
            }
            if self.workState != nil {
                map["WorkState"] = self.workState!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BondNetworkInterfaceId"] as? String {
                self.bondNetworkInterfaceId = value
            }
            if let value = dict["SlaveNetworkInterfaceId"] as? String {
                self.slaveNetworkInterfaceId = value
            }
            if let value = dict["WorkState"] as? String {
                self.workState = value
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public class Tag : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public var tag: [DescribeNetworkInterfaceAttributeResponseBody.Tags.Tag]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tag != nil {
                var tmp : [Any] = []
                for k in self.tag! {
                    tmp.append(k.toMap())
                }
                map["Tag"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Tag"] as? [Any?] {
                var tmp : [DescribeNetworkInterfaceAttributeResponseBody.Tags.Tag] = []
                for v in value {
                    if v != nil {
                        var model = DescribeNetworkInterfaceAttributeResponseBody.Tags.Tag()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tag = tmp
            }
        }
    }
    public var associatedPublicIp: DescribeNetworkInterfaceAttributeResponseBody.AssociatedPublicIp?

    public var attachment: DescribeNetworkInterfaceAttributeResponseBody.Attachment?

    public var bondInterfaceSpecification: DescribeNetworkInterfaceAttributeResponseBody.BondInterfaceSpecification?

    public var connectionTrackingConfiguration: DescribeNetworkInterfaceAttributeResponseBody.ConnectionTrackingConfiguration?

    public var creationTime: String?

    public var deleteOnRelease: Bool?

    public var description_: String?

    public var enhancedNetwork: DescribeNetworkInterfaceAttributeResponseBody.EnhancedNetwork?

    public var instanceId: String?

    public var ipv4PrefixSets: DescribeNetworkInterfaceAttributeResponseBody.Ipv4PrefixSets?

    public var ipv6PrefixSets: DescribeNetworkInterfaceAttributeResponseBody.Ipv6PrefixSets?

    public var ipv6Sets: DescribeNetworkInterfaceAttributeResponseBody.Ipv6Sets?

    public var macAddress: String?

    public var networkInterfaceId: String?

    public var networkInterfaceName: String?

    public var networkInterfaceTrafficConfig: DescribeNetworkInterfaceAttributeResponseBody.NetworkInterfaceTrafficConfig?

    public var networkInterfaceTrafficMode: String?

    public var ownerId: String?

    public var privateIpAddress: String?

    public var privateIpSets: DescribeNetworkInterfaceAttributeResponseBody.PrivateIpSets?

    public var queueNumber: Int32?

    public var queuePairNumber: Int32?

    public var requestId: String?

    public var resourceGroupId: String?

    public var securityGroupIds: DescribeNetworkInterfaceAttributeResponseBody.SecurityGroupIds?

    public var serviceID: Int64?

    public var serviceManaged: Bool?

    public var slaveInterfaceSpecification: DescribeNetworkInterfaceAttributeResponseBody.SlaveInterfaceSpecification?

    public var sourceDestCheck: Bool?

    public var status: String?

    public var tags: DescribeNetworkInterfaceAttributeResponseBody.Tags?

    public var tcpOptionAddressEnabled: String?

    public var type: String?

    public var vSwitchId: String?

    public var vpcId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.associatedPublicIp?.validate()
        try self.attachment?.validate()
        try self.bondInterfaceSpecification?.validate()
        try self.connectionTrackingConfiguration?.validate()
        try self.enhancedNetwork?.validate()
        try self.ipv4PrefixSets?.validate()
        try self.ipv6PrefixSets?.validate()
        try self.ipv6Sets?.validate()
        try self.networkInterfaceTrafficConfig?.validate()
        try self.privateIpSets?.validate()
        try self.securityGroupIds?.validate()
        try self.slaveInterfaceSpecification?.validate()
        try self.tags?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.associatedPublicIp != nil {
            map["AssociatedPublicIp"] = self.associatedPublicIp?.toMap()
        }
        if self.attachment != nil {
            map["Attachment"] = self.attachment?.toMap()
        }
        if self.bondInterfaceSpecification != nil {
            map["BondInterfaceSpecification"] = self.bondInterfaceSpecification?.toMap()
        }
        if self.connectionTrackingConfiguration != nil {
            map["ConnectionTrackingConfiguration"] = self.connectionTrackingConfiguration?.toMap()
        }
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.deleteOnRelease != nil {
            map["DeleteOnRelease"] = self.deleteOnRelease!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enhancedNetwork != nil {
            map["EnhancedNetwork"] = self.enhancedNetwork?.toMap()
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ipv4PrefixSets != nil {
            map["Ipv4PrefixSets"] = self.ipv4PrefixSets?.toMap()
        }
        if self.ipv6PrefixSets != nil {
            map["Ipv6PrefixSets"] = self.ipv6PrefixSets?.toMap()
        }
        if self.ipv6Sets != nil {
            map["Ipv6Sets"] = self.ipv6Sets?.toMap()
        }
        if self.macAddress != nil {
            map["MacAddress"] = self.macAddress!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.networkInterfaceName != nil {
            map["NetworkInterfaceName"] = self.networkInterfaceName!
        }
        if self.networkInterfaceTrafficConfig != nil {
            map["NetworkInterfaceTrafficConfig"] = self.networkInterfaceTrafficConfig?.toMap()
        }
        if self.networkInterfaceTrafficMode != nil {
            map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.privateIpSets != nil {
            map["PrivateIpSets"] = self.privateIpSets?.toMap()
        }
        if self.queueNumber != nil {
            map["QueueNumber"] = self.queueNumber!
        }
        if self.queuePairNumber != nil {
            map["QueuePairNumber"] = self.queuePairNumber!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds?.toMap()
        }
        if self.serviceID != nil {
            map["ServiceID"] = self.serviceID!
        }
        if self.serviceManaged != nil {
            map["ServiceManaged"] = self.serviceManaged!
        }
        if self.slaveInterfaceSpecification != nil {
            map["SlaveInterfaceSpecification"] = self.slaveInterfaceSpecification?.toMap()
        }
        if self.sourceDestCheck != nil {
            map["SourceDestCheck"] = self.sourceDestCheck!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tags != nil {
            map["Tags"] = self.tags?.toMap()
        }
        if self.tcpOptionAddressEnabled != nil {
            map["TcpOptionAddressEnabled"] = self.tcpOptionAddressEnabled!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AssociatedPublicIp"] as? [String: Any?] {
            var model = DescribeNetworkInterfaceAttributeResponseBody.AssociatedPublicIp()
            model.fromMap(value)
            self.associatedPublicIp = model
        }
        if let value = dict["Attachment"] as? [String: Any?] {
            var model = DescribeNetworkInterfaceAttributeResponseBody.Attachment()
            model.fromMap(value)
            self.attachment = model
        }
        if let value = dict["BondInterfaceSpecification"] as? [String: Any?] {
            var model = DescribeNetworkInterfaceAttributeResponseBody.BondInterfaceSpecification()
            model.fromMap(value)
            self.bondInterfaceSpecification = model
        }
        if let value = dict["ConnectionTrackingConfiguration"] as? [String: Any?] {
            var model = DescribeNetworkInterfaceAttributeResponseBody.ConnectionTrackingConfiguration()
            model.fromMap(value)
            self.connectionTrackingConfiguration = model
        }
        if let value = dict["CreationTime"] as? String {
            self.creationTime = value
        }
        if let value = dict["DeleteOnRelease"] as? Bool {
            self.deleteOnRelease = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EnhancedNetwork"] as? [String: Any?] {
            var model = DescribeNetworkInterfaceAttributeResponseBody.EnhancedNetwork()
            model.fromMap(value)
            self.enhancedNetwork = model
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Ipv4PrefixSets"] as? [String: Any?] {
            var model = DescribeNetworkInterfaceAttributeResponseBody.Ipv4PrefixSets()
            model.fromMap(value)
            self.ipv4PrefixSets = model
        }
        if let value = dict["Ipv6PrefixSets"] as? [String: Any?] {
            var model = DescribeNetworkInterfaceAttributeResponseBody.Ipv6PrefixSets()
            model.fromMap(value)
            self.ipv6PrefixSets = model
        }
        if let value = dict["Ipv6Sets"] as? [String: Any?] {
            var model = DescribeNetworkInterfaceAttributeResponseBody.Ipv6Sets()
            model.fromMap(value)
            self.ipv6Sets = model
        }
        if let value = dict["MacAddress"] as? String {
            self.macAddress = value
        }
        if let value = dict["NetworkInterfaceId"] as? String {
            self.networkInterfaceId = value
        }
        if let value = dict["NetworkInterfaceName"] as? String {
            self.networkInterfaceName = value
        }
        if let value = dict["NetworkInterfaceTrafficConfig"] as? [String: Any?] {
            var model = DescribeNetworkInterfaceAttributeResponseBody.NetworkInterfaceTrafficConfig()
            model.fromMap(value)
            self.networkInterfaceTrafficConfig = model
        }
        if let value = dict["NetworkInterfaceTrafficMode"] as? String {
            self.networkInterfaceTrafficMode = value
        }
        if let value = dict["OwnerId"] as? String {
            self.ownerId = value
        }
        if let value = dict["PrivateIpAddress"] as? String {
            self.privateIpAddress = value
        }
        if let value = dict["PrivateIpSets"] as? [String: Any?] {
            var model = DescribeNetworkInterfaceAttributeResponseBody.PrivateIpSets()
            model.fromMap(value)
            self.privateIpSets = model
        }
        if let value = dict["QueueNumber"] as? Int32 {
            self.queueNumber = value
        }
        if let value = dict["QueuePairNumber"] as? Int32 {
            self.queuePairNumber = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["SecurityGroupIds"] as? [String: Any?] {
            var model = DescribeNetworkInterfaceAttributeResponseBody.SecurityGroupIds()
            model.fromMap(value)
            self.securityGroupIds = model
        }
        if let value = dict["ServiceID"] as? Int64 {
            self.serviceID = value
        }
        if let value = dict["ServiceManaged"] as? Bool {
            self.serviceManaged = value
        }
        if let value = dict["SlaveInterfaceSpecification"] as? [String: Any?] {
            var model = DescribeNetworkInterfaceAttributeResponseBody.SlaveInterfaceSpecification()
            model.fromMap(value)
            self.slaveInterfaceSpecification = model
        }
        if let value = dict["SourceDestCheck"] as? Bool {
            self.sourceDestCheck = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tags"] as? [String: Any?] {
            var model = DescribeNetworkInterfaceAttributeResponseBody.Tags()
            model.fromMap(value)
            self.tags = model
        }
        if let value = dict["TcpOptionAddressEnabled"] as? String {
            self.tcpOptionAddressEnabled = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribeNetworkInterfaceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNetworkInterfaceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeNetworkInterfaceAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeNetworkInterfacePermissionsRequest : Tea.TeaModel {
    public var networkInterfaceId: String?

    public var networkInterfacePermissionId: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.networkInterfacePermissionId != nil {
            map["NetworkInterfacePermissionId"] = self.networkInterfacePermissionId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NetworkInterfaceId"] as? String {
            self.networkInterfaceId = value
        }
        if let value = dict["NetworkInterfacePermissionId"] as? [String] {
            self.networkInterfacePermissionId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeNetworkInterfacePermissionsResponseBody : Tea.TeaModel {
    public class NetworkInterfacePermissions : Tea.TeaModel {
        public class NetworkInterfacePermission : Tea.TeaModel {
            public var accountId: Int64?

            public var networkInterfaceId: String?

            public var networkInterfacePermissionId: String?

            public var permission: String?

            public var permissionState: String?

            public var serviceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountId != nil {
                    map["AccountId"] = self.accountId!
                }
                if self.networkInterfaceId != nil {
                    map["NetworkInterfaceId"] = self.networkInterfaceId!
                }
                if self.networkInterfacePermissionId != nil {
                    map["NetworkInterfacePermissionId"] = self.networkInterfacePermissionId!
                }
                if self.permission != nil {
                    map["Permission"] = self.permission!
                }
                if self.permissionState != nil {
                    map["PermissionState"] = self.permissionState!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccountId"] as? Int64 {
                    self.accountId = value
                }
                if let value = dict["NetworkInterfaceId"] as? String {
                    self.networkInterfaceId = value
                }
                if let value = dict["NetworkInterfacePermissionId"] as? String {
                    self.networkInterfacePermissionId = value
                }
                if let value = dict["Permission"] as? String {
                    self.permission = value
                }
                if let value = dict["PermissionState"] as? String {
                    self.permissionState = value
                }
                if let value = dict["ServiceName"] as? String {
                    self.serviceName = value
                }
            }
        }
        public var networkInterfacePermission: [DescribeNetworkInterfacePermissionsResponseBody.NetworkInterfacePermissions.NetworkInterfacePermission]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.networkInterfacePermission != nil {
                var tmp : [Any] = []
                for k in self.networkInterfacePermission! {
                    tmp.append(k.toMap())
                }
                map["NetworkInterfacePermission"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["NetworkInterfacePermission"] as? [Any?] {
                var tmp : [DescribeNetworkInterfacePermissionsResponseBody.NetworkInterfacePermissions.NetworkInterfacePermission] = []
                for v in value {
                    if v != nil {
                        var model = DescribeNetworkInterfacePermissionsResponseBody.NetworkInterfacePermissions.NetworkInterfacePermission()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.networkInterfacePermission = tmp
            }
        }
    }
    public var networkInterfacePermissions: DescribeNetworkInterfacePermissionsResponseBody.NetworkInterfacePermissions?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkInterfacePermissions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkInterfacePermissions != nil {
            map["NetworkInterfacePermissions"] = self.networkInterfacePermissions?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NetworkInterfacePermissions"] as? [String: Any?] {
            var model = DescribeNetworkInterfacePermissionsResponseBody.NetworkInterfacePermissions()
            model.fromMap(value)
            self.networkInterfacePermissions = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeNetworkInterfacePermissionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNetworkInterfacePermissionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeNetworkInterfacePermissionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeNetworkInterfacesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var instanceId: String?

    public var ipv6Address: [String]?

    public var maxResults: Int32?

    public var networkInterfaceId: [String]?

    public var networkInterfaceName: String?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var primaryIpAddress: String?

    public var privateIpAddress: [String]?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public var serviceManaged: Bool?

    public var status: String?

    public var tag: [DescribeNetworkInterfacesRequest.Tag]?

    public var type: String?

    public var vSwitchId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ipv6Address != nil {
            map["Ipv6Address"] = self.ipv6Address!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.networkInterfaceName != nil {
            map["NetworkInterfaceName"] = self.networkInterfaceName!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.primaryIpAddress != nil {
            map["PrimaryIpAddress"] = self.primaryIpAddress!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.serviceManaged != nil {
            map["ServiceManaged"] = self.serviceManaged!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Ipv6Address"] as? [String] {
            self.ipv6Address = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NetworkInterfaceId"] as? [String] {
            self.networkInterfaceId = value
        }
        if let value = dict["NetworkInterfaceName"] as? String {
            self.networkInterfaceName = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["PrimaryIpAddress"] as? String {
            self.primaryIpAddress = value
        }
        if let value = dict["PrivateIpAddress"] as? [String] {
            self.privateIpAddress = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["ServiceManaged"] as? Bool {
            self.serviceManaged = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeNetworkInterfacesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeNetworkInterfacesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class DescribeNetworkInterfacesResponseBody : Tea.TeaModel {
    public class NetworkInterfaceSets : Tea.TeaModel {
        public class NetworkInterfaceSet : Tea.TeaModel {
            public class AssociatedPublicIp : Tea.TeaModel {
                public var allocationId: String?

                public var publicIpAddress: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.allocationId != nil {
                        map["AllocationId"] = self.allocationId!
                    }
                    if self.publicIpAddress != nil {
                        map["PublicIpAddress"] = self.publicIpAddress!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AllocationId"] as? String {
                        self.allocationId = value
                    }
                    if let value = dict["PublicIpAddress"] as? String {
                        self.publicIpAddress = value
                    }
                }
            }
            public class Attachment : Tea.TeaModel {
                public var deviceIndex: Int32?

                public var instanceId: String?

                public var networkCardIndex: Int32?

                public var trunkNetworkInterfaceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.deviceIndex != nil {
                        map["DeviceIndex"] = self.deviceIndex!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.networkCardIndex != nil {
                        map["NetworkCardIndex"] = self.networkCardIndex!
                    }
                    if self.trunkNetworkInterfaceId != nil {
                        map["TrunkNetworkInterfaceId"] = self.trunkNetworkInterfaceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DeviceIndex"] as? Int32 {
                        self.deviceIndex = value
                    }
                    if let value = dict["InstanceId"] as? String {
                        self.instanceId = value
                    }
                    if let value = dict["NetworkCardIndex"] as? Int32 {
                        self.networkCardIndex = value
                    }
                    if let value = dict["TrunkNetworkInterfaceId"] as? String {
                        self.trunkNetworkInterfaceId = value
                    }
                }
            }
            public class Ipv4PrefixSets : Tea.TeaModel {
                public class Ipv4PrefixSet : Tea.TeaModel {
                    public var ipv4Prefix: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ipv4Prefix != nil {
                            map["Ipv4Prefix"] = self.ipv4Prefix!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Ipv4Prefix"] as? String {
                            self.ipv4Prefix = value
                        }
                    }
                }
                public var ipv4PrefixSet: [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv4PrefixSets.Ipv4PrefixSet]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipv4PrefixSet != nil {
                        var tmp : [Any] = []
                        for k in self.ipv4PrefixSet! {
                            tmp.append(k.toMap())
                        }
                        map["Ipv4PrefixSet"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Ipv4PrefixSet"] as? [Any?] {
                        var tmp : [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv4PrefixSets.Ipv4PrefixSet] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv4PrefixSets.Ipv4PrefixSet()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.ipv4PrefixSet = tmp
                    }
                }
            }
            public class Ipv6PrefixSets : Tea.TeaModel {
                public class Ipv6PrefixSet : Tea.TeaModel {
                    public var ipv6Prefix: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ipv6Prefix != nil {
                            map["Ipv6Prefix"] = self.ipv6Prefix!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Ipv6Prefix"] as? String {
                            self.ipv6Prefix = value
                        }
                    }
                }
                public var ipv6PrefixSet: [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv6PrefixSets.Ipv6PrefixSet]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipv6PrefixSet != nil {
                        var tmp : [Any] = []
                        for k in self.ipv6PrefixSet! {
                            tmp.append(k.toMap())
                        }
                        map["Ipv6PrefixSet"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Ipv6PrefixSet"] as? [Any?] {
                        var tmp : [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv6PrefixSets.Ipv6PrefixSet] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv6PrefixSets.Ipv6PrefixSet()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.ipv6PrefixSet = tmp
                    }
                }
            }
            public class Ipv6Sets : Tea.TeaModel {
                public class Ipv6Set : Tea.TeaModel {
                    public var ipv6Address: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ipv6Address != nil {
                            map["Ipv6Address"] = self.ipv6Address!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Ipv6Address"] as? String {
                            self.ipv6Address = value
                        }
                    }
                }
                public var ipv6Set: [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv6Sets.Ipv6Set]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipv6Set != nil {
                        var tmp : [Any] = []
                        for k in self.ipv6Set! {
                            tmp.append(k.toMap())
                        }
                        map["Ipv6Set"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Ipv6Set"] as? [Any?] {
                        var tmp : [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv6Sets.Ipv6Set] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv6Sets.Ipv6Set()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.ipv6Set = tmp
                    }
                }
            }
            public class PrivateIpSets : Tea.TeaModel {
                public class PrivateIpSet : Tea.TeaModel {
                    public class AssociatedPublicIp : Tea.TeaModel {
                        public var allocationId: String?

                        public var publicIpAddress: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.allocationId != nil {
                                map["AllocationId"] = self.allocationId!
                            }
                            if self.publicIpAddress != nil {
                                map["PublicIpAddress"] = self.publicIpAddress!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["AllocationId"] as? String {
                                self.allocationId = value
                            }
                            if let value = dict["PublicIpAddress"] as? String {
                                self.publicIpAddress = value
                            }
                        }
                    }
                    public var associatedPublicIp: DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets.PrivateIpSet.AssociatedPublicIp?

                    public var primary: Bool?

                    public var privateDnsName: String?

                    public var privateIpAddress: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.associatedPublicIp?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.associatedPublicIp != nil {
                            map["AssociatedPublicIp"] = self.associatedPublicIp?.toMap()
                        }
                        if self.primary != nil {
                            map["Primary"] = self.primary!
                        }
                        if self.privateDnsName != nil {
                            map["PrivateDnsName"] = self.privateDnsName!
                        }
                        if self.privateIpAddress != nil {
                            map["PrivateIpAddress"] = self.privateIpAddress!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AssociatedPublicIp"] as? [String: Any?] {
                            var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets.PrivateIpSet.AssociatedPublicIp()
                            model.fromMap(value)
                            self.associatedPublicIp = model
                        }
                        if let value = dict["Primary"] as? Bool {
                            self.primary = value
                        }
                        if let value = dict["PrivateDnsName"] as? String {
                            self.privateDnsName = value
                        }
                        if let value = dict["PrivateIpAddress"] as? String {
                            self.privateIpAddress = value
                        }
                    }
                }
                public var privateIpSet: [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets.PrivateIpSet]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.privateIpSet != nil {
                        var tmp : [Any] = []
                        for k in self.privateIpSet! {
                            tmp.append(k.toMap())
                        }
                        map["PrivateIpSet"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["PrivateIpSet"] as? [Any?] {
                        var tmp : [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets.PrivateIpSet] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets.PrivateIpSet()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.privateIpSet = tmp
                    }
                }
            }
            public class SecurityGroupIds : Tea.TeaModel {
                public var securityGroupId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.securityGroupId != nil {
                        map["SecurityGroupId"] = self.securityGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["SecurityGroupId"] as? [String] {
                        self.securityGroupId = value
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["TagKey"] as? String {
                            self.tagKey = value
                        }
                        if let value = dict["TagValue"] as? String {
                            self.tagValue = value
                        }
                    }
                }
                public var tag: [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var associatedPublicIp: DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.AssociatedPublicIp?

            public var attachment: DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Attachment?

            public var creationTime: String?

            public var deleteOnRelease: Bool?

            public var description_: String?

            public var instanceId: String?

            public var ipv4PrefixSets: DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv4PrefixSets?

            public var ipv6PrefixSets: DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv6PrefixSets?

            public var ipv6Sets: DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv6Sets?

            public var macAddress: String?

            public var networkInterfaceId: String?

            public var networkInterfaceName: String?

            public var networkInterfaceTrafficMode: String?

            public var ownerId: String?

            public var privateIpAddress: String?

            public var privateIpSets: DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets?

            public var queueNumber: Int32?

            public var queuePairNumber: Int32?

            public var resourceGroupId: String?

            public var securityGroupIds: DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.SecurityGroupIds?

            public var serviceID: Int64?

            public var serviceManaged: Bool?

            public var sourceDestCheck: Bool?

            public var status: String?

            public var tags: DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Tags?

            public var type: String?

            public var vSwitchId: String?

            public var vpcId: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.associatedPublicIp?.validate()
                try self.attachment?.validate()
                try self.ipv4PrefixSets?.validate()
                try self.ipv6PrefixSets?.validate()
                try self.ipv6Sets?.validate()
                try self.privateIpSets?.validate()
                try self.securityGroupIds?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.associatedPublicIp != nil {
                    map["AssociatedPublicIp"] = self.associatedPublicIp?.toMap()
                }
                if self.attachment != nil {
                    map["Attachment"] = self.attachment?.toMap()
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.deleteOnRelease != nil {
                    map["DeleteOnRelease"] = self.deleteOnRelease!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.ipv4PrefixSets != nil {
                    map["Ipv4PrefixSets"] = self.ipv4PrefixSets?.toMap()
                }
                if self.ipv6PrefixSets != nil {
                    map["Ipv6PrefixSets"] = self.ipv6PrefixSets?.toMap()
                }
                if self.ipv6Sets != nil {
                    map["Ipv6Sets"] = self.ipv6Sets?.toMap()
                }
                if self.macAddress != nil {
                    map["MacAddress"] = self.macAddress!
                }
                if self.networkInterfaceId != nil {
                    map["NetworkInterfaceId"] = self.networkInterfaceId!
                }
                if self.networkInterfaceName != nil {
                    map["NetworkInterfaceName"] = self.networkInterfaceName!
                }
                if self.networkInterfaceTrafficMode != nil {
                    map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
                }
                if self.ownerId != nil {
                    map["OwnerId"] = self.ownerId!
                }
                if self.privateIpAddress != nil {
                    map["PrivateIpAddress"] = self.privateIpAddress!
                }
                if self.privateIpSets != nil {
                    map["PrivateIpSets"] = self.privateIpSets?.toMap()
                }
                if self.queueNumber != nil {
                    map["QueueNumber"] = self.queueNumber!
                }
                if self.queuePairNumber != nil {
                    map["QueuePairNumber"] = self.queuePairNumber!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.securityGroupIds != nil {
                    map["SecurityGroupIds"] = self.securityGroupIds?.toMap()
                }
                if self.serviceID != nil {
                    map["ServiceID"] = self.serviceID!
                }
                if self.serviceManaged != nil {
                    map["ServiceManaged"] = self.serviceManaged!
                }
                if self.sourceDestCheck != nil {
                    map["SourceDestCheck"] = self.sourceDestCheck!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AssociatedPublicIp"] as? [String: Any?] {
                    var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.AssociatedPublicIp()
                    model.fromMap(value)
                    self.associatedPublicIp = model
                }
                if let value = dict["Attachment"] as? [String: Any?] {
                    var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Attachment()
                    model.fromMap(value)
                    self.attachment = model
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["DeleteOnRelease"] as? Bool {
                    self.deleteOnRelease = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["Ipv4PrefixSets"] as? [String: Any?] {
                    var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv4PrefixSets()
                    model.fromMap(value)
                    self.ipv4PrefixSets = model
                }
                if let value = dict["Ipv6PrefixSets"] as? [String: Any?] {
                    var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv6PrefixSets()
                    model.fromMap(value)
                    self.ipv6PrefixSets = model
                }
                if let value = dict["Ipv6Sets"] as? [String: Any?] {
                    var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv6Sets()
                    model.fromMap(value)
                    self.ipv6Sets = model
                }
                if let value = dict["MacAddress"] as? String {
                    self.macAddress = value
                }
                if let value = dict["NetworkInterfaceId"] as? String {
                    self.networkInterfaceId = value
                }
                if let value = dict["NetworkInterfaceName"] as? String {
                    self.networkInterfaceName = value
                }
                if let value = dict["NetworkInterfaceTrafficMode"] as? String {
                    self.networkInterfaceTrafficMode = value
                }
                if let value = dict["OwnerId"] as? String {
                    self.ownerId = value
                }
                if let value = dict["PrivateIpAddress"] as? String {
                    self.privateIpAddress = value
                }
                if let value = dict["PrivateIpSets"] as? [String: Any?] {
                    var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets()
                    model.fromMap(value)
                    self.privateIpSets = model
                }
                if let value = dict["QueueNumber"] as? Int32 {
                    self.queueNumber = value
                }
                if let value = dict["QueuePairNumber"] as? Int32 {
                    self.queuePairNumber = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["SecurityGroupIds"] as? [String: Any?] {
                    var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.SecurityGroupIds()
                    model.fromMap(value)
                    self.securityGroupIds = model
                }
                if let value = dict["ServiceID"] as? Int64 {
                    self.serviceID = value
                }
                if let value = dict["ServiceManaged"] as? Bool {
                    self.serviceManaged = value
                }
                if let value = dict["SourceDestCheck"] as? Bool {
                    self.sourceDestCheck = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["VSwitchId"] as? String {
                    self.vSwitchId = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var networkInterfaceSet: [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.networkInterfaceSet != nil {
                var tmp : [Any] = []
                for k in self.networkInterfaceSet! {
                    tmp.append(k.toMap())
                }
                map["NetworkInterfaceSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["NetworkInterfaceSet"] as? [Any?] {
                var tmp : [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet] = []
                for v in value {
                    if v != nil {
                        var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.networkInterfaceSet = tmp
            }
        }
    }
    public var networkInterfaceSets: DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets?

    public var nextToken: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkInterfaceSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkInterfaceSets != nil {
            map["NetworkInterfaceSets"] = self.networkInterfaceSets?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NetworkInterfaceSets"] as? [String: Any?] {
            var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets()
            model.fromMap(value)
            self.networkInterfaceSets = model
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeNetworkInterfacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNetworkInterfacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeNetworkInterfacesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeNewProjectEipMonitorDataRequest : Tea.TeaModel {
    public var allocationId: String?

    public var endTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AllocationId"] as? String {
            self.allocationId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeNewProjectEipMonitorDataResponseBody : Tea.TeaModel {
    public class EipMonitorDatas : Tea.TeaModel {
        public class EipMonitorData : Tea.TeaModel {
            public var eipBandwidth: Int32?

            public var eipFlow: Int32?

            public var eipPackets: Int32?

            public var eipRX: Int32?

            public var eipTX: Int32?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eipBandwidth != nil {
                    map["EipBandwidth"] = self.eipBandwidth!
                }
                if self.eipFlow != nil {
                    map["EipFlow"] = self.eipFlow!
                }
                if self.eipPackets != nil {
                    map["EipPackets"] = self.eipPackets!
                }
                if self.eipRX != nil {
                    map["EipRX"] = self.eipRX!
                }
                if self.eipTX != nil {
                    map["EipTX"] = self.eipTX!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["EipBandwidth"] as? Int32 {
                    self.eipBandwidth = value
                }
                if let value = dict["EipFlow"] as? Int32 {
                    self.eipFlow = value
                }
                if let value = dict["EipPackets"] as? Int32 {
                    self.eipPackets = value
                }
                if let value = dict["EipRX"] as? Int32 {
                    self.eipRX = value
                }
                if let value = dict["EipTX"] as? Int32 {
                    self.eipTX = value
                }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
            }
        }
        public var eipMonitorData: [DescribeNewProjectEipMonitorDataResponseBody.EipMonitorDatas.EipMonitorData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eipMonitorData != nil {
                var tmp : [Any] = []
                for k in self.eipMonitorData! {
                    tmp.append(k.toMap())
                }
                map["EipMonitorData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EipMonitorData"] as? [Any?] {
                var tmp : [DescribeNewProjectEipMonitorDataResponseBody.EipMonitorDatas.EipMonitorData] = []
                for v in value {
                    if v != nil {
                        var model = DescribeNewProjectEipMonitorDataResponseBody.EipMonitorDatas.EipMonitorData()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.eipMonitorData = tmp
            }
        }
    }
    public var eipMonitorDatas: DescribeNewProjectEipMonitorDataResponseBody.EipMonitorDatas?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eipMonitorDatas?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eipMonitorDatas != nil {
            map["EipMonitorDatas"] = self.eipMonitorDatas?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EipMonitorDatas"] as? [String: Any?] {
            var model = DescribeNewProjectEipMonitorDataResponseBody.EipMonitorDatas()
            model.fromMap(value)
            self.eipMonitorDatas = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeNewProjectEipMonitorDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNewProjectEipMonitorDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeNewProjectEipMonitorDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePhysicalConnectionsRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? [String] {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var filter: [DescribePhysicalConnectionsRequest.Filter]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userCidr: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Filter"] as? [Any?] {
            var tmp : [DescribePhysicalConnectionsRequest.Filter] = []
            for v in value {
                if v != nil {
                    var model = DescribePhysicalConnectionsRequest.Filter()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.filter = tmp
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["UserCidr"] as? String {
            self.userCidr = value
        }
    }
}

public class DescribePhysicalConnectionsResponseBody : Tea.TeaModel {
    public class PhysicalConnectionSet : Tea.TeaModel {
        public class PhysicalConnectionType : Tea.TeaModel {
            public var accessPointId: String?

            public var adLocation: String?

            public var bandwidth: Int64?

            public var businessStatus: String?

            public var circuitCode: String?

            public var creationTime: String?

            public var description_: String?

            public var enabledTime: String?

            public var lineOperator: String?

            public var name: String?

            public var peerLocation: String?

            public var physicalConnectionId: String?

            public var portNumber: String?

            public var portType: String?

            public var redundantPhysicalConnectionId: String?

            public var spec: String?

            public var status: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessPointId != nil {
                    map["AccessPointId"] = self.accessPointId!
                }
                if self.adLocation != nil {
                    map["AdLocation"] = self.adLocation!
                }
                if self.bandwidth != nil {
                    map["Bandwidth"] = self.bandwidth!
                }
                if self.businessStatus != nil {
                    map["BusinessStatus"] = self.businessStatus!
                }
                if self.circuitCode != nil {
                    map["CircuitCode"] = self.circuitCode!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.enabledTime != nil {
                    map["EnabledTime"] = self.enabledTime!
                }
                if self.lineOperator != nil {
                    map["LineOperator"] = self.lineOperator!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.peerLocation != nil {
                    map["PeerLocation"] = self.peerLocation!
                }
                if self.physicalConnectionId != nil {
                    map["PhysicalConnectionId"] = self.physicalConnectionId!
                }
                if self.portNumber != nil {
                    map["PortNumber"] = self.portNumber!
                }
                if self.portType != nil {
                    map["PortType"] = self.portType!
                }
                if self.redundantPhysicalConnectionId != nil {
                    map["RedundantPhysicalConnectionId"] = self.redundantPhysicalConnectionId!
                }
                if self.spec != nil {
                    map["Spec"] = self.spec!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccessPointId"] as? String {
                    self.accessPointId = value
                }
                if let value = dict["AdLocation"] as? String {
                    self.adLocation = value
                }
                if let value = dict["Bandwidth"] as? Int64 {
                    self.bandwidth = value
                }
                if let value = dict["BusinessStatus"] as? String {
                    self.businessStatus = value
                }
                if let value = dict["CircuitCode"] as? String {
                    self.circuitCode = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["EnabledTime"] as? String {
                    self.enabledTime = value
                }
                if let value = dict["LineOperator"] as? String {
                    self.lineOperator = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["PeerLocation"] as? String {
                    self.peerLocation = value
                }
                if let value = dict["PhysicalConnectionId"] as? String {
                    self.physicalConnectionId = value
                }
                if let value = dict["PortNumber"] as? String {
                    self.portNumber = value
                }
                if let value = dict["PortType"] as? String {
                    self.portType = value
                }
                if let value = dict["RedundantPhysicalConnectionId"] as? String {
                    self.redundantPhysicalConnectionId = value
                }
                if let value = dict["Spec"] as? String {
                    self.spec = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var physicalConnectionType: [DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet.PhysicalConnectionType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.physicalConnectionType != nil {
                var tmp : [Any] = []
                for k in self.physicalConnectionType! {
                    tmp.append(k.toMap())
                }
                map["PhysicalConnectionType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PhysicalConnectionType"] as? [Any?] {
                var tmp : [DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet.PhysicalConnectionType] = []
                for v in value {
                    if v != nil {
                        var model = DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet.PhysicalConnectionType()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.physicalConnectionType = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var physicalConnectionSet: DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.physicalConnectionSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.physicalConnectionSet != nil {
            map["PhysicalConnectionSet"] = self.physicalConnectionSet?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["PhysicalConnectionSet"] as? [String: Any?] {
            var model = DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet()
            model.fromMap(value)
            self.physicalConnectionSet = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribePhysicalConnectionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePhysicalConnectionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePhysicalConnectionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePortRangeListAssociationsRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var portRangeListId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.portRangeListId != nil {
            map["PortRangeListId"] = self.portRangeListId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PortRangeListId"] as? String {
            self.portRangeListId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribePortRangeListAssociationsResponseBody : Tea.TeaModel {
    public class PortRangeListAssociations : Tea.TeaModel {
        public var resourceId: String?

        public var resourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ResourceId"] as? String {
                self.resourceId = value
            }
            if let value = dict["ResourceType"] as? String {
                self.resourceType = value
            }
        }
    }
    public var nextToken: String?

    public var portRangeListAssociations: [DescribePortRangeListAssociationsResponseBody.PortRangeListAssociations]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.portRangeListAssociations != nil {
            var tmp : [Any] = []
            for k in self.portRangeListAssociations! {
                tmp.append(k.toMap())
            }
            map["PortRangeListAssociations"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PortRangeListAssociations"] as? [Any?] {
            var tmp : [DescribePortRangeListAssociationsResponseBody.PortRangeListAssociations] = []
            for v in value {
                if v != nil {
                    var model = DescribePortRangeListAssociationsResponseBody.PortRangeListAssociations()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.portRangeListAssociations = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribePortRangeListAssociationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePortRangeListAssociationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePortRangeListAssociationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePortRangeListEntriesRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var portRangeListId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.portRangeListId != nil {
            map["PortRangeListId"] = self.portRangeListId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PortRangeListId"] as? String {
            self.portRangeListId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribePortRangeListEntriesResponseBody : Tea.TeaModel {
    public class Entries : Tea.TeaModel {
        public var description_: String?

        public var portRange: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["PortRange"] as? String {
                self.portRange = value
            }
        }
    }
    public var entries: [DescribePortRangeListEntriesResponseBody.Entries]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entries != nil {
            var tmp : [Any] = []
            for k in self.entries! {
                tmp.append(k.toMap())
            }
            map["Entries"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Entries"] as? [Any?] {
            var tmp : [DescribePortRangeListEntriesResponseBody.Entries] = []
            for v in value {
                if v != nil {
                    var model = DescribePortRangeListEntriesResponseBody.Entries()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.entries = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribePortRangeListEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePortRangeListEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePortRangeListEntriesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePortRangeListsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var portRangeListId: [String]?

    public var portRangeListName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribePortRangeListsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.portRangeListId != nil {
            map["PortRangeListId"] = self.portRangeListId!
        }
        if self.portRangeListName != nil {
            map["PortRangeListName"] = self.portRangeListName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PortRangeListId"] as? [String] {
            self.portRangeListId = value
        }
        if let value = dict["PortRangeListName"] as? String {
            self.portRangeListName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribePortRangeListsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribePortRangeListsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribePortRangeListsResponseBody : Tea.TeaModel {
    public class PortRangeLists : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public var associationCount: Int32?

        public var creationTime: String?

        public var description_: String?

        public var maxEntries: Int32?

        public var portRangeListId: String?

        public var portRangeListName: String?

        public var resourceGroupId: String?

        public var tags: [DescribePortRangeListsResponseBody.PortRangeLists.Tags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.associationCount != nil {
                map["AssociationCount"] = self.associationCount!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.maxEntries != nil {
                map["MaxEntries"] = self.maxEntries!
            }
            if self.portRangeListId != nil {
                map["PortRangeListId"] = self.portRangeListId!
            }
            if self.portRangeListName != nil {
                map["PortRangeListName"] = self.portRangeListName!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AssociationCount"] as? Int32 {
                self.associationCount = value
            }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["MaxEntries"] as? Int32 {
                self.maxEntries = value
            }
            if let value = dict["PortRangeListId"] as? String {
                self.portRangeListId = value
            }
            if let value = dict["PortRangeListName"] as? String {
                self.portRangeListName = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [DescribePortRangeListsResponseBody.PortRangeLists.Tags] = []
                for v in value {
                    if v != nil {
                        var model = DescribePortRangeListsResponseBody.PortRangeLists.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
        }
    }
    public var nextToken: String?

    public var portRangeLists: [DescribePortRangeListsResponseBody.PortRangeLists]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.portRangeLists != nil {
            var tmp : [Any] = []
            for k in self.portRangeLists! {
                tmp.append(k.toMap())
            }
            map["PortRangeLists"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PortRangeLists"] as? [Any?] {
            var tmp : [DescribePortRangeListsResponseBody.PortRangeLists] = []
            for v in value {
                if v != nil {
                    var model = DescribePortRangeListsResponseBody.PortRangeLists()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.portRangeLists = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribePortRangeListsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePortRangeListsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePortRangeListsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePrefixListAssociationsRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var prefixListId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.prefixListId != nil {
            map["PrefixListId"] = self.prefixListId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PrefixListId"] as? String {
            self.prefixListId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribePrefixListAssociationsResponseBody : Tea.TeaModel {
    public class PrefixListAssociations : Tea.TeaModel {
        public class PrefixListAssociation : Tea.TeaModel {
            public var resourceId: String?

            public var resourceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
            }
        }
        public var prefixListAssociation: [DescribePrefixListAssociationsResponseBody.PrefixListAssociations.PrefixListAssociation]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.prefixListAssociation != nil {
                var tmp : [Any] = []
                for k in self.prefixListAssociation! {
                    tmp.append(k.toMap())
                }
                map["PrefixListAssociation"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PrefixListAssociation"] as? [Any?] {
                var tmp : [DescribePrefixListAssociationsResponseBody.PrefixListAssociations.PrefixListAssociation] = []
                for v in value {
                    if v != nil {
                        var model = DescribePrefixListAssociationsResponseBody.PrefixListAssociations.PrefixListAssociation()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.prefixListAssociation = tmp
            }
        }
    }
    public var nextToken: String?

    public var prefixListAssociations: DescribePrefixListAssociationsResponseBody.PrefixListAssociations?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.prefixListAssociations?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.prefixListAssociations != nil {
            map["PrefixListAssociations"] = self.prefixListAssociations?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PrefixListAssociations"] as? [String: Any?] {
            var model = DescribePrefixListAssociationsResponseBody.PrefixListAssociations()
            model.fromMap(value)
            self.prefixListAssociations = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribePrefixListAssociationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePrefixListAssociationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePrefixListAssociationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePrefixListAttributesRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var prefixListId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.prefixListId != nil {
            map["PrefixListId"] = self.prefixListId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PrefixListId"] as? String {
            self.prefixListId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribePrefixListAttributesResponseBody : Tea.TeaModel {
    public class Entries : Tea.TeaModel {
        public class Entry : Tea.TeaModel {
            public var cidr: String?

            public var description_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cidr != nil {
                    map["Cidr"] = self.cidr!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Cidr"] as? String {
                    self.cidr = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
            }
        }
        public var entry: [DescribePrefixListAttributesResponseBody.Entries.Entry]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.entry != nil {
                var tmp : [Any] = []
                for k in self.entry! {
                    tmp.append(k.toMap())
                }
                map["Entry"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Entry"] as? [Any?] {
                var tmp : [DescribePrefixListAttributesResponseBody.Entries.Entry] = []
                for v in value {
                    if v != nil {
                        var model = DescribePrefixListAttributesResponseBody.Entries.Entry()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.entry = tmp
            }
        }
    }
    public var addressFamily: String?

    public var creationTime: String?

    public var description_: String?

    public var entries: DescribePrefixListAttributesResponseBody.Entries?

    public var maxEntries: Int32?

    public var prefixListId: String?

    public var prefixListName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.entries?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressFamily != nil {
            map["AddressFamily"] = self.addressFamily!
        }
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.entries != nil {
            map["Entries"] = self.entries?.toMap()
        }
        if self.maxEntries != nil {
            map["MaxEntries"] = self.maxEntries!
        }
        if self.prefixListId != nil {
            map["PrefixListId"] = self.prefixListId!
        }
        if self.prefixListName != nil {
            map["PrefixListName"] = self.prefixListName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddressFamily"] as? String {
            self.addressFamily = value
        }
        if let value = dict["CreationTime"] as? String {
            self.creationTime = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Entries"] as? [String: Any?] {
            var model = DescribePrefixListAttributesResponseBody.Entries()
            model.fromMap(value)
            self.entries = model
        }
        if let value = dict["MaxEntries"] as? Int32 {
            self.maxEntries = value
        }
        if let value = dict["PrefixListId"] as? String {
            self.prefixListId = value
        }
        if let value = dict["PrefixListName"] as? String {
            self.prefixListName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribePrefixListAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePrefixListAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePrefixListAttributesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePrefixListsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var addressFamily: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var prefixListId: [String]?

    public var prefixListName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribePrefixListsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressFamily != nil {
            map["AddressFamily"] = self.addressFamily!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.prefixListId != nil {
            map["PrefixListId"] = self.prefixListId!
        }
        if self.prefixListName != nil {
            map["PrefixListName"] = self.prefixListName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddressFamily"] as? String {
            self.addressFamily = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PrefixListId"] as? [String] {
            self.prefixListId = value
        }
        if let value = dict["PrefixListName"] as? String {
            self.prefixListName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribePrefixListsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribePrefixListsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribePrefixListsResponseBody : Tea.TeaModel {
    public class PrefixLists : Tea.TeaModel {
        public class PrefixList : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["TagKey"] as? String {
                            self.tagKey = value
                        }
                        if let value = dict["TagValue"] as? String {
                            self.tagValue = value
                        }
                    }
                }
                public var tag: [DescribePrefixListsResponseBody.PrefixLists.PrefixList.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribePrefixListsResponseBody.PrefixLists.PrefixList.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribePrefixListsResponseBody.PrefixLists.PrefixList.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var addressFamily: String?

            public var associationCount: Int32?

            public var creationTime: String?

            public var description_: String?

            public var maxEntries: Int32?

            public var prefixListId: String?

            public var prefixListName: String?

            public var resourceGroupId: String?

            public var tags: DescribePrefixListsResponseBody.PrefixLists.PrefixList.Tags?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addressFamily != nil {
                    map["AddressFamily"] = self.addressFamily!
                }
                if self.associationCount != nil {
                    map["AssociationCount"] = self.associationCount!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.maxEntries != nil {
                    map["MaxEntries"] = self.maxEntries!
                }
                if self.prefixListId != nil {
                    map["PrefixListId"] = self.prefixListId!
                }
                if self.prefixListName != nil {
                    map["PrefixListName"] = self.prefixListName!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AddressFamily"] as? String {
                    self.addressFamily = value
                }
                if let value = dict["AssociationCount"] as? Int32 {
                    self.associationCount = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["MaxEntries"] as? Int32 {
                    self.maxEntries = value
                }
                if let value = dict["PrefixListId"] as? String {
                    self.prefixListId = value
                }
                if let value = dict["PrefixListName"] as? String {
                    self.prefixListName = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribePrefixListsResponseBody.PrefixLists.PrefixList.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
            }
        }
        public var prefixList: [DescribePrefixListsResponseBody.PrefixLists.PrefixList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.prefixList != nil {
                var tmp : [Any] = []
                for k in self.prefixList! {
                    tmp.append(k.toMap())
                }
                map["PrefixList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PrefixList"] as? [Any?] {
                var tmp : [DescribePrefixListsResponseBody.PrefixLists.PrefixList] = []
                for v in value {
                    if v != nil {
                        var model = DescribePrefixListsResponseBody.PrefixLists.PrefixList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.prefixList = tmp
            }
        }
    }
    public var nextToken: String?

    public var prefixLists: DescribePrefixListsResponseBody.PrefixLists?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.prefixLists?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.prefixLists != nil {
            map["PrefixLists"] = self.prefixLists?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PrefixLists"] as? [String: Any?] {
            var model = DescribePrefixListsResponseBody.PrefixLists()
            model.fromMap(value)
            self.prefixLists = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribePrefixListsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePrefixListsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePrefixListsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePriceRequest : Tea.TeaModel {
    public class DataDisk : Tea.TeaModel {
        public var category: String?

        public var performanceLevel: String?

        public var size: Int64?

        public var provisionedIops: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["PerformanceLevel"] as? String {
                self.performanceLevel = value
            }
            if let value = dict["Size"] as? Int64 {
                self.size = value
            }
            if let value = dict["ProvisionedIops"] as? Int64 {
                self.provisionedIops = value
            }
        }
    }
    public class SchedulerOptions : Tea.TeaModel {
        public var dedicatedHostId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dedicatedHostId != nil {
                map["DedicatedHostId"] = self.dedicatedHostId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DedicatedHostId"] as? String {
                self.dedicatedHostId = value
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var category: String?

        public var performanceLevel: String?

        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["PerformanceLevel"] as? String {
                self.performanceLevel = value
            }
            if let value = dict["Size"] as? Int32 {
                self.size = value
            }
        }
    }
    public class RecurrenceRules : Tea.TeaModel {
        public var endHour: Int32?

        public var recurrenceType: String?

        public var recurrenceValue: String?

        public var startHour: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endHour != nil {
                map["EndHour"] = self.endHour!
            }
            if self.recurrenceType != nil {
                map["RecurrenceType"] = self.recurrenceType!
            }
            if self.recurrenceValue != nil {
                map["RecurrenceValue"] = self.recurrenceValue!
            }
            if self.startHour != nil {
                map["StartHour"] = self.startHour!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EndHour"] as? Int32 {
                self.endHour = value
            }
            if let value = dict["RecurrenceType"] as? String {
                self.recurrenceType = value
            }
            if let value = dict["RecurrenceValue"] as? String {
                self.recurrenceValue = value
            }
            if let value = dict["StartHour"] as? Int32 {
                self.startHour = value
            }
        }
    }
    public var dataDisk: [DescribePriceRequest.DataDisk]?

    public var schedulerOptions: DescribePriceRequest.SchedulerOptions?

    public var systemDisk: DescribePriceRequest.SystemDisk?

    public var amount: Int32?

    public var assuranceTimes: String?

    public var capacity: Int32?

    public var dedicatedHostType: String?

    public var imageId: String?

    public var instanceAmount: Int32?

    public var instanceCpuCoreCount: Int32?

    public var instanceNetworkType: String?

    public var instanceType: String?

    public var instanceTypeList: [String]?

    public var internetChargeType: String?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var isp: String?

    public var offeringType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var platform: String?

    public var priceUnit: String?

    public var recurrenceRules: [DescribePriceRequest.RecurrenceRules]?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var scope: String?

    public var spotDuration: Int32?

    public var spotStrategy: String?

    public var startTime: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.schedulerOptions?.validate()
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataDisk != nil {
            var tmp : [Any] = []
            for k in self.dataDisk! {
                tmp.append(k.toMap())
            }
            map["DataDisk"] = tmp
        }
        if self.schedulerOptions != nil {
            map["SchedulerOptions"] = self.schedulerOptions?.toMap()
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.assuranceTimes != nil {
            map["AssuranceTimes"] = self.assuranceTimes!
        }
        if self.capacity != nil {
            map["Capacity"] = self.capacity!
        }
        if self.dedicatedHostType != nil {
            map["DedicatedHostType"] = self.dedicatedHostType!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceAmount != nil {
            map["InstanceAmount"] = self.instanceAmount!
        }
        if self.instanceCpuCoreCount != nil {
            map["InstanceCpuCoreCount"] = self.instanceCpuCoreCount!
        }
        if self.instanceNetworkType != nil {
            map["InstanceNetworkType"] = self.instanceNetworkType!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.instanceTypeList != nil {
            map["InstanceTypeList"] = self.instanceTypeList!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.offeringType != nil {
            map["OfferingType"] = self.offeringType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.priceUnit != nil {
            map["PriceUnit"] = self.priceUnit!
        }
        if self.recurrenceRules != nil {
            var tmp : [Any] = []
            for k in self.recurrenceRules! {
                tmp.append(k.toMap())
            }
            map["RecurrenceRules"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataDisk"] as? [Any?] {
            var tmp : [DescribePriceRequest.DataDisk] = []
            for v in value {
                if v != nil {
                    var model = DescribePriceRequest.DataDisk()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.dataDisk = tmp
        }
        if let value = dict["SchedulerOptions"] as? [String: Any?] {
            var model = DescribePriceRequest.SchedulerOptions()
            model.fromMap(value)
            self.schedulerOptions = model
        }
        if let value = dict["SystemDisk"] as? [String: Any?] {
            var model = DescribePriceRequest.SystemDisk()
            model.fromMap(value)
            self.systemDisk = model
        }
        if let value = dict["Amount"] as? Int32 {
            self.amount = value
        }
        if let value = dict["AssuranceTimes"] as? String {
            self.assuranceTimes = value
        }
        if let value = dict["Capacity"] as? Int32 {
            self.capacity = value
        }
        if let value = dict["DedicatedHostType"] as? String {
            self.dedicatedHostType = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["InstanceAmount"] as? Int32 {
            self.instanceAmount = value
        }
        if let value = dict["InstanceCpuCoreCount"] as? Int32 {
            self.instanceCpuCoreCount = value
        }
        if let value = dict["InstanceNetworkType"] as? String {
            self.instanceNetworkType = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["InstanceTypeList"] as? [String] {
            self.instanceTypeList = value
        }
        if let value = dict["InternetChargeType"] as? String {
            self.internetChargeType = value
        }
        if let value = dict["InternetMaxBandwidthOut"] as? Int32 {
            self.internetMaxBandwidthOut = value
        }
        if let value = dict["IoOptimized"] as? String {
            self.ioOptimized = value
        }
        if let value = dict["Isp"] as? String {
            self.isp = value
        }
        if let value = dict["OfferingType"] as? String {
            self.offeringType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["Platform"] as? String {
            self.platform = value
        }
        if let value = dict["PriceUnit"] as? String {
            self.priceUnit = value
        }
        if let value = dict["RecurrenceRules"] as? [Any?] {
            var tmp : [DescribePriceRequest.RecurrenceRules] = []
            for v in value {
                if v != nil {
                    var model = DescribePriceRequest.RecurrenceRules()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.recurrenceRules = tmp
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Scope"] as? String {
            self.scope = value
        }
        if let value = dict["SpotDuration"] as? Int32 {
            self.spotDuration = value
        }
        if let value = dict["SpotStrategy"] as? String {
            self.spotStrategy = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribePriceResponseBody : Tea.TeaModel {
    public class PriceInfo : Tea.TeaModel {
        public class Price : Tea.TeaModel {
            public class DetailInfos : Tea.TeaModel {
                public class DetailInfo : Tea.TeaModel {
                    public class SubRules : Tea.TeaModel {
                        public class Rule : Tea.TeaModel {
                            public var description_: String?

                            public var ruleId: Int64?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.description_ != nil {
                                    map["Description"] = self.description_!
                                }
                                if self.ruleId != nil {
                                    map["RuleId"] = self.ruleId!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["Description"] as? String {
                                    self.description_ = value
                                }
                                if let value = dict["RuleId"] as? Int64 {
                                    self.ruleId = value
                                }
                            }
                        }
                        public var rule: [DescribePriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo.SubRules.Rule]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.rule != nil {
                                var tmp : [Any] = []
                                for k in self.rule! {
                                    tmp.append(k.toMap())
                                }
                                map["Rule"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Rule"] as? [Any?] {
                                var tmp : [DescribePriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo.SubRules.Rule] = []
                                for v in value {
                                    if v != nil {
                                        var model = DescribePriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo.SubRules.Rule()
                                        if v != nil {
                                            model.fromMap(v as? [String: Any?])
                                        }
                                        tmp.append(model)
                                    }
                                }
                                self.rule = tmp
                            }
                        }
                    }
                    public var discountPrice: Double?

                    public var originalPrice: Double?

                    public var resource: String?

                    public var subRules: DescribePriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo.SubRules?

                    public var tradePrice: Double?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.subRules?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.discountPrice != nil {
                            map["DiscountPrice"] = self.discountPrice!
                        }
                        if self.originalPrice != nil {
                            map["OriginalPrice"] = self.originalPrice!
                        }
                        if self.resource != nil {
                            map["Resource"] = self.resource!
                        }
                        if self.subRules != nil {
                            map["SubRules"] = self.subRules?.toMap()
                        }
                        if self.tradePrice != nil {
                            map["TradePrice"] = self.tradePrice!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["DiscountPrice"] as? Double {
                            self.discountPrice = value
                        }
                        if let value = dict["OriginalPrice"] as? Double {
                            self.originalPrice = value
                        }
                        if let value = dict["Resource"] as? String {
                            self.resource = value
                        }
                        if let value = dict["SubRules"] as? [String: Any?] {
                            var model = DescribePriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo.SubRules()
                            model.fromMap(value)
                            self.subRules = model
                        }
                        if let value = dict["TradePrice"] as? Double {
                            self.tradePrice = value
                        }
                    }
                }
                public var detailInfo: [DescribePriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.detailInfo != nil {
                        var tmp : [Any] = []
                        for k in self.detailInfo! {
                            tmp.append(k.toMap())
                        }
                        map["DetailInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DetailInfo"] as? [Any?] {
                        var tmp : [DescribePriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo] = []
                        for v in value {
                            if v != nil {
                                var model = DescribePriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.detailInfo = tmp
                    }
                }
            }
            public var currency: String?

            public var detailInfos: DescribePriceResponseBody.PriceInfo.Price.DetailInfos?

            public var discountPrice: Double?

            public var originalPrice: Double?

            public var reservedInstanceHourPrice: Double?

            public var tradePrice: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.detailInfos?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.currency != nil {
                    map["Currency"] = self.currency!
                }
                if self.detailInfos != nil {
                    map["DetailInfos"] = self.detailInfos?.toMap()
                }
                if self.discountPrice != nil {
                    map["DiscountPrice"] = self.discountPrice!
                }
                if self.originalPrice != nil {
                    map["OriginalPrice"] = self.originalPrice!
                }
                if self.reservedInstanceHourPrice != nil {
                    map["ReservedInstanceHourPrice"] = self.reservedInstanceHourPrice!
                }
                if self.tradePrice != nil {
                    map["TradePrice"] = self.tradePrice!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Currency"] as? String {
                    self.currency = value
                }
                if let value = dict["DetailInfos"] as? [String: Any?] {
                    var model = DescribePriceResponseBody.PriceInfo.Price.DetailInfos()
                    model.fromMap(value)
                    self.detailInfos = model
                }
                if let value = dict["DiscountPrice"] as? Double {
                    self.discountPrice = value
                }
                if let value = dict["OriginalPrice"] as? Double {
                    self.originalPrice = value
                }
                if let value = dict["ReservedInstanceHourPrice"] as? Double {
                    self.reservedInstanceHourPrice = value
                }
                if let value = dict["TradePrice"] as? Double {
                    self.tradePrice = value
                }
            }
        }
        public class RelatedPrice : Tea.TeaModel {
            public class MarketplaceImagePrice : Tea.TeaModel {
                public var currency: String?

                public var discountPrice: Double?

                public var originalPrice: Double?

                public var tradePrice: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.currency != nil {
                        map["Currency"] = self.currency!
                    }
                    if self.discountPrice != nil {
                        map["DiscountPrice"] = self.discountPrice!
                    }
                    if self.originalPrice != nil {
                        map["OriginalPrice"] = self.originalPrice!
                    }
                    if self.tradePrice != nil {
                        map["TradePrice"] = self.tradePrice!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Currency"] as? String {
                        self.currency = value
                    }
                    if let value = dict["DiscountPrice"] as? Double {
                        self.discountPrice = value
                    }
                    if let value = dict["OriginalPrice"] as? Double {
                        self.originalPrice = value
                    }
                    if let value = dict["TradePrice"] as? Double {
                        self.tradePrice = value
                    }
                }
            }
            public var marketplaceImagePrice: DescribePriceResponseBody.PriceInfo.RelatedPrice.MarketplaceImagePrice?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.marketplaceImagePrice?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.marketplaceImagePrice != nil {
                    map["MarketplaceImagePrice"] = self.marketplaceImagePrice?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["MarketplaceImagePrice"] as? [String: Any?] {
                    var model = DescribePriceResponseBody.PriceInfo.RelatedPrice.MarketplaceImagePrice()
                    model.fromMap(value)
                    self.marketplaceImagePrice = model
                }
            }
        }
        public class Rules : Tea.TeaModel {
            public class Rule : Tea.TeaModel {
                public var description_: String?

                public var ruleId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.ruleId != nil {
                        map["RuleId"] = self.ruleId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Description"] as? String {
                        self.description_ = value
                    }
                    if let value = dict["RuleId"] as? Int64 {
                        self.ruleId = value
                    }
                }
            }
            public var rule: [DescribePriceResponseBody.PriceInfo.Rules.Rule]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.rule != nil {
                    var tmp : [Any] = []
                    for k in self.rule! {
                        tmp.append(k.toMap())
                    }
                    map["Rule"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Rule"] as? [Any?] {
                    var tmp : [DescribePriceResponseBody.PriceInfo.Rules.Rule] = []
                    for v in value {
                        if v != nil {
                            var model = DescribePriceResponseBody.PriceInfo.Rules.Rule()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.rule = tmp
                }
            }
        }
        public var price: DescribePriceResponseBody.PriceInfo.Price?

        public var relatedPrice: DescribePriceResponseBody.PriceInfo.RelatedPrice?

        public var rules: DescribePriceResponseBody.PriceInfo.Rules?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.price?.validate()
            try self.relatedPrice?.validate()
            try self.rules?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.price != nil {
                map["Price"] = self.price?.toMap()
            }
            if self.relatedPrice != nil {
                map["RelatedPrice"] = self.relatedPrice?.toMap()
            }
            if self.rules != nil {
                map["Rules"] = self.rules?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Price"] as? [String: Any?] {
                var model = DescribePriceResponseBody.PriceInfo.Price()
                model.fromMap(value)
                self.price = model
            }
            if let value = dict["RelatedPrice"] as? [String: Any?] {
                var model = DescribePriceResponseBody.PriceInfo.RelatedPrice()
                model.fromMap(value)
                self.relatedPrice = model
            }
            if let value = dict["Rules"] as? [String: Any?] {
                var model = DescribePriceResponseBody.PriceInfo.Rules()
                model.fromMap(value)
                self.rules = model
            }
        }
    }
    public var priceInfo: DescribePriceResponseBody.PriceInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.priceInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.priceInfo != nil {
            map["PriceInfo"] = self.priceInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PriceInfo"] as? [String: Any?] {
            var model = DescribePriceResponseBody.PriceInfo()
            model.fromMap(value)
            self.priceInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribePriceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePriceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePriceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRecommendInstanceTypeRequest : Tea.TeaModel {
    public var cores: Int32?

    public var instanceChargeType: String?

    public var instanceFamilyLevel: String?

    public var instanceType: String?

    public var instanceTypeFamily: [String]?

    public var ioOptimized: String?

    public var maxPrice: Double?

    public var memory: Double?

    public var networkType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var priorityStrategy: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scene: String?

    public var spotStrategy: String?

    public var systemDiskCategory: String?

    public var zoneId: String?

    public var zoneMatchMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cores != nil {
            map["Cores"] = self.cores!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceFamilyLevel != nil {
            map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.instanceTypeFamily != nil {
            map["InstanceTypeFamily"] = self.instanceTypeFamily!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.maxPrice != nil {
            map["MaxPrice"] = self.maxPrice!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.priorityStrategy != nil {
            map["PriorityStrategy"] = self.priorityStrategy!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scene != nil {
            map["Scene"] = self.scene!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.systemDiskCategory != nil {
            map["SystemDiskCategory"] = self.systemDiskCategory!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        if self.zoneMatchMode != nil {
            map["ZoneMatchMode"] = self.zoneMatchMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Cores"] as? Int32 {
            self.cores = value
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["InstanceFamilyLevel"] as? String {
            self.instanceFamilyLevel = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["InstanceTypeFamily"] as? [String] {
            self.instanceTypeFamily = value
        }
        if let value = dict["IoOptimized"] as? String {
            self.ioOptimized = value
        }
        if let value = dict["MaxPrice"] as? Double {
            self.maxPrice = value
        }
        if let value = dict["Memory"] as? Double {
            self.memory = value
        }
        if let value = dict["NetworkType"] as? String {
            self.networkType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PriorityStrategy"] as? String {
            self.priorityStrategy = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Scene"] as? String {
            self.scene = value
        }
        if let value = dict["SpotStrategy"] as? String {
            self.spotStrategy = value
        }
        if let value = dict["SystemDiskCategory"] as? String {
            self.systemDiskCategory = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
        if let value = dict["ZoneMatchMode"] as? String {
            self.zoneMatchMode = value
        }
    }
}

public class DescribeRecommendInstanceTypeResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class RecommendInstanceType : Tea.TeaModel {
            public class InstanceType : Tea.TeaModel {
                public var cores: Int32?

                public var generation: String?

                public var instanceType: String?

                public var instanceTypeFamily: String?

                public var memory: Int32?

                public var supportIoOptimized: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cores != nil {
                        map["Cores"] = self.cores!
                    }
                    if self.generation != nil {
                        map["Generation"] = self.generation!
                    }
                    if self.instanceType != nil {
                        map["InstanceType"] = self.instanceType!
                    }
                    if self.instanceTypeFamily != nil {
                        map["InstanceTypeFamily"] = self.instanceTypeFamily!
                    }
                    if self.memory != nil {
                        map["Memory"] = self.memory!
                    }
                    if self.supportIoOptimized != nil {
                        map["SupportIoOptimized"] = self.supportIoOptimized!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Cores"] as? Int32 {
                        self.cores = value
                    }
                    if let value = dict["Generation"] as? String {
                        self.generation = value
                    }
                    if let value = dict["InstanceType"] as? String {
                        self.instanceType = value
                    }
                    if let value = dict["InstanceTypeFamily"] as? String {
                        self.instanceTypeFamily = value
                    }
                    if let value = dict["Memory"] as? Int32 {
                        self.memory = value
                    }
                    if let value = dict["SupportIoOptimized"] as? String {
                        self.supportIoOptimized = value
                    }
                }
            }
            public class Zones : Tea.TeaModel {
                public class Zone : Tea.TeaModel {
                    public class NetworkTypes : Tea.TeaModel {
                        public var networkType: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.networkType != nil {
                                map["NetworkType"] = self.networkType!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["NetworkType"] as? [String] {
                                self.networkType = value
                            }
                        }
                    }
                    public var networkTypes: DescribeRecommendInstanceTypeResponseBody.Data.RecommendInstanceType.Zones.Zone.NetworkTypes?

                    public var zoneNo: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.networkTypes?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.networkTypes != nil {
                            map["NetworkTypes"] = self.networkTypes?.toMap()
                        }
                        if self.zoneNo != nil {
                            map["ZoneNo"] = self.zoneNo!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["NetworkTypes"] as? [String: Any?] {
                            var model = DescribeRecommendInstanceTypeResponseBody.Data.RecommendInstanceType.Zones.Zone.NetworkTypes()
                            model.fromMap(value)
                            self.networkTypes = model
                        }
                        if let value = dict["ZoneNo"] as? String {
                            self.zoneNo = value
                        }
                    }
                }
                public var zone: [DescribeRecommendInstanceTypeResponseBody.Data.RecommendInstanceType.Zones.Zone]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.zone != nil {
                        var tmp : [Any] = []
                        for k in self.zone! {
                            tmp.append(k.toMap())
                        }
                        map["zone"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["zone"] as? [Any?] {
                        var tmp : [DescribeRecommendInstanceTypeResponseBody.Data.RecommendInstanceType.Zones.Zone] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeRecommendInstanceTypeResponseBody.Data.RecommendInstanceType.Zones.Zone()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.zone = tmp
                    }
                }
            }
            public var commodityCode: String?

            public var instanceChargeType: String?

            public var instanceType: DescribeRecommendInstanceTypeResponseBody.Data.RecommendInstanceType.InstanceType?

            public var networkType: String?

            public var priority: Int32?

            public var regionId: String?

            public var scene: String?

            public var spotStrategy: String?

            public var zoneId: String?

            public var zones: DescribeRecommendInstanceTypeResponseBody.Data.RecommendInstanceType.Zones?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.instanceType?.validate()
                try self.zones?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.commodityCode != nil {
                    map["CommodityCode"] = self.commodityCode!
                }
                if self.instanceChargeType != nil {
                    map["InstanceChargeType"] = self.instanceChargeType!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType?.toMap()
                }
                if self.networkType != nil {
                    map["NetworkType"] = self.networkType!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.spotStrategy != nil {
                    map["SpotStrategy"] = self.spotStrategy!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                if self.zones != nil {
                    map["Zones"] = self.zones?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CommodityCode"] as? String {
                    self.commodityCode = value
                }
                if let value = dict["InstanceChargeType"] as? String {
                    self.instanceChargeType = value
                }
                if let value = dict["InstanceType"] as? [String: Any?] {
                    var model = DescribeRecommendInstanceTypeResponseBody.Data.RecommendInstanceType.InstanceType()
                    model.fromMap(value)
                    self.instanceType = model
                }
                if let value = dict["NetworkType"] as? String {
                    self.networkType = value
                }
                if let value = dict["Priority"] as? Int32 {
                    self.priority = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["Scene"] as? String {
                    self.scene = value
                }
                if let value = dict["SpotStrategy"] as? String {
                    self.spotStrategy = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
                if let value = dict["Zones"] as? [String: Any?] {
                    var model = DescribeRecommendInstanceTypeResponseBody.Data.RecommendInstanceType.Zones()
                    model.fromMap(value)
                    self.zones = model
                }
            }
        }
        public var recommendInstanceType: [DescribeRecommendInstanceTypeResponseBody.Data.RecommendInstanceType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.recommendInstanceType != nil {
                var tmp : [Any] = []
                for k in self.recommendInstanceType! {
                    tmp.append(k.toMap())
                }
                map["RecommendInstanceType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RecommendInstanceType"] as? [Any?] {
                var tmp : [DescribeRecommendInstanceTypeResponseBody.Data.RecommendInstanceType] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRecommendInstanceTypeResponseBody.Data.RecommendInstanceType()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.recommendInstanceType = tmp
            }
        }
    }
    public var data: DescribeRecommendInstanceTypeResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeRecommendInstanceTypeResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeRecommendInstanceTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRecommendInstanceTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRecommendInstanceTypeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRegionsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var instanceChargeType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class DescribeRegionsResponseBody : Tea.TeaModel {
    public class Regions : Tea.TeaModel {
        public class Region : Tea.TeaModel {
            public var localName: String?

            public var regionEndpoint: String?

            public var regionId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.localName != nil {
                    map["LocalName"] = self.localName!
                }
                if self.regionEndpoint != nil {
                    map["RegionEndpoint"] = self.regionEndpoint!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LocalName"] as? String {
                    self.localName = value
                }
                if let value = dict["RegionEndpoint"] as? String {
                    self.regionEndpoint = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var region: [DescribeRegionsResponseBody.Regions.Region]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.region != nil {
                var tmp : [Any] = []
                for k in self.region! {
                    tmp.append(k.toMap())
                }
                map["Region"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Region"] as? [Any?] {
                var tmp : [DescribeRegionsResponseBody.Regions.Region] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRegionsResponseBody.Regions.Region()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.region = tmp
            }
        }
    }
    public var regions: DescribeRegionsResponseBody.Regions?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.regions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regions != nil {
            map["Regions"] = self.regions?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Regions"] as? [String: Any?] {
            var model = DescribeRegionsResponseBody.Regions()
            model.fromMap(value)
            self.regions = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRegionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRenewalPriceRequest : Tea.TeaModel {
    public var expectedRenewDay: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var priceUnit: String?

    public var regionId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.expectedRenewDay != nil {
            map["ExpectedRenewDay"] = self.expectedRenewDay!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.priceUnit != nil {
            map["PriceUnit"] = self.priceUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ExpectedRenewDay"] as? Int32 {
            self.expectedRenewDay = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PriceUnit"] as? String {
            self.priceUnit = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class DescribeRenewalPriceResponseBody : Tea.TeaModel {
    public class PriceInfo : Tea.TeaModel {
        public class Price : Tea.TeaModel {
            public class DetailInfos : Tea.TeaModel {
                public class DetailInfo : Tea.TeaModel {
                    public class SubRules : Tea.TeaModel {
                        public class Rule : Tea.TeaModel {
                            public var description_: String?

                            public var ruleId: Int64?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.description_ != nil {
                                    map["Description"] = self.description_!
                                }
                                if self.ruleId != nil {
                                    map["RuleId"] = self.ruleId!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["Description"] as? String {
                                    self.description_ = value
                                }
                                if let value = dict["RuleId"] as? Int64 {
                                    self.ruleId = value
                                }
                            }
                        }
                        public var rule: [DescribeRenewalPriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo.SubRules.Rule]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.rule != nil {
                                var tmp : [Any] = []
                                for k in self.rule! {
                                    tmp.append(k.toMap())
                                }
                                map["Rule"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Rule"] as? [Any?] {
                                var tmp : [DescribeRenewalPriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo.SubRules.Rule] = []
                                for v in value {
                                    if v != nil {
                                        var model = DescribeRenewalPriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo.SubRules.Rule()
                                        if v != nil {
                                            model.fromMap(v as? [String: Any?])
                                        }
                                        tmp.append(model)
                                    }
                                }
                                self.rule = tmp
                            }
                        }
                    }
                    public var discountPrice: Double?

                    public var originalPrice: Double?

                    public var resource: String?

                    public var subRules: DescribeRenewalPriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo.SubRules?

                    public var tradePrice: Double?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.subRules?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.discountPrice != nil {
                            map["DiscountPrice"] = self.discountPrice!
                        }
                        if self.originalPrice != nil {
                            map["OriginalPrice"] = self.originalPrice!
                        }
                        if self.resource != nil {
                            map["Resource"] = self.resource!
                        }
                        if self.subRules != nil {
                            map["SubRules"] = self.subRules?.toMap()
                        }
                        if self.tradePrice != nil {
                            map["TradePrice"] = self.tradePrice!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["DiscountPrice"] as? Double {
                            self.discountPrice = value
                        }
                        if let value = dict["OriginalPrice"] as? Double {
                            self.originalPrice = value
                        }
                        if let value = dict["Resource"] as? String {
                            self.resource = value
                        }
                        if let value = dict["SubRules"] as? [String: Any?] {
                            var model = DescribeRenewalPriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo.SubRules()
                            model.fromMap(value)
                            self.subRules = model
                        }
                        if let value = dict["TradePrice"] as? Double {
                            self.tradePrice = value
                        }
                    }
                }
                public var detailInfo: [DescribeRenewalPriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.detailInfo != nil {
                        var tmp : [Any] = []
                        for k in self.detailInfo! {
                            tmp.append(k.toMap())
                        }
                        map["DetailInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DetailInfo"] as? [Any?] {
                        var tmp : [DescribeRenewalPriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeRenewalPriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.detailInfo = tmp
                    }
                }
            }
            public var currency: String?

            public var detailInfos: DescribeRenewalPriceResponseBody.PriceInfo.Price.DetailInfos?

            public var discountPrice: Double?

            public var originalPrice: Double?

            public var tradePrice: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.detailInfos?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.currency != nil {
                    map["Currency"] = self.currency!
                }
                if self.detailInfos != nil {
                    map["DetailInfos"] = self.detailInfos?.toMap()
                }
                if self.discountPrice != nil {
                    map["DiscountPrice"] = self.discountPrice!
                }
                if self.originalPrice != nil {
                    map["OriginalPrice"] = self.originalPrice!
                }
                if self.tradePrice != nil {
                    map["TradePrice"] = self.tradePrice!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Currency"] as? String {
                    self.currency = value
                }
                if let value = dict["DetailInfos"] as? [String: Any?] {
                    var model = DescribeRenewalPriceResponseBody.PriceInfo.Price.DetailInfos()
                    model.fromMap(value)
                    self.detailInfos = model
                }
                if let value = dict["DiscountPrice"] as? Double {
                    self.discountPrice = value
                }
                if let value = dict["OriginalPrice"] as? Double {
                    self.originalPrice = value
                }
                if let value = dict["TradePrice"] as? Double {
                    self.tradePrice = value
                }
            }
        }
        public class Rules : Tea.TeaModel {
            public class Rule : Tea.TeaModel {
                public var description_: String?

                public var ruleId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.ruleId != nil {
                        map["RuleId"] = self.ruleId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Description"] as? String {
                        self.description_ = value
                    }
                    if let value = dict["RuleId"] as? Int64 {
                        self.ruleId = value
                    }
                }
            }
            public var rule: [DescribeRenewalPriceResponseBody.PriceInfo.Rules.Rule]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.rule != nil {
                    var tmp : [Any] = []
                    for k in self.rule! {
                        tmp.append(k.toMap())
                    }
                    map["Rule"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Rule"] as? [Any?] {
                    var tmp : [DescribeRenewalPriceResponseBody.PriceInfo.Rules.Rule] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeRenewalPriceResponseBody.PriceInfo.Rules.Rule()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.rule = tmp
                }
            }
        }
        public var price: DescribeRenewalPriceResponseBody.PriceInfo.Price?

        public var rules: DescribeRenewalPriceResponseBody.PriceInfo.Rules?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.price?.validate()
            try self.rules?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.price != nil {
                map["Price"] = self.price?.toMap()
            }
            if self.rules != nil {
                map["Rules"] = self.rules?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Price"] as? [String: Any?] {
                var model = DescribeRenewalPriceResponseBody.PriceInfo.Price()
                model.fromMap(value)
                self.price = model
            }
            if let value = dict["Rules"] as? [String: Any?] {
                var model = DescribeRenewalPriceResponseBody.PriceInfo.Rules()
                model.fromMap(value)
                self.rules = model
            }
        }
    }
    public var priceInfo: DescribeRenewalPriceResponseBody.PriceInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.priceInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.priceInfo != nil {
            map["PriceInfo"] = self.priceInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PriceInfo"] as? [String: Any?] {
            var model = DescribeRenewalPriceResponseBody.PriceInfo()
            model.fromMap(value)
            self.priceInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeRenewalPriceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRenewalPriceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRenewalPriceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeReservedInstanceAutoRenewAttributeRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var reservedInstanceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reservedInstanceId != nil {
            map["ReservedInstanceId"] = self.reservedInstanceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ReservedInstanceId"] as? [String] {
            self.reservedInstanceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeReservedInstanceAutoRenewAttributeResponseBody : Tea.TeaModel {
    public class ReservedInstanceRenewAttributes : Tea.TeaModel {
        public class ReservedInstanceRenewAttribute : Tea.TeaModel {
            public var duration: Int32?

            public var periodUnit: String?

            public var renewalStatus: String?

            public var reservedInstanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.periodUnit != nil {
                    map["PeriodUnit"] = self.periodUnit!
                }
                if self.renewalStatus != nil {
                    map["RenewalStatus"] = self.renewalStatus!
                }
                if self.reservedInstanceId != nil {
                    map["ReservedInstanceId"] = self.reservedInstanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Duration"] as? Int32 {
                    self.duration = value
                }
                if let value = dict["PeriodUnit"] as? String {
                    self.periodUnit = value
                }
                if let value = dict["RenewalStatus"] as? String {
                    self.renewalStatus = value
                }
                if let value = dict["ReservedInstanceId"] as? String {
                    self.reservedInstanceId = value
                }
            }
        }
        public var reservedInstanceRenewAttribute: [DescribeReservedInstanceAutoRenewAttributeResponseBody.ReservedInstanceRenewAttributes.ReservedInstanceRenewAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.reservedInstanceRenewAttribute != nil {
                var tmp : [Any] = []
                for k in self.reservedInstanceRenewAttribute! {
                    tmp.append(k.toMap())
                }
                map["ReservedInstanceRenewAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ReservedInstanceRenewAttribute"] as? [Any?] {
                var tmp : [DescribeReservedInstanceAutoRenewAttributeResponseBody.ReservedInstanceRenewAttributes.ReservedInstanceRenewAttribute] = []
                for v in value {
                    if v != nil {
                        var model = DescribeReservedInstanceAutoRenewAttributeResponseBody.ReservedInstanceRenewAttributes.ReservedInstanceRenewAttribute()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.reservedInstanceRenewAttribute = tmp
            }
        }
    }
    public var requestId: String?

    public var reservedInstanceRenewAttributes: DescribeReservedInstanceAutoRenewAttributeResponseBody.ReservedInstanceRenewAttributes?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.reservedInstanceRenewAttributes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.reservedInstanceRenewAttributes != nil {
            map["ReservedInstanceRenewAttributes"] = self.reservedInstanceRenewAttributes?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ReservedInstanceRenewAttributes"] as? [String: Any?] {
            var model = DescribeReservedInstanceAutoRenewAttributeResponseBody.ReservedInstanceRenewAttributes()
            model.fromMap(value)
            self.reservedInstanceRenewAttributes = model
        }
    }
}

public class DescribeReservedInstanceAutoRenewAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeReservedInstanceAutoRenewAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeReservedInstanceAutoRenewAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeReservedInstancesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var allocationType: String?

    public var instanceType: String?

    public var instanceTypeFamily: String?

    public var lockReason: String?

    public var offeringType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var reservedInstanceId: [String]?

    public var reservedInstanceName: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scope: String?

    public var status: [String]?

    public var tag: [DescribeReservedInstancesRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationType != nil {
            map["AllocationType"] = self.allocationType!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.instanceTypeFamily != nil {
            map["InstanceTypeFamily"] = self.instanceTypeFamily!
        }
        if self.lockReason != nil {
            map["LockReason"] = self.lockReason!
        }
        if self.offeringType != nil {
            map["OfferingType"] = self.offeringType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reservedInstanceId != nil {
            map["ReservedInstanceId"] = self.reservedInstanceId!
        }
        if self.reservedInstanceName != nil {
            map["ReservedInstanceName"] = self.reservedInstanceName!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AllocationType"] as? String {
            self.allocationType = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["InstanceTypeFamily"] as? String {
            self.instanceTypeFamily = value
        }
        if let value = dict["LockReason"] as? String {
            self.lockReason = value
        }
        if let value = dict["OfferingType"] as? String {
            self.offeringType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ReservedInstanceId"] as? [String] {
            self.reservedInstanceId = value
        }
        if let value = dict["ReservedInstanceName"] as? String {
            self.reservedInstanceName = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Scope"] as? String {
            self.scope = value
        }
        if let value = dict["Status"] as? [String] {
            self.status = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeReservedInstancesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeReservedInstancesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribeReservedInstancesResponseBody : Tea.TeaModel {
    public class ReservedInstances : Tea.TeaModel {
        public class ReservedInstance : Tea.TeaModel {
            public class OperationLocks : Tea.TeaModel {
                public class OperationLock : Tea.TeaModel {
                    public var lockReason: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.lockReason != nil {
                            map["LockReason"] = self.lockReason!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["LockReason"] as? String {
                            self.lockReason = value
                        }
                    }
                }
                public var operationLock: [DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance.OperationLocks.OperationLock]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.operationLock != nil {
                        var tmp : [Any] = []
                        for k in self.operationLock! {
                            tmp.append(k.toMap())
                        }
                        map["OperationLock"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["OperationLock"] as? [Any?] {
                        var tmp : [DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance.OperationLocks.OperationLock] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance.OperationLocks.OperationLock()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.operationLock = tmp
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["TagKey"] as? String {
                            self.tagKey = value
                        }
                        if let value = dict["TagValue"] as? String {
                            self.tagValue = value
                        }
                    }
                }
                public var tag: [DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var allocationStatus: String?

            public var creationTime: String?

            public var description_: String?

            public var expiredTime: String?

            public var instanceAmount: Int32?

            public var instanceType: String?

            public var offeringType: String?

            public var operationLocks: DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance.OperationLocks?

            public var platform: String?

            public var regionId: String?

            public var reservedInstanceId: String?

            public var reservedInstanceName: String?

            public var resourceGroupId: String?

            public var scope: String?

            public var startTime: String?

            public var status: String?

            public var tags: DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance.Tags?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.operationLocks?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allocationStatus != nil {
                    map["AllocationStatus"] = self.allocationStatus!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.instanceAmount != nil {
                    map["InstanceAmount"] = self.instanceAmount!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.offeringType != nil {
                    map["OfferingType"] = self.offeringType!
                }
                if self.operationLocks != nil {
                    map["OperationLocks"] = self.operationLocks?.toMap()
                }
                if self.platform != nil {
                    map["Platform"] = self.platform!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.reservedInstanceId != nil {
                    map["ReservedInstanceId"] = self.reservedInstanceId!
                }
                if self.reservedInstanceName != nil {
                    map["ReservedInstanceName"] = self.reservedInstanceName!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.scope != nil {
                    map["Scope"] = self.scope!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AllocationStatus"] as? String {
                    self.allocationStatus = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["ExpiredTime"] as? String {
                    self.expiredTime = value
                }
                if let value = dict["InstanceAmount"] as? Int32 {
                    self.instanceAmount = value
                }
                if let value = dict["InstanceType"] as? String {
                    self.instanceType = value
                }
                if let value = dict["OfferingType"] as? String {
                    self.offeringType = value
                }
                if let value = dict["OperationLocks"] as? [String: Any?] {
                    var model = DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance.OperationLocks()
                    model.fromMap(value)
                    self.operationLocks = model
                }
                if let value = dict["Platform"] as? String {
                    self.platform = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ReservedInstanceId"] as? String {
                    self.reservedInstanceId = value
                }
                if let value = dict["ReservedInstanceName"] as? String {
                    self.reservedInstanceName = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["Scope"] as? String {
                    self.scope = value
                }
                if let value = dict["StartTime"] as? String {
                    self.startTime = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var reservedInstance: [DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.reservedInstance != nil {
                var tmp : [Any] = []
                for k in self.reservedInstance! {
                    tmp.append(k.toMap())
                }
                map["ReservedInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ReservedInstance"] as? [Any?] {
                var tmp : [DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance] = []
                for v in value {
                    if v != nil {
                        var model = DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.reservedInstance = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var reservedInstances: DescribeReservedInstancesResponseBody.ReservedInstances?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.reservedInstances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.reservedInstances != nil {
            map["ReservedInstances"] = self.reservedInstances?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ReservedInstances"] as? [String: Any?] {
            var model = DescribeReservedInstancesResponseBody.ReservedInstances()
            model.fromMap(value)
            self.reservedInstances = model
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeReservedInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeReservedInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeReservedInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeResourceByTagsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tag: [DescribeResourceByTagsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeResourceByTagsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeResourceByTagsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribeResourceByTagsResponseBody : Tea.TeaModel {
    public class Resources : Tea.TeaModel {
        public class Resource : Tea.TeaModel {
            public var regionId: String?

            public var resourceId: String?

            public var resourceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
            }
        }
        public var resource: [DescribeResourceByTagsResponseBody.Resources.Resource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resource != nil {
                var tmp : [Any] = []
                for k in self.resource! {
                    tmp.append(k.toMap())
                }
                map["Resource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Resource"] as? [Any?] {
                var tmp : [DescribeResourceByTagsResponseBody.Resources.Resource] = []
                for v in value {
                    if v != nil {
                        var model = DescribeResourceByTagsResponseBody.Resources.Resource()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.resource = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var resources: DescribeResourceByTagsResponseBody.Resources?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resources != nil {
            map["Resources"] = self.resources?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Resources"] as? [String: Any?] {
            var model = DescribeResourceByTagsResponseBody.Resources()
            model.fromMap(value)
            self.resources = model
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeResourceByTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeResourceByTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeResourceByTagsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeResourcesModificationRequest : Tea.TeaModel {
    public var conditions: [String]?

    public var cores: Int32?

    public var destinationResource: String?

    public var instanceType: String?

    public var memory: Double?

    public var migrateAcrossZone: Bool?

    public var operationType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conditions != nil {
            map["Conditions"] = self.conditions!
        }
        if self.cores != nil {
            map["Cores"] = self.cores!
        }
        if self.destinationResource != nil {
            map["DestinationResource"] = self.destinationResource!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.migrateAcrossZone != nil {
            map["MigrateAcrossZone"] = self.migrateAcrossZone!
        }
        if self.operationType != nil {
            map["OperationType"] = self.operationType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Conditions"] as? [String] {
            self.conditions = value
        }
        if let value = dict["Cores"] as? Int32 {
            self.cores = value
        }
        if let value = dict["DestinationResource"] as? String {
            self.destinationResource = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["Memory"] as? Double {
            self.memory = value
        }
        if let value = dict["MigrateAcrossZone"] as? Bool {
            self.migrateAcrossZone = value
        }
        if let value = dict["OperationType"] as? String {
            self.operationType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribeResourcesModificationResponseBody : Tea.TeaModel {
    public class AvailableZones : Tea.TeaModel {
        public class AvailableZone : Tea.TeaModel {
            public class AvailableResources : Tea.TeaModel {
                public class AvailableResource : Tea.TeaModel {
                    public class ConditionSupportedResources : Tea.TeaModel {
                        public class ConditionSupportedResource : Tea.TeaModel {
                            public class Conditions : Tea.TeaModel {
                                public class Condition : Tea.TeaModel {
                                    public var key: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.key != nil {
                                            map["Key"] = self.key!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                        guard let dict else { return }
                                        if let value = dict["Key"] as? String {
                                            self.key = value
                                        }
                                    }
                                }
                                public var condition: [DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.ConditionSupportedResources.ConditionSupportedResource.Conditions.Condition]?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.condition != nil {
                                        var tmp : [Any] = []
                                        for k in self.condition! {
                                            tmp.append(k.toMap())
                                        }
                                        map["Condition"] = tmp
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                    guard let dict else { return }
                                    if let value = dict["Condition"] as? [Any?] {
                                        var tmp : [DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.ConditionSupportedResources.ConditionSupportedResource.Conditions.Condition] = []
                                        for v in value {
                                            if v != nil {
                                                var model = DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.ConditionSupportedResources.ConditionSupportedResource.Conditions.Condition()
                                                if v != nil {
                                                    model.fromMap(v as? [String: Any?])
                                                }
                                                tmp.append(model)
                                            }
                                        }
                                        self.condition = tmp
                                    }
                                }
                            }
                            public var conditions: DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.ConditionSupportedResources.ConditionSupportedResource.Conditions?

                            public var max: Int32?

                            public var min: Int32?

                            public var status: String?

                            public var statusCategory: String?

                            public var unit: String?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.conditions?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.conditions != nil {
                                    map["Conditions"] = self.conditions?.toMap()
                                }
                                if self.max != nil {
                                    map["Max"] = self.max!
                                }
                                if self.min != nil {
                                    map["Min"] = self.min!
                                }
                                if self.status != nil {
                                    map["Status"] = self.status!
                                }
                                if self.statusCategory != nil {
                                    map["StatusCategory"] = self.statusCategory!
                                }
                                if self.unit != nil {
                                    map["Unit"] = self.unit!
                                }
                                if self.value != nil {
                                    map["Value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["Conditions"] as? [String: Any?] {
                                    var model = DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.ConditionSupportedResources.ConditionSupportedResource.Conditions()
                                    model.fromMap(value)
                                    self.conditions = model
                                }
                                if let value = dict["Max"] as? Int32 {
                                    self.max = value
                                }
                                if let value = dict["Min"] as? Int32 {
                                    self.min = value
                                }
                                if let value = dict["Status"] as? String {
                                    self.status = value
                                }
                                if let value = dict["StatusCategory"] as? String {
                                    self.statusCategory = value
                                }
                                if let value = dict["Unit"] as? String {
                                    self.unit = value
                                }
                                if let value = dict["Value"] as? String {
                                    self.value = value
                                }
                            }
                        }
                        public var conditionSupportedResource: [DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.ConditionSupportedResources.ConditionSupportedResource]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.conditionSupportedResource != nil {
                                var tmp : [Any] = []
                                for k in self.conditionSupportedResource! {
                                    tmp.append(k.toMap())
                                }
                                map["ConditionSupportedResource"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["ConditionSupportedResource"] as? [Any?] {
                                var tmp : [DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.ConditionSupportedResources.ConditionSupportedResource] = []
                                for v in value {
                                    if v != nil {
                                        var model = DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.ConditionSupportedResources.ConditionSupportedResource()
                                        if v != nil {
                                            model.fromMap(v as? [String: Any?])
                                        }
                                        tmp.append(model)
                                    }
                                }
                                self.conditionSupportedResource = tmp
                            }
                        }
                    }
                    public class SupportedResources : Tea.TeaModel {
                        public class SupportedResource : Tea.TeaModel {
                            public var max: Int32?

                            public var min: Int32?

                            public var status: String?

                            public var statusCategory: String?

                            public var unit: String?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.max != nil {
                                    map["Max"] = self.max!
                                }
                                if self.min != nil {
                                    map["Min"] = self.min!
                                }
                                if self.status != nil {
                                    map["Status"] = self.status!
                                }
                                if self.statusCategory != nil {
                                    map["StatusCategory"] = self.statusCategory!
                                }
                                if self.unit != nil {
                                    map["Unit"] = self.unit!
                                }
                                if self.value != nil {
                                    map["Value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["Max"] as? Int32 {
                                    self.max = value
                                }
                                if let value = dict["Min"] as? Int32 {
                                    self.min = value
                                }
                                if let value = dict["Status"] as? String {
                                    self.status = value
                                }
                                if let value = dict["StatusCategory"] as? String {
                                    self.statusCategory = value
                                }
                                if let value = dict["Unit"] as? String {
                                    self.unit = value
                                }
                                if let value = dict["Value"] as? String {
                                    self.value = value
                                }
                            }
                        }
                        public var supportedResource: [DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.SupportedResources.SupportedResource]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.supportedResource != nil {
                                var tmp : [Any] = []
                                for k in self.supportedResource! {
                                    tmp.append(k.toMap())
                                }
                                map["SupportedResource"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["SupportedResource"] as? [Any?] {
                                var tmp : [DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.SupportedResources.SupportedResource] = []
                                for v in value {
                                    if v != nil {
                                        var model = DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.SupportedResources.SupportedResource()
                                        if v != nil {
                                            model.fromMap(v as? [String: Any?])
                                        }
                                        tmp.append(model)
                                    }
                                }
                                self.supportedResource = tmp
                            }
                        }
                    }
                    public var conditionSupportedResources: DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.ConditionSupportedResources?

                    public var supportedResources: DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.SupportedResources?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.conditionSupportedResources?.validate()
                        try self.supportedResources?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.conditionSupportedResources != nil {
                            map["ConditionSupportedResources"] = self.conditionSupportedResources?.toMap()
                        }
                        if self.supportedResources != nil {
                            map["SupportedResources"] = self.supportedResources?.toMap()
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ConditionSupportedResources"] as? [String: Any?] {
                            var model = DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.ConditionSupportedResources()
                            model.fromMap(value)
                            self.conditionSupportedResources = model
                        }
                        if let value = dict["SupportedResources"] as? [String: Any?] {
                            var model = DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.SupportedResources()
                            model.fromMap(value)
                            self.supportedResources = model
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                    }
                }
                public var availableResource: [DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.availableResource != nil {
                        var tmp : [Any] = []
                        for k in self.availableResource! {
                            tmp.append(k.toMap())
                        }
                        map["AvailableResource"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AvailableResource"] as? [Any?] {
                        var tmp : [DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.availableResource = tmp
                    }
                }
            }
            public var availableResources: DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources?

            public var regionId: String?

            public var status: String?

            public var statusCategory: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.availableResources?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.availableResources != nil {
                    map["AvailableResources"] = self.availableResources?.toMap()
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.statusCategory != nil {
                    map["StatusCategory"] = self.statusCategory!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AvailableResources"] as? [String: Any?] {
                    var model = DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources()
                    model.fromMap(value)
                    self.availableResources = model
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["StatusCategory"] as? String {
                    self.statusCategory = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var availableZone: [DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.availableZone != nil {
                var tmp : [Any] = []
                for k in self.availableZone! {
                    tmp.append(k.toMap())
                }
                map["AvailableZone"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AvailableZone"] as? [Any?] {
                var tmp : [DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone] = []
                for v in value {
                    if v != nil {
                        var model = DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.availableZone = tmp
            }
        }
    }
    public var availableZones: DescribeResourcesModificationResponseBody.AvailableZones?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.availableZones?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableZones != nil {
            map["AvailableZones"] = self.availableZones?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AvailableZones"] as? [String: Any?] {
            var model = DescribeResourcesModificationResponseBody.AvailableZones()
            model.fromMap(value)
            self.availableZones = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeResourcesModificationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeResourcesModificationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeResourcesModificationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRouteTablesRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableId: String?

    public var routeTableName: String?

    public var routerId: String?

    public var routerType: String?

    public var VRouterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        if self.routeTableName != nil {
            map["RouteTableName"] = self.routeTableName!
        }
        if self.routerId != nil {
            map["RouterId"] = self.routerId!
        }
        if self.routerType != nil {
            map["RouterType"] = self.routerType!
        }
        if self.VRouterId != nil {
            map["VRouterId"] = self.VRouterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouteTableId"] as? String {
            self.routeTableId = value
        }
        if let value = dict["RouteTableName"] as? String {
            self.routeTableName = value
        }
        if let value = dict["RouterId"] as? String {
            self.routerId = value
        }
        if let value = dict["RouterType"] as? String {
            self.routerType = value
        }
        if let value = dict["VRouterId"] as? String {
            self.VRouterId = value
        }
    }
}

public class DescribeRouteTablesResponseBody : Tea.TeaModel {
    public class RouteTables : Tea.TeaModel {
        public class RouteTable : Tea.TeaModel {
            public class RouteEntrys : Tea.TeaModel {
                public class RouteEntry : Tea.TeaModel {
                    public class NextHops : Tea.TeaModel {
                        public class NextHop : Tea.TeaModel {
                            public var enabled: Int32?

                            public var nextHopId: String?

                            public var nextHopType: String?

                            public var weight: Int32?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.enabled != nil {
                                    map["Enabled"] = self.enabled!
                                }
                                if self.nextHopId != nil {
                                    map["NextHopId"] = self.nextHopId!
                                }
                                if self.nextHopType != nil {
                                    map["NextHopType"] = self.nextHopType!
                                }
                                if self.weight != nil {
                                    map["Weight"] = self.weight!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["Enabled"] as? Int32 {
                                    self.enabled = value
                                }
                                if let value = dict["NextHopId"] as? String {
                                    self.nextHopId = value
                                }
                                if let value = dict["NextHopType"] as? String {
                                    self.nextHopType = value
                                }
                                if let value = dict["Weight"] as? Int32 {
                                    self.weight = value
                                }
                            }
                        }
                        public var nextHop: [DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry.NextHops.NextHop]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.nextHop != nil {
                                var tmp : [Any] = []
                                for k in self.nextHop! {
                                    tmp.append(k.toMap())
                                }
                                map["NextHop"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["NextHop"] as? [Any?] {
                                var tmp : [DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry.NextHops.NextHop] = []
                                for v in value {
                                    if v != nil {
                                        var model = DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry.NextHops.NextHop()
                                        if v != nil {
                                            model.fromMap(v as? [String: Any?])
                                        }
                                        tmp.append(model)
                                    }
                                }
                                self.nextHop = tmp
                            }
                        }
                    }
                    public var destinationCidrBlock: String?

                    public var instanceId: String?

                    public var nextHopType: String?

                    public var nextHops: DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry.NextHops?

                    public var routeTableId: String?

                    public var status: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.nextHops?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.destinationCidrBlock != nil {
                            map["DestinationCidrBlock"] = self.destinationCidrBlock!
                        }
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.nextHopType != nil {
                            map["NextHopType"] = self.nextHopType!
                        }
                        if self.nextHops != nil {
                            map["NextHops"] = self.nextHops?.toMap()
                        }
                        if self.routeTableId != nil {
                            map["RouteTableId"] = self.routeTableId!
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["DestinationCidrBlock"] as? String {
                            self.destinationCidrBlock = value
                        }
                        if let value = dict["InstanceId"] as? String {
                            self.instanceId = value
                        }
                        if let value = dict["NextHopType"] as? String {
                            self.nextHopType = value
                        }
                        if let value = dict["NextHops"] as? [String: Any?] {
                            var model = DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry.NextHops()
                            model.fromMap(value)
                            self.nextHops = model
                        }
                        if let value = dict["RouteTableId"] as? String {
                            self.routeTableId = value
                        }
                        if let value = dict["Status"] as? String {
                            self.status = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                    }
                }
                public var routeEntry: [DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.routeEntry != nil {
                        var tmp : [Any] = []
                        for k in self.routeEntry! {
                            tmp.append(k.toMap())
                        }
                        map["RouteEntry"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RouteEntry"] as? [Any?] {
                        var tmp : [DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.routeEntry = tmp
                    }
                }
            }
            public var creationTime: String?

            public var resourceGroupId: String?

            public var routeEntrys: DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys?

            public var routeTableId: String?

            public var routeTableType: String?

            public var VRouterId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.routeEntrys?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.routeEntrys != nil {
                    map["RouteEntrys"] = self.routeEntrys?.toMap()
                }
                if self.routeTableId != nil {
                    map["RouteTableId"] = self.routeTableId!
                }
                if self.routeTableType != nil {
                    map["RouteTableType"] = self.routeTableType!
                }
                if self.VRouterId != nil {
                    map["VRouterId"] = self.VRouterId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["RouteEntrys"] as? [String: Any?] {
                    var model = DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys()
                    model.fromMap(value)
                    self.routeEntrys = model
                }
                if let value = dict["RouteTableId"] as? String {
                    self.routeTableId = value
                }
                if let value = dict["RouteTableType"] as? String {
                    self.routeTableType = value
                }
                if let value = dict["VRouterId"] as? String {
                    self.VRouterId = value
                }
            }
        }
        public var routeTable: [DescribeRouteTablesResponseBody.RouteTables.RouteTable]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.routeTable != nil {
                var tmp : [Any] = []
                for k in self.routeTable! {
                    tmp.append(k.toMap())
                }
                map["RouteTable"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RouteTable"] as? [Any?] {
                var tmp : [DescribeRouteTablesResponseBody.RouteTables.RouteTable] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRouteTablesResponseBody.RouteTables.RouteTable()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.routeTable = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var routeTables: DescribeRouteTablesResponseBody.RouteTables?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.routeTables?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeTables != nil {
            map["RouteTables"] = self.routeTables?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RouteTables"] as? [String: Any?] {
            var model = DescribeRouteTablesResponseBody.RouteTables()
            model.fromMap(value)
            self.routeTables = model
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeRouteTablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRouteTablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRouteTablesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRouterInterfacesRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? [String] {
                self.value = value
            }
        }
    }
    public var filter: [DescribeRouterInterfacesRequest.Filter]?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Filter"] as? [Any?] {
            var tmp : [DescribeRouterInterfacesRequest.Filter] = []
            for v in value {
                if v != nil {
                    var model = DescribeRouterInterfacesRequest.Filter()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.filter = tmp
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeRouterInterfacesResponseBody : Tea.TeaModel {
    public class RouterInterfaceSet : Tea.TeaModel {
        public class RouterInterfaceType : Tea.TeaModel {
            public var accessPointId: String?

            public var businessStatus: String?

            public var chargeType: String?

            public var connectedTime: String?

            public var creationTime: String?

            public var description_: String?

            public var endTime: String?

            public var healthCheckSourceIp: String?

            public var healthCheckTargetIp: String?

            public var name: String?

            public var oppositeAccessPointId: String?

            public var oppositeInterfaceBusinessStatus: String?

            public var oppositeInterfaceId: String?

            public var oppositeInterfaceOwnerId: String?

            public var oppositeInterfaceSpec: String?

            public var oppositeInterfaceStatus: String?

            public var oppositeRegionId: String?

            public var oppositeRouterId: String?

            public var oppositeRouterType: String?

            public var role: String?

            public var routerId: String?

            public var routerInterfaceId: String?

            public var routerType: String?

            public var spec: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessPointId != nil {
                    map["AccessPointId"] = self.accessPointId!
                }
                if self.businessStatus != nil {
                    map["BusinessStatus"] = self.businessStatus!
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.connectedTime != nil {
                    map["ConnectedTime"] = self.connectedTime!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.healthCheckSourceIp != nil {
                    map["HealthCheckSourceIp"] = self.healthCheckSourceIp!
                }
                if self.healthCheckTargetIp != nil {
                    map["HealthCheckTargetIp"] = self.healthCheckTargetIp!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.oppositeAccessPointId != nil {
                    map["OppositeAccessPointId"] = self.oppositeAccessPointId!
                }
                if self.oppositeInterfaceBusinessStatus != nil {
                    map["OppositeInterfaceBusinessStatus"] = self.oppositeInterfaceBusinessStatus!
                }
                if self.oppositeInterfaceId != nil {
                    map["OppositeInterfaceId"] = self.oppositeInterfaceId!
                }
                if self.oppositeInterfaceOwnerId != nil {
                    map["OppositeInterfaceOwnerId"] = self.oppositeInterfaceOwnerId!
                }
                if self.oppositeInterfaceSpec != nil {
                    map["OppositeInterfaceSpec"] = self.oppositeInterfaceSpec!
                }
                if self.oppositeInterfaceStatus != nil {
                    map["OppositeInterfaceStatus"] = self.oppositeInterfaceStatus!
                }
                if self.oppositeRegionId != nil {
                    map["OppositeRegionId"] = self.oppositeRegionId!
                }
                if self.oppositeRouterId != nil {
                    map["OppositeRouterId"] = self.oppositeRouterId!
                }
                if self.oppositeRouterType != nil {
                    map["OppositeRouterType"] = self.oppositeRouterType!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.routerId != nil {
                    map["RouterId"] = self.routerId!
                }
                if self.routerInterfaceId != nil {
                    map["RouterInterfaceId"] = self.routerInterfaceId!
                }
                if self.routerType != nil {
                    map["RouterType"] = self.routerType!
                }
                if self.spec != nil {
                    map["Spec"] = self.spec!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccessPointId"] as? String {
                    self.accessPointId = value
                }
                if let value = dict["BusinessStatus"] as? String {
                    self.businessStatus = value
                }
                if let value = dict["ChargeType"] as? String {
                    self.chargeType = value
                }
                if let value = dict["ConnectedTime"] as? String {
                    self.connectedTime = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["EndTime"] as? String {
                    self.endTime = value
                }
                if let value = dict["HealthCheckSourceIp"] as? String {
                    self.healthCheckSourceIp = value
                }
                if let value = dict["HealthCheckTargetIp"] as? String {
                    self.healthCheckTargetIp = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["OppositeAccessPointId"] as? String {
                    self.oppositeAccessPointId = value
                }
                if let value = dict["OppositeInterfaceBusinessStatus"] as? String {
                    self.oppositeInterfaceBusinessStatus = value
                }
                if let value = dict["OppositeInterfaceId"] as? String {
                    self.oppositeInterfaceId = value
                }
                if let value = dict["OppositeInterfaceOwnerId"] as? String {
                    self.oppositeInterfaceOwnerId = value
                }
                if let value = dict["OppositeInterfaceSpec"] as? String {
                    self.oppositeInterfaceSpec = value
                }
                if let value = dict["OppositeInterfaceStatus"] as? String {
                    self.oppositeInterfaceStatus = value
                }
                if let value = dict["OppositeRegionId"] as? String {
                    self.oppositeRegionId = value
                }
                if let value = dict["OppositeRouterId"] as? String {
                    self.oppositeRouterId = value
                }
                if let value = dict["OppositeRouterType"] as? String {
                    self.oppositeRouterType = value
                }
                if let value = dict["Role"] as? String {
                    self.role = value
                }
                if let value = dict["RouterId"] as? String {
                    self.routerId = value
                }
                if let value = dict["RouterInterfaceId"] as? String {
                    self.routerInterfaceId = value
                }
                if let value = dict["RouterType"] as? String {
                    self.routerType = value
                }
                if let value = dict["Spec"] as? String {
                    self.spec = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var routerInterfaceType: [DescribeRouterInterfacesResponseBody.RouterInterfaceSet.RouterInterfaceType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.routerInterfaceType != nil {
                var tmp : [Any] = []
                for k in self.routerInterfaceType! {
                    tmp.append(k.toMap())
                }
                map["RouterInterfaceType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RouterInterfaceType"] as? [Any?] {
                var tmp : [DescribeRouterInterfacesResponseBody.RouterInterfaceSet.RouterInterfaceType] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRouterInterfacesResponseBody.RouterInterfaceSet.RouterInterfaceType()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.routerInterfaceType = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var routerInterfaceSet: DescribeRouterInterfacesResponseBody.RouterInterfaceSet?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.routerInterfaceSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routerInterfaceSet != nil {
            map["RouterInterfaceSet"] = self.routerInterfaceSet?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RouterInterfaceSet"] as? [String: Any?] {
            var model = DescribeRouterInterfacesResponseBody.RouterInterfaceSet()
            model.fromMap(value)
            self.routerInterfaceSet = model
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeRouterInterfacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRouterInterfacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRouterInterfacesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSavingsPlanEstimationRequest : Tea.TeaModel {
    public var estimationResource: String?

    public var instanceTypeScope: String?

    public var offeringType: String?

    public var period: String?

    public var periodUnit: String?

    public var planType: String?

    public var regionId: String?

    public var resourceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.estimationResource != nil {
            map["EstimationResource"] = self.estimationResource!
        }
        if self.instanceTypeScope != nil {
            map["InstanceTypeScope"] = self.instanceTypeScope!
        }
        if self.offeringType != nil {
            map["OfferingType"] = self.offeringType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.planType != nil {
            map["PlanType"] = self.planType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EstimationResource"] as? String {
            self.estimationResource = value
        }
        if let value = dict["InstanceTypeScope"] as? String {
            self.instanceTypeScope = value
        }
        if let value = dict["OfferingType"] as? String {
            self.offeringType = value
        }
        if let value = dict["Period"] as? String {
            self.period = value
        }
        if let value = dict["PeriodUnit"] as? String {
            self.periodUnit = value
        }
        if let value = dict["PlanType"] as? String {
            self.planType = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
    }
}

public class DescribeSavingsPlanEstimationResponseBody : Tea.TeaModel {
    public var committedAmount: String?

    public var currency: String?

    public var instanceTypeFamily: String?

    public var instanceTypeFamilyGroup: String?

    public var offeringType: String?

    public var period: Int32?

    public var periodUnit: String?

    public var planType: String?

    public var requestId: String?

    public var resourceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.committedAmount != nil {
            map["CommittedAmount"] = self.committedAmount!
        }
        if self.currency != nil {
            map["Currency"] = self.currency!
        }
        if self.instanceTypeFamily != nil {
            map["InstanceTypeFamily"] = self.instanceTypeFamily!
        }
        if self.instanceTypeFamilyGroup != nil {
            map["InstanceTypeFamilyGroup"] = self.instanceTypeFamilyGroup!
        }
        if self.offeringType != nil {
            map["OfferingType"] = self.offeringType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.planType != nil {
            map["PlanType"] = self.planType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CommittedAmount"] as? String {
            self.committedAmount = value
        }
        if let value = dict["Currency"] as? String {
            self.currency = value
        }
        if let value = dict["InstanceTypeFamily"] as? String {
            self.instanceTypeFamily = value
        }
        if let value = dict["InstanceTypeFamilyGroup"] as? String {
            self.instanceTypeFamilyGroup = value
        }
        if let value = dict["OfferingType"] as? String {
            self.offeringType = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PeriodUnit"] as? String {
            self.periodUnit = value
        }
        if let value = dict["PlanType"] as? String {
            self.planType = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
    }
}

public class DescribeSavingsPlanEstimationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSavingsPlanEstimationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSavingsPlanEstimationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSavingsPlanPriceRequest : Tea.TeaModel {
    public var committedAmount: String?

    public var instanceTypeFamily: String?

    public var instanceTypeFamilyGroup: String?

    public var offeringType: String?

    public var period: Int32?

    public var periodUnit: String?

    public var planType: String?

    public var regionId: String?

    public var resourceId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.committedAmount != nil {
            map["CommittedAmount"] = self.committedAmount!
        }
        if self.instanceTypeFamily != nil {
            map["InstanceTypeFamily"] = self.instanceTypeFamily!
        }
        if self.instanceTypeFamilyGroup != nil {
            map["InstanceTypeFamilyGroup"] = self.instanceTypeFamilyGroup!
        }
        if self.offeringType != nil {
            map["OfferingType"] = self.offeringType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.planType != nil {
            map["PlanType"] = self.planType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CommittedAmount"] as? String {
            self.committedAmount = value
        }
        if let value = dict["InstanceTypeFamily"] as? String {
            self.instanceTypeFamily = value
        }
        if let value = dict["InstanceTypeFamilyGroup"] as? String {
            self.instanceTypeFamilyGroup = value
        }
        if let value = dict["OfferingType"] as? String {
            self.offeringType = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PeriodUnit"] as? String {
            self.periodUnit = value
        }
        if let value = dict["PlanType"] as? String {
            self.planType = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
    }
}

public class DescribeSavingsPlanPriceResponseBody : Tea.TeaModel {
    public class PriceInfo : Tea.TeaModel {
        public class Price : Tea.TeaModel {
            public var currency: String?

            public var discountPrice: Double?

            public var originalPrice: Double?

            public var tradePrice: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.currency != nil {
                    map["Currency"] = self.currency!
                }
                if self.discountPrice != nil {
                    map["DiscountPrice"] = self.discountPrice!
                }
                if self.originalPrice != nil {
                    map["OriginalPrice"] = self.originalPrice!
                }
                if self.tradePrice != nil {
                    map["TradePrice"] = self.tradePrice!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Currency"] as? String {
                    self.currency = value
                }
                if let value = dict["DiscountPrice"] as? Double {
                    self.discountPrice = value
                }
                if let value = dict["OriginalPrice"] as? Double {
                    self.originalPrice = value
                }
                if let value = dict["TradePrice"] as? Double {
                    self.tradePrice = value
                }
            }
        }
        public class Rules : Tea.TeaModel {
            public var description_: String?

            public var ruleId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["RuleId"] as? String {
                    self.ruleId = value
                }
            }
        }
        public var price: DescribeSavingsPlanPriceResponseBody.PriceInfo.Price?

        public var rules: [DescribeSavingsPlanPriceResponseBody.PriceInfo.Rules]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.price?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.price != nil {
                map["Price"] = self.price?.toMap()
            }
            if self.rules != nil {
                var tmp : [Any] = []
                for k in self.rules! {
                    tmp.append(k.toMap())
                }
                map["Rules"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Price"] as? [String: Any?] {
                var model = DescribeSavingsPlanPriceResponseBody.PriceInfo.Price()
                model.fromMap(value)
                self.price = model
            }
            if let value = dict["Rules"] as? [Any?] {
                var tmp : [DescribeSavingsPlanPriceResponseBody.PriceInfo.Rules] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSavingsPlanPriceResponseBody.PriceInfo.Rules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.rules = tmp
            }
        }
    }
    public var priceInfo: DescribeSavingsPlanPriceResponseBody.PriceInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.priceInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.priceInfo != nil {
            map["PriceInfo"] = self.priceInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PriceInfo"] as? [String: Any?] {
            var model = DescribeSavingsPlanPriceResponseBody.PriceInfo()
            model.fromMap(value)
            self.priceInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeSavingsPlanPriceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSavingsPlanPriceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSavingsPlanPriceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSecurityGroupAttributeRequest : Tea.TeaModel {
    public var direction: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var nicType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.nicType != nil {
            map["NicType"] = self.nicType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Direction"] as? String {
            self.direction = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["NicType"] as? String {
            self.nicType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
    }
}

public class DescribeSecurityGroupAttributeResponseBody : Tea.TeaModel {
    public class Permissions : Tea.TeaModel {
        public class Permission : Tea.TeaModel {
            public var createTime: String?

            public var description_: String?

            public var destCidrIp: String?

            public var destGroupId: String?

            public var destGroupName: String?

            public var destGroupOwnerAccount: String?

            public var destPrefixListId: String?

            public var destPrefixListName: String?

            public var direction: String?

            public var ipProtocol: String?

            public var ipv6DestCidrIp: String?

            public var ipv6SourceCidrIp: String?

            public var nicType: String?

            public var policy: String?

            public var portRange: String?

            public var portRangeListId: String?

            public var portRangeListName: String?

            public var priority: String?

            public var securityGroupRuleId: String?

            public var sourceCidrIp: String?

            public var sourceGroupId: String?

            public var sourceGroupName: String?

            public var sourceGroupOwnerAccount: String?

            public var sourcePortRange: String?

            public var sourcePrefixListId: String?

            public var sourcePrefixListName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.destCidrIp != nil {
                    map["DestCidrIp"] = self.destCidrIp!
                }
                if self.destGroupId != nil {
                    map["DestGroupId"] = self.destGroupId!
                }
                if self.destGroupName != nil {
                    map["DestGroupName"] = self.destGroupName!
                }
                if self.destGroupOwnerAccount != nil {
                    map["DestGroupOwnerAccount"] = self.destGroupOwnerAccount!
                }
                if self.destPrefixListId != nil {
                    map["DestPrefixListId"] = self.destPrefixListId!
                }
                if self.destPrefixListName != nil {
                    map["DestPrefixListName"] = self.destPrefixListName!
                }
                if self.direction != nil {
                    map["Direction"] = self.direction!
                }
                if self.ipProtocol != nil {
                    map["IpProtocol"] = self.ipProtocol!
                }
                if self.ipv6DestCidrIp != nil {
                    map["Ipv6DestCidrIp"] = self.ipv6DestCidrIp!
                }
                if self.ipv6SourceCidrIp != nil {
                    map["Ipv6SourceCidrIp"] = self.ipv6SourceCidrIp!
                }
                if self.nicType != nil {
                    map["NicType"] = self.nicType!
                }
                if self.policy != nil {
                    map["Policy"] = self.policy!
                }
                if self.portRange != nil {
                    map["PortRange"] = self.portRange!
                }
                if self.portRangeListId != nil {
                    map["PortRangeListId"] = self.portRangeListId!
                }
                if self.portRangeListName != nil {
                    map["PortRangeListName"] = self.portRangeListName!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.securityGroupRuleId != nil {
                    map["SecurityGroupRuleId"] = self.securityGroupRuleId!
                }
                if self.sourceCidrIp != nil {
                    map["SourceCidrIp"] = self.sourceCidrIp!
                }
                if self.sourceGroupId != nil {
                    map["SourceGroupId"] = self.sourceGroupId!
                }
                if self.sourceGroupName != nil {
                    map["SourceGroupName"] = self.sourceGroupName!
                }
                if self.sourceGroupOwnerAccount != nil {
                    map["SourceGroupOwnerAccount"] = self.sourceGroupOwnerAccount!
                }
                if self.sourcePortRange != nil {
                    map["SourcePortRange"] = self.sourcePortRange!
                }
                if self.sourcePrefixListId != nil {
                    map["SourcePrefixListId"] = self.sourcePrefixListId!
                }
                if self.sourcePrefixListName != nil {
                    map["SourcePrefixListName"] = self.sourcePrefixListName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["DestCidrIp"] as? String {
                    self.destCidrIp = value
                }
                if let value = dict["DestGroupId"] as? String {
                    self.destGroupId = value
                }
                if let value = dict["DestGroupName"] as? String {
                    self.destGroupName = value
                }
                if let value = dict["DestGroupOwnerAccount"] as? String {
                    self.destGroupOwnerAccount = value
                }
                if let value = dict["DestPrefixListId"] as? String {
                    self.destPrefixListId = value
                }
                if let value = dict["DestPrefixListName"] as? String {
                    self.destPrefixListName = value
                }
                if let value = dict["Direction"] as? String {
                    self.direction = value
                }
                if let value = dict["IpProtocol"] as? String {
                    self.ipProtocol = value
                }
                if let value = dict["Ipv6DestCidrIp"] as? String {
                    self.ipv6DestCidrIp = value
                }
                if let value = dict["Ipv6SourceCidrIp"] as? String {
                    self.ipv6SourceCidrIp = value
                }
                if let value = dict["NicType"] as? String {
                    self.nicType = value
                }
                if let value = dict["Policy"] as? String {
                    self.policy = value
                }
                if let value = dict["PortRange"] as? String {
                    self.portRange = value
                }
                if let value = dict["PortRangeListId"] as? String {
                    self.portRangeListId = value
                }
                if let value = dict["PortRangeListName"] as? String {
                    self.portRangeListName = value
                }
                if let value = dict["Priority"] as? String {
                    self.priority = value
                }
                if let value = dict["SecurityGroupRuleId"] as? String {
                    self.securityGroupRuleId = value
                }
                if let value = dict["SourceCidrIp"] as? String {
                    self.sourceCidrIp = value
                }
                if let value = dict["SourceGroupId"] as? String {
                    self.sourceGroupId = value
                }
                if let value = dict["SourceGroupName"] as? String {
                    self.sourceGroupName = value
                }
                if let value = dict["SourceGroupOwnerAccount"] as? String {
                    self.sourceGroupOwnerAccount = value
                }
                if let value = dict["SourcePortRange"] as? String {
                    self.sourcePortRange = value
                }
                if let value = dict["SourcePrefixListId"] as? String {
                    self.sourcePrefixListId = value
                }
                if let value = dict["SourcePrefixListName"] as? String {
                    self.sourcePrefixListName = value
                }
            }
        }
        public var permission: [DescribeSecurityGroupAttributeResponseBody.Permissions.Permission]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.permission != nil {
                var tmp : [Any] = []
                for k in self.permission! {
                    tmp.append(k.toMap())
                }
                map["Permission"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Permission"] as? [Any?] {
                var tmp : [DescribeSecurityGroupAttributeResponseBody.Permissions.Permission] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSecurityGroupAttributeResponseBody.Permissions.Permission()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.permission = tmp
            }
        }
    }
    public var description_: String?

    public var innerAccessPolicy: String?

    public var nextToken: String?

    public var permissions: DescribeSecurityGroupAttributeResponseBody.Permissions?

    public var regionId: String?

    public var requestId: String?

    public var securityGroupId: String?

    public var securityGroupName: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.permissions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.innerAccessPolicy != nil {
            map["InnerAccessPolicy"] = self.innerAccessPolicy!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.permissions != nil {
            map["Permissions"] = self.permissions?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupName != nil {
            map["SecurityGroupName"] = self.securityGroupName!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["InnerAccessPolicy"] as? String {
            self.innerAccessPolicy = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["Permissions"] as? [String: Any?] {
            var model = DescribeSecurityGroupAttributeResponseBody.Permissions()
            model.fromMap(value)
            self.permissions = model
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SecurityGroupName"] as? String {
            self.securityGroupName = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class DescribeSecurityGroupAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSecurityGroupAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSecurityGroupAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSecurityGroupReferencesRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityGroupId"] as? [String] {
            self.securityGroupId = value
        }
    }
}

public class DescribeSecurityGroupReferencesResponseBody : Tea.TeaModel {
    public class SecurityGroupReferences : Tea.TeaModel {
        public class SecurityGroupReference : Tea.TeaModel {
            public class ReferencingSecurityGroups : Tea.TeaModel {
                public class ReferencingSecurityGroup : Tea.TeaModel {
                    public var aliUid: String?

                    public var securityGroupId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.aliUid != nil {
                            map["AliUid"] = self.aliUid!
                        }
                        if self.securityGroupId != nil {
                            map["SecurityGroupId"] = self.securityGroupId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AliUid"] as? String {
                            self.aliUid = value
                        }
                        if let value = dict["SecurityGroupId"] as? String {
                            self.securityGroupId = value
                        }
                    }
                }
                public var referencingSecurityGroup: [DescribeSecurityGroupReferencesResponseBody.SecurityGroupReferences.SecurityGroupReference.ReferencingSecurityGroups.ReferencingSecurityGroup]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.referencingSecurityGroup != nil {
                        var tmp : [Any] = []
                        for k in self.referencingSecurityGroup! {
                            tmp.append(k.toMap())
                        }
                        map["ReferencingSecurityGroup"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ReferencingSecurityGroup"] as? [Any?] {
                        var tmp : [DescribeSecurityGroupReferencesResponseBody.SecurityGroupReferences.SecurityGroupReference.ReferencingSecurityGroups.ReferencingSecurityGroup] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeSecurityGroupReferencesResponseBody.SecurityGroupReferences.SecurityGroupReference.ReferencingSecurityGroups.ReferencingSecurityGroup()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.referencingSecurityGroup = tmp
                    }
                }
            }
            public var referencingSecurityGroups: DescribeSecurityGroupReferencesResponseBody.SecurityGroupReferences.SecurityGroupReference.ReferencingSecurityGroups?

            public var securityGroupId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.referencingSecurityGroups?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.referencingSecurityGroups != nil {
                    map["ReferencingSecurityGroups"] = self.referencingSecurityGroups?.toMap()
                }
                if self.securityGroupId != nil {
                    map["SecurityGroupId"] = self.securityGroupId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ReferencingSecurityGroups"] as? [String: Any?] {
                    var model = DescribeSecurityGroupReferencesResponseBody.SecurityGroupReferences.SecurityGroupReference.ReferencingSecurityGroups()
                    model.fromMap(value)
                    self.referencingSecurityGroups = model
                }
                if let value = dict["SecurityGroupId"] as? String {
                    self.securityGroupId = value
                }
            }
        }
        public var securityGroupReference: [DescribeSecurityGroupReferencesResponseBody.SecurityGroupReferences.SecurityGroupReference]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.securityGroupReference != nil {
                var tmp : [Any] = []
                for k in self.securityGroupReference! {
                    tmp.append(k.toMap())
                }
                map["SecurityGroupReference"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SecurityGroupReference"] as? [Any?] {
                var tmp : [DescribeSecurityGroupReferencesResponseBody.SecurityGroupReferences.SecurityGroupReference] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSecurityGroupReferencesResponseBody.SecurityGroupReferences.SecurityGroupReference()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.securityGroupReference = tmp
            }
        }
    }
    public var requestId: String?

    public var securityGroupReferences: DescribeSecurityGroupReferencesResponseBody.SecurityGroupReferences?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.securityGroupReferences?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityGroupReferences != nil {
            map["SecurityGroupReferences"] = self.securityGroupReferences?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SecurityGroupReferences"] as? [String: Any?] {
            var model = DescribeSecurityGroupReferencesResponseBody.SecurityGroupReferences()
            model.fromMap(value)
            self.securityGroupReferences = model
        }
    }
}

public class DescribeSecurityGroupReferencesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSecurityGroupReferencesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSecurityGroupReferencesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSecurityGroupsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var dryRun: Bool?

    public var fuzzyQuery: Bool?

    public var isQueryEcsCount: Bool?

    public var maxResults: Int32?

    public var networkType: String?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public var securityGroupIds: String?

    public var securityGroupName: String?

    public var securityGroupType: String?

    public var serviceManaged: Bool?

    public var tag: [DescribeSecurityGroupsRequest.Tag]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.fuzzyQuery != nil {
            map["FuzzyQuery"] = self.fuzzyQuery!
        }
        if self.isQueryEcsCount != nil {
            map["IsQueryEcsCount"] = self.isQueryEcsCount!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds!
        }
        if self.securityGroupName != nil {
            map["SecurityGroupName"] = self.securityGroupName!
        }
        if self.securityGroupType != nil {
            map["SecurityGroupType"] = self.securityGroupType!
        }
        if self.serviceManaged != nil {
            map["ServiceManaged"] = self.serviceManaged!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["FuzzyQuery"] as? Bool {
            self.fuzzyQuery = value
        }
        if let value = dict["IsQueryEcsCount"] as? Bool {
            self.isQueryEcsCount = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NetworkType"] as? String {
            self.networkType = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SecurityGroupIds"] as? String {
            self.securityGroupIds = value
        }
        if let value = dict["SecurityGroupName"] as? String {
            self.securityGroupName = value
        }
        if let value = dict["SecurityGroupType"] as? String {
            self.securityGroupType = value
        }
        if let value = dict["ServiceManaged"] as? Bool {
            self.serviceManaged = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeSecurityGroupsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeSecurityGroupsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class DescribeSecurityGroupsResponseBody : Tea.TeaModel {
    public class SecurityGroups : Tea.TeaModel {
        public class SecurityGroup : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["TagKey"] as? String {
                            self.tagKey = value
                        }
                        if let value = dict["TagValue"] as? String {
                            self.tagValue = value
                        }
                    }
                }
                public var tag: [DescribeSecurityGroupsResponseBody.SecurityGroups.SecurityGroup.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeSecurityGroupsResponseBody.SecurityGroups.SecurityGroup.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeSecurityGroupsResponseBody.SecurityGroups.SecurityGroup.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var availableInstanceAmount: Int32?

            public var creationTime: String?

            public var description_: String?

            public var ecsCount: Int32?

            public var groupToGroupRuleCount: Int32?

            public var resourceGroupId: String?

            public var ruleCount: Int32?

            public var securityGroupId: String?

            public var securityGroupName: String?

            public var securityGroupType: String?

            public var serviceID: Int64?

            public var serviceManaged: Bool?

            public var tags: DescribeSecurityGroupsResponseBody.SecurityGroups.SecurityGroup.Tags?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.availableInstanceAmount != nil {
                    map["AvailableInstanceAmount"] = self.availableInstanceAmount!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ecsCount != nil {
                    map["EcsCount"] = self.ecsCount!
                }
                if self.groupToGroupRuleCount != nil {
                    map["GroupToGroupRuleCount"] = self.groupToGroupRuleCount!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.ruleCount != nil {
                    map["RuleCount"] = self.ruleCount!
                }
                if self.securityGroupId != nil {
                    map["SecurityGroupId"] = self.securityGroupId!
                }
                if self.securityGroupName != nil {
                    map["SecurityGroupName"] = self.securityGroupName!
                }
                if self.securityGroupType != nil {
                    map["SecurityGroupType"] = self.securityGroupType!
                }
                if self.serviceID != nil {
                    map["ServiceID"] = self.serviceID!
                }
                if self.serviceManaged != nil {
                    map["ServiceManaged"] = self.serviceManaged!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AvailableInstanceAmount"] as? Int32 {
                    self.availableInstanceAmount = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["EcsCount"] as? Int32 {
                    self.ecsCount = value
                }
                if let value = dict["GroupToGroupRuleCount"] as? Int32 {
                    self.groupToGroupRuleCount = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["RuleCount"] as? Int32 {
                    self.ruleCount = value
                }
                if let value = dict["SecurityGroupId"] as? String {
                    self.securityGroupId = value
                }
                if let value = dict["SecurityGroupName"] as? String {
                    self.securityGroupName = value
                }
                if let value = dict["SecurityGroupType"] as? String {
                    self.securityGroupType = value
                }
                if let value = dict["ServiceID"] as? Int64 {
                    self.serviceID = value
                }
                if let value = dict["ServiceManaged"] as? Bool {
                    self.serviceManaged = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeSecurityGroupsResponseBody.SecurityGroups.SecurityGroup.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
            }
        }
        public var securityGroup: [DescribeSecurityGroupsResponseBody.SecurityGroups.SecurityGroup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.securityGroup != nil {
                var tmp : [Any] = []
                for k in self.securityGroup! {
                    tmp.append(k.toMap())
                }
                map["SecurityGroup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SecurityGroup"] as? [Any?] {
                var tmp : [DescribeSecurityGroupsResponseBody.SecurityGroups.SecurityGroup] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSecurityGroupsResponseBody.SecurityGroups.SecurityGroup()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.securityGroup = tmp
            }
        }
    }
    public var nextToken: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestId: String?

    public var securityGroups: DescribeSecurityGroupsResponseBody.SecurityGroups?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.securityGroups?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityGroups != nil {
            map["SecurityGroups"] = self.securityGroups?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SecurityGroups"] as? [String: Any?] {
            var model = DescribeSecurityGroupsResponseBody.SecurityGroups()
            model.fromMap(value)
            self.securityGroups = model
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeSecurityGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSecurityGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSecurityGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSendFileResultsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var instanceId: String?

    public var invocationStatus: String?

    public var invokeId: String?

    public var maxResults: Int32?

    public var name: String?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeSendFileResultsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.invocationStatus != nil {
            map["InvocationStatus"] = self.invocationStatus!
        }
        if self.invokeId != nil {
            map["InvokeId"] = self.invokeId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InvocationStatus"] as? String {
            self.invocationStatus = value
        }
        if let value = dict["InvokeId"] as? String {
            self.invokeId = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeSendFileResultsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeSendFileResultsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribeSendFileResultsResponseBody : Tea.TeaModel {
    public class Invocations : Tea.TeaModel {
        public class Invocation : Tea.TeaModel {
            public class InvokeInstances : Tea.TeaModel {
                public class InvokeInstance : Tea.TeaModel {
                    public var creationTime: String?

                    public var errorCode: String?

                    public var errorInfo: String?

                    public var finishTime: String?

                    public var instanceId: String?

                    public var invocationStatus: String?

                    public var startTime: String?

                    public var updateTime: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.creationTime != nil {
                            map["CreationTime"] = self.creationTime!
                        }
                        if self.errorCode != nil {
                            map["ErrorCode"] = self.errorCode!
                        }
                        if self.errorInfo != nil {
                            map["ErrorInfo"] = self.errorInfo!
                        }
                        if self.finishTime != nil {
                            map["FinishTime"] = self.finishTime!
                        }
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.invocationStatus != nil {
                            map["InvocationStatus"] = self.invocationStatus!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        if self.updateTime != nil {
                            map["UpdateTime"] = self.updateTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["CreationTime"] as? String {
                            self.creationTime = value
                        }
                        if let value = dict["ErrorCode"] as? String {
                            self.errorCode = value
                        }
                        if let value = dict["ErrorInfo"] as? String {
                            self.errorInfo = value
                        }
                        if let value = dict["FinishTime"] as? String {
                            self.finishTime = value
                        }
                        if let value = dict["InstanceId"] as? String {
                            self.instanceId = value
                        }
                        if let value = dict["InvocationStatus"] as? String {
                            self.invocationStatus = value
                        }
                        if let value = dict["StartTime"] as? String {
                            self.startTime = value
                        }
                        if let value = dict["UpdateTime"] as? String {
                            self.updateTime = value
                        }
                    }
                }
                public var invokeInstance: [DescribeSendFileResultsResponseBody.Invocations.Invocation.InvokeInstances.InvokeInstance]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.invokeInstance != nil {
                        var tmp : [Any] = []
                        for k in self.invokeInstance! {
                            tmp.append(k.toMap())
                        }
                        map["InvokeInstance"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["InvokeInstance"] as? [Any?] {
                        var tmp : [DescribeSendFileResultsResponseBody.Invocations.Invocation.InvokeInstances.InvokeInstance] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeSendFileResultsResponseBody.Invocations.Invocation.InvokeInstances.InvokeInstance()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.invokeInstance = tmp
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["TagKey"] as? String {
                            self.tagKey = value
                        }
                        if let value = dict["TagValue"] as? String {
                            self.tagValue = value
                        }
                    }
                }
                public var tag: [DescribeSendFileResultsResponseBody.Invocations.Invocation.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeSendFileResultsResponseBody.Invocations.Invocation.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeSendFileResultsResponseBody.Invocations.Invocation.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var content: String?

            public var contentType: String?

            public var creationTime: String?

            public var description_: String?

            public var fileGroup: String?

            public var fileMode: String?

            public var fileOwner: String?

            public var invocationStatus: String?

            public var invokeId: String?

            public var invokeInstances: DescribeSendFileResultsResponseBody.Invocations.Invocation.InvokeInstances?

            public var name: String?

            public var overwrite: String?

            public var tags: DescribeSendFileResultsResponseBody.Invocations.Invocation.Tags?

            public var targetDir: String?

            public var vmCount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.invokeInstances?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.contentType != nil {
                    map["ContentType"] = self.contentType!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.fileGroup != nil {
                    map["FileGroup"] = self.fileGroup!
                }
                if self.fileMode != nil {
                    map["FileMode"] = self.fileMode!
                }
                if self.fileOwner != nil {
                    map["FileOwner"] = self.fileOwner!
                }
                if self.invocationStatus != nil {
                    map["InvocationStatus"] = self.invocationStatus!
                }
                if self.invokeId != nil {
                    map["InvokeId"] = self.invokeId!
                }
                if self.invokeInstances != nil {
                    map["InvokeInstances"] = self.invokeInstances?.toMap()
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.overwrite != nil {
                    map["Overwrite"] = self.overwrite!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.targetDir != nil {
                    map["TargetDir"] = self.targetDir!
                }
                if self.vmCount != nil {
                    map["VmCount"] = self.vmCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Content"] as? String {
                    self.content = value
                }
                if let value = dict["ContentType"] as? String {
                    self.contentType = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["FileGroup"] as? String {
                    self.fileGroup = value
                }
                if let value = dict["FileMode"] as? String {
                    self.fileMode = value
                }
                if let value = dict["FileOwner"] as? String {
                    self.fileOwner = value
                }
                if let value = dict["InvocationStatus"] as? String {
                    self.invocationStatus = value
                }
                if let value = dict["InvokeId"] as? String {
                    self.invokeId = value
                }
                if let value = dict["InvokeInstances"] as? [String: Any?] {
                    var model = DescribeSendFileResultsResponseBody.Invocations.Invocation.InvokeInstances()
                    model.fromMap(value)
                    self.invokeInstances = model
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Overwrite"] as? String {
                    self.overwrite = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeSendFileResultsResponseBody.Invocations.Invocation.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["TargetDir"] as? String {
                    self.targetDir = value
                }
                if let value = dict["VmCount"] as? Int32 {
                    self.vmCount = value
                }
            }
        }
        public var invocation: [DescribeSendFileResultsResponseBody.Invocations.Invocation]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.invocation != nil {
                var tmp : [Any] = []
                for k in self.invocation! {
                    tmp.append(k.toMap())
                }
                map["Invocation"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Invocation"] as? [Any?] {
                var tmp : [DescribeSendFileResultsResponseBody.Invocations.Invocation] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSendFileResultsResponseBody.Invocations.Invocation()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.invocation = tmp
            }
        }
    }
    public var invocations: DescribeSendFileResultsResponseBody.Invocations?

    public var nextToken: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.invocations?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.invocations != nil {
            map["Invocations"] = self.invocations?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Invocations"] as? [String: Any?] {
            var model = DescribeSendFileResultsResponseBody.Invocations()
            model.fromMap(value)
            self.invocations = model
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribeSendFileResultsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSendFileResultsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSendFileResultsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSnapshotGroupsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var additionalAttributes: [String]?

    public var instanceId: String?

    public var maxResults: Int32?

    public var name: String?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snapshotGroupId: [String]?

    public var status: [String]?

    public var tag: [DescribeSnapshotGroupsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.additionalAttributes != nil {
            map["AdditionalAttributes"] = self.additionalAttributes!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snapshotGroupId != nil {
            map["SnapshotGroupId"] = self.snapshotGroupId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AdditionalAttributes"] as? [String] {
            self.additionalAttributes = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SnapshotGroupId"] as? [String] {
            self.snapshotGroupId = value
        }
        if let value = dict["Status"] as? [String] {
            self.status = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeSnapshotGroupsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeSnapshotGroupsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribeSnapshotGroupsResponseBody : Tea.TeaModel {
    public class SnapshotGroups : Tea.TeaModel {
        public class SnapshotGroup : Tea.TeaModel {
            public class Snapshots : Tea.TeaModel {
                public class Snapshot : Tea.TeaModel {
                    public class Tags : Tea.TeaModel {
                        public class Tag : Tea.TeaModel {
                            public var key: String?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.key != nil {
                                    map["Key"] = self.key!
                                }
                                if self.value != nil {
                                    map["Value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["Key"] as? String {
                                    self.key = value
                                }
                                if let value = dict["Value"] as? String {
                                    self.value = value
                                }
                            }
                        }
                        public var tag: [DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Snapshots.Snapshot.Tags.Tag]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.tag != nil {
                                var tmp : [Any] = []
                                for k in self.tag! {
                                    tmp.append(k.toMap())
                                }
                                map["Tag"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Tag"] as? [Any?] {
                                var tmp : [DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Snapshots.Snapshot.Tags.Tag] = []
                                for v in value {
                                    if v != nil {
                                        var model = DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Snapshots.Snapshot.Tags.Tag()
                                        if v != nil {
                                            model.fromMap(v as? [String: Any?])
                                        }
                                        tmp.append(model)
                                    }
                                }
                                self.tag = tmp
                            }
                        }
                    }
                    public var available: Bool?

                    public var instantAccess: Bool?

                    public var instantAccessRetentionDays: Int32?

                    public var progress: String?

                    public var snapshotId: String?

                    public var sourceDiskId: String?

                    public var sourceDiskType: String?

                    public var tags: DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Snapshots.Snapshot.Tags?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.tags?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.available != nil {
                            map["Available"] = self.available!
                        }
                        if self.instantAccess != nil {
                            map["InstantAccess"] = self.instantAccess!
                        }
                        if self.instantAccessRetentionDays != nil {
                            map["InstantAccessRetentionDays"] = self.instantAccessRetentionDays!
                        }
                        if self.progress != nil {
                            map["Progress"] = self.progress!
                        }
                        if self.snapshotId != nil {
                            map["SnapshotId"] = self.snapshotId!
                        }
                        if self.sourceDiskId != nil {
                            map["SourceDiskId"] = self.sourceDiskId!
                        }
                        if self.sourceDiskType != nil {
                            map["SourceDiskType"] = self.sourceDiskType!
                        }
                        if self.tags != nil {
                            map["Tags"] = self.tags?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Available"] as? Bool {
                            self.available = value
                        }
                        if let value = dict["InstantAccess"] as? Bool {
                            self.instantAccess = value
                        }
                        if let value = dict["InstantAccessRetentionDays"] as? Int32 {
                            self.instantAccessRetentionDays = value
                        }
                        if let value = dict["Progress"] as? String {
                            self.progress = value
                        }
                        if let value = dict["SnapshotId"] as? String {
                            self.snapshotId = value
                        }
                        if let value = dict["SourceDiskId"] as? String {
                            self.sourceDiskId = value
                        }
                        if let value = dict["SourceDiskType"] as? String {
                            self.sourceDiskType = value
                        }
                        if let value = dict["Tags"] as? [String: Any?] {
                            var model = DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Snapshots.Snapshot.Tags()
                            model.fromMap(value)
                            self.tags = model
                        }
                    }
                }
                public var snapshot: [DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Snapshots.Snapshot]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.snapshot != nil {
                        var tmp : [Any] = []
                        for k in self.snapshot! {
                            tmp.append(k.toMap())
                        }
                        map["Snapshot"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Snapshot"] as? [Any?] {
                        var tmp : [DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Snapshots.Snapshot] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Snapshots.Snapshot()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.snapshot = tmp
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Key"] as? String {
                            self.key = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var tag: [DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var creationTime: String?

            public var description_: String?

            public var instanceId: String?

            public var name: String?

            public var progressStatus: String?

            public var resourceGroupId: String?

            public var snapshotGroupId: String?

            public var snapshots: DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Snapshots?

            public var status: String?

            public var tags: DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Tags?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.snapshots?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.progressStatus != nil {
                    map["ProgressStatus"] = self.progressStatus!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.snapshotGroupId != nil {
                    map["SnapshotGroupId"] = self.snapshotGroupId!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["ProgressStatus"] as? String {
                    self.progressStatus = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["SnapshotGroupId"] as? String {
                    self.snapshotGroupId = value
                }
                if let value = dict["Snapshots"] as? [String: Any?] {
                    var model = DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Snapshots()
                    model.fromMap(value)
                    self.snapshots = model
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
            }
        }
        public var snapshotGroup: [DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.snapshotGroup != nil {
                var tmp : [Any] = []
                for k in self.snapshotGroup! {
                    tmp.append(k.toMap())
                }
                map["SnapshotGroup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SnapshotGroup"] as? [Any?] {
                var tmp : [DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.snapshotGroup = tmp
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var snapshotGroups: DescribeSnapshotGroupsResponseBody.SnapshotGroups?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snapshotGroups?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotGroups != nil {
            map["SnapshotGroups"] = self.snapshotGroups?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SnapshotGroups"] as? [String: Any?] {
            var model = DescribeSnapshotGroupsResponseBody.SnapshotGroups()
            model.fromMap(value)
            self.snapshotGroups = model
        }
    }
}

public class DescribeSnapshotGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSnapshotGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSnapshotGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSnapshotLinksRequest : Tea.TeaModel {
    public var diskIds: String?

    public var instanceId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snapshotLinkIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskIds != nil {
            map["DiskIds"] = self.diskIds!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snapshotLinkIds != nil {
            map["SnapshotLinkIds"] = self.snapshotLinkIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DiskIds"] as? String {
            self.diskIds = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SnapshotLinkIds"] as? String {
            self.snapshotLinkIds = value
        }
    }
}

public class DescribeSnapshotLinksResponseBody : Tea.TeaModel {
    public class SnapshotLinks : Tea.TeaModel {
        public class SnapshotLink : Tea.TeaModel {
            public var category: String?

            public var instanceId: String?

            public var instanceName: String?

            public var instantAccess: Bool?

            public var regionId: String?

            public var snapshotLinkId: String?

            public var sourceDiskId: String?

            public var sourceDiskName: String?

            public var sourceDiskSize: Int32?

            public var sourceDiskType: String?

            public var totalCount: Int32?

            public var totalSize: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.instantAccess != nil {
                    map["InstantAccess"] = self.instantAccess!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.snapshotLinkId != nil {
                    map["SnapshotLinkId"] = self.snapshotLinkId!
                }
                if self.sourceDiskId != nil {
                    map["SourceDiskId"] = self.sourceDiskId!
                }
                if self.sourceDiskName != nil {
                    map["SourceDiskName"] = self.sourceDiskName!
                }
                if self.sourceDiskSize != nil {
                    map["SourceDiskSize"] = self.sourceDiskSize!
                }
                if self.sourceDiskType != nil {
                    map["SourceDiskType"] = self.sourceDiskType!
                }
                if self.totalCount != nil {
                    map["TotalCount"] = self.totalCount!
                }
                if self.totalSize != nil {
                    map["TotalSize"] = self.totalSize!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Category"] as? String {
                    self.category = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["InstanceName"] as? String {
                    self.instanceName = value
                }
                if let value = dict["InstantAccess"] as? Bool {
                    self.instantAccess = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["SnapshotLinkId"] as? String {
                    self.snapshotLinkId = value
                }
                if let value = dict["SourceDiskId"] as? String {
                    self.sourceDiskId = value
                }
                if let value = dict["SourceDiskName"] as? String {
                    self.sourceDiskName = value
                }
                if let value = dict["SourceDiskSize"] as? Int32 {
                    self.sourceDiskSize = value
                }
                if let value = dict["SourceDiskType"] as? String {
                    self.sourceDiskType = value
                }
                if let value = dict["TotalCount"] as? Int32 {
                    self.totalCount = value
                }
                if let value = dict["TotalSize"] as? Int64 {
                    self.totalSize = value
                }
            }
        }
        public var snapshotLink: [DescribeSnapshotLinksResponseBody.SnapshotLinks.SnapshotLink]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.snapshotLink != nil {
                var tmp : [Any] = []
                for k in self.snapshotLink! {
                    tmp.append(k.toMap())
                }
                map["SnapshotLink"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SnapshotLink"] as? [Any?] {
                var tmp : [DescribeSnapshotLinksResponseBody.SnapshotLinks.SnapshotLink] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSnapshotLinksResponseBody.SnapshotLinks.SnapshotLink()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.snapshotLink = tmp
            }
        }
    }
    public var nextToken: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var snapshotLinks: DescribeSnapshotLinksResponseBody.SnapshotLinks?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snapshotLinks?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotLinks != nil {
            map["SnapshotLinks"] = self.snapshotLinks?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SnapshotLinks"] as? [String: Any?] {
            var model = DescribeSnapshotLinksResponseBody.SnapshotLinks()
            model.fromMap(value)
            self.snapshotLinks = model
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeSnapshotLinksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSnapshotLinksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSnapshotLinksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSnapshotMonitorDataRequest : Tea.TeaModel {
    public var category: String?

    public var endTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Category"] as? String {
            self.category = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeSnapshotMonitorDataResponseBody : Tea.TeaModel {
    public class MonitorData : Tea.TeaModel {
        public class DataPoint : Tea.TeaModel {
            public var size: Int64?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Size"] as? Int64 {
                    self.size = value
                }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
            }
        }
        public var dataPoint: [DescribeSnapshotMonitorDataResponseBody.MonitorData.DataPoint]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataPoint != nil {
                var tmp : [Any] = []
                for k in self.dataPoint! {
                    tmp.append(k.toMap())
                }
                map["DataPoint"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataPoint"] as? [Any?] {
                var tmp : [DescribeSnapshotMonitorDataResponseBody.MonitorData.DataPoint] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSnapshotMonitorDataResponseBody.MonitorData.DataPoint()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataPoint = tmp
            }
        }
    }
    public var monitorData: DescribeSnapshotMonitorDataResponseBody.MonitorData?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.monitorData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorData != nil {
            map["MonitorData"] = self.monitorData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MonitorData"] as? [String: Any?] {
            var model = DescribeSnapshotMonitorDataResponseBody.MonitorData()
            model.fromMap(value)
            self.monitorData = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeSnapshotMonitorDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSnapshotMonitorDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSnapshotMonitorDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSnapshotPackageRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeSnapshotPackageResponseBody : Tea.TeaModel {
    public class SnapshotPackages : Tea.TeaModel {
        public class SnapshotPackage : Tea.TeaModel {
            public var displayName: String?

            public var endTime: String?

            public var initCapacity: Int64?

            public var startTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.initCapacity != nil {
                    map["InitCapacity"] = self.initCapacity!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DisplayName"] as? String {
                    self.displayName = value
                }
                if let value = dict["EndTime"] as? String {
                    self.endTime = value
                }
                if let value = dict["InitCapacity"] as? Int64 {
                    self.initCapacity = value
                }
                if let value = dict["StartTime"] as? String {
                    self.startTime = value
                }
            }
        }
        public var snapshotPackage: [DescribeSnapshotPackageResponseBody.SnapshotPackages.SnapshotPackage]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.snapshotPackage != nil {
                var tmp : [Any] = []
                for k in self.snapshotPackage! {
                    tmp.append(k.toMap())
                }
                map["SnapshotPackage"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SnapshotPackage"] as? [Any?] {
                var tmp : [DescribeSnapshotPackageResponseBody.SnapshotPackages.SnapshotPackage] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSnapshotPackageResponseBody.SnapshotPackages.SnapshotPackage()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.snapshotPackage = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var snapshotPackages: DescribeSnapshotPackageResponseBody.SnapshotPackages?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snapshotPackages?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotPackages != nil {
            map["SnapshotPackages"] = self.snapshotPackages?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SnapshotPackages"] as? [String: Any?] {
            var model = DescribeSnapshotPackageResponseBody.SnapshotPackages()
            model.fromMap(value)
            self.snapshotPackages = model
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeSnapshotPackageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSnapshotPackageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSnapshotPackageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSnapshotsRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var filter: [DescribeSnapshotsRequest.Filter]?

    public var category: String?

    public var diskId: String?

    public var dryRun: Bool?

    public var encrypted: Bool?

    public var instanceId: String?

    public var KMSKeyId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snapshotIds: String?

    public var snapshotLinkId: String?

    public var snapshotName: String?

    public var snapshotType: String?

    public var sourceDiskType: String?

    public var status: String?

    public var tag: [DescribeSnapshotsRequest.Tag]?

    public var usage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.encrypted != nil {
            map["Encrypted"] = self.encrypted!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.KMSKeyId != nil {
            map["KMSKeyId"] = self.KMSKeyId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snapshotIds != nil {
            map["SnapshotIds"] = self.snapshotIds!
        }
        if self.snapshotLinkId != nil {
            map["SnapshotLinkId"] = self.snapshotLinkId!
        }
        if self.snapshotName != nil {
            map["SnapshotName"] = self.snapshotName!
        }
        if self.snapshotType != nil {
            map["SnapshotType"] = self.snapshotType!
        }
        if self.sourceDiskType != nil {
            map["SourceDiskType"] = self.sourceDiskType!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.usage != nil {
            map["Usage"] = self.usage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Filter"] as? [Any?] {
            var tmp : [DescribeSnapshotsRequest.Filter] = []
            for v in value {
                if v != nil {
                    var model = DescribeSnapshotsRequest.Filter()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.filter = tmp
        }
        if let value = dict["Category"] as? String {
            self.category = value
        }
        if let value = dict["DiskId"] as? String {
            self.diskId = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Encrypted"] as? Bool {
            self.encrypted = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["KMSKeyId"] as? String {
            self.KMSKeyId = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SnapshotIds"] as? String {
            self.snapshotIds = value
        }
        if let value = dict["SnapshotLinkId"] as? String {
            self.snapshotLinkId = value
        }
        if let value = dict["SnapshotName"] as? String {
            self.snapshotName = value
        }
        if let value = dict["SnapshotType"] as? String {
            self.snapshotType = value
        }
        if let value = dict["SourceDiskType"] as? String {
            self.sourceDiskType = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeSnapshotsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeSnapshotsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["Usage"] as? String {
            self.usage = value
        }
    }
}

public class DescribeSnapshotsResponseBody : Tea.TeaModel {
    public class Snapshots : Tea.TeaModel {
        public class Snapshot : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["TagKey"] as? String {
                            self.tagKey = value
                        }
                        if let value = dict["TagValue"] as? String {
                            self.tagValue = value
                        }
                    }
                }
                public var tag: [DescribeSnapshotsResponseBody.Snapshots.Snapshot.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeSnapshotsResponseBody.Snapshots.Snapshot.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeSnapshotsResponseBody.Snapshots.Snapshot.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var available: Bool?

            public var category: String?

            public var creationTime: String?

            public var description_: String?

            public var encrypted: Bool?

            public var instantAccess: Bool?

            public var instantAccessRetentionDays: Int32?

            public var KMSKeyId: String?

            public var lastModifiedTime: String?

            public var productCode: String?

            public var progress: String?

            public var regionId: String?

            public var remainTime: Int32?

            public var resourceGroupId: String?

            public var retentionDays: Int32?

            public var snapshotId: String?

            public var snapshotLinkId: String?

            public var snapshotName: String?

            public var snapshotSN: String?

            public var snapshotType: String?

            public var sourceDiskId: String?

            public var sourceDiskSize: String?

            public var sourceDiskType: String?

            public var sourceRegionId: String?

            public var sourceSnapshotId: String?

            public var sourceStorageType: String?

            public var status: String?

            public var tags: DescribeSnapshotsResponseBody.Snapshots.Snapshot.Tags?

            public var usage: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.available != nil {
                    map["Available"] = self.available!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.encrypted != nil {
                    map["Encrypted"] = self.encrypted!
                }
                if self.instantAccess != nil {
                    map["InstantAccess"] = self.instantAccess!
                }
                if self.instantAccessRetentionDays != nil {
                    map["InstantAccessRetentionDays"] = self.instantAccessRetentionDays!
                }
                if self.KMSKeyId != nil {
                    map["KMSKeyId"] = self.KMSKeyId!
                }
                if self.lastModifiedTime != nil {
                    map["LastModifiedTime"] = self.lastModifiedTime!
                }
                if self.productCode != nil {
                    map["ProductCode"] = self.productCode!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.remainTime != nil {
                    map["RemainTime"] = self.remainTime!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.retentionDays != nil {
                    map["RetentionDays"] = self.retentionDays!
                }
                if self.snapshotId != nil {
                    map["SnapshotId"] = self.snapshotId!
                }
                if self.snapshotLinkId != nil {
                    map["SnapshotLinkId"] = self.snapshotLinkId!
                }
                if self.snapshotName != nil {
                    map["SnapshotName"] = self.snapshotName!
                }
                if self.snapshotSN != nil {
                    map["SnapshotSN"] = self.snapshotSN!
                }
                if self.snapshotType != nil {
                    map["SnapshotType"] = self.snapshotType!
                }
                if self.sourceDiskId != nil {
                    map["SourceDiskId"] = self.sourceDiskId!
                }
                if self.sourceDiskSize != nil {
                    map["SourceDiskSize"] = self.sourceDiskSize!
                }
                if self.sourceDiskType != nil {
                    map["SourceDiskType"] = self.sourceDiskType!
                }
                if self.sourceRegionId != nil {
                    map["SourceRegionId"] = self.sourceRegionId!
                }
                if self.sourceSnapshotId != nil {
                    map["SourceSnapshotId"] = self.sourceSnapshotId!
                }
                if self.sourceStorageType != nil {
                    map["SourceStorageType"] = self.sourceStorageType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.usage != nil {
                    map["Usage"] = self.usage!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Available"] as? Bool {
                    self.available = value
                }
                if let value = dict["Category"] as? String {
                    self.category = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Encrypted"] as? Bool {
                    self.encrypted = value
                }
                if let value = dict["InstantAccess"] as? Bool {
                    self.instantAccess = value
                }
                if let value = dict["InstantAccessRetentionDays"] as? Int32 {
                    self.instantAccessRetentionDays = value
                }
                if let value = dict["KMSKeyId"] as? String {
                    self.KMSKeyId = value
                }
                if let value = dict["LastModifiedTime"] as? String {
                    self.lastModifiedTime = value
                }
                if let value = dict["ProductCode"] as? String {
                    self.productCode = value
                }
                if let value = dict["Progress"] as? String {
                    self.progress = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["RemainTime"] as? Int32 {
                    self.remainTime = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["RetentionDays"] as? Int32 {
                    self.retentionDays = value
                }
                if let value = dict["SnapshotId"] as? String {
                    self.snapshotId = value
                }
                if let value = dict["SnapshotLinkId"] as? String {
                    self.snapshotLinkId = value
                }
                if let value = dict["SnapshotName"] as? String {
                    self.snapshotName = value
                }
                if let value = dict["SnapshotSN"] as? String {
                    self.snapshotSN = value
                }
                if let value = dict["SnapshotType"] as? String {
                    self.snapshotType = value
                }
                if let value = dict["SourceDiskId"] as? String {
                    self.sourceDiskId = value
                }
                if let value = dict["SourceDiskSize"] as? String {
                    self.sourceDiskSize = value
                }
                if let value = dict["SourceDiskType"] as? String {
                    self.sourceDiskType = value
                }
                if let value = dict["SourceRegionId"] as? String {
                    self.sourceRegionId = value
                }
                if let value = dict["SourceSnapshotId"] as? String {
                    self.sourceSnapshotId = value
                }
                if let value = dict["SourceStorageType"] as? String {
                    self.sourceStorageType = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeSnapshotsResponseBody.Snapshots.Snapshot.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["Usage"] as? String {
                    self.usage = value
                }
            }
        }
        public var snapshot: [DescribeSnapshotsResponseBody.Snapshots.Snapshot]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.snapshot != nil {
                var tmp : [Any] = []
                for k in self.snapshot! {
                    tmp.append(k.toMap())
                }
                map["Snapshot"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Snapshot"] as? [Any?] {
                var tmp : [DescribeSnapshotsResponseBody.Snapshots.Snapshot] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSnapshotsResponseBody.Snapshots.Snapshot()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.snapshot = tmp
            }
        }
    }
    public var nextToken: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var snapshots: DescribeSnapshotsResponseBody.Snapshots?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snapshots?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshots != nil {
            map["Snapshots"] = self.snapshots?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Snapshots"] as? [String: Any?] {
            var model = DescribeSnapshotsResponseBody.Snapshots()
            model.fromMap(value)
            self.snapshots = model
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeSnapshotsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSnapshotsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSnapshotsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSnapshotsUsageRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeSnapshotsUsageResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var snapshotCount: Int32?

    public var snapshotSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotCount != nil {
            map["SnapshotCount"] = self.snapshotCount!
        }
        if self.snapshotSize != nil {
            map["SnapshotSize"] = self.snapshotSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SnapshotCount"] as? Int32 {
            self.snapshotCount = value
        }
        if let value = dict["SnapshotSize"] as? Int64 {
            self.snapshotSize = value
        }
    }
}

public class DescribeSnapshotsUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSnapshotsUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSnapshotsUsageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSpotAdviceRequest : Tea.TeaModel {
    public var cores: Int32?

    public var gpuAmount: Int32?

    public var gpuSpec: String?

    public var instanceFamilyLevel: String?

    public var instanceTypeFamily: String?

    public var instanceTypes: [String]?

    public var memory: Double?

    public var minCores: Int32?

    public var minMemory: Double?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cores != nil {
            map["Cores"] = self.cores!
        }
        if self.gpuAmount != nil {
            map["GpuAmount"] = self.gpuAmount!
        }
        if self.gpuSpec != nil {
            map["GpuSpec"] = self.gpuSpec!
        }
        if self.instanceFamilyLevel != nil {
            map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
        }
        if self.instanceTypeFamily != nil {
            map["InstanceTypeFamily"] = self.instanceTypeFamily!
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.minCores != nil {
            map["MinCores"] = self.minCores!
        }
        if self.minMemory != nil {
            map["MinMemory"] = self.minMemory!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Cores"] as? Int32 {
            self.cores = value
        }
        if let value = dict["GpuAmount"] as? Int32 {
            self.gpuAmount = value
        }
        if let value = dict["GpuSpec"] as? String {
            self.gpuSpec = value
        }
        if let value = dict["InstanceFamilyLevel"] as? String {
            self.instanceFamilyLevel = value
        }
        if let value = dict["InstanceTypeFamily"] as? String {
            self.instanceTypeFamily = value
        }
        if let value = dict["InstanceTypes"] as? [String] {
            self.instanceTypes = value
        }
        if let value = dict["Memory"] as? Double {
            self.memory = value
        }
        if let value = dict["MinCores"] as? Int32 {
            self.minCores = value
        }
        if let value = dict["MinMemory"] as? Double {
            self.minMemory = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribeSpotAdviceResponseBody : Tea.TeaModel {
    public class AvailableSpotZones : Tea.TeaModel {
        public class AvailableSpotZone : Tea.TeaModel {
            public class AvailableSpotResources : Tea.TeaModel {
                public class AvailableSpotResource : Tea.TeaModel {
                    public var averageSpotDiscount: Int32?

                    public var instanceType: String?

                    public var interruptRateDesc: String?

                    public var interruptionRate: Double?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.averageSpotDiscount != nil {
                            map["AverageSpotDiscount"] = self.averageSpotDiscount!
                        }
                        if self.instanceType != nil {
                            map["InstanceType"] = self.instanceType!
                        }
                        if self.interruptRateDesc != nil {
                            map["InterruptRateDesc"] = self.interruptRateDesc!
                        }
                        if self.interruptionRate != nil {
                            map["InterruptionRate"] = self.interruptionRate!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AverageSpotDiscount"] as? Int32 {
                            self.averageSpotDiscount = value
                        }
                        if let value = dict["InstanceType"] as? String {
                            self.instanceType = value
                        }
                        if let value = dict["InterruptRateDesc"] as? String {
                            self.interruptRateDesc = value
                        }
                        if let value = dict["InterruptionRate"] as? Double {
                            self.interruptionRate = value
                        }
                    }
                }
                public var availableSpotResource: [DescribeSpotAdviceResponseBody.AvailableSpotZones.AvailableSpotZone.AvailableSpotResources.AvailableSpotResource]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.availableSpotResource != nil {
                        var tmp : [Any] = []
                        for k in self.availableSpotResource! {
                            tmp.append(k.toMap())
                        }
                        map["AvailableSpotResource"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AvailableSpotResource"] as? [Any?] {
                        var tmp : [DescribeSpotAdviceResponseBody.AvailableSpotZones.AvailableSpotZone.AvailableSpotResources.AvailableSpotResource] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeSpotAdviceResponseBody.AvailableSpotZones.AvailableSpotZone.AvailableSpotResources.AvailableSpotResource()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.availableSpotResource = tmp
                    }
                }
            }
            public var availableSpotResources: DescribeSpotAdviceResponseBody.AvailableSpotZones.AvailableSpotZone.AvailableSpotResources?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.availableSpotResources?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.availableSpotResources != nil {
                    map["AvailableSpotResources"] = self.availableSpotResources?.toMap()
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AvailableSpotResources"] as? [String: Any?] {
                    var model = DescribeSpotAdviceResponseBody.AvailableSpotZones.AvailableSpotZone.AvailableSpotResources()
                    model.fromMap(value)
                    self.availableSpotResources = model
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var availableSpotZone: [DescribeSpotAdviceResponseBody.AvailableSpotZones.AvailableSpotZone]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.availableSpotZone != nil {
                var tmp : [Any] = []
                for k in self.availableSpotZone! {
                    tmp.append(k.toMap())
                }
                map["AvailableSpotZone"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AvailableSpotZone"] as? [Any?] {
                var tmp : [DescribeSpotAdviceResponseBody.AvailableSpotZones.AvailableSpotZone] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSpotAdviceResponseBody.AvailableSpotZones.AvailableSpotZone()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.availableSpotZone = tmp
            }
        }
    }
    public var availableSpotZones: DescribeSpotAdviceResponseBody.AvailableSpotZones?

    public var regionId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.availableSpotZones?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableSpotZones != nil {
            map["AvailableSpotZones"] = self.availableSpotZones?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AvailableSpotZones"] as? [String: Any?] {
            var model = DescribeSpotAdviceResponseBody.AvailableSpotZones()
            model.fromMap(value)
            self.availableSpotZones = model
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeSpotAdviceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSpotAdviceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSpotAdviceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSpotPriceHistoryRequest : Tea.TeaModel {
    public var endTime: String?

    public var instanceType: String?

    public var ioOptimized: String?

    public var networkType: String?

    public var OSType: String?

    public var offset: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var spotDuration: Int32?

    public var startTime: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.OSType != nil {
            map["OSType"] = self.OSType!
        }
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["IoOptimized"] as? String {
            self.ioOptimized = value
        }
        if let value = dict["NetworkType"] as? String {
            self.networkType = value
        }
        if let value = dict["OSType"] as? String {
            self.OSType = value
        }
        if let value = dict["Offset"] as? Int32 {
            self.offset = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SpotDuration"] as? Int32 {
            self.spotDuration = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribeSpotPriceHistoryResponseBody : Tea.TeaModel {
    public class SpotPrices : Tea.TeaModel {
        public class SpotPriceType : Tea.TeaModel {
            public var instanceType: String?

            public var ioOptimized: String?

            public var networkType: String?

            public var originPrice: Double?

            public var spotPrice: Double?

            public var timestamp: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.ioOptimized != nil {
                    map["IoOptimized"] = self.ioOptimized!
                }
                if self.networkType != nil {
                    map["NetworkType"] = self.networkType!
                }
                if self.originPrice != nil {
                    map["OriginPrice"] = self.originPrice!
                }
                if self.spotPrice != nil {
                    map["SpotPrice"] = self.spotPrice!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["InstanceType"] as? String {
                    self.instanceType = value
                }
                if let value = dict["IoOptimized"] as? String {
                    self.ioOptimized = value
                }
                if let value = dict["NetworkType"] as? String {
                    self.networkType = value
                }
                if let value = dict["OriginPrice"] as? Double {
                    self.originPrice = value
                }
                if let value = dict["SpotPrice"] as? Double {
                    self.spotPrice = value
                }
                if let value = dict["Timestamp"] as? String {
                    self.timestamp = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var spotPriceType: [DescribeSpotPriceHistoryResponseBody.SpotPrices.SpotPriceType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.spotPriceType != nil {
                var tmp : [Any] = []
                for k in self.spotPriceType! {
                    tmp.append(k.toMap())
                }
                map["SpotPriceType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SpotPriceType"] as? [Any?] {
                var tmp : [DescribeSpotPriceHistoryResponseBody.SpotPrices.SpotPriceType] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSpotPriceHistoryResponseBody.SpotPrices.SpotPriceType()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.spotPriceType = tmp
            }
        }
    }
    public var currency: String?

    public var nextOffset: Int32?

    public var requestId: String?

    public var spotPrices: DescribeSpotPriceHistoryResponseBody.SpotPrices?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.spotPrices?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currency != nil {
            map["Currency"] = self.currency!
        }
        if self.nextOffset != nil {
            map["NextOffset"] = self.nextOffset!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.spotPrices != nil {
            map["SpotPrices"] = self.spotPrices?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Currency"] as? String {
            self.currency = value
        }
        if let value = dict["NextOffset"] as? Int32 {
            self.nextOffset = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SpotPrices"] as? [String: Any?] {
            var model = DescribeSpotPriceHistoryResponseBody.SpotPrices()
            model.fromMap(value)
            self.spotPrices = model
        }
    }
}

public class DescribeSpotPriceHistoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSpotPriceHistoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSpotPriceHistoryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeStorageCapacityUnitsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var allocationType: String?

    public var capacity: Int32?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: [String]?

    public var storageCapacityUnitId: [String]?

    public var tag: [DescribeStorageCapacityUnitsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationType != nil {
            map["AllocationType"] = self.allocationType!
        }
        if self.capacity != nil {
            map["Capacity"] = self.capacity!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.storageCapacityUnitId != nil {
            map["StorageCapacityUnitId"] = self.storageCapacityUnitId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AllocationType"] as? String {
            self.allocationType = value
        }
        if let value = dict["Capacity"] as? Int32 {
            self.capacity = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Status"] as? [String] {
            self.status = value
        }
        if let value = dict["StorageCapacityUnitId"] as? [String] {
            self.storageCapacityUnitId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeStorageCapacityUnitsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeStorageCapacityUnitsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribeStorageCapacityUnitsResponseBody : Tea.TeaModel {
    public class StorageCapacityUnits : Tea.TeaModel {
        public class StorageCapacityUnit : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["TagKey"] as? String {
                            self.tagKey = value
                        }
                        if let value = dict["TagValue"] as? String {
                            self.tagValue = value
                        }
                    }
                }
                public var tag: [DescribeStorageCapacityUnitsResponseBody.StorageCapacityUnits.StorageCapacityUnit.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeStorageCapacityUnitsResponseBody.StorageCapacityUnits.StorageCapacityUnit.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeStorageCapacityUnitsResponseBody.StorageCapacityUnits.StorageCapacityUnit.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var allocationStatus: String?

            public var capacity: Int32?

            public var creationTime: String?

            public var description_: String?

            public var expiredTime: String?

            public var name: String?

            public var regionId: String?

            public var startTime: String?

            public var status: String?

            public var storageCapacityUnitId: String?

            public var tags: DescribeStorageCapacityUnitsResponseBody.StorageCapacityUnits.StorageCapacityUnit.Tags?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allocationStatus != nil {
                    map["AllocationStatus"] = self.allocationStatus!
                }
                if self.capacity != nil {
                    map["Capacity"] = self.capacity!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.storageCapacityUnitId != nil {
                    map["StorageCapacityUnitId"] = self.storageCapacityUnitId!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AllocationStatus"] as? String {
                    self.allocationStatus = value
                }
                if let value = dict["Capacity"] as? Int32 {
                    self.capacity = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["ExpiredTime"] as? String {
                    self.expiredTime = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["StartTime"] as? String {
                    self.startTime = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["StorageCapacityUnitId"] as? String {
                    self.storageCapacityUnitId = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeStorageCapacityUnitsResponseBody.StorageCapacityUnits.StorageCapacityUnit.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
            }
        }
        public var storageCapacityUnit: [DescribeStorageCapacityUnitsResponseBody.StorageCapacityUnits.StorageCapacityUnit]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.storageCapacityUnit != nil {
                var tmp : [Any] = []
                for k in self.storageCapacityUnit! {
                    tmp.append(k.toMap())
                }
                map["StorageCapacityUnit"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["StorageCapacityUnit"] as? [Any?] {
                var tmp : [DescribeStorageCapacityUnitsResponseBody.StorageCapacityUnits.StorageCapacityUnit] = []
                for v in value {
                    if v != nil {
                        var model = DescribeStorageCapacityUnitsResponseBody.StorageCapacityUnits.StorageCapacityUnit()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.storageCapacityUnit = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var storageCapacityUnits: DescribeStorageCapacityUnitsResponseBody.StorageCapacityUnits?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.storageCapacityUnits?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.storageCapacityUnits != nil {
            map["StorageCapacityUnits"] = self.storageCapacityUnits?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StorageCapacityUnits"] as? [String: Any?] {
            var model = DescribeStorageCapacityUnitsResponseBody.StorageCapacityUnits()
            model.fromMap(value)
            self.storageCapacityUnits = model
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeStorageCapacityUnitsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeStorageCapacityUnitsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeStorageCapacityUnitsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeStorageSetDetailsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var diskIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var storageSetId: String?

    public var storageSetPartitionNumber: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.diskIds != nil {
            map["DiskIds"] = self.diskIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        if self.storageSetPartitionNumber != nil {
            map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DiskIds"] as? String {
            self.diskIds = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StorageSetId"] as? String {
            self.storageSetId = value
        }
        if let value = dict["StorageSetPartitionNumber"] as? Int32 {
            self.storageSetPartitionNumber = value
        }
    }
}

public class DescribeStorageSetDetailsResponseBody : Tea.TeaModel {
    public class Disks : Tea.TeaModel {
        public class Disk : Tea.TeaModel {
            public var category: String?

            public var creationTime: String?

            public var diskId: String?

            public var diskName: String?

            public var regionId: String?

            public var storageSetId: String?

            public var storageSetPartitionNumber: Int32?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.diskId != nil {
                    map["DiskId"] = self.diskId!
                }
                if self.diskName != nil {
                    map["DiskName"] = self.diskName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.storageSetId != nil {
                    map["StorageSetId"] = self.storageSetId!
                }
                if self.storageSetPartitionNumber != nil {
                    map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Category"] as? String {
                    self.category = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["DiskId"] as? String {
                    self.diskId = value
                }
                if let value = dict["DiskName"] as? String {
                    self.diskName = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["StorageSetId"] as? String {
                    self.storageSetId = value
                }
                if let value = dict["StorageSetPartitionNumber"] as? Int32 {
                    self.storageSetPartitionNumber = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var disk: [DescribeStorageSetDetailsResponseBody.Disks.Disk]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.disk != nil {
                var tmp : [Any] = []
                for k in self.disk! {
                    tmp.append(k.toMap())
                }
                map["Disk"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Disk"] as? [Any?] {
                var tmp : [DescribeStorageSetDetailsResponseBody.Disks.Disk] = []
                for v in value {
                    if v != nil {
                        var model = DescribeStorageSetDetailsResponseBody.Disks.Disk()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.disk = tmp
            }
        }
    }
    public var disks: DescribeStorageSetDetailsResponseBody.Disks?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.disks?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.disks != nil {
            map["Disks"] = self.disks?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Disks"] as? [String: Any?] {
            var model = DescribeStorageSetDetailsResponseBody.Disks()
            model.fromMap(value)
            self.disks = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeStorageSetDetailsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeStorageSetDetailsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeStorageSetDetailsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeStorageSetsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var storageSetIds: String?

    public var storageSetName: String?

    public var tag: [DescribeStorageSetsRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.storageSetIds != nil {
            map["StorageSetIds"] = self.storageSetIds!
        }
        if self.storageSetName != nil {
            map["StorageSetName"] = self.storageSetName!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StorageSetIds"] as? String {
            self.storageSetIds = value
        }
        if let value = dict["StorageSetName"] as? String {
            self.storageSetName = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeStorageSetsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeStorageSetsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribeStorageSetsResponseBody : Tea.TeaModel {
    public class StorageSets : Tea.TeaModel {
        public class StorageSet : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Key"] as? String {
                            self.key = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var tag: [DescribeStorageSetsResponseBody.StorageSets.StorageSet.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeStorageSetsResponseBody.StorageSets.StorageSet.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeStorageSetsResponseBody.StorageSets.StorageSet.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var creationTime: String?

            public var description_: String?

            public var regionId: String?

            public var resourceGroupId: String?

            public var storageSetId: String?

            public var storageSetName: String?

            public var storageSetPartitionNumber: Int32?

            public var tags: DescribeStorageSetsResponseBody.StorageSets.StorageSet.Tags?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.storageSetId != nil {
                    map["StorageSetId"] = self.storageSetId!
                }
                if self.storageSetName != nil {
                    map["StorageSetName"] = self.storageSetName!
                }
                if self.storageSetPartitionNumber != nil {
                    map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["StorageSetId"] as? String {
                    self.storageSetId = value
                }
                if let value = dict["StorageSetName"] as? String {
                    self.storageSetName = value
                }
                if let value = dict["StorageSetPartitionNumber"] as? Int32 {
                    self.storageSetPartitionNumber = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeStorageSetsResponseBody.StorageSets.StorageSet.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var storageSet: [DescribeStorageSetsResponseBody.StorageSets.StorageSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.storageSet != nil {
                var tmp : [Any] = []
                for k in self.storageSet! {
                    tmp.append(k.toMap())
                }
                map["StorageSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["StorageSet"] as? [Any?] {
                var tmp : [DescribeStorageSetsResponseBody.StorageSets.StorageSet] = []
                for v in value {
                    if v != nil {
                        var model = DescribeStorageSetsResponseBody.StorageSets.StorageSet()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.storageSet = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var storageSets: DescribeStorageSetsResponseBody.StorageSets?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.storageSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.storageSets != nil {
            map["StorageSets"] = self.storageSets?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StorageSets"] as? [String: Any?] {
            var model = DescribeStorageSetsResponseBody.StorageSets()
            model.fromMap(value)
            self.storageSets = model
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeStorageSetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeStorageSetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeStorageSetsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeTagsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var category: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tag: [DescribeTagsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Category"] as? String {
            self.category = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeTagsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeTagsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribeTagsResponseBody : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public class Tag : Tea.TeaModel {
            public class ResourceTypeCount : Tea.TeaModel {
                public var ddh: Int32?

                public var disk: Int32?

                public var eni: Int32?

                public var image: Int32?

                public var instance: Int32?

                public var keyPair: Int32?

                public var launchTemplate: Int32?

                public var reservedInstance: Int32?

                public var securitygroup: Int32?

                public var snapshot: Int32?

                public var snapshotPolicy: Int32?

                public var volume: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ddh != nil {
                        map["Ddh"] = self.ddh!
                    }
                    if self.disk != nil {
                        map["Disk"] = self.disk!
                    }
                    if self.eni != nil {
                        map["Eni"] = self.eni!
                    }
                    if self.image != nil {
                        map["Image"] = self.image!
                    }
                    if self.instance != nil {
                        map["Instance"] = self.instance!
                    }
                    if self.keyPair != nil {
                        map["KeyPair"] = self.keyPair!
                    }
                    if self.launchTemplate != nil {
                        map["LaunchTemplate"] = self.launchTemplate!
                    }
                    if self.reservedInstance != nil {
                        map["ReservedInstance"] = self.reservedInstance!
                    }
                    if self.securitygroup != nil {
                        map["Securitygroup"] = self.securitygroup!
                    }
                    if self.snapshot != nil {
                        map["Snapshot"] = self.snapshot!
                    }
                    if self.snapshotPolicy != nil {
                        map["SnapshotPolicy"] = self.snapshotPolicy!
                    }
                    if self.volume != nil {
                        map["Volume"] = self.volume!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Ddh"] as? Int32 {
                        self.ddh = value
                    }
                    if let value = dict["Disk"] as? Int32 {
                        self.disk = value
                    }
                    if let value = dict["Eni"] as? Int32 {
                        self.eni = value
                    }
                    if let value = dict["Image"] as? Int32 {
                        self.image = value
                    }
                    if let value = dict["Instance"] as? Int32 {
                        self.instance = value
                    }
                    if let value = dict["KeyPair"] as? Int32 {
                        self.keyPair = value
                    }
                    if let value = dict["LaunchTemplate"] as? Int32 {
                        self.launchTemplate = value
                    }
                    if let value = dict["ReservedInstance"] as? Int32 {
                        self.reservedInstance = value
                    }
                    if let value = dict["Securitygroup"] as? Int32 {
                        self.securitygroup = value
                    }
                    if let value = dict["Snapshot"] as? Int32 {
                        self.snapshot = value
                    }
                    if let value = dict["SnapshotPolicy"] as? Int32 {
                        self.snapshotPolicy = value
                    }
                    if let value = dict["Volume"] as? Int32 {
                        self.volume = value
                    }
                }
            }
            public var resourceTypeCount: DescribeTagsResponseBody.Tags.Tag.ResourceTypeCount?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.resourceTypeCount?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceTypeCount != nil {
                    map["ResourceTypeCount"] = self.resourceTypeCount?.toMap()
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ResourceTypeCount"] as? [String: Any?] {
                    var model = DescribeTagsResponseBody.Tags.Tag.ResourceTypeCount()
                    model.fromMap(value)
                    self.resourceTypeCount = model
                }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public var tag: [DescribeTagsResponseBody.Tags.Tag]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tag != nil {
                var tmp : [Any] = []
                for k in self.tag! {
                    tmp.append(k.toMap())
                }
                map["Tag"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Tag"] as? [Any?] {
                var tmp : [DescribeTagsResponseBody.Tags.Tag] = []
                for v in value {
                    if v != nil {
                        var model = DescribeTagsResponseBody.Tags.Tag()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tag = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var tags: DescribeTagsResponseBody.Tags?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tags?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tags != nil {
            map["Tags"] = self.tags?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Tags"] as? [String: Any?] {
            var model = DescribeTagsResponseBody.Tags()
            model.fromMap(value)
            self.tags = model
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeTagsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeTaskAttributeRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class DescribeTaskAttributeResponseBody : Tea.TeaModel {
    public class OperationProgressSet : Tea.TeaModel {
        public class OperationProgress : Tea.TeaModel {
            public class RelatedItemSet : Tea.TeaModel {
                public class RelatedItem : Tea.TeaModel {
                    public var name: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Name"] as? String {
                            self.name = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var relatedItem: [DescribeTaskAttributeResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet.RelatedItem]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.relatedItem != nil {
                        var tmp : [Any] = []
                        for k in self.relatedItem! {
                            tmp.append(k.toMap())
                        }
                        map["RelatedItem"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RelatedItem"] as? [Any?] {
                        var tmp : [DescribeTaskAttributeResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet.RelatedItem] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeTaskAttributeResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet.RelatedItem()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.relatedItem = tmp
                    }
                }
            }
            public var errorCode: String?

            public var errorMsg: String?

            public var operationStatus: String?

            public var relatedItemSet: DescribeTaskAttributeResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.relatedItemSet?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.operationStatus != nil {
                    map["OperationStatus"] = self.operationStatus!
                }
                if self.relatedItemSet != nil {
                    map["RelatedItemSet"] = self.relatedItemSet?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ErrorCode"] as? String {
                    self.errorCode = value
                }
                if let value = dict["ErrorMsg"] as? String {
                    self.errorMsg = value
                }
                if let value = dict["OperationStatus"] as? String {
                    self.operationStatus = value
                }
                if let value = dict["RelatedItemSet"] as? [String: Any?] {
                    var model = DescribeTaskAttributeResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet()
                    model.fromMap(value)
                    self.relatedItemSet = model
                }
            }
        }
        public var operationProgress: [DescribeTaskAttributeResponseBody.OperationProgressSet.OperationProgress]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.operationProgress != nil {
                var tmp : [Any] = []
                for k in self.operationProgress! {
                    tmp.append(k.toMap())
                }
                map["OperationProgress"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OperationProgress"] as? [Any?] {
                var tmp : [DescribeTaskAttributeResponseBody.OperationProgressSet.OperationProgress] = []
                for v in value {
                    if v != nil {
                        var model = DescribeTaskAttributeResponseBody.OperationProgressSet.OperationProgress()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.operationProgress = tmp
            }
        }
    }
    public var creationTime: String?

    public var failedCount: Int32?

    public var finishedTime: String?

    public var operationProgressSet: DescribeTaskAttributeResponseBody.OperationProgressSet?

    public var regionId: String?

    public var requestId: String?

    public var successCount: Int32?

    public var supportCancel: String?

    public var taskAction: String?

    public var taskId: String?

    public var taskProcess: String?

    public var taskStatus: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.operationProgressSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.failedCount != nil {
            map["FailedCount"] = self.failedCount!
        }
        if self.finishedTime != nil {
            map["FinishedTime"] = self.finishedTime!
        }
        if self.operationProgressSet != nil {
            map["OperationProgressSet"] = self.operationProgressSet?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successCount != nil {
            map["SuccessCount"] = self.successCount!
        }
        if self.supportCancel != nil {
            map["SupportCancel"] = self.supportCancel!
        }
        if self.taskAction != nil {
            map["TaskAction"] = self.taskAction!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskProcess != nil {
            map["TaskProcess"] = self.taskProcess!
        }
        if self.taskStatus != nil {
            map["TaskStatus"] = self.taskStatus!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreationTime"] as? String {
            self.creationTime = value
        }
        if let value = dict["FailedCount"] as? Int32 {
            self.failedCount = value
        }
        if let value = dict["FinishedTime"] as? String {
            self.finishedTime = value
        }
        if let value = dict["OperationProgressSet"] as? [String: Any?] {
            var model = DescribeTaskAttributeResponseBody.OperationProgressSet()
            model.fromMap(value)
            self.operationProgressSet = model
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SuccessCount"] as? Int32 {
            self.successCount = value
        }
        if let value = dict["SupportCancel"] as? String {
            self.supportCancel = value
        }
        if let value = dict["TaskAction"] as? String {
            self.taskAction = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
        if let value = dict["TaskProcess"] as? String {
            self.taskProcess = value
        }
        if let value = dict["TaskStatus"] as? String {
            self.taskStatus = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeTaskAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTaskAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeTaskAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeTasksRequest : Tea.TeaModel {
    public var endTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceIds: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public var taskAction: String?

    public var taskIds: String?

    public var taskStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.taskAction != nil {
            map["TaskAction"] = self.taskAction!
        }
        if self.taskIds != nil {
            map["TaskIds"] = self.taskIds!
        }
        if self.taskStatus != nil {
            map["TaskStatus"] = self.taskStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceIds"] as? [String] {
            self.resourceIds = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["TaskAction"] as? String {
            self.taskAction = value
        }
        if let value = dict["TaskIds"] as? String {
            self.taskIds = value
        }
        if let value = dict["TaskStatus"] as? String {
            self.taskStatus = value
        }
    }
}

public class DescribeTasksResponseBody : Tea.TeaModel {
    public class TaskSet : Tea.TeaModel {
        public class Task : Tea.TeaModel {
            public var creationTime: String?

            public var finishedTime: String?

            public var resourceId: String?

            public var supportCancel: String?

            public var taskAction: String?

            public var taskId: String?

            public var taskStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.finishedTime != nil {
                    map["FinishedTime"] = self.finishedTime!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.supportCancel != nil {
                    map["SupportCancel"] = self.supportCancel!
                }
                if self.taskAction != nil {
                    map["TaskAction"] = self.taskAction!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.taskStatus != nil {
                    map["TaskStatus"] = self.taskStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["FinishedTime"] as? String {
                    self.finishedTime = value
                }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
                if let value = dict["SupportCancel"] as? String {
                    self.supportCancel = value
                }
                if let value = dict["TaskAction"] as? String {
                    self.taskAction = value
                }
                if let value = dict["TaskId"] as? String {
                    self.taskId = value
                }
                if let value = dict["TaskStatus"] as? String {
                    self.taskStatus = value
                }
            }
        }
        public var task: [DescribeTasksResponseBody.TaskSet.Task]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.task != nil {
                var tmp : [Any] = []
                for k in self.task! {
                    tmp.append(k.toMap())
                }
                map["Task"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Task"] as? [Any?] {
                var tmp : [DescribeTasksResponseBody.TaskSet.Task] = []
                for v in value {
                    if v != nil {
                        var model = DescribeTasksResponseBody.TaskSet.Task()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.task = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestId: String?

    public var taskSet: DescribeTasksResponseBody.TaskSet?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.taskSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskSet != nil {
            map["TaskSet"] = self.taskSet?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskSet"] as? [String: Any?] {
            var model = DescribeTasksResponseBody.TaskSet()
            model.fromMap(value)
            self.taskSet = model
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeTasksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeTerminalSessionsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sessionId != nil {
            map["SessionId"] = self.sessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SessionId"] as? String {
            self.sessionId = value
        }
    }
}

public class DescribeTerminalSessionsResponseBody : Tea.TeaModel {
    public class Sessions : Tea.TeaModel {
        public class Session : Tea.TeaModel {
            public class Connections : Tea.TeaModel {
                public class Connection : Tea.TeaModel {
                    public var closedReason: String?

                    public var endTime: String?

                    public var instanceId: String?

                    public var startTime: String?

                    public var status: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.closedReason != nil {
                            map["ClosedReason"] = self.closedReason!
                        }
                        if self.endTime != nil {
                            map["EndTime"] = self.endTime!
                        }
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ClosedReason"] as? String {
                            self.closedReason = value
                        }
                        if let value = dict["EndTime"] as? String {
                            self.endTime = value
                        }
                        if let value = dict["InstanceId"] as? String {
                            self.instanceId = value
                        }
                        if let value = dict["StartTime"] as? String {
                            self.startTime = value
                        }
                        if let value = dict["Status"] as? String {
                            self.status = value
                        }
                    }
                }
                public var connection: [DescribeTerminalSessionsResponseBody.Sessions.Session.Connections.Connection]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.connection != nil {
                        var tmp : [Any] = []
                        for k in self.connection! {
                            tmp.append(k.toMap())
                        }
                        map["Connection"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Connection"] as? [Any?] {
                        var tmp : [DescribeTerminalSessionsResponseBody.Sessions.Session.Connections.Connection] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeTerminalSessionsResponseBody.Sessions.Session.Connections.Connection()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.connection = tmp
                    }
                }
            }
            public var clientIP: String?

            public var connections: DescribeTerminalSessionsResponseBody.Sessions.Session.Connections?

            public var creationTime: String?

            public var identityType: String?

            public var portNumber: Int32?

            public var principalId: String?

            public var sessionId: String?

            public var targetServer: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.connections?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clientIP != nil {
                    map["ClientIP"] = self.clientIP!
                }
                if self.connections != nil {
                    map["Connections"] = self.connections?.toMap()
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.identityType != nil {
                    map["IdentityType"] = self.identityType!
                }
                if self.portNumber != nil {
                    map["PortNumber"] = self.portNumber!
                }
                if self.principalId != nil {
                    map["PrincipalId"] = self.principalId!
                }
                if self.sessionId != nil {
                    map["SessionId"] = self.sessionId!
                }
                if self.targetServer != nil {
                    map["TargetServer"] = self.targetServer!
                }
                if self.username != nil {
                    map["Username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ClientIP"] as? String {
                    self.clientIP = value
                }
                if let value = dict["Connections"] as? [String: Any?] {
                    var model = DescribeTerminalSessionsResponseBody.Sessions.Session.Connections()
                    model.fromMap(value)
                    self.connections = model
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["IdentityType"] as? String {
                    self.identityType = value
                }
                if let value = dict["PortNumber"] as? Int32 {
                    self.portNumber = value
                }
                if let value = dict["PrincipalId"] as? String {
                    self.principalId = value
                }
                if let value = dict["SessionId"] as? String {
                    self.sessionId = value
                }
                if let value = dict["TargetServer"] as? String {
                    self.targetServer = value
                }
                if let value = dict["Username"] as? String {
                    self.username = value
                }
            }
        }
        public var session: [DescribeTerminalSessionsResponseBody.Sessions.Session]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.session != nil {
                var tmp : [Any] = []
                for k in self.session! {
                    tmp.append(k.toMap())
                }
                map["Session"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Session"] as? [Any?] {
                var tmp : [DescribeTerminalSessionsResponseBody.Sessions.Session] = []
                for v in value {
                    if v != nil {
                        var model = DescribeTerminalSessionsResponseBody.Sessions.Session()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.session = tmp
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var sessions: DescribeTerminalSessionsResponseBody.Sessions?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sessions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sessions != nil {
            map["Sessions"] = self.sessions?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Sessions"] as? [String: Any?] {
            var model = DescribeTerminalSessionsResponseBody.Sessions()
            model.fromMap(value)
            self.sessions = model
        }
    }
}

public class DescribeTerminalSessionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTerminalSessionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeTerminalSessionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeUserBusinessBehaviorRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var statusKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.statusKey != nil {
            map["statusKey"] = self.statusKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["statusKey"] as? String {
            self.statusKey = value
        }
    }
}

public class DescribeUserBusinessBehaviorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var statusValue: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statusValue != nil {
            map["StatusValue"] = self.statusValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StatusValue"] as? String {
            self.statusValue = value
        }
    }
}

public class DescribeUserBusinessBehaviorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUserBusinessBehaviorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeUserBusinessBehaviorResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeUserDataRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeUserDataResponseBody : Tea.TeaModel {
    public var instanceId: String?

    public var regionId: String?

    public var requestId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["UserData"] as? String {
            self.userData = value
        }
    }
}

public class DescribeUserDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUserDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeUserDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeVRoutersRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var VRouterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.VRouterId != nil {
            map["VRouterId"] = self.VRouterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VRouterId"] as? String {
            self.VRouterId = value
        }
    }
}

public class DescribeVRoutersResponseBody : Tea.TeaModel {
    public class VRouters : Tea.TeaModel {
        public class VRouter : Tea.TeaModel {
            public class RouteTableIds : Tea.TeaModel {
                public var routeTableId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.routeTableId != nil {
                        map["RouteTableId"] = self.routeTableId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RouteTableId"] as? [String] {
                        self.routeTableId = value
                    }
                }
            }
            public var creationTime: String?

            public var description_: String?

            public var regionId: String?

            public var routeTableIds: DescribeVRoutersResponseBody.VRouters.VRouter.RouteTableIds?

            public var VRouterId: String?

            public var VRouterName: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.routeTableIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.routeTableIds != nil {
                    map["RouteTableIds"] = self.routeTableIds?.toMap()
                }
                if self.VRouterId != nil {
                    map["VRouterId"] = self.VRouterId!
                }
                if self.VRouterName != nil {
                    map["VRouterName"] = self.VRouterName!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["RouteTableIds"] as? [String: Any?] {
                    var model = DescribeVRoutersResponseBody.VRouters.VRouter.RouteTableIds()
                    model.fromMap(value)
                    self.routeTableIds = model
                }
                if let value = dict["VRouterId"] as? String {
                    self.VRouterId = value
                }
                if let value = dict["VRouterName"] as? String {
                    self.VRouterName = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
            }
        }
        public var VRouter: [DescribeVRoutersResponseBody.VRouters.VRouter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.VRouter != nil {
                var tmp : [Any] = []
                for k in self.VRouter! {
                    tmp.append(k.toMap())
                }
                map["VRouter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["VRouter"] as? [Any?] {
                var tmp : [DescribeVRoutersResponseBody.VRouters.VRouter] = []
                for v in value {
                    if v != nil {
                        var model = DescribeVRoutersResponseBody.VRouters.VRouter()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.VRouter = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var VRouters: DescribeVRoutersResponseBody.VRouters?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.VRouters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.VRouters != nil {
            map["VRouters"] = self.VRouters?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
        if let value = dict["VRouters"] as? [String: Any?] {
            var model = DescribeVRoutersResponseBody.VRouters()
            model.fromMap(value)
            self.VRouters = model
        }
    }
}

public class DescribeVRoutersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVRoutersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeVRoutersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeVSwitchesRequest : Tea.TeaModel {
    public var isDefault: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchId: String?

    public var vpcId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isDefault != nil {
            map["IsDefault"] = self.isDefault!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IsDefault"] as? Bool {
            self.isDefault = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribeVSwitchesResponseBody : Tea.TeaModel {
    public class VSwitches : Tea.TeaModel {
        public class VSwitch : Tea.TeaModel {
            public var availableIpAddressCount: Int64?

            public var cidrBlock: String?

            public var creationTime: String?

            public var description_: String?

            public var isDefault: Bool?

            public var resourceGroupId: String?

            public var status: String?

            public var vSwitchId: String?

            public var vSwitchName: String?

            public var vpcId: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.availableIpAddressCount != nil {
                    map["AvailableIpAddressCount"] = self.availableIpAddressCount!
                }
                if self.cidrBlock != nil {
                    map["CidrBlock"] = self.cidrBlock!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.isDefault != nil {
                    map["IsDefault"] = self.isDefault!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vSwitchName != nil {
                    map["VSwitchName"] = self.vSwitchName!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AvailableIpAddressCount"] as? Int64 {
                    self.availableIpAddressCount = value
                }
                if let value = dict["CidrBlock"] as? String {
                    self.cidrBlock = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["IsDefault"] as? Bool {
                    self.isDefault = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["VSwitchId"] as? String {
                    self.vSwitchId = value
                }
                if let value = dict["VSwitchName"] as? String {
                    self.vSwitchName = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var vSwitch: [DescribeVSwitchesResponseBody.VSwitches.VSwitch]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vSwitch != nil {
                var tmp : [Any] = []
                for k in self.vSwitch! {
                    tmp.append(k.toMap())
                }
                map["VSwitch"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["VSwitch"] as? [Any?] {
                var tmp : [DescribeVSwitchesResponseBody.VSwitches.VSwitch] = []
                for v in value {
                    if v != nil {
                        var model = DescribeVSwitchesResponseBody.VSwitches.VSwitch()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.vSwitch = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vSwitches: DescribeVSwitchesResponseBody.VSwitches?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vSwitches?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vSwitches != nil {
            map["VSwitches"] = self.vSwitches?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
        if let value = dict["VSwitches"] as? [String: Any?] {
            var model = DescribeVSwitchesResponseBody.VSwitches()
            model.fromMap(value)
            self.vSwitches = model
        }
    }
}

public class DescribeVSwitchesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVSwitchesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeVSwitchesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeVirtualBorderRoutersRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? [String] {
                self.value = value
            }
        }
    }
    public var filter: [DescribeVirtualBorderRoutersRequest.Filter]?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Filter"] as? [Any?] {
            var tmp : [DescribeVirtualBorderRoutersRequest.Filter] = []
            for v in value {
                if v != nil {
                    var model = DescribeVirtualBorderRoutersRequest.Filter()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.filter = tmp
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeVirtualBorderRoutersResponseBody : Tea.TeaModel {
    public class VirtualBorderRouterSet : Tea.TeaModel {
        public class VirtualBorderRouterType : Tea.TeaModel {
            public var accessPointId: String?

            public var activationTime: String?

            public var circuitCode: String?

            public var creationTime: String?

            public var description_: String?

            public var localGatewayIp: String?

            public var name: String?

            public var peerGatewayIp: String?

            public var peeringSubnetMask: String?

            public var physicalConnectionBusinessStatus: String?

            public var physicalConnectionId: String?

            public var physicalConnectionOwnerUid: String?

            public var physicalConnectionStatus: String?

            public var recoveryTime: String?

            public var routeTableId: String?

            public var status: String?

            public var terminationTime: String?

            public var vbrId: String?

            public var vlanId: Int32?

            public var vlanInterfaceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessPointId != nil {
                    map["AccessPointId"] = self.accessPointId!
                }
                if self.activationTime != nil {
                    map["ActivationTime"] = self.activationTime!
                }
                if self.circuitCode != nil {
                    map["CircuitCode"] = self.circuitCode!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.localGatewayIp != nil {
                    map["LocalGatewayIp"] = self.localGatewayIp!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.peerGatewayIp != nil {
                    map["PeerGatewayIp"] = self.peerGatewayIp!
                }
                if self.peeringSubnetMask != nil {
                    map["PeeringSubnetMask"] = self.peeringSubnetMask!
                }
                if self.physicalConnectionBusinessStatus != nil {
                    map["PhysicalConnectionBusinessStatus"] = self.physicalConnectionBusinessStatus!
                }
                if self.physicalConnectionId != nil {
                    map["PhysicalConnectionId"] = self.physicalConnectionId!
                }
                if self.physicalConnectionOwnerUid != nil {
                    map["PhysicalConnectionOwnerUid"] = self.physicalConnectionOwnerUid!
                }
                if self.physicalConnectionStatus != nil {
                    map["PhysicalConnectionStatus"] = self.physicalConnectionStatus!
                }
                if self.recoveryTime != nil {
                    map["RecoveryTime"] = self.recoveryTime!
                }
                if self.routeTableId != nil {
                    map["RouteTableId"] = self.routeTableId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.terminationTime != nil {
                    map["TerminationTime"] = self.terminationTime!
                }
                if self.vbrId != nil {
                    map["VbrId"] = self.vbrId!
                }
                if self.vlanId != nil {
                    map["VlanId"] = self.vlanId!
                }
                if self.vlanInterfaceId != nil {
                    map["VlanInterfaceId"] = self.vlanInterfaceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccessPointId"] as? String {
                    self.accessPointId = value
                }
                if let value = dict["ActivationTime"] as? String {
                    self.activationTime = value
                }
                if let value = dict["CircuitCode"] as? String {
                    self.circuitCode = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["LocalGatewayIp"] as? String {
                    self.localGatewayIp = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["PeerGatewayIp"] as? String {
                    self.peerGatewayIp = value
                }
                if let value = dict["PeeringSubnetMask"] as? String {
                    self.peeringSubnetMask = value
                }
                if let value = dict["PhysicalConnectionBusinessStatus"] as? String {
                    self.physicalConnectionBusinessStatus = value
                }
                if let value = dict["PhysicalConnectionId"] as? String {
                    self.physicalConnectionId = value
                }
                if let value = dict["PhysicalConnectionOwnerUid"] as? String {
                    self.physicalConnectionOwnerUid = value
                }
                if let value = dict["PhysicalConnectionStatus"] as? String {
                    self.physicalConnectionStatus = value
                }
                if let value = dict["RecoveryTime"] as? String {
                    self.recoveryTime = value
                }
                if let value = dict["RouteTableId"] as? String {
                    self.routeTableId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["TerminationTime"] as? String {
                    self.terminationTime = value
                }
                if let value = dict["VbrId"] as? String {
                    self.vbrId = value
                }
                if let value = dict["VlanId"] as? Int32 {
                    self.vlanId = value
                }
                if let value = dict["VlanInterfaceId"] as? String {
                    self.vlanInterfaceId = value
                }
            }
        }
        public var virtualBorderRouterType: [DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.virtualBorderRouterType != nil {
                var tmp : [Any] = []
                for k in self.virtualBorderRouterType! {
                    tmp.append(k.toMap())
                }
                map["VirtualBorderRouterType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["VirtualBorderRouterType"] as? [Any?] {
                var tmp : [DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType] = []
                for v in value {
                    if v != nil {
                        var model = DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.virtualBorderRouterType = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var virtualBorderRouterSet: DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.virtualBorderRouterSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.virtualBorderRouterSet != nil {
            map["VirtualBorderRouterSet"] = self.virtualBorderRouterSet?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
        if let value = dict["VirtualBorderRouterSet"] as? [String: Any?] {
            var model = DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet()
            model.fromMap(value)
            self.virtualBorderRouterSet = model
        }
    }
}

public class DescribeVirtualBorderRoutersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVirtualBorderRoutersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeVirtualBorderRoutersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeVirtualBorderRoutersForPhysicalConnectionRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? [String] {
                self.value = value
            }
        }
    }
    public var filter: [DescribeVirtualBorderRoutersForPhysicalConnectionRequest.Filter]?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Filter"] as? [Any?] {
            var tmp : [DescribeVirtualBorderRoutersForPhysicalConnectionRequest.Filter] = []
            for v in value {
                if v != nil {
                    var model = DescribeVirtualBorderRoutersForPhysicalConnectionRequest.Filter()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.filter = tmp
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["PhysicalConnectionId"] as? String {
            self.physicalConnectionId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody : Tea.TeaModel {
    public class VirtualBorderRouterForPhysicalConnectionSet : Tea.TeaModel {
        public class VirtualBorderRouterForPhysicalConnectionType : Tea.TeaModel {
            public var activationTime: String?

            public var circuitCode: String?

            public var creationTime: String?

            public var recoveryTime: String?

            public var terminationTime: String?

            public var vbrId: String?

            public var vbrOwnerUid: Int64?

            public var vlanId: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activationTime != nil {
                    map["ActivationTime"] = self.activationTime!
                }
                if self.circuitCode != nil {
                    map["CircuitCode"] = self.circuitCode!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.recoveryTime != nil {
                    map["RecoveryTime"] = self.recoveryTime!
                }
                if self.terminationTime != nil {
                    map["TerminationTime"] = self.terminationTime!
                }
                if self.vbrId != nil {
                    map["VbrId"] = self.vbrId!
                }
                if self.vbrOwnerUid != nil {
                    map["VbrOwnerUid"] = self.vbrOwnerUid!
                }
                if self.vlanId != nil {
                    map["VlanId"] = self.vlanId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ActivationTime"] as? String {
                    self.activationTime = value
                }
                if let value = dict["CircuitCode"] as? String {
                    self.circuitCode = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["RecoveryTime"] as? String {
                    self.recoveryTime = value
                }
                if let value = dict["TerminationTime"] as? String {
                    self.terminationTime = value
                }
                if let value = dict["VbrId"] as? String {
                    self.vbrId = value
                }
                if let value = dict["VbrOwnerUid"] as? Int64 {
                    self.vbrOwnerUid = value
                }
                if let value = dict["VlanId"] as? Int32 {
                    self.vlanId = value
                }
            }
        }
        public var virtualBorderRouterForPhysicalConnectionType: [DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody.VirtualBorderRouterForPhysicalConnectionSet.VirtualBorderRouterForPhysicalConnectionType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.virtualBorderRouterForPhysicalConnectionType != nil {
                var tmp : [Any] = []
                for k in self.virtualBorderRouterForPhysicalConnectionType! {
                    tmp.append(k.toMap())
                }
                map["VirtualBorderRouterForPhysicalConnectionType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["VirtualBorderRouterForPhysicalConnectionType"] as? [Any?] {
                var tmp : [DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody.VirtualBorderRouterForPhysicalConnectionSet.VirtualBorderRouterForPhysicalConnectionType] = []
                for v in value {
                    if v != nil {
                        var model = DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody.VirtualBorderRouterForPhysicalConnectionSet.VirtualBorderRouterForPhysicalConnectionType()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.virtualBorderRouterForPhysicalConnectionType = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var virtualBorderRouterForPhysicalConnectionSet: DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody.VirtualBorderRouterForPhysicalConnectionSet?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.virtualBorderRouterForPhysicalConnectionSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.virtualBorderRouterForPhysicalConnectionSet != nil {
            map["VirtualBorderRouterForPhysicalConnectionSet"] = self.virtualBorderRouterForPhysicalConnectionSet?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
        if let value = dict["VirtualBorderRouterForPhysicalConnectionSet"] as? [String: Any?] {
            var model = DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody.VirtualBorderRouterForPhysicalConnectionSet()
            model.fromMap(value)
            self.virtualBorderRouterForPhysicalConnectionSet = model
        }
    }
}

public class DescribeVirtualBorderRoutersForPhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeVpcsRequest : Tea.TeaModel {
    public var isDefault: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isDefault != nil {
            map["IsDefault"] = self.isDefault!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IsDefault"] as? Bool {
            self.isDefault = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class DescribeVpcsResponseBody : Tea.TeaModel {
    public class Vpcs : Tea.TeaModel {
        public class Vpc : Tea.TeaModel {
            public class UserCidrs : Tea.TeaModel {
                public var userCidr: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.userCidr != nil {
                        map["UserCidr"] = self.userCidr!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["UserCidr"] as? [String] {
                        self.userCidr = value
                    }
                }
            }
            public class VSwitchIds : Tea.TeaModel {
                public var vSwitchId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.vSwitchId != nil {
                        map["VSwitchId"] = self.vSwitchId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["VSwitchId"] as? [String] {
                        self.vSwitchId = value
                    }
                }
            }
            public var cidrBlock: String?

            public var creationTime: String?

            public var description_: String?

            public var isDefault: Bool?

            public var regionId: String?

            public var status: String?

            public var userCidrs: DescribeVpcsResponseBody.Vpcs.Vpc.UserCidrs?

            public var VRouterId: String?

            public var vSwitchIds: DescribeVpcsResponseBody.Vpcs.Vpc.VSwitchIds?

            public var vpcId: String?

            public var vpcName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.userCidrs?.validate()
                try self.vSwitchIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cidrBlock != nil {
                    map["CidrBlock"] = self.cidrBlock!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.isDefault != nil {
                    map["IsDefault"] = self.isDefault!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.userCidrs != nil {
                    map["UserCidrs"] = self.userCidrs?.toMap()
                }
                if self.VRouterId != nil {
                    map["VRouterId"] = self.VRouterId!
                }
                if self.vSwitchIds != nil {
                    map["VSwitchIds"] = self.vSwitchIds?.toMap()
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.vpcName != nil {
                    map["VpcName"] = self.vpcName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CidrBlock"] as? String {
                    self.cidrBlock = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["IsDefault"] as? Bool {
                    self.isDefault = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["UserCidrs"] as? [String: Any?] {
                    var model = DescribeVpcsResponseBody.Vpcs.Vpc.UserCidrs()
                    model.fromMap(value)
                    self.userCidrs = model
                }
                if let value = dict["VRouterId"] as? String {
                    self.VRouterId = value
                }
                if let value = dict["VSwitchIds"] as? [String: Any?] {
                    var model = DescribeVpcsResponseBody.Vpcs.Vpc.VSwitchIds()
                    model.fromMap(value)
                    self.vSwitchIds = model
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
                if let value = dict["VpcName"] as? String {
                    self.vpcName = value
                }
            }
        }
        public var vpc: [DescribeVpcsResponseBody.Vpcs.Vpc]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vpc != nil {
                var tmp : [Any] = []
                for k in self.vpc! {
                    tmp.append(k.toMap())
                }
                map["Vpc"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Vpc"] as? [Any?] {
                var tmp : [DescribeVpcsResponseBody.Vpcs.Vpc] = []
                for v in value {
                    if v != nil {
                        var model = DescribeVpcsResponseBody.Vpcs.Vpc()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.vpc = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vpcs: DescribeVpcsResponseBody.Vpcs?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vpcs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vpcs != nil {
            map["Vpcs"] = self.vpcs?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
        if let value = dict["Vpcs"] as? [String: Any?] {
            var model = DescribeVpcsResponseBody.Vpcs()
            model.fromMap(value)
            self.vpcs = model
        }
    }
}

public class DescribeVpcsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpcsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeVpcsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeZonesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var instanceChargeType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var spotStrategy: String?

    public var verbose: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.verbose != nil {
            map["Verbose"] = self.verbose!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SpotStrategy"] as? String {
            self.spotStrategy = value
        }
        if let value = dict["Verbose"] as? Bool {
            self.verbose = value
        }
    }
}

public class DescribeZonesResponseBody : Tea.TeaModel {
    public class Zones : Tea.TeaModel {
        public class Zone : Tea.TeaModel {
            public class AvailableDedicatedHostTypes : Tea.TeaModel {
                public var dedicatedHostType: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dedicatedHostType != nil {
                        map["DedicatedHostType"] = self.dedicatedHostType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DedicatedHostType"] as? [String] {
                        self.dedicatedHostType = value
                    }
                }
            }
            public class AvailableDiskCategories : Tea.TeaModel {
                public var diskCategories: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.diskCategories != nil {
                        map["DiskCategories"] = self.diskCategories!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DiskCategories"] as? [String] {
                        self.diskCategories = value
                    }
                }
            }
            public class AvailableInstanceTypes : Tea.TeaModel {
                public var instanceTypes: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceTypes != nil {
                        map["InstanceTypes"] = self.instanceTypes!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["InstanceTypes"] as? [String] {
                        self.instanceTypes = value
                    }
                }
            }
            public class AvailableResourceCreation : Tea.TeaModel {
                public var resourceTypes: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resourceTypes != nil {
                        map["ResourceTypes"] = self.resourceTypes!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ResourceTypes"] as? [String] {
                        self.resourceTypes = value
                    }
                }
            }
            public class AvailableResources : Tea.TeaModel {
                public class ResourcesInfo : Tea.TeaModel {
                    public class DataDiskCategories : Tea.TeaModel {
                        public var supportedDataDiskCategory: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.supportedDataDiskCategory != nil {
                                map["supportedDataDiskCategory"] = self.supportedDataDiskCategory!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["supportedDataDiskCategory"] as? [String] {
                                self.supportedDataDiskCategory = value
                            }
                        }
                    }
                    public class InstanceGenerations : Tea.TeaModel {
                        public var supportedInstanceGeneration: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.supportedInstanceGeneration != nil {
                                map["supportedInstanceGeneration"] = self.supportedInstanceGeneration!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["supportedInstanceGeneration"] as? [String] {
                                self.supportedInstanceGeneration = value
                            }
                        }
                    }
                    public class InstanceTypeFamilies : Tea.TeaModel {
                        public var supportedInstanceTypeFamily: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.supportedInstanceTypeFamily != nil {
                                map["supportedInstanceTypeFamily"] = self.supportedInstanceTypeFamily!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["supportedInstanceTypeFamily"] as? [String] {
                                self.supportedInstanceTypeFamily = value
                            }
                        }
                    }
                    public class InstanceTypes : Tea.TeaModel {
                        public var supportedInstanceType: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.supportedInstanceType != nil {
                                map["supportedInstanceType"] = self.supportedInstanceType!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["supportedInstanceType"] as? [String] {
                                self.supportedInstanceType = value
                            }
                        }
                    }
                    public class NetworkTypes : Tea.TeaModel {
                        public var supportedNetworkCategory: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.supportedNetworkCategory != nil {
                                map["supportedNetworkCategory"] = self.supportedNetworkCategory!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["supportedNetworkCategory"] as? [String] {
                                self.supportedNetworkCategory = value
                            }
                        }
                    }
                    public class SystemDiskCategories : Tea.TeaModel {
                        public var supportedSystemDiskCategory: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.supportedSystemDiskCategory != nil {
                                map["supportedSystemDiskCategory"] = self.supportedSystemDiskCategory!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["supportedSystemDiskCategory"] as? [String] {
                                self.supportedSystemDiskCategory = value
                            }
                        }
                    }
                    public var dataDiskCategories: DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo.DataDiskCategories?

                    public var instanceGenerations: DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo.InstanceGenerations?

                    public var instanceTypeFamilies: DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo.InstanceTypeFamilies?

                    public var instanceTypes: DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo.InstanceTypes?

                    public var ioOptimized: Bool?

                    public var networkTypes: DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo.NetworkTypes?

                    public var systemDiskCategories: DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo.SystemDiskCategories?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.dataDiskCategories?.validate()
                        try self.instanceGenerations?.validate()
                        try self.instanceTypeFamilies?.validate()
                        try self.instanceTypes?.validate()
                        try self.networkTypes?.validate()
                        try self.systemDiskCategories?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.dataDiskCategories != nil {
                            map["DataDiskCategories"] = self.dataDiskCategories?.toMap()
                        }
                        if self.instanceGenerations != nil {
                            map["InstanceGenerations"] = self.instanceGenerations?.toMap()
                        }
                        if self.instanceTypeFamilies != nil {
                            map["InstanceTypeFamilies"] = self.instanceTypeFamilies?.toMap()
                        }
                        if self.instanceTypes != nil {
                            map["InstanceTypes"] = self.instanceTypes?.toMap()
                        }
                        if self.ioOptimized != nil {
                            map["IoOptimized"] = self.ioOptimized!
                        }
                        if self.networkTypes != nil {
                            map["NetworkTypes"] = self.networkTypes?.toMap()
                        }
                        if self.systemDiskCategories != nil {
                            map["SystemDiskCategories"] = self.systemDiskCategories?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["DataDiskCategories"] as? [String: Any?] {
                            var model = DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo.DataDiskCategories()
                            model.fromMap(value)
                            self.dataDiskCategories = model
                        }
                        if let value = dict["InstanceGenerations"] as? [String: Any?] {
                            var model = DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo.InstanceGenerations()
                            model.fromMap(value)
                            self.instanceGenerations = model
                        }
                        if let value = dict["InstanceTypeFamilies"] as? [String: Any?] {
                            var model = DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo.InstanceTypeFamilies()
                            model.fromMap(value)
                            self.instanceTypeFamilies = model
                        }
                        if let value = dict["InstanceTypes"] as? [String: Any?] {
                            var model = DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo.InstanceTypes()
                            model.fromMap(value)
                            self.instanceTypes = model
                        }
                        if let value = dict["IoOptimized"] as? Bool {
                            self.ioOptimized = value
                        }
                        if let value = dict["NetworkTypes"] as? [String: Any?] {
                            var model = DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo.NetworkTypes()
                            model.fromMap(value)
                            self.networkTypes = model
                        }
                        if let value = dict["SystemDiskCategories"] as? [String: Any?] {
                            var model = DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo.SystemDiskCategories()
                            model.fromMap(value)
                            self.systemDiskCategories = model
                        }
                    }
                }
                public var resourcesInfo: [DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resourcesInfo != nil {
                        var tmp : [Any] = []
                        for k in self.resourcesInfo! {
                            tmp.append(k.toMap())
                        }
                        map["ResourcesInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ResourcesInfo"] as? [Any?] {
                        var tmp : [DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.resourcesInfo = tmp
                    }
                }
            }
            public class AvailableVolumeCategories : Tea.TeaModel {
                public var volumeCategories: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.volumeCategories != nil {
                        map["VolumeCategories"] = self.volumeCategories!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["VolumeCategories"] as? [String] {
                        self.volumeCategories = value
                    }
                }
            }
            public class DedicatedHostGenerations : Tea.TeaModel {
                public var dedicatedHostGeneration: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dedicatedHostGeneration != nil {
                        map["DedicatedHostGeneration"] = self.dedicatedHostGeneration!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DedicatedHostGeneration"] as? [String] {
                        self.dedicatedHostGeneration = value
                    }
                }
            }
            public var availableDedicatedHostTypes: DescribeZonesResponseBody.Zones.Zone.AvailableDedicatedHostTypes?

            public var availableDiskCategories: DescribeZonesResponseBody.Zones.Zone.AvailableDiskCategories?

            public var availableInstanceTypes: DescribeZonesResponseBody.Zones.Zone.AvailableInstanceTypes?

            public var availableResourceCreation: DescribeZonesResponseBody.Zones.Zone.AvailableResourceCreation?

            public var availableResources: DescribeZonesResponseBody.Zones.Zone.AvailableResources?

            public var availableVolumeCategories: DescribeZonesResponseBody.Zones.Zone.AvailableVolumeCategories?

            public var dedicatedHostGenerations: DescribeZonesResponseBody.Zones.Zone.DedicatedHostGenerations?

            public var localName: String?

            public var zoneId: String?

            public var zoneType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.availableDedicatedHostTypes?.validate()
                try self.availableDiskCategories?.validate()
                try self.availableInstanceTypes?.validate()
                try self.availableResourceCreation?.validate()
                try self.availableResources?.validate()
                try self.availableVolumeCategories?.validate()
                try self.dedicatedHostGenerations?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.availableDedicatedHostTypes != nil {
                    map["AvailableDedicatedHostTypes"] = self.availableDedicatedHostTypes?.toMap()
                }
                if self.availableDiskCategories != nil {
                    map["AvailableDiskCategories"] = self.availableDiskCategories?.toMap()
                }
                if self.availableInstanceTypes != nil {
                    map["AvailableInstanceTypes"] = self.availableInstanceTypes?.toMap()
                }
                if self.availableResourceCreation != nil {
                    map["AvailableResourceCreation"] = self.availableResourceCreation?.toMap()
                }
                if self.availableResources != nil {
                    map["AvailableResources"] = self.availableResources?.toMap()
                }
                if self.availableVolumeCategories != nil {
                    map["AvailableVolumeCategories"] = self.availableVolumeCategories?.toMap()
                }
                if self.dedicatedHostGenerations != nil {
                    map["DedicatedHostGenerations"] = self.dedicatedHostGenerations?.toMap()
                }
                if self.localName != nil {
                    map["LocalName"] = self.localName!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                if self.zoneType != nil {
                    map["ZoneType"] = self.zoneType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AvailableDedicatedHostTypes"] as? [String: Any?] {
                    var model = DescribeZonesResponseBody.Zones.Zone.AvailableDedicatedHostTypes()
                    model.fromMap(value)
                    self.availableDedicatedHostTypes = model
                }
                if let value = dict["AvailableDiskCategories"] as? [String: Any?] {
                    var model = DescribeZonesResponseBody.Zones.Zone.AvailableDiskCategories()
                    model.fromMap(value)
                    self.availableDiskCategories = model
                }
                if let value = dict["AvailableInstanceTypes"] as? [String: Any?] {
                    var model = DescribeZonesResponseBody.Zones.Zone.AvailableInstanceTypes()
                    model.fromMap(value)
                    self.availableInstanceTypes = model
                }
                if let value = dict["AvailableResourceCreation"] as? [String: Any?] {
                    var model = DescribeZonesResponseBody.Zones.Zone.AvailableResourceCreation()
                    model.fromMap(value)
                    self.availableResourceCreation = model
                }
                if let value = dict["AvailableResources"] as? [String: Any?] {
                    var model = DescribeZonesResponseBody.Zones.Zone.AvailableResources()
                    model.fromMap(value)
                    self.availableResources = model
                }
                if let value = dict["AvailableVolumeCategories"] as? [String: Any?] {
                    var model = DescribeZonesResponseBody.Zones.Zone.AvailableVolumeCategories()
                    model.fromMap(value)
                    self.availableVolumeCategories = model
                }
                if let value = dict["DedicatedHostGenerations"] as? [String: Any?] {
                    var model = DescribeZonesResponseBody.Zones.Zone.DedicatedHostGenerations()
                    model.fromMap(value)
                    self.dedicatedHostGenerations = model
                }
                if let value = dict["LocalName"] as? String {
                    self.localName = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
                if let value = dict["ZoneType"] as? String {
                    self.zoneType = value
                }
            }
        }
        public var zone: [DescribeZonesResponseBody.Zones.Zone]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.zone != nil {
                var tmp : [Any] = []
                for k in self.zone! {
                    tmp.append(k.toMap())
                }
                map["Zone"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Zone"] as? [Any?] {
                var tmp : [DescribeZonesResponseBody.Zones.Zone] = []
                for v in value {
                    if v != nil {
                        var model = DescribeZonesResponseBody.Zones.Zone()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.zone = tmp
            }
        }
    }
    public var requestId: String?

    public var zones: DescribeZonesResponseBody.Zones?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.zones?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.zones != nil {
            map["Zones"] = self.zones?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Zones"] as? [String: Any?] {
            var model = DescribeZonesResponseBody.Zones()
            model.fromMap(value)
            self.zones = model
        }
    }
}

public class DescribeZonesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeZonesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeZonesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DetachClassicLinkVpcRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class DetachClassicLinkVpcResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DetachClassicLinkVpcResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachClassicLinkVpcResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DetachClassicLinkVpcResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DetachDiskRequest : Tea.TeaModel {
    public var deleteWithInstance: Bool?

    public var diskId: String?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteWithInstance != nil {
            map["DeleteWithInstance"] = self.deleteWithInstance!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeleteWithInstance"] as? Bool {
            self.deleteWithInstance = value
        }
        if let value = dict["DiskId"] as? String {
            self.diskId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DetachDiskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DetachDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DetachDiskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DetachInstanceRamRoleRequest : Tea.TeaModel {
    public var instanceIds: String?

    public var ownerId: Int64?

    public var ramRoleName: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RamRoleName"] as? String {
            self.ramRoleName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DetachInstanceRamRoleResponseBody : Tea.TeaModel {
    public class DetachInstanceRamRoleResults : Tea.TeaModel {
        public class DetachInstanceRamRoleResult : Tea.TeaModel {
            public class InstanceRamRoleSets : Tea.TeaModel {
                public class InstanceRamRoleSet : Tea.TeaModel {
                    public var instanceId: String?

                    public var ramRoleName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.ramRoleName != nil {
                            map["RamRoleName"] = self.ramRoleName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["InstanceId"] as? String {
                            self.instanceId = value
                        }
                        if let value = dict["RamRoleName"] as? String {
                            self.ramRoleName = value
                        }
                    }
                }
                public var instanceRamRoleSet: [DetachInstanceRamRoleResponseBody.DetachInstanceRamRoleResults.DetachInstanceRamRoleResult.InstanceRamRoleSets.InstanceRamRoleSet]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceRamRoleSet != nil {
                        var tmp : [Any] = []
                        for k in self.instanceRamRoleSet! {
                            tmp.append(k.toMap())
                        }
                        map["InstanceRamRoleSet"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["InstanceRamRoleSet"] as? [Any?] {
                        var tmp : [DetachInstanceRamRoleResponseBody.DetachInstanceRamRoleResults.DetachInstanceRamRoleResult.InstanceRamRoleSets.InstanceRamRoleSet] = []
                        for v in value {
                            if v != nil {
                                var model = DetachInstanceRamRoleResponseBody.DetachInstanceRamRoleResults.DetachInstanceRamRoleResult.InstanceRamRoleSets.InstanceRamRoleSet()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.instanceRamRoleSet = tmp
                    }
                }
            }
            public var code: String?

            public var instanceId: String?

            public var instanceRamRoleSets: DetachInstanceRamRoleResponseBody.DetachInstanceRamRoleResults.DetachInstanceRamRoleResult.InstanceRamRoleSets?

            public var message: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.instanceRamRoleSets?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceRamRoleSets != nil {
                    map["InstanceRamRoleSets"] = self.instanceRamRoleSets?.toMap()
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Code"] as? String {
                    self.code = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["InstanceRamRoleSets"] as? [String: Any?] {
                    var model = DetachInstanceRamRoleResponseBody.DetachInstanceRamRoleResults.DetachInstanceRamRoleResult.InstanceRamRoleSets()
                    model.fromMap(value)
                    self.instanceRamRoleSets = model
                }
                if let value = dict["Message"] as? String {
                    self.message = value
                }
                if let value = dict["Success"] as? Bool {
                    self.success = value
                }
            }
        }
        public var detachInstanceRamRoleResult: [DetachInstanceRamRoleResponseBody.DetachInstanceRamRoleResults.DetachInstanceRamRoleResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.detachInstanceRamRoleResult != nil {
                var tmp : [Any] = []
                for k in self.detachInstanceRamRoleResult! {
                    tmp.append(k.toMap())
                }
                map["DetachInstanceRamRoleResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DetachInstanceRamRoleResult"] as? [Any?] {
                var tmp : [DetachInstanceRamRoleResponseBody.DetachInstanceRamRoleResults.DetachInstanceRamRoleResult] = []
                for v in value {
                    if v != nil {
                        var model = DetachInstanceRamRoleResponseBody.DetachInstanceRamRoleResults.DetachInstanceRamRoleResult()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.detachInstanceRamRoleResult = tmp
            }
        }
    }
    public var detachInstanceRamRoleResults: DetachInstanceRamRoleResponseBody.DetachInstanceRamRoleResults?

    public var failCount: Int32?

    public var ramRoleName: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.detachInstanceRamRoleResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.detachInstanceRamRoleResults != nil {
            map["DetachInstanceRamRoleResults"] = self.detachInstanceRamRoleResults?.toMap()
        }
        if self.failCount != nil {
            map["FailCount"] = self.failCount!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DetachInstanceRamRoleResults"] as? [String: Any?] {
            var model = DetachInstanceRamRoleResponseBody.DetachInstanceRamRoleResults()
            model.fromMap(value)
            self.detachInstanceRamRoleResults = model
        }
        if let value = dict["FailCount"] as? Int32 {
            self.failCount = value
        }
        if let value = dict["RamRoleName"] as? String {
            self.ramRoleName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DetachInstanceRamRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachInstanceRamRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DetachInstanceRamRoleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DetachKeyPairRequest : Tea.TeaModel {
    public var instanceIds: String?

    public var keyPairName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DetachKeyPairResponseBody : Tea.TeaModel {
    public class Results : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var code: String?

            public var instanceId: String?

            public var message: String?

            public var success: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Code"] as? String {
                    self.code = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["Message"] as? String {
                    self.message = value
                }
                if let value = dict["Success"] as? String {
                    self.success = value
                }
            }
        }
        public var result: [DetachKeyPairResponseBody.Results.Result]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Result"] as? [Any?] {
                var tmp : [DetachKeyPairResponseBody.Results.Result] = []
                for v in value {
                    if v != nil {
                        var model = DetachKeyPairResponseBody.Results.Result()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.result = tmp
            }
        }
    }
    public var failCount: String?

    public var keyPairName: String?

    public var requestId: String?

    public var results: DetachKeyPairResponseBody.Results?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.results?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failCount != nil {
            map["FailCount"] = self.failCount!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.results != nil {
            map["Results"] = self.results?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FailCount"] as? String {
            self.failCount = value
        }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Results"] as? [String: Any?] {
            var model = DetachKeyPairResponseBody.Results()
            model.fromMap(value)
            self.results = model
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
    }
}

public class DetachKeyPairResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachKeyPairResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DetachKeyPairResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DetachNetworkInterfaceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var trunkNetworkInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.trunkNetworkInstanceId != nil {
            map["TrunkNetworkInstanceId"] = self.trunkNetworkInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NetworkInterfaceId"] as? String {
            self.networkInterfaceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TrunkNetworkInstanceId"] as? String {
            self.trunkNetworkInstanceId = value
        }
    }
}

public class DetachNetworkInterfaceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DetachNetworkInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachNetworkInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DetachNetworkInterfaceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DisableActivationRequest : Tea.TeaModel {
    public var activationId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activationId != nil {
            map["ActivationId"] = self.activationId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ActivationId"] as? String {
            self.activationId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DisableActivationResponseBody : Tea.TeaModel {
    public class Activation : Tea.TeaModel {
        public var activationId: String?

        public var creationTime: String?

        public var deregisteredCount: Int32?

        public var description_: String?

        public var disabled: Bool?

        public var instanceCount: Int32?

        public var instanceName: String?

        public var ipAddressRange: String?

        public var registeredCount: Int32?

        public var timeToLiveInHours: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activationId != nil {
                map["ActivationId"] = self.activationId!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.deregisteredCount != nil {
                map["DeregisteredCount"] = self.deregisteredCount!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.disabled != nil {
                map["Disabled"] = self.disabled!
            }
            if self.instanceCount != nil {
                map["InstanceCount"] = self.instanceCount!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.ipAddressRange != nil {
                map["IpAddressRange"] = self.ipAddressRange!
            }
            if self.registeredCount != nil {
                map["RegisteredCount"] = self.registeredCount!
            }
            if self.timeToLiveInHours != nil {
                map["TimeToLiveInHours"] = self.timeToLiveInHours!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ActivationId"] as? String {
                self.activationId = value
            }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["DeregisteredCount"] as? Int32 {
                self.deregisteredCount = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Disabled"] as? Bool {
                self.disabled = value
            }
            if let value = dict["InstanceCount"] as? Int32 {
                self.instanceCount = value
            }
            if let value = dict["InstanceName"] as? String {
                self.instanceName = value
            }
            if let value = dict["IpAddressRange"] as? String {
                self.ipAddressRange = value
            }
            if let value = dict["RegisteredCount"] as? Int32 {
                self.registeredCount = value
            }
            if let value = dict["TimeToLiveInHours"] as? Int64 {
                self.timeToLiveInHours = value
            }
        }
    }
    public var activation: DisableActivationResponseBody.Activation?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.activation?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activation != nil {
            map["Activation"] = self.activation?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Activation"] as? [String: Any?] {
            var model = DisableActivationResponseBody.Activation()
            model.fromMap(value)
            self.activation = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DisableActivationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableActivationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DisableActivationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DisableDiskEncryptionByDefaultRequest : Tea.TeaModel {
    public var regionId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DisableDiskEncryptionByDefaultResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DisableDiskEncryptionByDefaultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableDiskEncryptionByDefaultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DisableDiskEncryptionByDefaultResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EnableDiskEncryptionByDefaultRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class EnableDiskEncryptionByDefaultResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class EnableDiskEncryptionByDefaultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableDiskEncryptionByDefaultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EnableDiskEncryptionByDefaultResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EnablePhysicalConnectionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userCidr: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PhysicalConnectionId"] as? String {
            self.physicalConnectionId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["UserCidr"] as? String {
            self.userCidr = value
        }
    }
}

public class EnablePhysicalConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class EnablePhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnablePhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EnablePhysicalConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EndTerminalSessionRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sessionId != nil {
            map["SessionId"] = self.sessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SessionId"] as? String {
            self.sessionId = value
        }
    }
}

public class EndTerminalSessionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class EndTerminalSessionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EndTerminalSessionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EndTerminalSessionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ExportImageRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var imageFormat: String?

    public var imageId: String?

    public var OSSBucket: String?

    public var OSSPrefix: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var roleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.imageFormat != nil {
            map["ImageFormat"] = self.imageFormat!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.OSSBucket != nil {
            map["OSSBucket"] = self.OSSBucket!
        }
        if self.OSSPrefix != nil {
            map["OSSPrefix"] = self.OSSPrefix!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.roleName != nil {
            map["RoleName"] = self.roleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["ImageFormat"] as? String {
            self.imageFormat = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["OSSBucket"] as? String {
            self.OSSBucket = value
        }
        if let value = dict["OSSPrefix"] as? String {
            self.OSSPrefix = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RoleName"] as? String {
            self.roleName = value
        }
    }
}

public class ExportImageResponseBody : Tea.TeaModel {
    public var regionId: String?

    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class ExportImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ExportImageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ExportSnapshotRequest : Tea.TeaModel {
    public var ossBucket: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var roleName: String?

    public var snapshotId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ossBucket != nil {
            map["OssBucket"] = self.ossBucket!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.roleName != nil {
            map["RoleName"] = self.roleName!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OssBucket"] as? String {
            self.ossBucket = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RoleName"] as? String {
            self.roleName = value
        }
        if let value = dict["SnapshotId"] as? String {
            self.snapshotId = value
        }
    }
}

public class ExportSnapshotResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class ExportSnapshotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportSnapshotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ExportSnapshotResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetInstanceConsoleOutputRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var removeSymbols: Bool?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.removeSymbols != nil {
            map["RemoveSymbols"] = self.removeSymbols!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RemoveSymbols"] as? Bool {
            self.removeSymbols = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class GetInstanceConsoleOutputResponseBody : Tea.TeaModel {
    public var consoleOutput: String?

    public var instanceId: String?

    public var lastUpdateTime: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleOutput != nil {
            map["ConsoleOutput"] = self.consoleOutput!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lastUpdateTime != nil {
            map["LastUpdateTime"] = self.lastUpdateTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConsoleOutput"] as? String {
            self.consoleOutput = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["LastUpdateTime"] as? String {
            self.lastUpdateTime = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetInstanceConsoleOutputResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceConsoleOutputResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetInstanceConsoleOutputResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetInstanceScreenshotRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var wakeUp: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.wakeUp != nil {
            map["WakeUp"] = self.wakeUp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["WakeUp"] as? Bool {
            self.wakeUp = value
        }
    }
}

public class GetInstanceScreenshotResponseBody : Tea.TeaModel {
    public var instanceId: String?

    public var requestId: String?

    public var screenshot: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.screenshot != nil {
            map["Screenshot"] = self.screenshot!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Screenshot"] as? String {
            self.screenshot = value
        }
    }
}

public class GetInstanceScreenshotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceScreenshotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetInstanceScreenshotResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ImportImageRequest : Tea.TeaModel {
    public class DiskDeviceMapping : Tea.TeaModel {
        public var device: String?

        public var diskImSize: Int32?

        public var diskImageSize: Int32?

        public var format: String?

        public var OSSBucket: String?

        public var OSSObject: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.device != nil {
                map["Device"] = self.device!
            }
            if self.diskImSize != nil {
                map["DiskImSize"] = self.diskImSize!
            }
            if self.diskImageSize != nil {
                map["DiskImageSize"] = self.diskImageSize!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.OSSBucket != nil {
                map["OSSBucket"] = self.OSSBucket!
            }
            if self.OSSObject != nil {
                map["OSSObject"] = self.OSSObject!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Device"] as? String {
                self.device = value
            }
            if let value = dict["DiskImSize"] as? Int32 {
                self.diskImSize = value
            }
            if let value = dict["DiskImageSize"] as? Int32 {
                self.diskImageSize = value
            }
            if let value = dict["Format"] as? String {
                self.format = value
            }
            if let value = dict["OSSBucket"] as? String {
                self.OSSBucket = value
            }
            if let value = dict["OSSObject"] as? String {
                self.OSSObject = value
            }
        }
    }
    public class Features : Tea.TeaModel {
        public var imdsSupport: String?

        public var nvmeSupport: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.imdsSupport != nil {
                map["ImdsSupport"] = self.imdsSupport!
            }
            if self.nvmeSupport != nil {
                map["NvmeSupport"] = self.nvmeSupport!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ImdsSupport"] as? String {
                self.imdsSupport = value
            }
            if let value = dict["NvmeSupport"] as? String {
                self.nvmeSupport = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var architecture: String?

    public var bootMode: String?

    public var clientToken: String?

    public var description_: String?

    public var detectionStrategy: String?

    public var diskDeviceMapping: [ImportImageRequest.DiskDeviceMapping]?

    public var dryRun: Bool?

    public var features: ImportImageRequest.Features?

    public var imageName: String?

    public var licenseType: String?

    public var OSType: String?

    public var ownerId: Int64?

    public var platform: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var roleName: String?

    public var storageLocationArn: String?

    public var tag: [ImportImageRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.features?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.architecture != nil {
            map["Architecture"] = self.architecture!
        }
        if self.bootMode != nil {
            map["BootMode"] = self.bootMode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.detectionStrategy != nil {
            map["DetectionStrategy"] = self.detectionStrategy!
        }
        if self.diskDeviceMapping != nil {
            var tmp : [Any] = []
            for k in self.diskDeviceMapping! {
                tmp.append(k.toMap())
            }
            map["DiskDeviceMapping"] = tmp
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.features != nil {
            map["Features"] = self.features?.toMap()
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.licenseType != nil {
            map["LicenseType"] = self.licenseType!
        }
        if self.OSType != nil {
            map["OSType"] = self.OSType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.roleName != nil {
            map["RoleName"] = self.roleName!
        }
        if self.storageLocationArn != nil {
            map["StorageLocationArn"] = self.storageLocationArn!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Architecture"] as? String {
            self.architecture = value
        }
        if let value = dict["BootMode"] as? String {
            self.bootMode = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DetectionStrategy"] as? String {
            self.detectionStrategy = value
        }
        if let value = dict["DiskDeviceMapping"] as? [Any?] {
            var tmp : [ImportImageRequest.DiskDeviceMapping] = []
            for v in value {
                if v != nil {
                    var model = ImportImageRequest.DiskDeviceMapping()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.diskDeviceMapping = tmp
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Features"] as? [String: Any?] {
            var model = ImportImageRequest.Features()
            model.fromMap(value)
            self.features = model
        }
        if let value = dict["ImageName"] as? String {
            self.imageName = value
        }
        if let value = dict["LicenseType"] as? String {
            self.licenseType = value
        }
        if let value = dict["OSType"] as? String {
            self.OSType = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Platform"] as? String {
            self.platform = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RoleName"] as? String {
            self.roleName = value
        }
        if let value = dict["StorageLocationArn"] as? String {
            self.storageLocationArn = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [ImportImageRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = ImportImageRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class ImportImageResponseBody : Tea.TeaModel {
    public var imageId: String?

    public var regionId: String?

    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class ImportImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ImportImageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ImportKeyPairRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var keyPairName: String?

    public var ownerId: Int64?

    public var publicKeyBody: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [ImportKeyPairRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.publicKeyBody != nil {
            map["PublicKeyBody"] = self.publicKeyBody!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PublicKeyBody"] as? String {
            self.publicKeyBody = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [ImportKeyPairRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = ImportKeyPairRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class ImportKeyPairResponseBody : Tea.TeaModel {
    public var keyPairFingerPrint: String?

    public var keyPairName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyPairFingerPrint != nil {
            map["KeyPairFingerPrint"] = self.keyPairFingerPrint!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["KeyPairFingerPrint"] as? String {
            self.keyPairFingerPrint = value
        }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ImportKeyPairResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportKeyPairResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ImportKeyPairResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class InstallCloudAssistantRequest : Tea.TeaModel {
    public var instanceId: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? [String] {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class InstallCloudAssistantResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class InstallCloudAssistantResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallCloudAssistantResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = InstallCloudAssistantResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class InvokeCommandRequest : Tea.TeaModel {
    public class ResourceTag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var commandId: String?

    public var containerId: String?

    public var containerName: String?

    public var frequency: String?

    public var instanceId: [String]?

    public var launcher: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var parameters: [String: Any]?

    public var regionId: String?

    public var repeatMode: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceTag: [InvokeCommandRequest.ResourceTag]?

    public var tag: [InvokeCommandRequest.Tag]?

    public var terminationMode: String?

    public var timed: Bool?

    public var timeout: Int64?

    public var username: String?

    public var windowsPasswordName: String?

    public var workingDir: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.commandId != nil {
            map["CommandId"] = self.commandId!
        }
        if self.containerId != nil {
            map["ContainerId"] = self.containerId!
        }
        if self.containerName != nil {
            map["ContainerName"] = self.containerName!
        }
        if self.frequency != nil {
            map["Frequency"] = self.frequency!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.launcher != nil {
            map["Launcher"] = self.launcher!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.repeatMode != nil {
            map["RepeatMode"] = self.repeatMode!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceTag != nil {
            var tmp : [Any] = []
            for k in self.resourceTag! {
                tmp.append(k.toMap())
            }
            map["ResourceTag"] = tmp
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.terminationMode != nil {
            map["TerminationMode"] = self.terminationMode!
        }
        if self.timed != nil {
            map["Timed"] = self.timed!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.username != nil {
            map["Username"] = self.username!
        }
        if self.windowsPasswordName != nil {
            map["WindowsPasswordName"] = self.windowsPasswordName!
        }
        if self.workingDir != nil {
            map["WorkingDir"] = self.workingDir!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CommandId"] as? String {
            self.commandId = value
        }
        if let value = dict["ContainerId"] as? String {
            self.containerId = value
        }
        if let value = dict["ContainerName"] as? String {
            self.containerName = value
        }
        if let value = dict["Frequency"] as? String {
            self.frequency = value
        }
        if let value = dict["InstanceId"] as? [String] {
            self.instanceId = value
        }
        if let value = dict["Launcher"] as? String {
            self.launcher = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Parameters"] as? [String: Any] {
            self.parameters = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RepeatMode"] as? String {
            self.repeatMode = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceTag"] as? [Any?] {
            var tmp : [InvokeCommandRequest.ResourceTag] = []
            for v in value {
                if v != nil {
                    var model = InvokeCommandRequest.ResourceTag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.resourceTag = tmp
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [InvokeCommandRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = InvokeCommandRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["TerminationMode"] as? String {
            self.terminationMode = value
        }
        if let value = dict["Timed"] as? Bool {
            self.timed = value
        }
        if let value = dict["Timeout"] as? Int64 {
            self.timeout = value
        }
        if let value = dict["Username"] as? String {
            self.username = value
        }
        if let value = dict["WindowsPasswordName"] as? String {
            self.windowsPasswordName = value
        }
        if let value = dict["WorkingDir"] as? String {
            self.workingDir = value
        }
    }
}

public class InvokeCommandShrinkRequest : Tea.TeaModel {
    public class ResourceTag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var commandId: String?

    public var containerId: String?

    public var containerName: String?

    public var frequency: String?

    public var instanceId: [String]?

    public var launcher: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var parametersShrink: String?

    public var regionId: String?

    public var repeatMode: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceTag: [InvokeCommandShrinkRequest.ResourceTag]?

    public var tag: [InvokeCommandShrinkRequest.Tag]?

    public var terminationMode: String?

    public var timed: Bool?

    public var timeout: Int64?

    public var username: String?

    public var windowsPasswordName: String?

    public var workingDir: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.commandId != nil {
            map["CommandId"] = self.commandId!
        }
        if self.containerId != nil {
            map["ContainerId"] = self.containerId!
        }
        if self.containerName != nil {
            map["ContainerName"] = self.containerName!
        }
        if self.frequency != nil {
            map["Frequency"] = self.frequency!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.launcher != nil {
            map["Launcher"] = self.launcher!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.parametersShrink != nil {
            map["Parameters"] = self.parametersShrink!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.repeatMode != nil {
            map["RepeatMode"] = self.repeatMode!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceTag != nil {
            var tmp : [Any] = []
            for k in self.resourceTag! {
                tmp.append(k.toMap())
            }
            map["ResourceTag"] = tmp
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.terminationMode != nil {
            map["TerminationMode"] = self.terminationMode!
        }
        if self.timed != nil {
            map["Timed"] = self.timed!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.username != nil {
            map["Username"] = self.username!
        }
        if self.windowsPasswordName != nil {
            map["WindowsPasswordName"] = self.windowsPasswordName!
        }
        if self.workingDir != nil {
            map["WorkingDir"] = self.workingDir!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CommandId"] as? String {
            self.commandId = value
        }
        if let value = dict["ContainerId"] as? String {
            self.containerId = value
        }
        if let value = dict["ContainerName"] as? String {
            self.containerName = value
        }
        if let value = dict["Frequency"] as? String {
            self.frequency = value
        }
        if let value = dict["InstanceId"] as? [String] {
            self.instanceId = value
        }
        if let value = dict["Launcher"] as? String {
            self.launcher = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Parameters"] as? String {
            self.parametersShrink = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RepeatMode"] as? String {
            self.repeatMode = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceTag"] as? [Any?] {
            var tmp : [InvokeCommandShrinkRequest.ResourceTag] = []
            for v in value {
                if v != nil {
                    var model = InvokeCommandShrinkRequest.ResourceTag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.resourceTag = tmp
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [InvokeCommandShrinkRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = InvokeCommandShrinkRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["TerminationMode"] as? String {
            self.terminationMode = value
        }
        if let value = dict["Timed"] as? Bool {
            self.timed = value
        }
        if let value = dict["Timeout"] as? Int64 {
            self.timeout = value
        }
        if let value = dict["Username"] as? String {
            self.username = value
        }
        if let value = dict["WindowsPasswordName"] as? String {
            self.windowsPasswordName = value
        }
        if let value = dict["WorkingDir"] as? String {
            self.workingDir = value
        }
    }
}

public class InvokeCommandResponseBody : Tea.TeaModel {
    public var invokeId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.invokeId != nil {
            map["InvokeId"] = self.invokeId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InvokeId"] as? String {
            self.invokeId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class InvokeCommandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InvokeCommandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = InvokeCommandResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class JoinResourceGroupRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class JoinResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class JoinResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: JoinResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = JoinResourceGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class JoinSecurityGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NetworkInterfaceId"] as? String {
            self.networkInterfaceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
    }
}

public class JoinSecurityGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class JoinSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: JoinSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = JoinSecurityGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class LeaveSecurityGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NetworkInterfaceId"] as? String {
            self.networkInterfaceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
    }
}

public class LeaveSecurityGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class LeaveSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: LeaveSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = LeaveSecurityGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListPluginStatusRequest : Tea.TeaModel {
    public var instanceId: [String]?

    public var maxResults: Int32?

    public var name: String?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? [String] {
            self.instanceId = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ListPluginStatusResponseBody : Tea.TeaModel {
    public class InstancePluginStatusSet : Tea.TeaModel {
        public class InstancePluginStatus : Tea.TeaModel {
            public class PluginStatusSet : Tea.TeaModel {
                public class PluginStatus : Tea.TeaModel {
                    public var firstHeartbeatTime: String?

                    public var lastHeartbeatTime: String?

                    public var pluginName: String?

                    public var pluginStatus: String?

                    public var pluginVersion: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.firstHeartbeatTime != nil {
                            map["FirstHeartbeatTime"] = self.firstHeartbeatTime!
                        }
                        if self.lastHeartbeatTime != nil {
                            map["LastHeartbeatTime"] = self.lastHeartbeatTime!
                        }
                        if self.pluginName != nil {
                            map["PluginName"] = self.pluginName!
                        }
                        if self.pluginStatus != nil {
                            map["PluginStatus"] = self.pluginStatus!
                        }
                        if self.pluginVersion != nil {
                            map["PluginVersion"] = self.pluginVersion!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["FirstHeartbeatTime"] as? String {
                            self.firstHeartbeatTime = value
                        }
                        if let value = dict["LastHeartbeatTime"] as? String {
                            self.lastHeartbeatTime = value
                        }
                        if let value = dict["PluginName"] as? String {
                            self.pluginName = value
                        }
                        if let value = dict["PluginStatus"] as? String {
                            self.pluginStatus = value
                        }
                        if let value = dict["PluginVersion"] as? String {
                            self.pluginVersion = value
                        }
                    }
                }
                public var pluginStatus: [ListPluginStatusResponseBody.InstancePluginStatusSet.InstancePluginStatus.PluginStatusSet.PluginStatus]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.pluginStatus != nil {
                        var tmp : [Any] = []
                        for k in self.pluginStatus! {
                            tmp.append(k.toMap())
                        }
                        map["PluginStatus"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["PluginStatus"] as? [Any?] {
                        var tmp : [ListPluginStatusResponseBody.InstancePluginStatusSet.InstancePluginStatus.PluginStatusSet.PluginStatus] = []
                        for v in value {
                            if v != nil {
                                var model = ListPluginStatusResponseBody.InstancePluginStatusSet.InstancePluginStatus.PluginStatusSet.PluginStatus()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.pluginStatus = tmp
                    }
                }
            }
            public var instanceId: String?

            public var pluginStatusSet: ListPluginStatusResponseBody.InstancePluginStatusSet.InstancePluginStatus.PluginStatusSet?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.pluginStatusSet?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.pluginStatusSet != nil {
                    map["PluginStatusSet"] = self.pluginStatusSet?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["PluginStatusSet"] as? [String: Any?] {
                    var model = ListPluginStatusResponseBody.InstancePluginStatusSet.InstancePluginStatus.PluginStatusSet()
                    model.fromMap(value)
                    self.pluginStatusSet = model
                }
            }
        }
        public var instancePluginStatus: [ListPluginStatusResponseBody.InstancePluginStatusSet.InstancePluginStatus]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instancePluginStatus != nil {
                var tmp : [Any] = []
                for k in self.instancePluginStatus! {
                    tmp.append(k.toMap())
                }
                map["InstancePluginStatus"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstancePluginStatus"] as? [Any?] {
                var tmp : [ListPluginStatusResponseBody.InstancePluginStatusSet.InstancePluginStatus] = []
                for v in value {
                    if v != nil {
                        var model = ListPluginStatusResponseBody.InstancePluginStatusSet.InstancePluginStatus()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instancePluginStatus = tmp
            }
        }
    }
    public var instancePluginStatusSet: ListPluginStatusResponseBody.InstancePluginStatusSet?

    public var nextToken: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instancePluginStatusSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instancePluginStatusSet != nil {
            map["InstancePluginStatusSet"] = self.instancePluginStatusSet?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstancePluginStatusSet"] as? [String: Any?] {
            var model = ListPluginStatusResponseBody.InstancePluginStatusSet()
            model.fromMap(value)
            self.instancePluginStatusSet = model
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ListPluginStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPluginStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListPluginStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class TagFilter : Tea.TeaModel {
        public var tagKey: String?

        public var tagValues: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValues != nil {
                map["TagValues"] = self.tagValues!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValues"] as? [String] {
                self.tagValues = value
            }
        }
    }
    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tag: [ListTagResourcesRequest.Tag]?

    public var tagFilter: [ListTagResourcesRequest.TagFilter]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.tagFilter != nil {
            var tmp : [Any] = []
            for k in self.tagFilter! {
                tmp.append(k.toMap())
            }
            map["TagFilter"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [ListTagResourcesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = ListTagResourcesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["TagFilter"] as? [Any?] {
            var tmp : [ListTagResourcesRequest.TagFilter] = []
            for v in value {
                if v != nil {
                    var model = ListTagResourcesRequest.TagFilter()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tagFilter = tmp
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public class TagResource : Tea.TeaModel {
            public var resourceId: String?

            public var resourceType: String?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public var tagResource: [ListTagResourcesResponseBody.TagResources.TagResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagResource != nil {
                var tmp : [Any] = []
                for k in self.tagResource! {
                    tmp.append(k.toMap())
                }
                map["TagResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagResource"] as? [Any?] {
                var tmp : [ListTagResourcesResponseBody.TagResources.TagResource] = []
                for v in value {
                    if v != nil {
                        var model = ListTagResourcesResponseBody.TagResources.TagResource()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tagResource = tmp
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var tagResources: ListTagResourcesResponseBody.TagResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            map["TagResources"] = self.tagResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TagResources"] as? [String: Any?] {
            var model = ListTagResourcesResponseBody.TagResources()
            model.fromMap(value)
            self.tagResources = model
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListTagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyAutoProvisioningGroupRequest : Tea.TeaModel {
    public class LaunchTemplateConfig : Tea.TeaModel {
        public var instanceType: String?

        public var maxPrice: Double?

        public var priority: Int32?

        public var vSwitchId: String?

        public var weightedCapacity: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.maxPrice != nil {
                map["MaxPrice"] = self.maxPrice!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["MaxPrice"] as? Double {
                self.maxPrice = value
            }
            if let value = dict["Priority"] as? Int32 {
                self.priority = value
            }
            if let value = dict["VSwitchId"] as? String {
                self.vSwitchId = value
            }
            if let value = dict["WeightedCapacity"] as? Double {
                self.weightedCapacity = value
            }
        }
    }
    public var autoProvisioningGroupId: String?

    public var autoProvisioningGroupName: String?

    public var defaultTargetCapacityType: String?

    public var excessCapacityTerminationPolicy: String?

    public var launchTemplateConfig: [ModifyAutoProvisioningGroupRequest.LaunchTemplateConfig]?

    public var maxSpotPrice: Double?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var payAsYouGoTargetCapacity: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var spotTargetCapacity: String?

    public var terminateInstancesWithExpiration: Bool?

    public var totalTargetCapacity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoProvisioningGroupId != nil {
            map["AutoProvisioningGroupId"] = self.autoProvisioningGroupId!
        }
        if self.autoProvisioningGroupName != nil {
            map["AutoProvisioningGroupName"] = self.autoProvisioningGroupName!
        }
        if self.defaultTargetCapacityType != nil {
            map["DefaultTargetCapacityType"] = self.defaultTargetCapacityType!
        }
        if self.excessCapacityTerminationPolicy != nil {
            map["ExcessCapacityTerminationPolicy"] = self.excessCapacityTerminationPolicy!
        }
        if self.launchTemplateConfig != nil {
            var tmp : [Any] = []
            for k in self.launchTemplateConfig! {
                tmp.append(k.toMap())
            }
            map["LaunchTemplateConfig"] = tmp
        }
        if self.maxSpotPrice != nil {
            map["MaxSpotPrice"] = self.maxSpotPrice!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.payAsYouGoTargetCapacity != nil {
            map["PayAsYouGoTargetCapacity"] = self.payAsYouGoTargetCapacity!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.spotTargetCapacity != nil {
            map["SpotTargetCapacity"] = self.spotTargetCapacity!
        }
        if self.terminateInstancesWithExpiration != nil {
            map["TerminateInstancesWithExpiration"] = self.terminateInstancesWithExpiration!
        }
        if self.totalTargetCapacity != nil {
            map["TotalTargetCapacity"] = self.totalTargetCapacity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoProvisioningGroupId"] as? String {
            self.autoProvisioningGroupId = value
        }
        if let value = dict["AutoProvisioningGroupName"] as? String {
            self.autoProvisioningGroupName = value
        }
        if let value = dict["DefaultTargetCapacityType"] as? String {
            self.defaultTargetCapacityType = value
        }
        if let value = dict["ExcessCapacityTerminationPolicy"] as? String {
            self.excessCapacityTerminationPolicy = value
        }
        if let value = dict["LaunchTemplateConfig"] as? [Any?] {
            var tmp : [ModifyAutoProvisioningGroupRequest.LaunchTemplateConfig] = []
            for v in value {
                if v != nil {
                    var model = ModifyAutoProvisioningGroupRequest.LaunchTemplateConfig()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.launchTemplateConfig = tmp
        }
        if let value = dict["MaxSpotPrice"] as? Double {
            self.maxSpotPrice = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PayAsYouGoTargetCapacity"] as? String {
            self.payAsYouGoTargetCapacity = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SpotTargetCapacity"] as? String {
            self.spotTargetCapacity = value
        }
        if let value = dict["TerminateInstancesWithExpiration"] as? Bool {
            self.terminateInstancesWithExpiration = value
        }
        if let value = dict["TotalTargetCapacity"] as? String {
            self.totalTargetCapacity = value
        }
    }
}

public class ModifyAutoProvisioningGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyAutoProvisioningGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAutoProvisioningGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyAutoProvisioningGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyAutoSnapshotPolicyExRequest : Tea.TeaModel {
    public class CopyEncryptionConfiguration : Tea.TeaModel {
        public class Arn : Tea.TeaModel {
            public var assumeRoleFor: Int64?

            public var roleType: String?

            public var rolearn: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.assumeRoleFor != nil {
                    map["AssumeRoleFor"] = self.assumeRoleFor!
                }
                if self.roleType != nil {
                    map["RoleType"] = self.roleType!
                }
                if self.rolearn != nil {
                    map["Rolearn"] = self.rolearn!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AssumeRoleFor"] as? Int64 {
                    self.assumeRoleFor = value
                }
                if let value = dict["RoleType"] as? String {
                    self.roleType = value
                }
                if let value = dict["Rolearn"] as? String {
                    self.rolearn = value
                }
            }
        }
        public var arn: [ModifyAutoSnapshotPolicyExRequest.CopyEncryptionConfiguration.Arn]?

        public var encrypted: Bool?

        public var KMSKeyId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.arn != nil {
                var tmp : [Any] = []
                for k in self.arn! {
                    tmp.append(k.toMap())
                }
                map["Arn"] = tmp
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Arn"] as? [Any?] {
                var tmp : [ModifyAutoSnapshotPolicyExRequest.CopyEncryptionConfiguration.Arn] = []
                for v in value {
                    if v != nil {
                        var model = ModifyAutoSnapshotPolicyExRequest.CopyEncryptionConfiguration.Arn()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.arn = tmp
            }
            if let value = dict["Encrypted"] as? Bool {
                self.encrypted = value
            }
            if let value = dict["KMSKeyId"] as? String {
                self.KMSKeyId = value
            }
        }
    }
    public var copiedSnapshotsRetentionDays: Int32?

    public var copyEncryptionConfiguration: ModifyAutoSnapshotPolicyExRequest.CopyEncryptionConfiguration?

    public var enableCrossRegionCopy: Bool?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var targetCopyRegions: String?

    public var autoSnapshotPolicyId: String?

    public var autoSnapshotPolicyName: String?

    public var regionId: String?

    public var repeatWeekdays: String?

    public var retentionDays: Int32?

    public var timePoints: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.copyEncryptionConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.copiedSnapshotsRetentionDays != nil {
            map["CopiedSnapshotsRetentionDays"] = self.copiedSnapshotsRetentionDays!
        }
        if self.copyEncryptionConfiguration != nil {
            map["CopyEncryptionConfiguration"] = self.copyEncryptionConfiguration?.toMap()
        }
        if self.enableCrossRegionCopy != nil {
            map["EnableCrossRegionCopy"] = self.enableCrossRegionCopy!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.targetCopyRegions != nil {
            map["TargetCopyRegions"] = self.targetCopyRegions!
        }
        if self.autoSnapshotPolicyId != nil {
            map["autoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
        }
        if self.autoSnapshotPolicyName != nil {
            map["autoSnapshotPolicyName"] = self.autoSnapshotPolicyName!
        }
        if self.regionId != nil {
            map["regionId"] = self.regionId!
        }
        if self.repeatWeekdays != nil {
            map["repeatWeekdays"] = self.repeatWeekdays!
        }
        if self.retentionDays != nil {
            map["retentionDays"] = self.retentionDays!
        }
        if self.timePoints != nil {
            map["timePoints"] = self.timePoints!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CopiedSnapshotsRetentionDays"] as? Int32 {
            self.copiedSnapshotsRetentionDays = value
        }
        if let value = dict["CopyEncryptionConfiguration"] as? [String: Any?] {
            var model = ModifyAutoSnapshotPolicyExRequest.CopyEncryptionConfiguration()
            model.fromMap(value)
            self.copyEncryptionConfiguration = model
        }
        if let value = dict["EnableCrossRegionCopy"] as? Bool {
            self.enableCrossRegionCopy = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TargetCopyRegions"] as? String {
            self.targetCopyRegions = value
        }
        if let value = dict["autoSnapshotPolicyId"] as? String {
            self.autoSnapshotPolicyId = value
        }
        if let value = dict["autoSnapshotPolicyName"] as? String {
            self.autoSnapshotPolicyName = value
        }
        if let value = dict["regionId"] as? String {
            self.regionId = value
        }
        if let value = dict["repeatWeekdays"] as? String {
            self.repeatWeekdays = value
        }
        if let value = dict["retentionDays"] as? Int32 {
            self.retentionDays = value
        }
        if let value = dict["timePoints"] as? String {
            self.timePoints = value
        }
    }
}

public class ModifyAutoSnapshotPolicyExResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyAutoSnapshotPolicyExResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAutoSnapshotPolicyExResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyAutoSnapshotPolicyExResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyBandwidthPackageSpecRequest : Tea.TeaModel {
    public var bandwidth: String?

    public var bandwidthPackageId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Bandwidth"] as? String {
            self.bandwidth = value
        }
        if let value = dict["BandwidthPackageId"] as? String {
            self.bandwidthPackageId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyBandwidthPackageSpecResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyBandwidthPackageSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyBandwidthPackageSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyBandwidthPackageSpecResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyCapacityReservationRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
        }
    }
    public var privatePoolOptions: ModifyCapacityReservationRequest.PrivatePoolOptions?

    public var description_: String?

    public var endTime: String?

    public var endTimeType: String?

    public var instanceAmount: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var platform: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.endTimeType != nil {
            map["EndTimeType"] = self.endTimeType!
        }
        if self.instanceAmount != nil {
            map["InstanceAmount"] = self.instanceAmount!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PrivatePoolOptions"] as? [String: Any?] {
            var model = ModifyCapacityReservationRequest.PrivatePoolOptions()
            model.fromMap(value)
            self.privatePoolOptions = model
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["EndTimeType"] as? String {
            self.endTimeType = value
        }
        if let value = dict["InstanceAmount"] as? Int32 {
            self.instanceAmount = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Platform"] as? String {
            self.platform = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class ModifyCapacityReservationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyCapacityReservationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCapacityReservationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyCapacityReservationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyCloudAssistantSettingsRequest : Tea.TeaModel {
    public class AgentUpgradeConfig : Tea.TeaModel {
        public var allowedUpgradeWindow: [String]?

        public var enabled: Bool?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowedUpgradeWindow != nil {
                map["AllowedUpgradeWindow"] = self.allowedUpgradeWindow!
            }
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.timeZone != nil {
                map["TimeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AllowedUpgradeWindow"] as? [String] {
                self.allowedUpgradeWindow = value
            }
            if let value = dict["Enabled"] as? Bool {
                self.enabled = value
            }
            if let value = dict["TimeZone"] as? String {
                self.timeZone = value
            }
        }
    }
    public class OssDeliveryConfig : Tea.TeaModel {
        public var bucketName: String?

        public var enabled: Bool?

        public var encryptionAlgorithm: String?

        public var encryptionKeyId: String?

        public var encryptionType: String?

        public var prefix_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bucketName != nil {
                map["BucketName"] = self.bucketName!
            }
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.encryptionAlgorithm != nil {
                map["EncryptionAlgorithm"] = self.encryptionAlgorithm!
            }
            if self.encryptionKeyId != nil {
                map["EncryptionKeyId"] = self.encryptionKeyId!
            }
            if self.encryptionType != nil {
                map["EncryptionType"] = self.encryptionType!
            }
            if self.prefix_ != nil {
                map["Prefix"] = self.prefix_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BucketName"] as? String {
                self.bucketName = value
            }
            if let value = dict["Enabled"] as? Bool {
                self.enabled = value
            }
            if let value = dict["EncryptionAlgorithm"] as? String {
                self.encryptionAlgorithm = value
            }
            if let value = dict["EncryptionKeyId"] as? String {
                self.encryptionKeyId = value
            }
            if let value = dict["EncryptionType"] as? String {
                self.encryptionType = value
            }
            if let value = dict["Prefix"] as? String {
                self.prefix_ = value
            }
        }
    }
    public class SlsDeliveryConfig : Tea.TeaModel {
        public var enabled: Bool?

        public var logstoreName: String?

        public var projectName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.logstoreName != nil {
                map["LogstoreName"] = self.logstoreName!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Enabled"] as? Bool {
                self.enabled = value
            }
            if let value = dict["LogstoreName"] as? String {
                self.logstoreName = value
            }
            if let value = dict["ProjectName"] as? String {
                self.projectName = value
            }
        }
    }
    public var agentUpgradeConfig: ModifyCloudAssistantSettingsRequest.AgentUpgradeConfig?

    public var ossDeliveryConfig: ModifyCloudAssistantSettingsRequest.OssDeliveryConfig?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var settingType: String?

    public var slsDeliveryConfig: ModifyCloudAssistantSettingsRequest.SlsDeliveryConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.agentUpgradeConfig?.validate()
        try self.ossDeliveryConfig?.validate()
        try self.slsDeliveryConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentUpgradeConfig != nil {
            map["AgentUpgradeConfig"] = self.agentUpgradeConfig?.toMap()
        }
        if self.ossDeliveryConfig != nil {
            map["OssDeliveryConfig"] = self.ossDeliveryConfig?.toMap()
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.settingType != nil {
            map["SettingType"] = self.settingType!
        }
        if self.slsDeliveryConfig != nil {
            map["SlsDeliveryConfig"] = self.slsDeliveryConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AgentUpgradeConfig"] as? [String: Any?] {
            var model = ModifyCloudAssistantSettingsRequest.AgentUpgradeConfig()
            model.fromMap(value)
            self.agentUpgradeConfig = model
        }
        if let value = dict["OssDeliveryConfig"] as? [String: Any?] {
            var model = ModifyCloudAssistantSettingsRequest.OssDeliveryConfig()
            model.fromMap(value)
            self.ossDeliveryConfig = model
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SettingType"] as? String {
            self.settingType = value
        }
        if let value = dict["SlsDeliveryConfig"] as? [String: Any?] {
            var model = ModifyCloudAssistantSettingsRequest.SlsDeliveryConfig()
            model.fromMap(value)
            self.slsDeliveryConfig = model
        }
    }
}

public class ModifyCloudAssistantSettingsShrinkRequest : Tea.TeaModel {
    public var agentUpgradeConfigShrink: String?

    public var ossDeliveryConfigShrink: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var settingType: String?

    public var slsDeliveryConfigShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentUpgradeConfigShrink != nil {
            map["AgentUpgradeConfig"] = self.agentUpgradeConfigShrink!
        }
        if self.ossDeliveryConfigShrink != nil {
            map["OssDeliveryConfig"] = self.ossDeliveryConfigShrink!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.settingType != nil {
            map["SettingType"] = self.settingType!
        }
        if self.slsDeliveryConfigShrink != nil {
            map["SlsDeliveryConfig"] = self.slsDeliveryConfigShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AgentUpgradeConfig"] as? String {
            self.agentUpgradeConfigShrink = value
        }
        if let value = dict["OssDeliveryConfig"] as? String {
            self.ossDeliveryConfigShrink = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SettingType"] as? String {
            self.settingType = value
        }
        if let value = dict["SlsDeliveryConfig"] as? String {
            self.slsDeliveryConfigShrink = value
        }
    }
}

public class ModifyCloudAssistantSettingsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyCloudAssistantSettingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCloudAssistantSettingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyCloudAssistantSettingsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyCommandRequest : Tea.TeaModel {
    public var commandContent: String?

    public var commandId: String?

    public var description_: String?

    public var launcher: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var timeout: Int64?

    public var workingDir: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandContent != nil {
            map["CommandContent"] = self.commandContent!
        }
        if self.commandId != nil {
            map["CommandId"] = self.commandId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.launcher != nil {
            map["Launcher"] = self.launcher!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.workingDir != nil {
            map["WorkingDir"] = self.workingDir!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CommandContent"] as? String {
            self.commandContent = value
        }
        if let value = dict["CommandId"] as? String {
            self.commandId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Launcher"] as? String {
            self.launcher = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Timeout"] as? Int64 {
            self.timeout = value
        }
        if let value = dict["WorkingDir"] as? String {
            self.workingDir = value
        }
    }
}

public class ModifyCommandResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyCommandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCommandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyCommandResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDedicatedHostAttributeRequest : Tea.TeaModel {
    public class NetworkAttributes : Tea.TeaModel {
        public var slbUdpTimeout: Int32?

        public var udpTimeout: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.slbUdpTimeout != nil {
                map["SlbUdpTimeout"] = self.slbUdpTimeout!
            }
            if self.udpTimeout != nil {
                map["UdpTimeout"] = self.udpTimeout!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SlbUdpTimeout"] as? Int32 {
                self.slbUdpTimeout = value
            }
            if let value = dict["UdpTimeout"] as? Int32 {
                self.udpTimeout = value
            }
        }
    }
    public var networkAttributes: ModifyDedicatedHostAttributeRequest.NetworkAttributes?

    public var actionOnMaintenance: String?

    public var autoPlacement: String?

    public var cpuOverCommitRatio: Double?

    public var dedicatedHostClusterId: String?

    public var dedicatedHostId: String?

    public var dedicatedHostName: String?

    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkAttributes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAttributes != nil {
            map["NetworkAttributes"] = self.networkAttributes?.toMap()
        }
        if self.actionOnMaintenance != nil {
            map["ActionOnMaintenance"] = self.actionOnMaintenance!
        }
        if self.autoPlacement != nil {
            map["AutoPlacement"] = self.autoPlacement!
        }
        if self.cpuOverCommitRatio != nil {
            map["CpuOverCommitRatio"] = self.cpuOverCommitRatio!
        }
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.dedicatedHostName != nil {
            map["DedicatedHostName"] = self.dedicatedHostName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NetworkAttributes"] as? [String: Any?] {
            var model = ModifyDedicatedHostAttributeRequest.NetworkAttributes()
            model.fromMap(value)
            self.networkAttributes = model
        }
        if let value = dict["ActionOnMaintenance"] as? String {
            self.actionOnMaintenance = value
        }
        if let value = dict["AutoPlacement"] as? String {
            self.autoPlacement = value
        }
        if let value = dict["CpuOverCommitRatio"] as? Double {
            self.cpuOverCommitRatio = value
        }
        if let value = dict["DedicatedHostClusterId"] as? String {
            self.dedicatedHostClusterId = value
        }
        if let value = dict["DedicatedHostId"] as? String {
            self.dedicatedHostId = value
        }
        if let value = dict["DedicatedHostName"] as? String {
            self.dedicatedHostName = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyDedicatedHostAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDedicatedHostAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDedicatedHostAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDedicatedHostAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDedicatedHostAutoReleaseTimeRequest : Tea.TeaModel {
    public var autoReleaseTime: String?

    public var dedicatedHostId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoReleaseTime != nil {
            map["AutoReleaseTime"] = self.autoReleaseTime!
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoReleaseTime"] as? String {
            self.autoReleaseTime = value
        }
        if let value = dict["DedicatedHostId"] as? String {
            self.dedicatedHostId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyDedicatedHostAutoReleaseTimeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDedicatedHostAutoReleaseTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDedicatedHostAutoReleaseTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDedicatedHostAutoReleaseTimeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDedicatedHostAutoRenewAttributeRequest : Tea.TeaModel {
    public var autoRenew: Bool?

    public var autoRenewWithEcs: String?

    public var dedicatedHostIds: String?

    public var duration: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var periodUnit: String?

    public var regionId: String?

    public var renewalStatus: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewWithEcs != nil {
            map["AutoRenewWithEcs"] = self.autoRenewWithEcs!
        }
        if self.dedicatedHostIds != nil {
            map["DedicatedHostIds"] = self.dedicatedHostIds!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.renewalStatus != nil {
            map["RenewalStatus"] = self.renewalStatus!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoRenew"] as? Bool {
            self.autoRenew = value
        }
        if let value = dict["AutoRenewWithEcs"] as? String {
            self.autoRenewWithEcs = value
        }
        if let value = dict["DedicatedHostIds"] as? String {
            self.dedicatedHostIds = value
        }
        if let value = dict["Duration"] as? Int32 {
            self.duration = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PeriodUnit"] as? String {
            self.periodUnit = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RenewalStatus"] as? String {
            self.renewalStatus = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyDedicatedHostAutoRenewAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDedicatedHostAutoRenewAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDedicatedHostAutoRenewAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDedicatedHostAutoRenewAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDedicatedHostClusterAttributeRequest : Tea.TeaModel {
    public var dedicatedHostClusterId: String?

    public var dedicatedHostClusterName: String?

    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.dedicatedHostClusterName != nil {
            map["DedicatedHostClusterName"] = self.dedicatedHostClusterName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DedicatedHostClusterId"] as? String {
            self.dedicatedHostClusterId = value
        }
        if let value = dict["DedicatedHostClusterName"] as? String {
            self.dedicatedHostClusterName = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyDedicatedHostClusterAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDedicatedHostClusterAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDedicatedHostClusterAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDedicatedHostClusterAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDedicatedHostsChargeTypeRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var clientToken: String?

    public var dedicatedHostChargeType: String?

    public var dedicatedHostIds: String?

    public var detailFee: Bool?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dedicatedHostChargeType != nil {
            map["DedicatedHostChargeType"] = self.dedicatedHostChargeType!
        }
        if self.dedicatedHostIds != nil {
            map["DedicatedHostIds"] = self.dedicatedHostIds!
        }
        if self.detailFee != nil {
            map["DetailFee"] = self.detailFee!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DedicatedHostChargeType"] as? String {
            self.dedicatedHostChargeType = value
        }
        if let value = dict["DedicatedHostIds"] as? String {
            self.dedicatedHostIds = value
        }
        if let value = dict["DetailFee"] as? Bool {
            self.detailFee = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PeriodUnit"] as? String {
            self.periodUnit = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyDedicatedHostsChargeTypeResponseBody : Tea.TeaModel {
    public class FeeOfInstances : Tea.TeaModel {
        public class FeeOfInstance : Tea.TeaModel {
            public var currency: String?

            public var fee: String?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.currency != nil {
                    map["Currency"] = self.currency!
                }
                if self.fee != nil {
                    map["Fee"] = self.fee!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Currency"] as? String {
                    self.currency = value
                }
                if let value = dict["Fee"] as? String {
                    self.fee = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
            }
        }
        public var feeOfInstance: [ModifyDedicatedHostsChargeTypeResponseBody.FeeOfInstances.FeeOfInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.feeOfInstance != nil {
                var tmp : [Any] = []
                for k in self.feeOfInstance! {
                    tmp.append(k.toMap())
                }
                map["FeeOfInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["FeeOfInstance"] as? [Any?] {
                var tmp : [ModifyDedicatedHostsChargeTypeResponseBody.FeeOfInstances.FeeOfInstance] = []
                for v in value {
                    if v != nil {
                        var model = ModifyDedicatedHostsChargeTypeResponseBody.FeeOfInstances.FeeOfInstance()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.feeOfInstance = tmp
            }
        }
    }
    public var feeOfInstances: ModifyDedicatedHostsChargeTypeResponseBody.FeeOfInstances?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.feeOfInstances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.feeOfInstances != nil {
            map["FeeOfInstances"] = self.feeOfInstances?.toMap()
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FeeOfInstances"] as? [String: Any?] {
            var model = ModifyDedicatedHostsChargeTypeResponseBody.FeeOfInstances()
            model.fromMap(value)
            self.feeOfInstances = model
        }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDedicatedHostsChargeTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDedicatedHostsChargeTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDedicatedHostsChargeTypeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDeploymentSetAttributeRequest : Tea.TeaModel {
    public var deploymentSetId: String?

    public var deploymentSetName: String?

    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.deploymentSetName != nil {
            map["DeploymentSetName"] = self.deploymentSetName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeploymentSetId"] as? String {
            self.deploymentSetId = value
        }
        if let value = dict["DeploymentSetName"] as? String {
            self.deploymentSetName = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyDeploymentSetAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDeploymentSetAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDeploymentSetAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDeploymentSetAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDiagnosticMetricSetRequest : Tea.TeaModel {
    public var description_: String?

    public var metricIds: [String]?

    public var metricSetId: String?

    public var metricSetName: String?

    public var regionId: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.metricIds != nil {
            map["MetricIds"] = self.metricIds!
        }
        if self.metricSetId != nil {
            map["MetricSetId"] = self.metricSetId!
        }
        if self.metricSetName != nil {
            map["MetricSetName"] = self.metricSetName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["MetricIds"] as? [String] {
            self.metricIds = value
        }
        if let value = dict["MetricSetId"] as? String {
            self.metricSetId = value
        }
        if let value = dict["MetricSetName"] as? String {
            self.metricSetName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class ModifyDiagnosticMetricSetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDiagnosticMetricSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDiagnosticMetricSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDiagnosticMetricSetResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDiskAttributeRequest : Tea.TeaModel {
    public var burstingEnabled: Bool?

    public var deleteAutoSnapshot: Bool?

    public var deleteWithInstance: Bool?

    public var description_: String?

    public var diskId: String?

    public var diskIds: [String]?

    public var diskName: String?

    public var enableAutoSnapshot: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.burstingEnabled != nil {
            map["BurstingEnabled"] = self.burstingEnabled!
        }
        if self.deleteAutoSnapshot != nil {
            map["DeleteAutoSnapshot"] = self.deleteAutoSnapshot!
        }
        if self.deleteWithInstance != nil {
            map["DeleteWithInstance"] = self.deleteWithInstance!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.diskIds != nil {
            map["DiskIds"] = self.diskIds!
        }
        if self.diskName != nil {
            map["DiskName"] = self.diskName!
        }
        if self.enableAutoSnapshot != nil {
            map["EnableAutoSnapshot"] = self.enableAutoSnapshot!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BurstingEnabled"] as? Bool {
            self.burstingEnabled = value
        }
        if let value = dict["DeleteAutoSnapshot"] as? Bool {
            self.deleteAutoSnapshot = value
        }
        if let value = dict["DeleteWithInstance"] as? Bool {
            self.deleteWithInstance = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DiskId"] as? String {
            self.diskId = value
        }
        if let value = dict["DiskIds"] as? [String] {
            self.diskIds = value
        }
        if let value = dict["DiskName"] as? String {
            self.diskName = value
        }
        if let value = dict["EnableAutoSnapshot"] as? Bool {
            self.enableAutoSnapshot = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyDiskAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDiskAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDiskAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDiskAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDiskChargeTypeRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var clientToken: String?

    public var diskChargeType: String?

    public var diskIds: String?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.diskChargeType != nil {
            map["DiskChargeType"] = self.diskChargeType!
        }
        if self.diskIds != nil {
            map["DiskIds"] = self.diskIds!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DiskChargeType"] as? String {
            self.diskChargeType = value
        }
        if let value = dict["DiskIds"] as? String {
            self.diskIds = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyDiskChargeTypeResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDiskChargeTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDiskChargeTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDiskChargeTypeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDiskDefaultKMSKeyIdRequest : Tea.TeaModel {
    public var KMSKeyId: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.KMSKeyId != nil {
            map["KMSKeyId"] = self.KMSKeyId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["KMSKeyId"] as? String {
            self.KMSKeyId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyDiskDefaultKMSKeyIdResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDiskDefaultKMSKeyIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDiskDefaultKMSKeyIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDiskDefaultKMSKeyIdResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDiskDeploymentRequest : Tea.TeaModel {
    public var diskCategory: String?

    public var diskId: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var performanceLevel: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var storageClusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskCategory != nil {
            map["DiskCategory"] = self.diskCategory!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.performanceLevel != nil {
            map["PerformanceLevel"] = self.performanceLevel!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.storageClusterId != nil {
            map["StorageClusterId"] = self.storageClusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DiskCategory"] as? String {
            self.diskCategory = value
        }
        if let value = dict["DiskId"] as? String {
            self.diskId = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PerformanceLevel"] as? String {
            self.performanceLevel = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StorageClusterId"] as? String {
            self.storageClusterId = value
        }
    }
}

public class ModifyDiskDeploymentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class ModifyDiskDeploymentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDiskDeploymentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDiskDeploymentResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDiskSpecRequest : Tea.TeaModel {
    public class PerformanceControlOptions : Tea.TeaModel {
        public var IOPS: Int32?

        public var recover: String?

        public var throughput: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.IOPS != nil {
                map["IOPS"] = self.IOPS!
            }
            if self.recover != nil {
                map["Recover"] = self.recover!
            }
            if self.throughput != nil {
                map["Throughput"] = self.throughput!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IOPS"] as? Int32 {
                self.IOPS = value
            }
            if let value = dict["Recover"] as? String {
                self.recover = value
            }
            if let value = dict["Throughput"] as? Int32 {
                self.throughput = value
            }
        }
    }
    public var destinationZoneId: String?

    public var diskCategory: String?

    public var diskId: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var performanceControlOptions: ModifyDiskSpecRequest.PerformanceControlOptions?

    public var performanceLevel: String?

    public var provisionedIops: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.performanceControlOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationZoneId != nil {
            map["DestinationZoneId"] = self.destinationZoneId!
        }
        if self.diskCategory != nil {
            map["DiskCategory"] = self.diskCategory!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.performanceControlOptions != nil {
            map["PerformanceControlOptions"] = self.performanceControlOptions?.toMap()
        }
        if self.performanceLevel != nil {
            map["PerformanceLevel"] = self.performanceLevel!
        }
        if self.provisionedIops != nil {
            map["ProvisionedIops"] = self.provisionedIops!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DestinationZoneId"] as? String {
            self.destinationZoneId = value
        }
        if let value = dict["DiskCategory"] as? String {
            self.diskCategory = value
        }
        if let value = dict["DiskId"] as? String {
            self.diskId = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PerformanceControlOptions"] as? [String: Any?] {
            var model = ModifyDiskSpecRequest.PerformanceControlOptions()
            model.fromMap(value)
            self.performanceControlOptions = model
        }
        if let value = dict["PerformanceLevel"] as? String {
            self.performanceLevel = value
        }
        if let value = dict["ProvisionedIops"] as? Int64 {
            self.provisionedIops = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyDiskSpecResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class ModifyDiskSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDiskSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDiskSpecResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyEipAddressAttributeRequest : Tea.TeaModel {
    public var allocationId: String?

    public var bandwidth: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AllocationId"] as? String {
            self.allocationId = value
        }
        if let value = dict["Bandwidth"] as? String {
            self.bandwidth = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyEipAddressAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyEipAddressAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyEipAddressAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyEipAddressAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyElasticityAssuranceRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
        }
    }
    public class RecurrenceRules : Tea.TeaModel {
        public var endHour: Int32?

        public var recurrenceType: String?

        public var recurrenceValue: String?

        public var startHour: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endHour != nil {
                map["EndHour"] = self.endHour!
            }
            if self.recurrenceType != nil {
                map["RecurrenceType"] = self.recurrenceType!
            }
            if self.recurrenceValue != nil {
                map["RecurrenceValue"] = self.recurrenceValue!
            }
            if self.startHour != nil {
                map["StartHour"] = self.startHour!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EndHour"] as? Int32 {
                self.endHour = value
            }
            if let value = dict["RecurrenceType"] as? String {
                self.recurrenceType = value
            }
            if let value = dict["RecurrenceValue"] as? String {
                self.recurrenceValue = value
            }
            if let value = dict["StartHour"] as? Int32 {
                self.startHour = value
            }
        }
    }
    public var privatePoolOptions: ModifyElasticityAssuranceRequest.PrivatePoolOptions?

    public var clientToken: String?

    public var description_: String?

    public var instanceAmount: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var recurrenceRules: [ModifyElasticityAssuranceRequest.RecurrenceRules]?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceAmount != nil {
            map["InstanceAmount"] = self.instanceAmount!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.recurrenceRules != nil {
            var tmp : [Any] = []
            for k in self.recurrenceRules! {
                tmp.append(k.toMap())
            }
            map["RecurrenceRules"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PrivatePoolOptions"] as? [String: Any?] {
            var model = ModifyElasticityAssuranceRequest.PrivatePoolOptions()
            model.fromMap(value)
            self.privatePoolOptions = model
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["InstanceAmount"] as? Int32 {
            self.instanceAmount = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RecurrenceRules"] as? [Any?] {
            var tmp : [ModifyElasticityAssuranceRequest.RecurrenceRules] = []
            for v in value {
                if v != nil {
                    var model = ModifyElasticityAssuranceRequest.RecurrenceRules()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.recurrenceRules = tmp
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyElasticityAssuranceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyElasticityAssuranceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyElasticityAssuranceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyElasticityAssuranceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyElasticityAssuranceAutoRenewAttributeRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Id"] as? [String] {
                self.id = value
            }
        }
    }
    public var privatePoolOptions: ModifyElasticityAssuranceAutoRenewAttributeRequest.PrivatePoolOptions?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var renewalStatus: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.renewalStatus != nil {
            map["RenewalStatus"] = self.renewalStatus!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PrivatePoolOptions"] as? [String: Any?] {
            var model = ModifyElasticityAssuranceAutoRenewAttributeRequest.PrivatePoolOptions()
            model.fromMap(value)
            self.privatePoolOptions = model
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PeriodUnit"] as? String {
            self.periodUnit = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RenewalStatus"] as? String {
            self.renewalStatus = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyElasticityAssuranceAutoRenewAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyElasticityAssuranceAutoRenewAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyElasticityAssuranceAutoRenewAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyElasticityAssuranceAutoRenewAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyForwardEntryRequest : Tea.TeaModel {
    public var externalIp: String?

    public var externalPort: String?

    public var forwardEntryId: String?

    public var forwardTableId: String?

    public var internalIp: String?

    public var internalPort: String?

    public var ipProtocol: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.externalIp != nil {
            map["ExternalIp"] = self.externalIp!
        }
        if self.externalPort != nil {
            map["ExternalPort"] = self.externalPort!
        }
        if self.forwardEntryId != nil {
            map["ForwardEntryId"] = self.forwardEntryId!
        }
        if self.forwardTableId != nil {
            map["ForwardTableId"] = self.forwardTableId!
        }
        if self.internalIp != nil {
            map["InternalIp"] = self.internalIp!
        }
        if self.internalPort != nil {
            map["InternalPort"] = self.internalPort!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ExternalIp"] as? String {
            self.externalIp = value
        }
        if let value = dict["ExternalPort"] as? String {
            self.externalPort = value
        }
        if let value = dict["ForwardEntryId"] as? String {
            self.forwardEntryId = value
        }
        if let value = dict["ForwardTableId"] as? String {
            self.forwardTableId = value
        }
        if let value = dict["InternalIp"] as? String {
            self.internalIp = value
        }
        if let value = dict["InternalPort"] as? String {
            self.internalPort = value
        }
        if let value = dict["IpProtocol"] as? String {
            self.ipProtocol = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyForwardEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyForwardEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyForwardEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyForwardEntryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyHaVipAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var haVipId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.haVipId != nil {
            map["HaVipId"] = self.haVipId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["HaVipId"] as? String {
            self.haVipId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyHaVipAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyHaVipAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyHaVipAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyHaVipAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyHpcClusterAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var hpcClusterId: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.hpcClusterId != nil {
            map["HpcClusterId"] = self.hpcClusterId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["HpcClusterId"] as? String {
            self.hpcClusterId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyHpcClusterAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyHpcClusterAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyHpcClusterAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyHpcClusterAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyImageAttributeRequest : Tea.TeaModel {
    public class Features : Tea.TeaModel {
        public var imdsSupport: String?

        public var nvmeSupport: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.imdsSupport != nil {
                map["ImdsSupport"] = self.imdsSupport!
            }
            if self.nvmeSupport != nil {
                map["NvmeSupport"] = self.nvmeSupport!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ImdsSupport"] as? String {
                self.imdsSupport = value
            }
            if let value = dict["NvmeSupport"] as? String {
                self.nvmeSupport = value
            }
        }
    }
    public var bootMode: String?

    public var description_: String?

    public var dryRun: Bool?

    public var features: ModifyImageAttributeRequest.Features?

    public var imageFamily: String?

    public var imageId: String?

    public var imageName: String?

    public var licenseType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.features?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bootMode != nil {
            map["BootMode"] = self.bootMode!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.features != nil {
            map["Features"] = self.features?.toMap()
        }
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.licenseType != nil {
            map["LicenseType"] = self.licenseType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BootMode"] as? String {
            self.bootMode = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Features"] as? [String: Any?] {
            var model = ModifyImageAttributeRequest.Features()
            model.fromMap(value)
            self.features = model
        }
        if let value = dict["ImageFamily"] as? String {
            self.imageFamily = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["ImageName"] as? String {
            self.imageName = value
        }
        if let value = dict["LicenseType"] as? String {
            self.licenseType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class ModifyImageAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyImageAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyImageAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyImageAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyImageShareGroupPermissionRequest : Tea.TeaModel {
    public var addGroup: [String]?

    public var removeGroup: [String]?

    public var imageId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addGroup != nil {
            map["AddGroup"] = self.addGroup!
        }
        if self.removeGroup != nil {
            map["RemoveGroup"] = self.removeGroup!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddGroup"] as? [String] {
            self.addGroup = value
        }
        if let value = dict["RemoveGroup"] as? [String] {
            self.removeGroup = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyImageShareGroupPermissionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyImageShareGroupPermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyImageShareGroupPermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyImageShareGroupPermissionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyImageSharePermissionRequest : Tea.TeaModel {
    public var addAccount: [String]?

    public var dryRun: Bool?

    public var imageId: String?

    public var isPublic: Bool?

    public var launchPermission: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var removeAccount: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addAccount != nil {
            map["AddAccount"] = self.addAccount!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.isPublic != nil {
            map["IsPublic"] = self.isPublic!
        }
        if self.launchPermission != nil {
            map["LaunchPermission"] = self.launchPermission!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.removeAccount != nil {
            map["RemoveAccount"] = self.removeAccount!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddAccount"] as? [String] {
            self.addAccount = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["IsPublic"] as? Bool {
            self.isPublic = value
        }
        if let value = dict["LaunchPermission"] as? String {
            self.launchPermission = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RemoveAccount"] as? [String] {
            self.removeAccount = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyImageSharePermissionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyImageSharePermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyImageSharePermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyImageSharePermissionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyInstanceAttachmentAttributesRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public var matchCriteria: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["MatchCriteria"] as? String {
                self.matchCriteria = value
            }
        }
    }
    public var privatePoolOptions: ModifyInstanceAttachmentAttributesRequest.PrivatePoolOptions?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PrivatePoolOptions"] as? [String: Any?] {
            var model = ModifyInstanceAttachmentAttributesRequest.PrivatePoolOptions()
            model.fromMap(value)
            self.privatePoolOptions = model
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyInstanceAttachmentAttributesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyInstanceAttachmentAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceAttachmentAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyInstanceAttachmentAttributesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyInstanceAttributeRequest : Tea.TeaModel {
    public class CpuOptions : Tea.TeaModel {
        public var core: Int32?

        public var threadsPerCore: Int32?

        public var topologyType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.core != nil {
                map["Core"] = self.core!
            }
            if self.threadsPerCore != nil {
                map["ThreadsPerCore"] = self.threadsPerCore!
            }
            if self.topologyType != nil {
                map["TopologyType"] = self.topologyType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Core"] as? Int32 {
                self.core = value
            }
            if let value = dict["ThreadsPerCore"] as? Int32 {
                self.threadsPerCore = value
            }
            if let value = dict["TopologyType"] as? String {
                self.topologyType = value
            }
        }
    }
    public class PrivateDnsNameOptions : Tea.TeaModel {
        public var enableInstanceIdDnsAAAARecord: Bool?

        public var enableInstanceIdDnsARecord: Bool?

        public var enableIpDnsARecord: Bool?

        public var enableIpDnsPtrRecord: Bool?

        public var hostnameType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableInstanceIdDnsAAAARecord != nil {
                map["EnableInstanceIdDnsAAAARecord"] = self.enableInstanceIdDnsAAAARecord!
            }
            if self.enableInstanceIdDnsARecord != nil {
                map["EnableInstanceIdDnsARecord"] = self.enableInstanceIdDnsARecord!
            }
            if self.enableIpDnsARecord != nil {
                map["EnableIpDnsARecord"] = self.enableIpDnsARecord!
            }
            if self.enableIpDnsPtrRecord != nil {
                map["EnableIpDnsPtrRecord"] = self.enableIpDnsPtrRecord!
            }
            if self.hostnameType != nil {
                map["HostnameType"] = self.hostnameType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EnableInstanceIdDnsAAAARecord"] as? Bool {
                self.enableInstanceIdDnsAAAARecord = value
            }
            if let value = dict["EnableInstanceIdDnsARecord"] as? Bool {
                self.enableInstanceIdDnsARecord = value
            }
            if let value = dict["EnableIpDnsARecord"] as? Bool {
                self.enableIpDnsARecord = value
            }
            if let value = dict["EnableIpDnsPtrRecord"] as? Bool {
                self.enableIpDnsPtrRecord = value
            }
            if let value = dict["HostnameType"] as? String {
                self.hostnameType = value
            }
        }
    }
    public class RemoteConnectionOptions : Tea.TeaModel {
        public var password: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Password"] as? String {
                self.password = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var cpuOptions: ModifyInstanceAttributeRequest.CpuOptions?

    public var creditSpecification: String?

    public var deletionProtection: Bool?

    public var description_: String?

    public var enableJumboFrame: Bool?

    public var enableNetworkEncryption: Bool?

    public var hostName: String?

    public var instanceId: String?

    public var instanceName: String?

    public var networkInterfaceQueueNumber: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var password: String?

    public var privateDnsNameOptions: ModifyInstanceAttributeRequest.PrivateDnsNameOptions?

    public var recyclable: Bool?

    public var remoteConnectionOptions: ModifyInstanceAttributeRequest.RemoteConnectionOptions?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupIds: [String]?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.cpuOptions?.validate()
        try self.privateDnsNameOptions?.validate()
        try self.remoteConnectionOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cpuOptions != nil {
            map["CpuOptions"] = self.cpuOptions?.toMap()
        }
        if self.creditSpecification != nil {
            map["CreditSpecification"] = self.creditSpecification!
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enableJumboFrame != nil {
            map["EnableJumboFrame"] = self.enableJumboFrame!
        }
        if self.enableNetworkEncryption != nil {
            map["EnableNetworkEncryption"] = self.enableNetworkEncryption!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.networkInterfaceQueueNumber != nil {
            map["NetworkInterfaceQueueNumber"] = self.networkInterfaceQueueNumber!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.privateDnsNameOptions != nil {
            map["PrivateDnsNameOptions"] = self.privateDnsNameOptions?.toMap()
        }
        if self.recyclable != nil {
            map["Recyclable"] = self.recyclable!
        }
        if self.remoteConnectionOptions != nil {
            map["RemoteConnectionOptions"] = self.remoteConnectionOptions?.toMap()
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CpuOptions"] as? [String: Any?] {
            var model = ModifyInstanceAttributeRequest.CpuOptions()
            model.fromMap(value)
            self.cpuOptions = model
        }
        if let value = dict["CreditSpecification"] as? String {
            self.creditSpecification = value
        }
        if let value = dict["DeletionProtection"] as? Bool {
            self.deletionProtection = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EnableJumboFrame"] as? Bool {
            self.enableJumboFrame = value
        }
        if let value = dict["EnableNetworkEncryption"] as? Bool {
            self.enableNetworkEncryption = value
        }
        if let value = dict["HostName"] as? String {
            self.hostName = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["NetworkInterfaceQueueNumber"] as? Int32 {
            self.networkInterfaceQueueNumber = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Password"] as? String {
            self.password = value
        }
        if let value = dict["PrivateDnsNameOptions"] as? [String: Any?] {
            var model = ModifyInstanceAttributeRequest.PrivateDnsNameOptions()
            model.fromMap(value)
            self.privateDnsNameOptions = model
        }
        if let value = dict["Recyclable"] as? Bool {
            self.recyclable = value
        }
        if let value = dict["RemoteConnectionOptions"] as? [String: Any?] {
            var model = ModifyInstanceAttributeRequest.RemoteConnectionOptions()
            model.fromMap(value)
            self.remoteConnectionOptions = model
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityGroupIds"] as? [String] {
            self.securityGroupIds = value
        }
        if let value = dict["UserData"] as? String {
            self.userData = value
        }
    }
}

public class ModifyInstanceAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyInstanceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyInstanceAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyInstanceAutoReleaseTimeRequest : Tea.TeaModel {
    public var autoReleaseTime: String?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoReleaseTime != nil {
            map["AutoReleaseTime"] = self.autoReleaseTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoReleaseTime"] as? String {
            self.autoReleaseTime = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyInstanceAutoReleaseTimeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyInstanceAutoReleaseTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceAutoReleaseTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyInstanceAutoReleaseTimeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyInstanceAutoRenewAttributeRequest : Tea.TeaModel {
    public var autoRenew: Bool?

    public var duration: Int32?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var periodUnit: String?

    public var regionId: String?

    public var renewalStatus: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.renewalStatus != nil {
            map["RenewalStatus"] = self.renewalStatus!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoRenew"] as? Bool {
            self.autoRenew = value
        }
        if let value = dict["Duration"] as? Int32 {
            self.duration = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PeriodUnit"] as? String {
            self.periodUnit = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RenewalStatus"] as? String {
            self.renewalStatus = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyInstanceAutoRenewAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyInstanceAutoRenewAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceAutoRenewAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyInstanceAutoRenewAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyInstanceChargeTypeRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var clientToken: String?

    public var dryRun: Bool?

    public var includeDataDisks: Bool?

    public var instanceChargeType: String?

    public var instanceIds: String?

    public var isDetailFee: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.includeDataDisks != nil {
            map["IncludeDataDisks"] = self.includeDataDisks!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.isDetailFee != nil {
            map["IsDetailFee"] = self.isDetailFee!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["IncludeDataDisks"] as? Bool {
            self.includeDataDisks = value
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
        if let value = dict["IsDetailFee"] as? Bool {
            self.isDetailFee = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PeriodUnit"] as? String {
            self.periodUnit = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyInstanceChargeTypeResponseBody : Tea.TeaModel {
    public class FeeOfInstances : Tea.TeaModel {
        public class FeeOfInstance : Tea.TeaModel {
            public var currency: String?

            public var fee: String?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.currency != nil {
                    map["Currency"] = self.currency!
                }
                if self.fee != nil {
                    map["Fee"] = self.fee!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Currency"] as? String {
                    self.currency = value
                }
                if let value = dict["Fee"] as? String {
                    self.fee = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
            }
        }
        public var feeOfInstance: [ModifyInstanceChargeTypeResponseBody.FeeOfInstances.FeeOfInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.feeOfInstance != nil {
                var tmp : [Any] = []
                for k in self.feeOfInstance! {
                    tmp.append(k.toMap())
                }
                map["FeeOfInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["FeeOfInstance"] as? [Any?] {
                var tmp : [ModifyInstanceChargeTypeResponseBody.FeeOfInstances.FeeOfInstance] = []
                for v in value {
                    if v != nil {
                        var model = ModifyInstanceChargeTypeResponseBody.FeeOfInstances.FeeOfInstance()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.feeOfInstance = tmp
            }
        }
    }
    public var feeOfInstances: ModifyInstanceChargeTypeResponseBody.FeeOfInstances?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.feeOfInstances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.feeOfInstances != nil {
            map["FeeOfInstances"] = self.feeOfInstances?.toMap()
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FeeOfInstances"] as? [String: Any?] {
            var model = ModifyInstanceChargeTypeResponseBody.FeeOfInstances()
            model.fromMap(value)
            self.feeOfInstances = model
        }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyInstanceChargeTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceChargeTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyInstanceChargeTypeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyInstanceDeploymentRequest : Tea.TeaModel {
    public var affinity: String?

    public var dedicatedHostClusterId: String?

    public var dedicatedHostId: String?

    public var deploymentSetGroupNo: Int32?

    public var deploymentSetId: String?

    public var force: Bool?

    public var instanceId: String?

    public var instanceType: String?

    public var migrationType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var removeFromDeploymentSet: Bool?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tenancy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.affinity != nil {
            map["Affinity"] = self.affinity!
        }
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.deploymentSetGroupNo != nil {
            map["DeploymentSetGroupNo"] = self.deploymentSetGroupNo!
        }
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.migrationType != nil {
            map["MigrationType"] = self.migrationType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.removeFromDeploymentSet != nil {
            map["RemoveFromDeploymentSet"] = self.removeFromDeploymentSet!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tenancy != nil {
            map["Tenancy"] = self.tenancy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Affinity"] as? String {
            self.affinity = value
        }
        if let value = dict["DedicatedHostClusterId"] as? String {
            self.dedicatedHostClusterId = value
        }
        if let value = dict["DedicatedHostId"] as? String {
            self.dedicatedHostId = value
        }
        if let value = dict["DeploymentSetGroupNo"] as? Int32 {
            self.deploymentSetGroupNo = value
        }
        if let value = dict["DeploymentSetId"] as? String {
            self.deploymentSetId = value
        }
        if let value = dict["Force"] as? Bool {
            self.force = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["MigrationType"] as? String {
            self.migrationType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RemoveFromDeploymentSet"] as? Bool {
            self.removeFromDeploymentSet = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tenancy"] as? String {
            self.tenancy = value
        }
    }
}

public class ModifyInstanceDeploymentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyInstanceDeploymentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceDeploymentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyInstanceDeploymentResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyInstanceMaintenanceAttributesRequest : Tea.TeaModel {
    public class MaintenanceWindow : Tea.TeaModel {
        public var endTime: String?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EndTime"] as? String {
                self.endTime = value
            }
            if let value = dict["StartTime"] as? String {
                self.startTime = value
            }
        }
    }
    public var actionOnMaintenance: String?

    public var instanceId: [String]?

    public var maintenanceWindow: [ModifyInstanceMaintenanceAttributesRequest.MaintenanceWindow]?

    public var notifyOnMaintenance: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionOnMaintenance != nil {
            map["ActionOnMaintenance"] = self.actionOnMaintenance!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maintenanceWindow != nil {
            var tmp : [Any] = []
            for k in self.maintenanceWindow! {
                tmp.append(k.toMap())
            }
            map["MaintenanceWindow"] = tmp
        }
        if self.notifyOnMaintenance != nil {
            map["NotifyOnMaintenance"] = self.notifyOnMaintenance!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ActionOnMaintenance"] as? String {
            self.actionOnMaintenance = value
        }
        if let value = dict["InstanceId"] as? [String] {
            self.instanceId = value
        }
        if let value = dict["MaintenanceWindow"] as? [Any?] {
            var tmp : [ModifyInstanceMaintenanceAttributesRequest.MaintenanceWindow] = []
            for v in value {
                if v != nil {
                    var model = ModifyInstanceMaintenanceAttributesRequest.MaintenanceWindow()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.maintenanceWindow = tmp
        }
        if let value = dict["NotifyOnMaintenance"] as? Bool {
            self.notifyOnMaintenance = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyInstanceMaintenanceAttributesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyInstanceMaintenanceAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceMaintenanceAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyInstanceMaintenanceAttributesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyInstanceMetadataOptionsRequest : Tea.TeaModel {
    public var httpEndpoint: String?

    public var httpPutResponseHopLimit: Int32?

    public var httpTokens: String?

    public var instanceId: String?

    public var instanceMetadataTags: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.httpEndpoint != nil {
            map["HttpEndpoint"] = self.httpEndpoint!
        }
        if self.httpPutResponseHopLimit != nil {
            map["HttpPutResponseHopLimit"] = self.httpPutResponseHopLimit!
        }
        if self.httpTokens != nil {
            map["HttpTokens"] = self.httpTokens!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceMetadataTags != nil {
            map["InstanceMetadataTags"] = self.instanceMetadataTags!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["HttpEndpoint"] as? String {
            self.httpEndpoint = value
        }
        if let value = dict["HttpPutResponseHopLimit"] as? Int32 {
            self.httpPutResponseHopLimit = value
        }
        if let value = dict["HttpTokens"] as? String {
            self.httpTokens = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceMetadataTags"] as? String {
            self.instanceMetadataTags = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyInstanceMetadataOptionsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyInstanceMetadataOptionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceMetadataOptionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyInstanceMetadataOptionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyInstanceNetworkSpecRequest : Tea.TeaModel {
    public var allocatePublicIp: Bool?

    public var autoPay: Bool?

    public var clientToken: String?

    public var endTime: String?

    public var ISP: String?

    public var instanceId: String?

    public var internetMaxBandwidthIn: Int32?

    public var internetMaxBandwidthOut: Int32?

    public var networkChargeType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocatePublicIp != nil {
            map["AllocatePublicIp"] = self.allocatePublicIp!
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ISP != nil {
            map["ISP"] = self.ISP!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.internetMaxBandwidthIn != nil {
            map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.networkChargeType != nil {
            map["NetworkChargeType"] = self.networkChargeType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AllocatePublicIp"] as? Bool {
            self.allocatePublicIp = value
        }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["ISP"] as? String {
            self.ISP = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InternetMaxBandwidthIn"] as? Int32 {
            self.internetMaxBandwidthIn = value
        }
        if let value = dict["InternetMaxBandwidthOut"] as? Int32 {
            self.internetMaxBandwidthOut = value
        }
        if let value = dict["NetworkChargeType"] as? String {
            self.networkChargeType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class ModifyInstanceNetworkSpecResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyInstanceNetworkSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceNetworkSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyInstanceNetworkSpecResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyInstanceSpecRequest : Tea.TeaModel {
    public class SystemDisk : Tea.TeaModel {
        public var category: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Category"] as? String {
                self.category = value
            }
        }
    }
    public class Temporary : Tea.TeaModel {
        public var endTime: String?

        public var internetMaxBandwidthOut: Int32?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.internetMaxBandwidthOut != nil {
                map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EndTime"] as? String {
                self.endTime = value
            }
            if let value = dict["InternetMaxBandwidthOut"] as? Int32 {
                self.internetMaxBandwidthOut = value
            }
            if let value = dict["StartTime"] as? String {
                self.startTime = value
            }
        }
    }
    public class Disk : Tea.TeaModel {
        public var category: String?

        public var diskId: String?

        public var performanceLevel: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.diskId != nil {
                map["DiskId"] = self.diskId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["DiskId"] as? String {
                self.diskId = value
            }
            if let value = dict["PerformanceLevel"] as? String {
                self.performanceLevel = value
            }
        }
    }
    public var systemDisk: ModifyInstanceSpecRequest.SystemDisk?

    public var temporary: ModifyInstanceSpecRequest.Temporary?

    public var allowMigrateAcrossZone: Bool?

    public var async: Bool?

    public var clientToken: String?

    public var disk: [ModifyInstanceSpecRequest.Disk]?

    public var dryRun: Bool?

    public var instanceId: String?

    public var instanceType: String?

    public var internetMaxBandwidthIn: Int32?

    public var internetMaxBandwidthOut: Int32?

    public var modifyMode: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemDisk?.validate()
        try self.temporary?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.temporary != nil {
            map["Temporary"] = self.temporary?.toMap()
        }
        if self.allowMigrateAcrossZone != nil {
            map["AllowMigrateAcrossZone"] = self.allowMigrateAcrossZone!
        }
        if self.async != nil {
            map["Async"] = self.async!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.disk != nil {
            var tmp : [Any] = []
            for k in self.disk! {
                tmp.append(k.toMap())
            }
            map["Disk"] = tmp
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetMaxBandwidthIn != nil {
            map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.modifyMode != nil {
            map["ModifyMode"] = self.modifyMode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["SystemDisk"] as? [String: Any?] {
            var model = ModifyInstanceSpecRequest.SystemDisk()
            model.fromMap(value)
            self.systemDisk = model
        }
        if let value = dict["Temporary"] as? [String: Any?] {
            var model = ModifyInstanceSpecRequest.Temporary()
            model.fromMap(value)
            self.temporary = model
        }
        if let value = dict["AllowMigrateAcrossZone"] as? Bool {
            self.allowMigrateAcrossZone = value
        }
        if let value = dict["Async"] as? Bool {
            self.async = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Disk"] as? [Any?] {
            var tmp : [ModifyInstanceSpecRequest.Disk] = []
            for v in value {
                if v != nil {
                    var model = ModifyInstanceSpecRequest.Disk()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.disk = tmp
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["InternetMaxBandwidthIn"] as? Int32 {
            self.internetMaxBandwidthIn = value
        }
        if let value = dict["InternetMaxBandwidthOut"] as? Int32 {
            self.internetMaxBandwidthOut = value
        }
        if let value = dict["ModifyMode"] as? String {
            self.modifyMode = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyInstanceSpecResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyInstanceSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyInstanceSpecResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyInstanceVncPasswdRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vncPassword: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vncPassword != nil {
            map["VncPassword"] = self.vncPassword!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VncPassword"] as? String {
            self.vncPassword = value
        }
    }
}

public class ModifyInstanceVncPasswdResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyInstanceVncPasswdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceVncPasswdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyInstanceVncPasswdResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyInstanceVpcAttributeRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var privateIpAddress: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: [String]?

    public var vSwitchId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PrivateIpAddress"] as? String {
            self.privateIpAddress = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityGroupId"] as? [String] {
            self.securityGroupId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class ModifyInstanceVpcAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyInstanceVpcAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceVpcAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyInstanceVpcAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyInvocationAttributeRequest : Tea.TeaModel {
    public var commandContent: String?

    public var contentEncoding: String?

    public var enableParameter: Bool?

    public var frequency: String?

    public var instanceId: [String]?

    public var invokeId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var parameters: [String: Any]?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandContent != nil {
            map["CommandContent"] = self.commandContent!
        }
        if self.contentEncoding != nil {
            map["ContentEncoding"] = self.contentEncoding!
        }
        if self.enableParameter != nil {
            map["EnableParameter"] = self.enableParameter!
        }
        if self.frequency != nil {
            map["Frequency"] = self.frequency!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.invokeId != nil {
            map["InvokeId"] = self.invokeId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CommandContent"] as? String {
            self.commandContent = value
        }
        if let value = dict["ContentEncoding"] as? String {
            self.contentEncoding = value
        }
        if let value = dict["EnableParameter"] as? Bool {
            self.enableParameter = value
        }
        if let value = dict["Frequency"] as? String {
            self.frequency = value
        }
        if let value = dict["InstanceId"] as? [String] {
            self.instanceId = value
        }
        if let value = dict["InvokeId"] as? String {
            self.invokeId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Parameters"] as? [String: Any] {
            self.parameters = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyInvocationAttributeShrinkRequest : Tea.TeaModel {
    public var commandContent: String?

    public var contentEncoding: String?

    public var enableParameter: Bool?

    public var frequency: String?

    public var instanceId: [String]?

    public var invokeId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var parametersShrink: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandContent != nil {
            map["CommandContent"] = self.commandContent!
        }
        if self.contentEncoding != nil {
            map["ContentEncoding"] = self.contentEncoding!
        }
        if self.enableParameter != nil {
            map["EnableParameter"] = self.enableParameter!
        }
        if self.frequency != nil {
            map["Frequency"] = self.frequency!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.invokeId != nil {
            map["InvokeId"] = self.invokeId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.parametersShrink != nil {
            map["Parameters"] = self.parametersShrink!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CommandContent"] as? String {
            self.commandContent = value
        }
        if let value = dict["ContentEncoding"] as? String {
            self.contentEncoding = value
        }
        if let value = dict["EnableParameter"] as? Bool {
            self.enableParameter = value
        }
        if let value = dict["Frequency"] as? String {
            self.frequency = value
        }
        if let value = dict["InstanceId"] as? [String] {
            self.instanceId = value
        }
        if let value = dict["InvokeId"] as? String {
            self.invokeId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Parameters"] as? String {
            self.parametersShrink = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyInvocationAttributeResponseBody : Tea.TeaModel {
    public var commandId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandId != nil {
            map["CommandId"] = self.commandId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CommandId"] as? String {
            self.commandId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyInvocationAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInvocationAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyInvocationAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyLaunchTemplateDefaultVersionRequest : Tea.TeaModel {
    public var defaultVersionNumber: Int64?

    public var launchTemplateId: String?

    public var launchTemplateName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.defaultVersionNumber != nil {
            map["DefaultVersionNumber"] = self.defaultVersionNumber!
        }
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateName != nil {
            map["LaunchTemplateName"] = self.launchTemplateName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DefaultVersionNumber"] as? Int64 {
            self.defaultVersionNumber = value
        }
        if let value = dict["LaunchTemplateId"] as? String {
            self.launchTemplateId = value
        }
        if let value = dict["LaunchTemplateName"] as? String {
            self.launchTemplateName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyLaunchTemplateDefaultVersionResponseBody : Tea.TeaModel {
    public var launchTemplateId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LaunchTemplateId"] as? String {
            self.launchTemplateId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyLaunchTemplateDefaultVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyLaunchTemplateDefaultVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyLaunchTemplateDefaultVersionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyManagedInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var instanceName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyManagedInstanceResponseBody : Tea.TeaModel {
    public class Instance : Tea.TeaModel {
        public var instanceId: String?

        public var instanceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["InstanceName"] as? String {
                self.instanceName = value
            }
        }
    }
    public var instance: ModifyManagedInstanceResponseBody.Instance?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instance?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instance != nil {
            map["Instance"] = self.instance?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Instance"] as? [String: Any?] {
            var model = ModifyManagedInstanceResponseBody.Instance()
            model.fromMap(value)
            self.instance = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyManagedInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyManagedInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyManagedInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyNetworkInterfaceAttributeRequest : Tea.TeaModel {
    public class ConnectionTrackingConfiguration : Tea.TeaModel {
        public var tcpClosedAndTimeWaitTimeout: Int32?

        public var tcpEstablishedTimeout: Int32?

        public var udpTimeout: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tcpClosedAndTimeWaitTimeout != nil {
                map["TcpClosedAndTimeWaitTimeout"] = self.tcpClosedAndTimeWaitTimeout!
            }
            if self.tcpEstablishedTimeout != nil {
                map["TcpEstablishedTimeout"] = self.tcpEstablishedTimeout!
            }
            if self.udpTimeout != nil {
                map["UdpTimeout"] = self.udpTimeout!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TcpClosedAndTimeWaitTimeout"] as? Int32 {
                self.tcpClosedAndTimeWaitTimeout = value
            }
            if let value = dict["TcpEstablishedTimeout"] as? Int32 {
                self.tcpEstablishedTimeout = value
            }
            if let value = dict["UdpTimeout"] as? Int32 {
                self.udpTimeout = value
            }
        }
    }
    public class EnhancedNetwork : Tea.TeaModel {
        public var enableRss: Bool?

        public var enableSriov: Bool?

        public var virtualFunctionQuantity: Int32?

        public var virtualFunctionTotalQueueNumber: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableRss != nil {
                map["EnableRss"] = self.enableRss!
            }
            if self.enableSriov != nil {
                map["EnableSriov"] = self.enableSriov!
            }
            if self.virtualFunctionQuantity != nil {
                map["VirtualFunctionQuantity"] = self.virtualFunctionQuantity!
            }
            if self.virtualFunctionTotalQueueNumber != nil {
                map["VirtualFunctionTotalQueueNumber"] = self.virtualFunctionTotalQueueNumber!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EnableRss"] as? Bool {
                self.enableRss = value
            }
            if let value = dict["EnableSriov"] as? Bool {
                self.enableSriov = value
            }
            if let value = dict["VirtualFunctionQuantity"] as? Int32 {
                self.virtualFunctionQuantity = value
            }
            if let value = dict["VirtualFunctionTotalQueueNumber"] as? Int32 {
                self.virtualFunctionTotalQueueNumber = value
            }
        }
    }
    public class NetworkInterfaceTrafficConfig : Tea.TeaModel {
        public var networkInterfaceTrafficMode: String?

        public var queueNumber: Int32?

        public var queuePairNumber: Int32?

        public var rxQueueSize: Int32?

        public var txQueueSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.networkInterfaceTrafficMode != nil {
                map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
            }
            if self.queueNumber != nil {
                map["QueueNumber"] = self.queueNumber!
            }
            if self.queuePairNumber != nil {
                map["QueuePairNumber"] = self.queuePairNumber!
            }
            if self.rxQueueSize != nil {
                map["RxQueueSize"] = self.rxQueueSize!
            }
            if self.txQueueSize != nil {
                map["TxQueueSize"] = self.txQueueSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["NetworkInterfaceTrafficMode"] as? String {
                self.networkInterfaceTrafficMode = value
            }
            if let value = dict["QueueNumber"] as? Int32 {
                self.queueNumber = value
            }
            if let value = dict["QueuePairNumber"] as? Int32 {
                self.queuePairNumber = value
            }
            if let value = dict["RxQueueSize"] as? Int32 {
                self.rxQueueSize = value
            }
            if let value = dict["TxQueueSize"] as? Int32 {
                self.txQueueSize = value
            }
        }
    }
    public var connectionTrackingConfiguration: ModifyNetworkInterfaceAttributeRequest.ConnectionTrackingConfiguration?

    public var deleteOnRelease: Bool?

    public var description_: String?

    public var enhancedNetwork: ModifyNetworkInterfaceAttributeRequest.EnhancedNetwork?

    public var networkInterfaceId: String?

    public var networkInterfaceName: String?

    public var networkInterfaceTrafficConfig: ModifyNetworkInterfaceAttributeRequest.NetworkInterfaceTrafficConfig?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var queueNumber: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var rxQueueSize: Int32?

    public var securityGroupId: [String]?

    public var sourceDestCheck: Bool?

    public var txQueueSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.connectionTrackingConfiguration?.validate()
        try self.enhancedNetwork?.validate()
        try self.networkInterfaceTrafficConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectionTrackingConfiguration != nil {
            map["ConnectionTrackingConfiguration"] = self.connectionTrackingConfiguration?.toMap()
        }
        if self.deleteOnRelease != nil {
            map["DeleteOnRelease"] = self.deleteOnRelease!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enhancedNetwork != nil {
            map["EnhancedNetwork"] = self.enhancedNetwork?.toMap()
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.networkInterfaceName != nil {
            map["NetworkInterfaceName"] = self.networkInterfaceName!
        }
        if self.networkInterfaceTrafficConfig != nil {
            map["NetworkInterfaceTrafficConfig"] = self.networkInterfaceTrafficConfig?.toMap()
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.queueNumber != nil {
            map["QueueNumber"] = self.queueNumber!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.rxQueueSize != nil {
            map["RxQueueSize"] = self.rxQueueSize!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.sourceDestCheck != nil {
            map["SourceDestCheck"] = self.sourceDestCheck!
        }
        if self.txQueueSize != nil {
            map["TxQueueSize"] = self.txQueueSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConnectionTrackingConfiguration"] as? [String: Any?] {
            var model = ModifyNetworkInterfaceAttributeRequest.ConnectionTrackingConfiguration()
            model.fromMap(value)
            self.connectionTrackingConfiguration = model
        }
        if let value = dict["DeleteOnRelease"] as? Bool {
            self.deleteOnRelease = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EnhancedNetwork"] as? [String: Any?] {
            var model = ModifyNetworkInterfaceAttributeRequest.EnhancedNetwork()
            model.fromMap(value)
            self.enhancedNetwork = model
        }
        if let value = dict["NetworkInterfaceId"] as? String {
            self.networkInterfaceId = value
        }
        if let value = dict["NetworkInterfaceName"] as? String {
            self.networkInterfaceName = value
        }
        if let value = dict["NetworkInterfaceTrafficConfig"] as? [String: Any?] {
            var model = ModifyNetworkInterfaceAttributeRequest.NetworkInterfaceTrafficConfig()
            model.fromMap(value)
            self.networkInterfaceTrafficConfig = model
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["QueueNumber"] as? Int32 {
            self.queueNumber = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RxQueueSize"] as? Int32 {
            self.rxQueueSize = value
        }
        if let value = dict["SecurityGroupId"] as? [String] {
            self.securityGroupId = value
        }
        if let value = dict["SourceDestCheck"] as? Bool {
            self.sourceDestCheck = value
        }
        if let value = dict["TxQueueSize"] as? Int32 {
            self.txQueueSize = value
        }
    }
}

public class ModifyNetworkInterfaceAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyNetworkInterfaceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyNetworkInterfaceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyNetworkInterfaceAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyPhysicalConnectionAttributeRequest : Tea.TeaModel {
    public var circuitCode: String?

    public var clientToken: String?

    public var description_: String?

    public var lineOperator: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerLocation: String?

    public var physicalConnectionId: String?

    public var portType: String?

    public var redundantPhysicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userCidr: String?

    public var bandwidth: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.circuitCode != nil {
            map["CircuitCode"] = self.circuitCode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.lineOperator != nil {
            map["LineOperator"] = self.lineOperator!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerLocation != nil {
            map["PeerLocation"] = self.peerLocation!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.portType != nil {
            map["PortType"] = self.portType!
        }
        if self.redundantPhysicalConnectionId != nil {
            map["RedundantPhysicalConnectionId"] = self.redundantPhysicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        if self.bandwidth != nil {
            map["bandwidth"] = self.bandwidth!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CircuitCode"] as? String {
            self.circuitCode = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["LineOperator"] as? String {
            self.lineOperator = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PeerLocation"] as? String {
            self.peerLocation = value
        }
        if let value = dict["PhysicalConnectionId"] as? String {
            self.physicalConnectionId = value
        }
        if let value = dict["PortType"] as? String {
            self.portType = value
        }
        if let value = dict["RedundantPhysicalConnectionId"] as? String {
            self.redundantPhysicalConnectionId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["UserCidr"] as? String {
            self.userCidr = value
        }
        if let value = dict["bandwidth"] as? Int32 {
            self.bandwidth = value
        }
    }
}

public class ModifyPhysicalConnectionAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyPhysicalConnectionAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyPhysicalConnectionAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyPhysicalConnectionAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyPortRangeListRequest : Tea.TeaModel {
    public class AddEntry : Tea.TeaModel {
        public var description_: String?

        public var portRange: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["PortRange"] as? String {
                self.portRange = value
            }
        }
    }
    public class RemoveEntry : Tea.TeaModel {
        public var portRange: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PortRange"] as? String {
                self.portRange = value
            }
        }
    }
    public var addEntry: [ModifyPortRangeListRequest.AddEntry]?

    public var clientToken: String?

    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var portRangeListId: String?

    public var portRangeListName: String?

    public var regionId: String?

    public var removeEntry: [ModifyPortRangeListRequest.RemoveEntry]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addEntry != nil {
            var tmp : [Any] = []
            for k in self.addEntry! {
                tmp.append(k.toMap())
            }
            map["AddEntry"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.portRangeListId != nil {
            map["PortRangeListId"] = self.portRangeListId!
        }
        if self.portRangeListName != nil {
            map["PortRangeListName"] = self.portRangeListName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.removeEntry != nil {
            var tmp : [Any] = []
            for k in self.removeEntry! {
                tmp.append(k.toMap())
            }
            map["RemoveEntry"] = tmp
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddEntry"] as? [Any?] {
            var tmp : [ModifyPortRangeListRequest.AddEntry] = []
            for v in value {
                if v != nil {
                    var model = ModifyPortRangeListRequest.AddEntry()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.addEntry = tmp
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PortRangeListId"] as? String {
            self.portRangeListId = value
        }
        if let value = dict["PortRangeListName"] as? String {
            self.portRangeListName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RemoveEntry"] as? [Any?] {
            var tmp : [ModifyPortRangeListRequest.RemoveEntry] = []
            for v in value {
                if v != nil {
                    var model = ModifyPortRangeListRequest.RemoveEntry()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.removeEntry = tmp
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyPortRangeListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyPortRangeListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyPortRangeListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyPortRangeListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyPrefixListRequest : Tea.TeaModel {
    public class AddEntry : Tea.TeaModel {
        public var cidr: String?

        public var description_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidr != nil {
                map["Cidr"] = self.cidr!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Cidr"] as? String {
                self.cidr = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
        }
    }
    public class RemoveEntry : Tea.TeaModel {
        public var cidr: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidr != nil {
                map["Cidr"] = self.cidr!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Cidr"] as? String {
                self.cidr = value
            }
        }
    }
    public var addEntry: [ModifyPrefixListRequest.AddEntry]?

    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var prefixListId: String?

    public var prefixListName: String?

    public var regionId: String?

    public var removeEntry: [ModifyPrefixListRequest.RemoveEntry]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addEntry != nil {
            var tmp : [Any] = []
            for k in self.addEntry! {
                tmp.append(k.toMap())
            }
            map["AddEntry"] = tmp
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.prefixListId != nil {
            map["PrefixListId"] = self.prefixListId!
        }
        if self.prefixListName != nil {
            map["PrefixListName"] = self.prefixListName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.removeEntry != nil {
            var tmp : [Any] = []
            for k in self.removeEntry! {
                tmp.append(k.toMap())
            }
            map["RemoveEntry"] = tmp
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddEntry"] as? [Any?] {
            var tmp : [ModifyPrefixListRequest.AddEntry] = []
            for v in value {
                if v != nil {
                    var model = ModifyPrefixListRequest.AddEntry()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.addEntry = tmp
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PrefixListId"] as? String {
            self.prefixListId = value
        }
        if let value = dict["PrefixListName"] as? String {
            self.prefixListName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RemoveEntry"] as? [Any?] {
            var tmp : [ModifyPrefixListRequest.RemoveEntry] = []
            for v in value {
                if v != nil {
                    var model = ModifyPrefixListRequest.RemoveEntry()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.removeEntry = tmp
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyPrefixListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyPrefixListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyPrefixListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyPrefixListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyPrepayInstanceSpecRequest : Tea.TeaModel {
    public class SystemDisk : Tea.TeaModel {
        public var category: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Category"] as? String {
                self.category = value
            }
        }
    }
    public class Disk : Tea.TeaModel {
        public var category: String?

        public var diskId: String?

        public var performanceLevel: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.diskId != nil {
                map["DiskId"] = self.diskId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["DiskId"] as? String {
                self.diskId = value
            }
            if let value = dict["PerformanceLevel"] as? String {
                self.performanceLevel = value
            }
        }
    }
    public var systemDisk: ModifyPrepayInstanceSpecRequest.SystemDisk?

    public var autoPay: Bool?

    public var clientToken: String?

    public var disk: [ModifyPrepayInstanceSpecRequest.Disk]?

    public var endTime: String?

    public var instanceId: String?

    public var instanceType: String?

    public var migrateAcrossZone: Bool?

    public var modifyMode: String?

    public var operatorType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var rebootTime: String?

    public var rebootWhenFinished: Bool?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.disk != nil {
            var tmp : [Any] = []
            for k in self.disk! {
                tmp.append(k.toMap())
            }
            map["Disk"] = tmp
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.migrateAcrossZone != nil {
            map["MigrateAcrossZone"] = self.migrateAcrossZone!
        }
        if self.modifyMode != nil {
            map["ModifyMode"] = self.modifyMode!
        }
        if self.operatorType != nil {
            map["OperatorType"] = self.operatorType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.rebootTime != nil {
            map["RebootTime"] = self.rebootTime!
        }
        if self.rebootWhenFinished != nil {
            map["RebootWhenFinished"] = self.rebootWhenFinished!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["SystemDisk"] as? [String: Any?] {
            var model = ModifyPrepayInstanceSpecRequest.SystemDisk()
            model.fromMap(value)
            self.systemDisk = model
        }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Disk"] as? [Any?] {
            var tmp : [ModifyPrepayInstanceSpecRequest.Disk] = []
            for v in value {
                if v != nil {
                    var model = ModifyPrepayInstanceSpecRequest.Disk()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.disk = tmp
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["MigrateAcrossZone"] as? Bool {
            self.migrateAcrossZone = value
        }
        if let value = dict["ModifyMode"] as? String {
            self.modifyMode = value
        }
        if let value = dict["OperatorType"] as? String {
            self.operatorType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RebootTime"] as? String {
            self.rebootTime = value
        }
        if let value = dict["RebootWhenFinished"] as? Bool {
            self.rebootWhenFinished = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyPrepayInstanceSpecResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyPrepayInstanceSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyPrepayInstanceSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyPrepayInstanceSpecResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyReservedInstanceAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var reservedInstanceId: String?

    public var reservedInstanceName: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reservedInstanceId != nil {
            map["ReservedInstanceId"] = self.reservedInstanceId!
        }
        if self.reservedInstanceName != nil {
            map["ReservedInstanceName"] = self.reservedInstanceName!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ReservedInstanceId"] as? String {
            self.reservedInstanceId = value
        }
        if let value = dict["ReservedInstanceName"] as? String {
            self.reservedInstanceName = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyReservedInstanceAttributeResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyReservedInstanceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyReservedInstanceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyReservedInstanceAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyReservedInstanceAutoRenewAttributeRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var renewalStatus: String?

    public var reservedInstanceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.renewalStatus != nil {
            map["RenewalStatus"] = self.renewalStatus!
        }
        if self.reservedInstanceId != nil {
            map["ReservedInstanceId"] = self.reservedInstanceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PeriodUnit"] as? String {
            self.periodUnit = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RenewalStatus"] as? String {
            self.renewalStatus = value
        }
        if let value = dict["ReservedInstanceId"] as? [String] {
            self.reservedInstanceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyReservedInstanceAutoRenewAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyReservedInstanceAutoRenewAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyReservedInstanceAutoRenewAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyReservedInstanceAutoRenewAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyReservedInstancesRequest : Tea.TeaModel {
    public class Configuration : Tea.TeaModel {
        public var instanceAmount: Int32?

        public var instanceType: String?

        public var reservedInstanceName: String?

        public var scope: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceAmount != nil {
                map["InstanceAmount"] = self.instanceAmount!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.reservedInstanceName != nil {
                map["ReservedInstanceName"] = self.reservedInstanceName!
            }
            if self.scope != nil {
                map["Scope"] = self.scope!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceAmount"] as? Int32 {
                self.instanceAmount = value
            }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["ReservedInstanceName"] as? String {
                self.reservedInstanceName = value
            }
            if let value = dict["Scope"] as? String {
                self.scope = value
            }
            if let value = dict["ZoneId"] as? String {
                self.zoneId = value
            }
        }
    }
    public var configuration: [ModifyReservedInstancesRequest.Configuration]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var reservedInstanceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configuration != nil {
            var tmp : [Any] = []
            for k in self.configuration! {
                tmp.append(k.toMap())
            }
            map["Configuration"] = tmp
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reservedInstanceId != nil {
            map["ReservedInstanceId"] = self.reservedInstanceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Configuration"] as? [Any?] {
            var tmp : [ModifyReservedInstancesRequest.Configuration] = []
            for v in value {
                if v != nil {
                    var model = ModifyReservedInstancesRequest.Configuration()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.configuration = tmp
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ReservedInstanceId"] as? [String] {
            self.reservedInstanceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyReservedInstancesResponseBody : Tea.TeaModel {
    public class ReservedInstanceIdSets : Tea.TeaModel {
        public var reservedInstanceId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.reservedInstanceId != nil {
                map["ReservedInstanceId"] = self.reservedInstanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ReservedInstanceId"] as? [String] {
                self.reservedInstanceId = value
            }
        }
    }
    public var requestId: String?

    public var reservedInstanceIdSets: ModifyReservedInstancesResponseBody.ReservedInstanceIdSets?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.reservedInstanceIdSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.reservedInstanceIdSets != nil {
            map["ReservedInstanceIdSets"] = self.reservedInstanceIdSets?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ReservedInstanceIdSets"] as? [String: Any?] {
            var model = ModifyReservedInstancesResponseBody.ReservedInstanceIdSets()
            model.fromMap(value)
            self.reservedInstanceIdSets = model
        }
    }
}

public class ModifyReservedInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyReservedInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyReservedInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyRouterInterfaceAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var healthCheckSourceIp: String?

    public var healthCheckTargetIp: String?

    public var name: String?

    public var oppositeInterfaceId: String?

    public var oppositeInterfaceOwnerId: Int64?

    public var oppositeRouterId: String?

    public var oppositeRouterType: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerInterfaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.healthCheckSourceIp != nil {
            map["HealthCheckSourceIp"] = self.healthCheckSourceIp!
        }
        if self.healthCheckTargetIp != nil {
            map["HealthCheckTargetIp"] = self.healthCheckTargetIp!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.oppositeInterfaceId != nil {
            map["OppositeInterfaceId"] = self.oppositeInterfaceId!
        }
        if self.oppositeInterfaceOwnerId != nil {
            map["OppositeInterfaceOwnerId"] = self.oppositeInterfaceOwnerId!
        }
        if self.oppositeRouterId != nil {
            map["OppositeRouterId"] = self.oppositeRouterId!
        }
        if self.oppositeRouterType != nil {
            map["OppositeRouterType"] = self.oppositeRouterType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["HealthCheckSourceIp"] as? String {
            self.healthCheckSourceIp = value
        }
        if let value = dict["HealthCheckTargetIp"] as? String {
            self.healthCheckTargetIp = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OppositeInterfaceId"] as? String {
            self.oppositeInterfaceId = value
        }
        if let value = dict["OppositeInterfaceOwnerId"] as? Int64 {
            self.oppositeInterfaceOwnerId = value
        }
        if let value = dict["OppositeRouterId"] as? String {
            self.oppositeRouterId = value
        }
        if let value = dict["OppositeRouterType"] as? String {
            self.oppositeRouterType = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouterInterfaceId"] as? String {
            self.routerInterfaceId = value
        }
    }
}

public class ModifyRouterInterfaceAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyRouterInterfaceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyRouterInterfaceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyRouterInterfaceAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyRouterInterfaceSpecRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerInterfaceId: String?

    public var spec: String?

    public var userCidr: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RouterInterfaceId"] as? String {
            self.routerInterfaceId = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
        if let value = dict["UserCidr"] as? String {
            self.userCidr = value
        }
    }
}

public class ModifyRouterInterfaceSpecResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
    }
}

public class ModifyRouterInterfaceSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyRouterInterfaceSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyRouterInterfaceSpecResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifySecurityGroupAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public var securityGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupName != nil {
            map["SecurityGroupName"] = self.securityGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SecurityGroupName"] as? String {
            self.securityGroupName = value
        }
    }
}

public class ModifySecurityGroupAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifySecurityGroupAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySecurityGroupAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifySecurityGroupAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifySecurityGroupEgressRuleRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var destCidrIp: String?

    public var destGroupId: String?

    public var destGroupOwnerAccount: String?

    public var destGroupOwnerId: Int64?

    public var destPrefixListId: String?

    public var ipProtocol: String?

    public var ipv6DestCidrIp: String?

    public var ipv6SourceCidrIp: String?

    public var nicType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var policy: String?

    public var portRange: String?

    public var portRangeListId: String?

    public var priority: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public var securityGroupRuleId: String?

    public var sourceCidrIp: String?

    public var sourcePortRange: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destCidrIp != nil {
            map["DestCidrIp"] = self.destCidrIp!
        }
        if self.destGroupId != nil {
            map["DestGroupId"] = self.destGroupId!
        }
        if self.destGroupOwnerAccount != nil {
            map["DestGroupOwnerAccount"] = self.destGroupOwnerAccount!
        }
        if self.destGroupOwnerId != nil {
            map["DestGroupOwnerId"] = self.destGroupOwnerId!
        }
        if self.destPrefixListId != nil {
            map["DestPrefixListId"] = self.destPrefixListId!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.ipv6DestCidrIp != nil {
            map["Ipv6DestCidrIp"] = self.ipv6DestCidrIp!
        }
        if self.ipv6SourceCidrIp != nil {
            map["Ipv6SourceCidrIp"] = self.ipv6SourceCidrIp!
        }
        if self.nicType != nil {
            map["NicType"] = self.nicType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.portRangeListId != nil {
            map["PortRangeListId"] = self.portRangeListId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupRuleId != nil {
            map["SecurityGroupRuleId"] = self.securityGroupRuleId!
        }
        if self.sourceCidrIp != nil {
            map["SourceCidrIp"] = self.sourceCidrIp!
        }
        if self.sourcePortRange != nil {
            map["SourcePortRange"] = self.sourcePortRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DestCidrIp"] as? String {
            self.destCidrIp = value
        }
        if let value = dict["DestGroupId"] as? String {
            self.destGroupId = value
        }
        if let value = dict["DestGroupOwnerAccount"] as? String {
            self.destGroupOwnerAccount = value
        }
        if let value = dict["DestGroupOwnerId"] as? Int64 {
            self.destGroupOwnerId = value
        }
        if let value = dict["DestPrefixListId"] as? String {
            self.destPrefixListId = value
        }
        if let value = dict["IpProtocol"] as? String {
            self.ipProtocol = value
        }
        if let value = dict["Ipv6DestCidrIp"] as? String {
            self.ipv6DestCidrIp = value
        }
        if let value = dict["Ipv6SourceCidrIp"] as? String {
            self.ipv6SourceCidrIp = value
        }
        if let value = dict["NicType"] as? String {
            self.nicType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Policy"] as? String {
            self.policy = value
        }
        if let value = dict["PortRange"] as? String {
            self.portRange = value
        }
        if let value = dict["PortRangeListId"] as? String {
            self.portRangeListId = value
        }
        if let value = dict["Priority"] as? String {
            self.priority = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SecurityGroupRuleId"] as? String {
            self.securityGroupRuleId = value
        }
        if let value = dict["SourceCidrIp"] as? String {
            self.sourceCidrIp = value
        }
        if let value = dict["SourcePortRange"] as? String {
            self.sourcePortRange = value
        }
    }
}

public class ModifySecurityGroupEgressRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifySecurityGroupEgressRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySecurityGroupEgressRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifySecurityGroupEgressRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifySecurityGroupPolicyRequest : Tea.TeaModel {
    public var clientToken: String?

    public var innerAccessPolicy: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.innerAccessPolicy != nil {
            map["InnerAccessPolicy"] = self.innerAccessPolicy!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["InnerAccessPolicy"] as? String {
            self.innerAccessPolicy = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
    }
}

public class ModifySecurityGroupPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifySecurityGroupPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySecurityGroupPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifySecurityGroupPolicyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifySecurityGroupRuleRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var destCidrIp: String?

    public var ipProtocol: String?

    public var ipv6DestCidrIp: String?

    public var ipv6SourceCidrIp: String?

    public var nicType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var policy: String?

    public var portRange: String?

    public var portRangeListId: String?

    public var priority: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public var securityGroupRuleId: String?

    public var sourceCidrIp: String?

    public var sourceGroupId: String?

    public var sourceGroupOwnerAccount: String?

    public var sourceGroupOwnerId: Int64?

    public var sourcePortRange: String?

    public var sourcePrefixListId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destCidrIp != nil {
            map["DestCidrIp"] = self.destCidrIp!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.ipv6DestCidrIp != nil {
            map["Ipv6DestCidrIp"] = self.ipv6DestCidrIp!
        }
        if self.ipv6SourceCidrIp != nil {
            map["Ipv6SourceCidrIp"] = self.ipv6SourceCidrIp!
        }
        if self.nicType != nil {
            map["NicType"] = self.nicType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.portRangeListId != nil {
            map["PortRangeListId"] = self.portRangeListId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupRuleId != nil {
            map["SecurityGroupRuleId"] = self.securityGroupRuleId!
        }
        if self.sourceCidrIp != nil {
            map["SourceCidrIp"] = self.sourceCidrIp!
        }
        if self.sourceGroupId != nil {
            map["SourceGroupId"] = self.sourceGroupId!
        }
        if self.sourceGroupOwnerAccount != nil {
            map["SourceGroupOwnerAccount"] = self.sourceGroupOwnerAccount!
        }
        if self.sourceGroupOwnerId != nil {
            map["SourceGroupOwnerId"] = self.sourceGroupOwnerId!
        }
        if self.sourcePortRange != nil {
            map["SourcePortRange"] = self.sourcePortRange!
        }
        if self.sourcePrefixListId != nil {
            map["SourcePrefixListId"] = self.sourcePrefixListId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DestCidrIp"] as? String {
            self.destCidrIp = value
        }
        if let value = dict["IpProtocol"] as? String {
            self.ipProtocol = value
        }
        if let value = dict["Ipv6DestCidrIp"] as? String {
            self.ipv6DestCidrIp = value
        }
        if let value = dict["Ipv6SourceCidrIp"] as? String {
            self.ipv6SourceCidrIp = value
        }
        if let value = dict["NicType"] as? String {
            self.nicType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Policy"] as? String {
            self.policy = value
        }
        if let value = dict["PortRange"] as? String {
            self.portRange = value
        }
        if let value = dict["PortRangeListId"] as? String {
            self.portRangeListId = value
        }
        if let value = dict["Priority"] as? String {
            self.priority = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SecurityGroupRuleId"] as? String {
            self.securityGroupRuleId = value
        }
        if let value = dict["SourceCidrIp"] as? String {
            self.sourceCidrIp = value
        }
        if let value = dict["SourceGroupId"] as? String {
            self.sourceGroupId = value
        }
        if let value = dict["SourceGroupOwnerAccount"] as? String {
            self.sourceGroupOwnerAccount = value
        }
        if let value = dict["SourceGroupOwnerId"] as? Int64 {
            self.sourceGroupOwnerId = value
        }
        if let value = dict["SourcePortRange"] as? String {
            self.sourcePortRange = value
        }
        if let value = dict["SourcePrefixListId"] as? String {
            self.sourcePrefixListId = value
        }
    }
}

public class ModifySecurityGroupRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifySecurityGroupRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySecurityGroupRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifySecurityGroupRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifySnapshotAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var disableInstantAccess: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var retentionDays: Int32?

    public var snapshotId: String?

    public var snapshotName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.disableInstantAccess != nil {
            map["DisableInstantAccess"] = self.disableInstantAccess!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.retentionDays != nil {
            map["RetentionDays"] = self.retentionDays!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        if self.snapshotName != nil {
            map["SnapshotName"] = self.snapshotName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DisableInstantAccess"] as? Bool {
            self.disableInstantAccess = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RetentionDays"] as? Int32 {
            self.retentionDays = value
        }
        if let value = dict["SnapshotId"] as? String {
            self.snapshotId = value
        }
        if let value = dict["SnapshotName"] as? String {
            self.snapshotName = value
        }
    }
}

public class ModifySnapshotAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifySnapshotAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySnapshotAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifySnapshotAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifySnapshotCategoryRequest : Tea.TeaModel {
    public var category: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var retentionDays: Int32?

    public var snapshotId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.retentionDays != nil {
            map["RetentionDays"] = self.retentionDays!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Category"] as? String {
            self.category = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RetentionDays"] as? Int32 {
            self.retentionDays = value
        }
        if let value = dict["SnapshotId"] as? String {
            self.snapshotId = value
        }
    }
}

public class ModifySnapshotCategoryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class ModifySnapshotCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySnapshotCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifySnapshotCategoryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifySnapshotGroupRequest : Tea.TeaModel {
    public var description_: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snapshotGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snapshotGroupId != nil {
            map["SnapshotGroupId"] = self.snapshotGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SnapshotGroupId"] as? String {
            self.snapshotGroupId = value
        }
    }
}

public class ModifySnapshotGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifySnapshotGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySnapshotGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifySnapshotGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyStorageCapacityUnitAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var storageCapacityUnitId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.storageCapacityUnitId != nil {
            map["StorageCapacityUnitId"] = self.storageCapacityUnitId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StorageCapacityUnitId"] as? String {
            self.storageCapacityUnitId = value
        }
    }
}

public class ModifyStorageCapacityUnitAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyStorageCapacityUnitAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyStorageCapacityUnitAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyStorageCapacityUnitAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyStorageSetAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var storageSetId: String?

    public var storageSetName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        if self.storageSetName != nil {
            map["StorageSetName"] = self.storageSetName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StorageSetId"] as? String {
            self.storageSetId = value
        }
        if let value = dict["StorageSetName"] as? String {
            self.storageSetName = value
        }
    }
}

public class ModifyStorageSetAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyStorageSetAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyStorageSetAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyStorageSetAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyUserBusinessBehaviorRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var statusKey: String?

    public var statusValue: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.statusKey != nil {
            map["statusKey"] = self.statusKey!
        }
        if self.statusValue != nil {
            map["statusValue"] = self.statusValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["statusKey"] as? String {
            self.statusKey = value
        }
        if let value = dict["statusValue"] as? String {
            self.statusValue = value
        }
    }
}

public class ModifyUserBusinessBehaviorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyUserBusinessBehaviorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyUserBusinessBehaviorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyUserBusinessBehaviorResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyVRouterAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var VRouterId: String?

    public var VRouterName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.VRouterId != nil {
            map["VRouterId"] = self.VRouterId!
        }
        if self.VRouterName != nil {
            map["VRouterName"] = self.VRouterName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VRouterId"] as? String {
            self.VRouterId = value
        }
        if let value = dict["VRouterName"] as? String {
            self.VRouterName = value
        }
    }
}

public class ModifyVRouterAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyVRouterAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVRouterAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyVRouterAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyVSwitchAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchId: String?

    public var vSwitchName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vSwitchName != nil {
            map["VSwitchName"] = self.vSwitchName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VSwitchName"] as? String {
            self.vSwitchName = value
        }
    }
}

public class ModifyVSwitchAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyVSwitchAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVSwitchAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyVSwitchAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyVirtualBorderRouterAttributeRequest : Tea.TeaModel {
    public var circuitCode: String?

    public var clientToken: String?

    public var description_: String?

    public var localGatewayIp: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerGatewayIp: String?

    public var peeringSubnetMask: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userCidr: String?

    public var vbrId: String?

    public var vlanId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.circuitCode != nil {
            map["CircuitCode"] = self.circuitCode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.localGatewayIp != nil {
            map["LocalGatewayIp"] = self.localGatewayIp!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerGatewayIp != nil {
            map["PeerGatewayIp"] = self.peerGatewayIp!
        }
        if self.peeringSubnetMask != nil {
            map["PeeringSubnetMask"] = self.peeringSubnetMask!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        if self.vlanId != nil {
            map["VlanId"] = self.vlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CircuitCode"] as? String {
            self.circuitCode = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["LocalGatewayIp"] as? String {
            self.localGatewayIp = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PeerGatewayIp"] as? String {
            self.peerGatewayIp = value
        }
        if let value = dict["PeeringSubnetMask"] as? String {
            self.peeringSubnetMask = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["UserCidr"] as? String {
            self.userCidr = value
        }
        if let value = dict["VbrId"] as? String {
            self.vbrId = value
        }
        if let value = dict["VlanId"] as? Int32 {
            self.vlanId = value
        }
    }
}

public class ModifyVirtualBorderRouterAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyVirtualBorderRouterAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVirtualBorderRouterAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyVirtualBorderRouterAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyVpcAttributeRequest : Tea.TeaModel {
    public var cidrBlock: String?

    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userCidr: String?

    public var vpcId: String?

    public var vpcName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vpcName != nil {
            map["VpcName"] = self.vpcName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CidrBlock"] as? String {
            self.cidrBlock = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["UserCidr"] as? String {
            self.userCidr = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["VpcName"] as? String {
            self.vpcName = value
        }
    }
}

public class ModifyVpcAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyVpcAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVpcAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyVpcAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class PurchaseElasticityAssuranceRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public var matchCriteria: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["MatchCriteria"] as? String {
                self.matchCriteria = value
            }
        }
    }
    public var privatePoolOptions: PurchaseElasticityAssuranceRequest.PrivatePoolOptions?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PrivatePoolOptions"] as? [String: Any?] {
            var model = PurchaseElasticityAssuranceRequest.PrivatePoolOptions()
            model.fromMap(value)
            self.privatePoolOptions = model
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PeriodUnit"] as? String {
            self.periodUnit = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class PurchaseElasticityAssuranceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class PurchaseElasticityAssuranceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PurchaseElasticityAssuranceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = PurchaseElasticityAssuranceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class PurchaseReservedInstancesOfferingRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var autoRenew: Bool?

    public var autoRenewPeriod: Int32?

    public var clientToken: String?

    public var description_: String?

    public var instanceAmount: Int32?

    public var instanceType: String?

    public var offeringType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var platform: String?

    public var regionId: String?

    public var reservedInstanceName: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scope: String?

    public var startTime: String?

    public var tag: [PurchaseReservedInstancesOfferingRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewPeriod != nil {
            map["AutoRenewPeriod"] = self.autoRenewPeriod!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceAmount != nil {
            map["InstanceAmount"] = self.instanceAmount!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.offeringType != nil {
            map["OfferingType"] = self.offeringType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reservedInstanceName != nil {
            map["ReservedInstanceName"] = self.reservedInstanceName!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoRenew"] as? Bool {
            self.autoRenew = value
        }
        if let value = dict["AutoRenewPeriod"] as? Int32 {
            self.autoRenewPeriod = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["InstanceAmount"] as? Int32 {
            self.instanceAmount = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["OfferingType"] as? String {
            self.offeringType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PeriodUnit"] as? String {
            self.periodUnit = value
        }
        if let value = dict["Platform"] as? String {
            self.platform = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ReservedInstanceName"] as? String {
            self.reservedInstanceName = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Scope"] as? String {
            self.scope = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [PurchaseReservedInstancesOfferingRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = PurchaseReservedInstancesOfferingRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class PurchaseReservedInstancesOfferingResponseBody : Tea.TeaModel {
    public class ReservedInstanceIdSets : Tea.TeaModel {
        public var reservedInstanceId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.reservedInstanceId != nil {
                map["ReservedInstanceId"] = self.reservedInstanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ReservedInstanceId"] as? [String] {
                self.reservedInstanceId = value
            }
        }
    }
    public var orderId: String?

    public var requestId: String?

    public var reservedInstanceIdSets: PurchaseReservedInstancesOfferingResponseBody.ReservedInstanceIdSets?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.reservedInstanceIdSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.reservedInstanceIdSets != nil {
            map["ReservedInstanceIdSets"] = self.reservedInstanceIdSets?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ReservedInstanceIdSets"] as? [String: Any?] {
            var model = PurchaseReservedInstancesOfferingResponseBody.ReservedInstanceIdSets()
            model.fromMap(value)
            self.reservedInstanceIdSets = model
        }
    }
}

public class PurchaseReservedInstancesOfferingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PurchaseReservedInstancesOfferingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = PurchaseReservedInstancesOfferingResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class PurchaseStorageCapacityUnitRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var amount: Int32?

    public var capacity: Int32?

    public var clientToken: String?

    public var description_: String?

    public var fromApp: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public var tag: [PurchaseStorageCapacityUnitRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.capacity != nil {
            map["Capacity"] = self.capacity!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.fromApp != nil {
            map["FromApp"] = self.fromApp!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Amount"] as? Int32 {
            self.amount = value
        }
        if let value = dict["Capacity"] as? Int32 {
            self.capacity = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["FromApp"] as? String {
            self.fromApp = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PeriodUnit"] as? String {
            self.periodUnit = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [PurchaseStorageCapacityUnitRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = PurchaseStorageCapacityUnitRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class PurchaseStorageCapacityUnitResponseBody : Tea.TeaModel {
    public class StorageCapacityUnitIds : Tea.TeaModel {
        public var storageCapacityUnitId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.storageCapacityUnitId != nil {
                map["StorageCapacityUnitId"] = self.storageCapacityUnitId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["StorageCapacityUnitId"] as? [String] {
                self.storageCapacityUnitId = value
            }
        }
    }
    public var orderId: String?

    public var requestId: String?

    public var storageCapacityUnitIds: PurchaseStorageCapacityUnitResponseBody.StorageCapacityUnitIds?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.storageCapacityUnitIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.storageCapacityUnitIds != nil {
            map["StorageCapacityUnitIds"] = self.storageCapacityUnitIds?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StorageCapacityUnitIds"] as? [String: Any?] {
            var model = PurchaseStorageCapacityUnitResponseBody.StorageCapacityUnitIds()
            model.fromMap(value)
            self.storageCapacityUnitIds = model
        }
    }
}

public class PurchaseStorageCapacityUnitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PurchaseStorageCapacityUnitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = PurchaseStorageCapacityUnitResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ReActivateInstancesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ReActivateInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ReActivateInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReActivateInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ReActivateInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ReInitDiskRequest : Tea.TeaModel {
    public var autoStartInstance: Bool?

    public var diskId: String?

    public var keyPairName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var password: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityEnhancementStrategy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoStartInstance != nil {
            map["AutoStartInstance"] = self.autoStartInstance!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityEnhancementStrategy != nil {
            map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoStartInstance"] as? Bool {
            self.autoStartInstance = value
        }
        if let value = dict["DiskId"] as? String {
            self.diskId = value
        }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Password"] as? String {
            self.password = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityEnhancementStrategy"] as? String {
            self.securityEnhancementStrategy = value
        }
    }
}

public class ReInitDiskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ReInitDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReInitDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ReInitDiskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RebootInstanceRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var forceStop: Bool?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.forceStop != nil {
            map["ForceStop"] = self.forceStop!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["ForceStop"] as? Bool {
            self.forceStop = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class RebootInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RebootInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RebootInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RebootInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RebootInstancesRequest : Tea.TeaModel {
    public var batchOptimization: String?

    public var dryRun: Bool?

    public var forceReboot: Bool?

    public var instanceId: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchOptimization != nil {
            map["BatchOptimization"] = self.batchOptimization!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.forceReboot != nil {
            map["ForceReboot"] = self.forceReboot!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BatchOptimization"] as? String {
            self.batchOptimization = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["ForceReboot"] as? Bool {
            self.forceReboot = value
        }
        if let value = dict["InstanceId"] as? [String] {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class RebootInstancesResponseBody : Tea.TeaModel {
    public class InstanceResponses : Tea.TeaModel {
        public class InstanceResponse : Tea.TeaModel {
            public var code: String?

            public var currentStatus: String?

            public var instanceId: String?

            public var message: String?

            public var previousStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.currentStatus != nil {
                    map["CurrentStatus"] = self.currentStatus!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.previousStatus != nil {
                    map["PreviousStatus"] = self.previousStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Code"] as? String {
                    self.code = value
                }
                if let value = dict["CurrentStatus"] as? String {
                    self.currentStatus = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["Message"] as? String {
                    self.message = value
                }
                if let value = dict["PreviousStatus"] as? String {
                    self.previousStatus = value
                }
            }
        }
        public var instanceResponse: [RebootInstancesResponseBody.InstanceResponses.InstanceResponse]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceResponse != nil {
                var tmp : [Any] = []
                for k in self.instanceResponse! {
                    tmp.append(k.toMap())
                }
                map["InstanceResponse"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceResponse"] as? [Any?] {
                var tmp : [RebootInstancesResponseBody.InstanceResponses.InstanceResponse] = []
                for v in value {
                    if v != nil {
                        var model = RebootInstancesResponseBody.InstanceResponses.InstanceResponse()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instanceResponse = tmp
            }
        }
    }
    public var instanceResponses: RebootInstancesResponseBody.InstanceResponses?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceResponses?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceResponses != nil {
            map["InstanceResponses"] = self.instanceResponses?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceResponses"] as? [String: Any?] {
            var model = RebootInstancesResponseBody.InstanceResponses()
            model.fromMap(value)
            self.instanceResponses = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RebootInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RebootInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RebootInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RecoverVirtualBorderRouterRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userCidr: String?

    public var vbrId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["UserCidr"] as? String {
            self.userCidr = value
        }
        if let value = dict["VbrId"] as? String {
            self.vbrId = value
        }
    }
}

public class RecoverVirtualBorderRouterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RecoverVirtualBorderRouterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RecoverVirtualBorderRouterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RecoverVirtualBorderRouterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RedeployDedicatedHostRequest : Tea.TeaModel {
    public var dedicatedHostId: String?

    public var migrationType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.migrationType != nil {
            map["MigrationType"] = self.migrationType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DedicatedHostId"] as? String {
            self.dedicatedHostId = value
        }
        if let value = dict["MigrationType"] as? String {
            self.migrationType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class RedeployDedicatedHostResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RedeployDedicatedHostResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RedeployDedicatedHostResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RedeployDedicatedHostResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RedeployInstanceRequest : Tea.TeaModel {
    public var forceStop: Bool?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forceStop != nil {
            map["ForceStop"] = self.forceStop!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ForceStop"] as? Bool {
            self.forceStop = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class RedeployInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class RedeployInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RedeployInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RedeployInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ReleaseCapacityReservationRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Id"] as? String {
                self.id = value
            }
        }
    }
    public var privatePoolOptions: ReleaseCapacityReservationRequest.PrivatePoolOptions?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PrivatePoolOptions"] as? [String: Any?] {
            var model = ReleaseCapacityReservationRequest.PrivatePoolOptions()
            model.fromMap(value)
            self.privatePoolOptions = model
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ReleaseCapacityReservationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ReleaseCapacityReservationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseCapacityReservationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ReleaseCapacityReservationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ReleaseDedicatedHostRequest : Tea.TeaModel {
    public var dedicatedHostId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DedicatedHostId"] as? String {
            self.dedicatedHostId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ReleaseDedicatedHostResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ReleaseDedicatedHostResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseDedicatedHostResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ReleaseDedicatedHostResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ReleaseEipAddressRequest : Tea.TeaModel {
    public var allocationId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AllocationId"] as? String {
            self.allocationId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ReleaseEipAddressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ReleaseEipAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseEipAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ReleaseEipAddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ReleasePublicIpAddressRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var instanceId: String?

    public var publicIpAddress: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.publicIpAddress != nil {
            map["PublicIpAddress"] = self.publicIpAddress!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["PublicIpAddress"] as? String {
            self.publicIpAddress = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class ReleasePublicIpAddressResponseBody : Tea.TeaModel {
    public var remainTimes: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.remainTimes != nil {
            map["RemainTimes"] = self.remainTimes!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RemainTimes"] as? String {
            self.remainTimes = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ReleasePublicIpAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleasePublicIpAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ReleasePublicIpAddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RemoveBandwidthPackageIpsRequest : Tea.TeaModel {
    public var bandwidthPackageId: String?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var removedIpAddresses: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.removedIpAddresses != nil {
            map["RemovedIpAddresses"] = self.removedIpAddresses!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BandwidthPackageId"] as? String {
            self.bandwidthPackageId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RemovedIpAddresses"] as? [String] {
            self.removedIpAddresses = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class RemoveBandwidthPackageIpsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RemoveBandwidthPackageIpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveBandwidthPackageIpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RemoveBandwidthPackageIpsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RemoveTagsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tag: [RemoveTagsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [RemoveTagsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = RemoveTagsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class RemoveTagsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RemoveTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RemoveTagsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RenewDedicatedHostsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dedicatedHostIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dedicatedHostIds != nil {
            map["DedicatedHostIds"] = self.dedicatedHostIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DedicatedHostIds"] as? String {
            self.dedicatedHostIds = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PeriodUnit"] as? String {
            self.periodUnit = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class RenewDedicatedHostsResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RenewDedicatedHostsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenewDedicatedHostsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RenewDedicatedHostsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RenewElasticityAssurancesRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Id"] as? [String] {
                self.id = value
            }
        }
    }
    public var privatePoolOptions: RenewElasticityAssurancesRequest.PrivatePoolOptions?

    public var autoPay: Bool?

    public var autoRenew: Bool?

    public var autoRenewPeriod: Int32?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewPeriod != nil {
            map["AutoRenewPeriod"] = self.autoRenewPeriod!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PrivatePoolOptions"] as? [String: Any?] {
            var model = RenewElasticityAssurancesRequest.PrivatePoolOptions()
            model.fromMap(value)
            self.privatePoolOptions = model
        }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["AutoRenew"] as? Bool {
            self.autoRenew = value
        }
        if let value = dict["AutoRenewPeriod"] as? Int32 {
            self.autoRenewPeriod = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PeriodUnit"] as? String {
            self.periodUnit = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class RenewElasticityAssurancesResponseBody : Tea.TeaModel {
    public class PrivatePoolOptionsIdSet : Tea.TeaModel {
        public var privatePoolOptionsId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.privatePoolOptionsId != nil {
                map["PrivatePoolOptionsId"] = self.privatePoolOptionsId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PrivatePoolOptionsId"] as? [String] {
                self.privatePoolOptionsId = value
            }
        }
    }
    public var orderId: String?

    public var privatePoolOptionsIdSet: RenewElasticityAssurancesResponseBody.PrivatePoolOptionsIdSet?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptionsIdSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.privatePoolOptionsIdSet != nil {
            map["PrivatePoolOptionsIdSet"] = self.privatePoolOptionsIdSet?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["PrivatePoolOptionsIdSet"] as? [String: Any?] {
            var model = RenewElasticityAssurancesResponseBody.PrivatePoolOptionsIdSet()
            model.fromMap(value)
            self.privatePoolOptionsIdSet = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RenewElasticityAssurancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenewElasticityAssurancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RenewElasticityAssurancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RenewInstanceRequest : Tea.TeaModel {
    public var clientToken: String?

    public var expectedRenewDay: Int32?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.expectedRenewDay != nil {
            map["ExpectedRenewDay"] = self.expectedRenewDay!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ExpectedRenewDay"] as? Int32 {
            self.expectedRenewDay = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PeriodUnit"] as? String {
            self.periodUnit = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class RenewInstanceResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RenewInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenewInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RenewInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RenewReservedInstancesRequest : Tea.TeaModel {
    public var autoRenew: Bool?

    public var autoRenewPeriod: Int32?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var reservedInstanceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewPeriod != nil {
            map["AutoRenewPeriod"] = self.autoRenewPeriod!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reservedInstanceId != nil {
            map["ReservedInstanceId"] = self.reservedInstanceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoRenew"] as? Bool {
            self.autoRenew = value
        }
        if let value = dict["AutoRenewPeriod"] as? Int32 {
            self.autoRenewPeriod = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PeriodUnit"] as? String {
            self.periodUnit = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ReservedInstanceId"] as? [String] {
            self.reservedInstanceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class RenewReservedInstancesResponseBody : Tea.TeaModel {
    public class ReservedInstanceIdSets : Tea.TeaModel {
        public var reservedInstanceId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.reservedInstanceId != nil {
                map["ReservedInstanceId"] = self.reservedInstanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ReservedInstanceId"] as? [String] {
                self.reservedInstanceId = value
            }
        }
    }
    public var orderId: String?

    public var requestId: String?

    public var reservedInstanceIdSets: RenewReservedInstancesResponseBody.ReservedInstanceIdSets?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.reservedInstanceIdSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.reservedInstanceIdSets != nil {
            map["ReservedInstanceIdSets"] = self.reservedInstanceIdSets?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ReservedInstanceIdSets"] as? [String: Any?] {
            var model = RenewReservedInstancesResponseBody.ReservedInstanceIdSets()
            model.fromMap(value)
            self.reservedInstanceIdSets = model
        }
    }
}

public class RenewReservedInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenewReservedInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RenewReservedInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ReplaceSystemDiskRequest : Tea.TeaModel {
    public class SystemDisk : Tea.TeaModel {
        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Size"] as? Int32 {
                self.size = value
            }
        }
    }
    public class Arn : Tea.TeaModel {
        public var assumeRoleFor: Int64?

        public var roleType: String?

        public var rolearn: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assumeRoleFor != nil {
                map["AssumeRoleFor"] = self.assumeRoleFor!
            }
            if self.roleType != nil {
                map["RoleType"] = self.roleType!
            }
            if self.rolearn != nil {
                map["Rolearn"] = self.rolearn!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AssumeRoleFor"] as? Int64 {
                self.assumeRoleFor = value
            }
            if let value = dict["RoleType"] as? String {
                self.roleType = value
            }
            if let value = dict["Rolearn"] as? String {
                self.rolearn = value
            }
        }
    }
    public var systemDisk: ReplaceSystemDiskRequest.SystemDisk?

    public var architecture: String?

    public var arn: [ReplaceSystemDiskRequest.Arn]?

    public var clientToken: String?

    public var diskId: String?

    public var encryptAlgorithm: String?

    public var encrypted: Bool?

    public var imageId: String?

    public var instanceId: String?

    public var KMSKeyId: String?

    public var keyPairName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var password: String?

    public var passwordInherit: Bool?

    public var platform: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityEnhancementStrategy: String?

    public var useAdditionalService: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.architecture != nil {
            map["Architecture"] = self.architecture!
        }
        if self.arn != nil {
            var tmp : [Any] = []
            for k in self.arn! {
                tmp.append(k.toMap())
            }
            map["Arn"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.encryptAlgorithm != nil {
            map["EncryptAlgorithm"] = self.encryptAlgorithm!
        }
        if self.encrypted != nil {
            map["Encrypted"] = self.encrypted!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.KMSKeyId != nil {
            map["KMSKeyId"] = self.KMSKeyId!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityEnhancementStrategy != nil {
            map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
        }
        if self.useAdditionalService != nil {
            map["UseAdditionalService"] = self.useAdditionalService!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["SystemDisk"] as? [String: Any?] {
            var model = ReplaceSystemDiskRequest.SystemDisk()
            model.fromMap(value)
            self.systemDisk = model
        }
        if let value = dict["Architecture"] as? String {
            self.architecture = value
        }
        if let value = dict["Arn"] as? [Any?] {
            var tmp : [ReplaceSystemDiskRequest.Arn] = []
            for v in value {
                if v != nil {
                    var model = ReplaceSystemDiskRequest.Arn()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.arn = tmp
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DiskId"] as? String {
            self.diskId = value
        }
        if let value = dict["EncryptAlgorithm"] as? String {
            self.encryptAlgorithm = value
        }
        if let value = dict["Encrypted"] as? Bool {
            self.encrypted = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["KMSKeyId"] as? String {
            self.KMSKeyId = value
        }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Password"] as? String {
            self.password = value
        }
        if let value = dict["PasswordInherit"] as? Bool {
            self.passwordInherit = value
        }
        if let value = dict["Platform"] as? String {
            self.platform = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityEnhancementStrategy"] as? String {
            self.securityEnhancementStrategy = value
        }
        if let value = dict["UseAdditionalService"] as? Bool {
            self.useAdditionalService = value
        }
    }
}

public class ReplaceSystemDiskResponseBody : Tea.TeaModel {
    public var diskId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DiskId"] as? String {
            self.diskId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ReplaceSystemDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReplaceSystemDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ReplaceSystemDiskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ReportInstancesStatusRequest : Tea.TeaModel {
    public var description_: String?

    public var device: [String]?

    public var diskId: [String]?

    public var endTime: String?

    public var instanceId: [String]?

    public var issueCategory: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var reason: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.device != nil {
            map["Device"] = self.device!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.issueCategory != nil {
            map["IssueCategory"] = self.issueCategory!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Device"] as? [String] {
            self.device = value
        }
        if let value = dict["DiskId"] as? [String] {
            self.diskId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["InstanceId"] as? [String] {
            self.instanceId = value
        }
        if let value = dict["IssueCategory"] as? String {
            self.issueCategory = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Reason"] as? String {
            self.reason = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class ReportInstancesStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ReportInstancesStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReportInstancesStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ReportInstancesStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ResetDiskRequest : Tea.TeaModel {
    public var diskId: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snapshotId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DiskId"] as? String {
            self.diskId = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SnapshotId"] as? String {
            self.snapshotId = value
        }
    }
}

public class ResetDiskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ResetDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ResetDiskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ResetDiskDefaultKMSKeyIdRequest : Tea.TeaModel {
    public var regionId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ResetDiskDefaultKMSKeyIdResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ResetDiskDefaultKMSKeyIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetDiskDefaultKMSKeyIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ResetDiskDefaultKMSKeyIdResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ResetDisksRequest : Tea.TeaModel {
    public class Disk : Tea.TeaModel {
        public var diskId: String?

        public var snapshotId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diskId != nil {
                map["DiskId"] = self.diskId!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DiskId"] as? String {
                self.diskId = value
            }
            if let value = dict["SnapshotId"] as? String {
                self.snapshotId = value
            }
        }
    }
    public var disk: [ResetDisksRequest.Disk]?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.disk != nil {
            var tmp : [Any] = []
            for k in self.disk! {
                tmp.append(k.toMap())
            }
            map["Disk"] = tmp
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Disk"] as? [Any?] {
            var tmp : [ResetDisksRequest.Disk] = []
            for v in value {
                if v != nil {
                    var model = ResetDisksRequest.Disk()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.disk = tmp
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ResetDisksResponseBody : Tea.TeaModel {
    public class OperationProgressSet : Tea.TeaModel {
        public class OperationProgress : Tea.TeaModel {
            public class RelatedItemSet : Tea.TeaModel {
                public class RelatedItem : Tea.TeaModel {
                    public var name: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Name"] as? String {
                            self.name = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var relatedItem: [ResetDisksResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet.RelatedItem]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.relatedItem != nil {
                        var tmp : [Any] = []
                        for k in self.relatedItem! {
                            tmp.append(k.toMap())
                        }
                        map["RelatedItem"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RelatedItem"] as? [Any?] {
                        var tmp : [ResetDisksResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet.RelatedItem] = []
                        for v in value {
                            if v != nil {
                                var model = ResetDisksResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet.RelatedItem()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.relatedItem = tmp
                    }
                }
            }
            public var errorCode: String?

            public var errorMsg: String?

            public var operationStatus: String?

            public var relatedItemSet: ResetDisksResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.relatedItemSet?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.operationStatus != nil {
                    map["OperationStatus"] = self.operationStatus!
                }
                if self.relatedItemSet != nil {
                    map["RelatedItemSet"] = self.relatedItemSet?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ErrorCode"] as? String {
                    self.errorCode = value
                }
                if let value = dict["ErrorMsg"] as? String {
                    self.errorMsg = value
                }
                if let value = dict["OperationStatus"] as? String {
                    self.operationStatus = value
                }
                if let value = dict["RelatedItemSet"] as? [String: Any?] {
                    var model = ResetDisksResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet()
                    model.fromMap(value)
                    self.relatedItemSet = model
                }
            }
        }
        public var operationProgress: [ResetDisksResponseBody.OperationProgressSet.OperationProgress]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.operationProgress != nil {
                var tmp : [Any] = []
                for k in self.operationProgress! {
                    tmp.append(k.toMap())
                }
                map["OperationProgress"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OperationProgress"] as? [Any?] {
                var tmp : [ResetDisksResponseBody.OperationProgressSet.OperationProgress] = []
                for v in value {
                    if v != nil {
                        var model = ResetDisksResponseBody.OperationProgressSet.OperationProgress()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.operationProgress = tmp
            }
        }
    }
    public var operationProgressSet: ResetDisksResponseBody.OperationProgressSet?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.operationProgressSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationProgressSet != nil {
            map["OperationProgressSet"] = self.operationProgressSet?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OperationProgressSet"] as? [String: Any?] {
            var model = ResetDisksResponseBody.OperationProgressSet()
            model.fromMap(value)
            self.operationProgressSet = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ResetDisksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetDisksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ResetDisksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ResizeDiskRequest : Tea.TeaModel {
    public var clientToken: String?

    public var diskId: String?

    public var newSize: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.newSize != nil {
            map["NewSize"] = self.newSize!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DiskId"] as? String {
            self.diskId = value
        }
        if let value = dict["NewSize"] as? Int32 {
            self.newSize = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class ResizeDiskResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ResizeDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResizeDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ResizeDiskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RevokeSecurityGroupRequest : Tea.TeaModel {
    public class Permissions : Tea.TeaModel {
        public var description_: String?

        public var destCidrIp: String?

        public var ipProtocol: String?

        public var ipv6DestCidrIp: String?

        public var ipv6SourceCidrIp: String?

        public var nicType: String?

        public var policy: String?

        public var portRange: String?

        public var portRangeListId: String?

        public var priority: String?

        public var sourceCidrIp: String?

        public var sourceGroupId: String?

        public var sourceGroupOwnerAccount: String?

        public var sourceGroupOwnerId: Int64?

        public var sourcePortRange: String?

        public var sourcePrefixListId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.destCidrIp != nil {
                map["DestCidrIp"] = self.destCidrIp!
            }
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.ipv6DestCidrIp != nil {
                map["Ipv6DestCidrIp"] = self.ipv6DestCidrIp!
            }
            if self.ipv6SourceCidrIp != nil {
                map["Ipv6SourceCidrIp"] = self.ipv6SourceCidrIp!
            }
            if self.nicType != nil {
                map["NicType"] = self.nicType!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            if self.portRangeListId != nil {
                map["PortRangeListId"] = self.portRangeListId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.sourceCidrIp != nil {
                map["SourceCidrIp"] = self.sourceCidrIp!
            }
            if self.sourceGroupId != nil {
                map["SourceGroupId"] = self.sourceGroupId!
            }
            if self.sourceGroupOwnerAccount != nil {
                map["SourceGroupOwnerAccount"] = self.sourceGroupOwnerAccount!
            }
            if self.sourceGroupOwnerId != nil {
                map["SourceGroupOwnerId"] = self.sourceGroupOwnerId!
            }
            if self.sourcePortRange != nil {
                map["SourcePortRange"] = self.sourcePortRange!
            }
            if self.sourcePrefixListId != nil {
                map["SourcePrefixListId"] = self.sourcePrefixListId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DestCidrIp"] as? String {
                self.destCidrIp = value
            }
            if let value = dict["IpProtocol"] as? String {
                self.ipProtocol = value
            }
            if let value = dict["Ipv6DestCidrIp"] as? String {
                self.ipv6DestCidrIp = value
            }
            if let value = dict["Ipv6SourceCidrIp"] as? String {
                self.ipv6SourceCidrIp = value
            }
            if let value = dict["NicType"] as? String {
                self.nicType = value
            }
            if let value = dict["Policy"] as? String {
                self.policy = value
            }
            if let value = dict["PortRange"] as? String {
                self.portRange = value
            }
            if let value = dict["PortRangeListId"] as? String {
                self.portRangeListId = value
            }
            if let value = dict["Priority"] as? String {
                self.priority = value
            }
            if let value = dict["SourceCidrIp"] as? String {
                self.sourceCidrIp = value
            }
            if let value = dict["SourceGroupId"] as? String {
                self.sourceGroupId = value
            }
            if let value = dict["SourceGroupOwnerAccount"] as? String {
                self.sourceGroupOwnerAccount = value
            }
            if let value = dict["SourceGroupOwnerId"] as? Int64 {
                self.sourceGroupOwnerId = value
            }
            if let value = dict["SourcePortRange"] as? String {
                self.sourcePortRange = value
            }
            if let value = dict["SourcePrefixListId"] as? String {
                self.sourcePrefixListId = value
            }
        }
    }
    public var clientToken: String?

    public var description_: String?

    public var destCidrIp: String?

    public var ipProtocol: String?

    public var ipv6DestCidrIp: String?

    public var ipv6SourceCidrIp: String?

    public var nicType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var permissions: [RevokeSecurityGroupRequest.Permissions]?

    public var policy: String?

    public var portRange: String?

    public var priority: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public var securityGroupRuleId: [String]?

    public var sourceCidrIp: String?

    public var sourceGroupId: String?

    public var sourceGroupOwnerAccount: String?

    public var sourceGroupOwnerId: Int64?

    public var sourcePortRange: String?

    public var sourcePrefixListId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destCidrIp != nil {
            map["DestCidrIp"] = self.destCidrIp!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.ipv6DestCidrIp != nil {
            map["Ipv6DestCidrIp"] = self.ipv6DestCidrIp!
        }
        if self.ipv6SourceCidrIp != nil {
            map["Ipv6SourceCidrIp"] = self.ipv6SourceCidrIp!
        }
        if self.nicType != nil {
            map["NicType"] = self.nicType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.permissions != nil {
            var tmp : [Any] = []
            for k in self.permissions! {
                tmp.append(k.toMap())
            }
            map["Permissions"] = tmp
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupRuleId != nil {
            map["SecurityGroupRuleId"] = self.securityGroupRuleId!
        }
        if self.sourceCidrIp != nil {
            map["SourceCidrIp"] = self.sourceCidrIp!
        }
        if self.sourceGroupId != nil {
            map["SourceGroupId"] = self.sourceGroupId!
        }
        if self.sourceGroupOwnerAccount != nil {
            map["SourceGroupOwnerAccount"] = self.sourceGroupOwnerAccount!
        }
        if self.sourceGroupOwnerId != nil {
            map["SourceGroupOwnerId"] = self.sourceGroupOwnerId!
        }
        if self.sourcePortRange != nil {
            map["SourcePortRange"] = self.sourcePortRange!
        }
        if self.sourcePrefixListId != nil {
            map["SourcePrefixListId"] = self.sourcePrefixListId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DestCidrIp"] as? String {
            self.destCidrIp = value
        }
        if let value = dict["IpProtocol"] as? String {
            self.ipProtocol = value
        }
        if let value = dict["Ipv6DestCidrIp"] as? String {
            self.ipv6DestCidrIp = value
        }
        if let value = dict["Ipv6SourceCidrIp"] as? String {
            self.ipv6SourceCidrIp = value
        }
        if let value = dict["NicType"] as? String {
            self.nicType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Permissions"] as? [Any?] {
            var tmp : [RevokeSecurityGroupRequest.Permissions] = []
            for v in value {
                if v != nil {
                    var model = RevokeSecurityGroupRequest.Permissions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.permissions = tmp
        }
        if let value = dict["Policy"] as? String {
            self.policy = value
        }
        if let value = dict["PortRange"] as? String {
            self.portRange = value
        }
        if let value = dict["Priority"] as? String {
            self.priority = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SecurityGroupRuleId"] as? [String] {
            self.securityGroupRuleId = value
        }
        if let value = dict["SourceCidrIp"] as? String {
            self.sourceCidrIp = value
        }
        if let value = dict["SourceGroupId"] as? String {
            self.sourceGroupId = value
        }
        if let value = dict["SourceGroupOwnerAccount"] as? String {
            self.sourceGroupOwnerAccount = value
        }
        if let value = dict["SourceGroupOwnerId"] as? Int64 {
            self.sourceGroupOwnerId = value
        }
        if let value = dict["SourcePortRange"] as? String {
            self.sourcePortRange = value
        }
        if let value = dict["SourcePrefixListId"] as? String {
            self.sourcePrefixListId = value
        }
    }
}

public class RevokeSecurityGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RevokeSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokeSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RevokeSecurityGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RevokeSecurityGroupEgressRequest : Tea.TeaModel {
    public class Permissions : Tea.TeaModel {
        public var description_: String?

        public var destCidrIp: String?

        public var destGroupId: String?

        public var destGroupOwnerAccount: String?

        public var destGroupOwnerId: String?

        public var destPrefixListId: String?

        public var ipProtocol: String?

        public var ipv6DestCidrIp: String?

        public var ipv6SourceCidrIp: String?

        public var nicType: String?

        public var policy: String?

        public var portRange: String?

        public var portRangeListId: String?

        public var priority: String?

        public var sourceCidrIp: String?

        public var sourcePortRange: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.destCidrIp != nil {
                map["DestCidrIp"] = self.destCidrIp!
            }
            if self.destGroupId != nil {
                map["DestGroupId"] = self.destGroupId!
            }
            if self.destGroupOwnerAccount != nil {
                map["DestGroupOwnerAccount"] = self.destGroupOwnerAccount!
            }
            if self.destGroupOwnerId != nil {
                map["DestGroupOwnerId"] = self.destGroupOwnerId!
            }
            if self.destPrefixListId != nil {
                map["DestPrefixListId"] = self.destPrefixListId!
            }
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.ipv6DestCidrIp != nil {
                map["Ipv6DestCidrIp"] = self.ipv6DestCidrIp!
            }
            if self.ipv6SourceCidrIp != nil {
                map["Ipv6SourceCidrIp"] = self.ipv6SourceCidrIp!
            }
            if self.nicType != nil {
                map["NicType"] = self.nicType!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            if self.portRangeListId != nil {
                map["PortRangeListId"] = self.portRangeListId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.sourceCidrIp != nil {
                map["SourceCidrIp"] = self.sourceCidrIp!
            }
            if self.sourcePortRange != nil {
                map["SourcePortRange"] = self.sourcePortRange!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DestCidrIp"] as? String {
                self.destCidrIp = value
            }
            if let value = dict["DestGroupId"] as? String {
                self.destGroupId = value
            }
            if let value = dict["DestGroupOwnerAccount"] as? String {
                self.destGroupOwnerAccount = value
            }
            if let value = dict["DestGroupOwnerId"] as? String {
                self.destGroupOwnerId = value
            }
            if let value = dict["DestPrefixListId"] as? String {
                self.destPrefixListId = value
            }
            if let value = dict["IpProtocol"] as? String {
                self.ipProtocol = value
            }
            if let value = dict["Ipv6DestCidrIp"] as? String {
                self.ipv6DestCidrIp = value
            }
            if let value = dict["Ipv6SourceCidrIp"] as? String {
                self.ipv6SourceCidrIp = value
            }
            if let value = dict["NicType"] as? String {
                self.nicType = value
            }
            if let value = dict["Policy"] as? String {
                self.policy = value
            }
            if let value = dict["PortRange"] as? String {
                self.portRange = value
            }
            if let value = dict["PortRangeListId"] as? String {
                self.portRangeListId = value
            }
            if let value = dict["Priority"] as? String {
                self.priority = value
            }
            if let value = dict["SourceCidrIp"] as? String {
                self.sourceCidrIp = value
            }
            if let value = dict["SourcePortRange"] as? String {
                self.sourcePortRange = value
            }
        }
    }
    public var clientToken: String?

    public var description_: String?

    public var destCidrIp: String?

    public var destGroupId: String?

    public var destGroupOwnerAccount: String?

    public var destGroupOwnerId: Int64?

    public var destPrefixListId: String?

    public var ipProtocol: String?

    public var ipv6DestCidrIp: String?

    public var ipv6SourceCidrIp: String?

    public var nicType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var permissions: [RevokeSecurityGroupEgressRequest.Permissions]?

    public var policy: String?

    public var portRange: String?

    public var priority: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public var securityGroupRuleId: [String]?

    public var sourceCidrIp: String?

    public var sourcePortRange: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destCidrIp != nil {
            map["DestCidrIp"] = self.destCidrIp!
        }
        if self.destGroupId != nil {
            map["DestGroupId"] = self.destGroupId!
        }
        if self.destGroupOwnerAccount != nil {
            map["DestGroupOwnerAccount"] = self.destGroupOwnerAccount!
        }
        if self.destGroupOwnerId != nil {
            map["DestGroupOwnerId"] = self.destGroupOwnerId!
        }
        if self.destPrefixListId != nil {
            map["DestPrefixListId"] = self.destPrefixListId!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.ipv6DestCidrIp != nil {
            map["Ipv6DestCidrIp"] = self.ipv6DestCidrIp!
        }
        if self.ipv6SourceCidrIp != nil {
            map["Ipv6SourceCidrIp"] = self.ipv6SourceCidrIp!
        }
        if self.nicType != nil {
            map["NicType"] = self.nicType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.permissions != nil {
            var tmp : [Any] = []
            for k in self.permissions! {
                tmp.append(k.toMap())
            }
            map["Permissions"] = tmp
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupRuleId != nil {
            map["SecurityGroupRuleId"] = self.securityGroupRuleId!
        }
        if self.sourceCidrIp != nil {
            map["SourceCidrIp"] = self.sourceCidrIp!
        }
        if self.sourcePortRange != nil {
            map["SourcePortRange"] = self.sourcePortRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DestCidrIp"] as? String {
            self.destCidrIp = value
        }
        if let value = dict["DestGroupId"] as? String {
            self.destGroupId = value
        }
        if let value = dict["DestGroupOwnerAccount"] as? String {
            self.destGroupOwnerAccount = value
        }
        if let value = dict["DestGroupOwnerId"] as? Int64 {
            self.destGroupOwnerId = value
        }
        if let value = dict["DestPrefixListId"] as? String {
            self.destPrefixListId = value
        }
        if let value = dict["IpProtocol"] as? String {
            self.ipProtocol = value
        }
        if let value = dict["Ipv6DestCidrIp"] as? String {
            self.ipv6DestCidrIp = value
        }
        if let value = dict["Ipv6SourceCidrIp"] as? String {
            self.ipv6SourceCidrIp = value
        }
        if let value = dict["NicType"] as? String {
            self.nicType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Permissions"] as? [Any?] {
            var tmp : [RevokeSecurityGroupEgressRequest.Permissions] = []
            for v in value {
                if v != nil {
                    var model = RevokeSecurityGroupEgressRequest.Permissions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.permissions = tmp
        }
        if let value = dict["Policy"] as? String {
            self.policy = value
        }
        if let value = dict["PortRange"] as? String {
            self.portRange = value
        }
        if let value = dict["Priority"] as? String {
            self.priority = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SecurityGroupRuleId"] as? [String] {
            self.securityGroupRuleId = value
        }
        if let value = dict["SourceCidrIp"] as? String {
            self.sourceCidrIp = value
        }
        if let value = dict["SourcePortRange"] as? String {
            self.sourcePortRange = value
        }
    }
}

public class RevokeSecurityGroupEgressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RevokeSecurityGroupEgressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokeSecurityGroupEgressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RevokeSecurityGroupEgressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RunCommandRequest : Tea.TeaModel {
    public class ResourceTag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var commandContent: String?

    public var containerId: String?

    public var containerName: String?

    public var contentEncoding: String?

    public var description_: String?

    public var enableParameter: Bool?

    public var frequency: String?

    public var instanceId: [String]?

    public var keepCommand: Bool?

    public var launcher: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var parameters: [String: Any]?

    public var regionId: String?

    public var repeatMode: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceTag: [RunCommandRequest.ResourceTag]?

    public var tag: [RunCommandRequest.Tag]?

    public var terminationMode: String?

    public var timed: Bool?

    public var timeout: Int64?

    public var type: String?

    public var username: String?

    public var windowsPasswordName: String?

    public var workingDir: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.commandContent != nil {
            map["CommandContent"] = self.commandContent!
        }
        if self.containerId != nil {
            map["ContainerId"] = self.containerId!
        }
        if self.containerName != nil {
            map["ContainerName"] = self.containerName!
        }
        if self.contentEncoding != nil {
            map["ContentEncoding"] = self.contentEncoding!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enableParameter != nil {
            map["EnableParameter"] = self.enableParameter!
        }
        if self.frequency != nil {
            map["Frequency"] = self.frequency!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.keepCommand != nil {
            map["KeepCommand"] = self.keepCommand!
        }
        if self.launcher != nil {
            map["Launcher"] = self.launcher!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.repeatMode != nil {
            map["RepeatMode"] = self.repeatMode!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceTag != nil {
            var tmp : [Any] = []
            for k in self.resourceTag! {
                tmp.append(k.toMap())
            }
            map["ResourceTag"] = tmp
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.terminationMode != nil {
            map["TerminationMode"] = self.terminationMode!
        }
        if self.timed != nil {
            map["Timed"] = self.timed!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.username != nil {
            map["Username"] = self.username!
        }
        if self.windowsPasswordName != nil {
            map["WindowsPasswordName"] = self.windowsPasswordName!
        }
        if self.workingDir != nil {
            map["WorkingDir"] = self.workingDir!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CommandContent"] as? String {
            self.commandContent = value
        }
        if let value = dict["ContainerId"] as? String {
            self.containerId = value
        }
        if let value = dict["ContainerName"] as? String {
            self.containerName = value
        }
        if let value = dict["ContentEncoding"] as? String {
            self.contentEncoding = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EnableParameter"] as? Bool {
            self.enableParameter = value
        }
        if let value = dict["Frequency"] as? String {
            self.frequency = value
        }
        if let value = dict["InstanceId"] as? [String] {
            self.instanceId = value
        }
        if let value = dict["KeepCommand"] as? Bool {
            self.keepCommand = value
        }
        if let value = dict["Launcher"] as? String {
            self.launcher = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Parameters"] as? [String: Any] {
            self.parameters = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RepeatMode"] as? String {
            self.repeatMode = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceTag"] as? [Any?] {
            var tmp : [RunCommandRequest.ResourceTag] = []
            for v in value {
                if v != nil {
                    var model = RunCommandRequest.ResourceTag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.resourceTag = tmp
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [RunCommandRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = RunCommandRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["TerminationMode"] as? String {
            self.terminationMode = value
        }
        if let value = dict["Timed"] as? Bool {
            self.timed = value
        }
        if let value = dict["Timeout"] as? Int64 {
            self.timeout = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["Username"] as? String {
            self.username = value
        }
        if let value = dict["WindowsPasswordName"] as? String {
            self.windowsPasswordName = value
        }
        if let value = dict["WorkingDir"] as? String {
            self.workingDir = value
        }
    }
}

public class RunCommandShrinkRequest : Tea.TeaModel {
    public class ResourceTag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var commandContent: String?

    public var containerId: String?

    public var containerName: String?

    public var contentEncoding: String?

    public var description_: String?

    public var enableParameter: Bool?

    public var frequency: String?

    public var instanceId: [String]?

    public var keepCommand: Bool?

    public var launcher: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var parametersShrink: String?

    public var regionId: String?

    public var repeatMode: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceTag: [RunCommandShrinkRequest.ResourceTag]?

    public var tag: [RunCommandShrinkRequest.Tag]?

    public var terminationMode: String?

    public var timed: Bool?

    public var timeout: Int64?

    public var type: String?

    public var username: String?

    public var windowsPasswordName: String?

    public var workingDir: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.commandContent != nil {
            map["CommandContent"] = self.commandContent!
        }
        if self.containerId != nil {
            map["ContainerId"] = self.containerId!
        }
        if self.containerName != nil {
            map["ContainerName"] = self.containerName!
        }
        if self.contentEncoding != nil {
            map["ContentEncoding"] = self.contentEncoding!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enableParameter != nil {
            map["EnableParameter"] = self.enableParameter!
        }
        if self.frequency != nil {
            map["Frequency"] = self.frequency!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.keepCommand != nil {
            map["KeepCommand"] = self.keepCommand!
        }
        if self.launcher != nil {
            map["Launcher"] = self.launcher!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.parametersShrink != nil {
            map["Parameters"] = self.parametersShrink!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.repeatMode != nil {
            map["RepeatMode"] = self.repeatMode!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceTag != nil {
            var tmp : [Any] = []
            for k in self.resourceTag! {
                tmp.append(k.toMap())
            }
            map["ResourceTag"] = tmp
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.terminationMode != nil {
            map["TerminationMode"] = self.terminationMode!
        }
        if self.timed != nil {
            map["Timed"] = self.timed!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.username != nil {
            map["Username"] = self.username!
        }
        if self.windowsPasswordName != nil {
            map["WindowsPasswordName"] = self.windowsPasswordName!
        }
        if self.workingDir != nil {
            map["WorkingDir"] = self.workingDir!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CommandContent"] as? String {
            self.commandContent = value
        }
        if let value = dict["ContainerId"] as? String {
            self.containerId = value
        }
        if let value = dict["ContainerName"] as? String {
            self.containerName = value
        }
        if let value = dict["ContentEncoding"] as? String {
            self.contentEncoding = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EnableParameter"] as? Bool {
            self.enableParameter = value
        }
        if let value = dict["Frequency"] as? String {
            self.frequency = value
        }
        if let value = dict["InstanceId"] as? [String] {
            self.instanceId = value
        }
        if let value = dict["KeepCommand"] as? Bool {
            self.keepCommand = value
        }
        if let value = dict["Launcher"] as? String {
            self.launcher = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Parameters"] as? String {
            self.parametersShrink = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RepeatMode"] as? String {
            self.repeatMode = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceTag"] as? [Any?] {
            var tmp : [RunCommandShrinkRequest.ResourceTag] = []
            for v in value {
                if v != nil {
                    var model = RunCommandShrinkRequest.ResourceTag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.resourceTag = tmp
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [RunCommandShrinkRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = RunCommandShrinkRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["TerminationMode"] as? String {
            self.terminationMode = value
        }
        if let value = dict["Timed"] as? Bool {
            self.timed = value
        }
        if let value = dict["Timeout"] as? Int64 {
            self.timeout = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["Username"] as? String {
            self.username = value
        }
        if let value = dict["WindowsPasswordName"] as? String {
            self.windowsPasswordName = value
        }
        if let value = dict["WorkingDir"] as? String {
            self.workingDir = value
        }
    }
}

public class RunCommandResponseBody : Tea.TeaModel {
    public var commandId: String?

    public var invokeId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandId != nil {
            map["CommandId"] = self.commandId!
        }
        if self.invokeId != nil {
            map["InvokeId"] = self.invokeId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CommandId"] as? String {
            self.commandId = value
        }
        if let value = dict["InvokeId"] as? String {
            self.invokeId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RunCommandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RunCommandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RunCommandResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RunInstancesRequest : Tea.TeaModel {
    public class CpuOptions : Tea.TeaModel {
        public var core: Int32?

        public var numa: String?

        public var threadsPerCore: Int32?

        public var topologyType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.core != nil {
                map["Core"] = self.core!
            }
            if self.numa != nil {
                map["Numa"] = self.numa!
            }
            if self.threadsPerCore != nil {
                map["ThreadsPerCore"] = self.threadsPerCore!
            }
            if self.topologyType != nil {
                map["TopologyType"] = self.topologyType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Core"] as? Int32 {
                self.core = value
            }
            if let value = dict["Numa"] as? String {
                self.numa = value
            }
            if let value = dict["ThreadsPerCore"] as? Int32 {
                self.threadsPerCore = value
            }
            if let value = dict["TopologyType"] as? String {
                self.topologyType = value
            }
        }
    }
    public class HibernationOptions : Tea.TeaModel {
        public var configured: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configured != nil {
                map["Configured"] = self.configured!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Configured"] as? Bool {
                self.configured = value
            }
        }
    }
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public var matchCriteria: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["MatchCriteria"] as? String {
                self.matchCriteria = value
            }
        }
    }
    public class SchedulerOptions : Tea.TeaModel {
        public var dedicatedHostClusterId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dedicatedHostClusterId != nil {
                map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DedicatedHostClusterId"] as? String {
                self.dedicatedHostClusterId = value
            }
        }
    }
    public class SecurityOptions : Tea.TeaModel {
        public var confidentialComputingMode: String?

        public var trustedSystemMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.confidentialComputingMode != nil {
                map["ConfidentialComputingMode"] = self.confidentialComputingMode!
            }
            if self.trustedSystemMode != nil {
                map["TrustedSystemMode"] = self.trustedSystemMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConfidentialComputingMode"] as? String {
                self.confidentialComputingMode = value
            }
            if let value = dict["TrustedSystemMode"] as? String {
                self.trustedSystemMode = value
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var category: String?

        public var description_: String?

        public var diskName: String?

        public var performanceLevel: String?

        public var size: String?

        public var burstingEnabled: Bool?

        public var encryptAlgorithm: String?

        public var encrypted: String?

        public var KMSKeyId: String?

        public var provisionedIops: Int64?

        public var storageClusterId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.encryptAlgorithm != nil {
                map["EncryptAlgorithm"] = self.encryptAlgorithm!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.storageClusterId != nil {
                map["StorageClusterId"] = self.storageClusterId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AutoSnapshotPolicyId"] as? String {
                self.autoSnapshotPolicyId = value
            }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DiskName"] as? String {
                self.diskName = value
            }
            if let value = dict["PerformanceLevel"] as? String {
                self.performanceLevel = value
            }
            if let value = dict["Size"] as? String {
                self.size = value
            }
            if let value = dict["BurstingEnabled"] as? Bool {
                self.burstingEnabled = value
            }
            if let value = dict["EncryptAlgorithm"] as? String {
                self.encryptAlgorithm = value
            }
            if let value = dict["Encrypted"] as? String {
                self.encrypted = value
            }
            if let value = dict["KMSKeyId"] as? String {
                self.KMSKeyId = value
            }
            if let value = dict["ProvisionedIops"] as? Int64 {
                self.provisionedIops = value
            }
            if let value = dict["StorageClusterId"] as? String {
                self.storageClusterId = value
            }
        }
    }
    public class Arn : Tea.TeaModel {
        public var assumeRoleFor: Int64?

        public var roleType: String?

        public var rolearn: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assumeRoleFor != nil {
                map["AssumeRoleFor"] = self.assumeRoleFor!
            }
            if self.roleType != nil {
                map["RoleType"] = self.roleType!
            }
            if self.rolearn != nil {
                map["Rolearn"] = self.rolearn!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AssumeRoleFor"] as? Int64 {
                self.assumeRoleFor = value
            }
            if let value = dict["RoleType"] as? String {
                self.roleType = value
            }
            if let value = dict["Rolearn"] as? String {
                self.rolearn = value
            }
        }
    }
    public class DataDisk : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var category: String?

        public var deleteWithInstance: Bool?

        public var description_: String?

        public var device: String?

        public var diskName: String?

        public var encryptAlgorithm: String?

        public var encrypted: String?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public var snapshotId: String?

        public var storageClusterId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.device != nil {
                map["Device"] = self.device!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encryptAlgorithm != nil {
                map["EncryptAlgorithm"] = self.encryptAlgorithm!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            if self.storageClusterId != nil {
                map["StorageClusterId"] = self.storageClusterId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AutoSnapshotPolicyId"] as? String {
                self.autoSnapshotPolicyId = value
            }
            if let value = dict["BurstingEnabled"] as? Bool {
                self.burstingEnabled = value
            }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["DeleteWithInstance"] as? Bool {
                self.deleteWithInstance = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Device"] as? String {
                self.device = value
            }
            if let value = dict["DiskName"] as? String {
                self.diskName = value
            }
            if let value = dict["EncryptAlgorithm"] as? String {
                self.encryptAlgorithm = value
            }
            if let value = dict["Encrypted"] as? String {
                self.encrypted = value
            }
            if let value = dict["KMSKeyId"] as? String {
                self.KMSKeyId = value
            }
            if let value = dict["PerformanceLevel"] as? String {
                self.performanceLevel = value
            }
            if let value = dict["ProvisionedIops"] as? Int64 {
                self.provisionedIops = value
            }
            if let value = dict["Size"] as? Int32 {
                self.size = value
            }
            if let value = dict["SnapshotId"] as? String {
                self.snapshotId = value
            }
            if let value = dict["StorageClusterId"] as? String {
                self.storageClusterId = value
            }
        }
    }
    public class ImageOptions : Tea.TeaModel {
        public var loginAsNonRoot: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loginAsNonRoot != nil {
                map["LoginAsNonRoot"] = self.loginAsNonRoot!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LoginAsNonRoot"] as? Bool {
                self.loginAsNonRoot = value
            }
        }
    }
    public class NetworkInterface : Tea.TeaModel {
        public var deleteOnRelease: Bool?

        public var description_: String?

        public var instanceType: String?

        public var ipv6Address: [String]?

        public var ipv6AddressCount: Int64?

        public var networkCardIndex: Int32?

        public var networkInterfaceId: String?

        public var networkInterfaceName: String?

        public var networkInterfaceTrafficMode: String?

        public var primaryIpAddress: String?

        public var queueNumber: Int32?

        public var queuePairNumber: Int64?

        public var rxQueueSize: Int32?

        public var securityGroupId: String?

        public var securityGroupIds: [String]?

        public var sourceDestCheck: Bool?

        public var txQueueSize: Int32?

        public var vSwitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deleteOnRelease != nil {
                map["DeleteOnRelease"] = self.deleteOnRelease!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.ipv6Address != nil {
                map["Ipv6Address"] = self.ipv6Address!
            }
            if self.ipv6AddressCount != nil {
                map["Ipv6AddressCount"] = self.ipv6AddressCount!
            }
            if self.networkCardIndex != nil {
                map["NetworkCardIndex"] = self.networkCardIndex!
            }
            if self.networkInterfaceId != nil {
                map["NetworkInterfaceId"] = self.networkInterfaceId!
            }
            if self.networkInterfaceName != nil {
                map["NetworkInterfaceName"] = self.networkInterfaceName!
            }
            if self.networkInterfaceTrafficMode != nil {
                map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
            }
            if self.primaryIpAddress != nil {
                map["PrimaryIpAddress"] = self.primaryIpAddress!
            }
            if self.queueNumber != nil {
                map["QueueNumber"] = self.queueNumber!
            }
            if self.queuePairNumber != nil {
                map["QueuePairNumber"] = self.queuePairNumber!
            }
            if self.rxQueueSize != nil {
                map["RxQueueSize"] = self.rxQueueSize!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.securityGroupIds != nil {
                map["SecurityGroupIds"] = self.securityGroupIds!
            }
            if self.sourceDestCheck != nil {
                map["SourceDestCheck"] = self.sourceDestCheck!
            }
            if self.txQueueSize != nil {
                map["TxQueueSize"] = self.txQueueSize!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DeleteOnRelease"] as? Bool {
                self.deleteOnRelease = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["Ipv6Address"] as? [String] {
                self.ipv6Address = value
            }
            if let value = dict["Ipv6AddressCount"] as? Int64 {
                self.ipv6AddressCount = value
            }
            if let value = dict["NetworkCardIndex"] as? Int32 {
                self.networkCardIndex = value
            }
            if let value = dict["NetworkInterfaceId"] as? String {
                self.networkInterfaceId = value
            }
            if let value = dict["NetworkInterfaceName"] as? String {
                self.networkInterfaceName = value
            }
            if let value = dict["NetworkInterfaceTrafficMode"] as? String {
                self.networkInterfaceTrafficMode = value
            }
            if let value = dict["PrimaryIpAddress"] as? String {
                self.primaryIpAddress = value
            }
            if let value = dict["QueueNumber"] as? Int32 {
                self.queueNumber = value
            }
            if let value = dict["QueuePairNumber"] as? Int64 {
                self.queuePairNumber = value
            }
            if let value = dict["RxQueueSize"] as? Int32 {
                self.rxQueueSize = value
            }
            if let value = dict["SecurityGroupId"] as? String {
                self.securityGroupId = value
            }
            if let value = dict["SecurityGroupIds"] as? [String] {
                self.securityGroupIds = value
            }
            if let value = dict["SourceDestCheck"] as? Bool {
                self.sourceDestCheck = value
            }
            if let value = dict["TxQueueSize"] as? Int32 {
                self.txQueueSize = value
            }
            if let value = dict["VSwitchId"] as? String {
                self.vSwitchId = value
            }
        }
    }
    public class NetworkOptions : Tea.TeaModel {
        public var enableJumboFrame: Bool?

        public var enableNetworkEncryption: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableJumboFrame != nil {
                map["EnableJumboFrame"] = self.enableJumboFrame!
            }
            if self.enableNetworkEncryption != nil {
                map["EnableNetworkEncryption"] = self.enableNetworkEncryption!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EnableJumboFrame"] as? Bool {
                self.enableJumboFrame = value
            }
            if let value = dict["EnableNetworkEncryption"] as? Bool {
                self.enableNetworkEncryption = value
            }
        }
    }
    public class PrivateDnsNameOptions : Tea.TeaModel {
        public var enableInstanceIdDnsAAAARecord: Bool?

        public var enableInstanceIdDnsARecord: Bool?

        public var enableIpDnsARecord: Bool?

        public var enableIpDnsPtrRecord: Bool?

        public var hostnameType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableInstanceIdDnsAAAARecord != nil {
                map["EnableInstanceIdDnsAAAARecord"] = self.enableInstanceIdDnsAAAARecord!
            }
            if self.enableInstanceIdDnsARecord != nil {
                map["EnableInstanceIdDnsARecord"] = self.enableInstanceIdDnsARecord!
            }
            if self.enableIpDnsARecord != nil {
                map["EnableIpDnsARecord"] = self.enableIpDnsARecord!
            }
            if self.enableIpDnsPtrRecord != nil {
                map["EnableIpDnsPtrRecord"] = self.enableIpDnsPtrRecord!
            }
            if self.hostnameType != nil {
                map["HostnameType"] = self.hostnameType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EnableInstanceIdDnsAAAARecord"] as? Bool {
                self.enableInstanceIdDnsAAAARecord = value
            }
            if let value = dict["EnableInstanceIdDnsARecord"] as? Bool {
                self.enableInstanceIdDnsARecord = value
            }
            if let value = dict["EnableIpDnsARecord"] as? Bool {
                self.enableIpDnsARecord = value
            }
            if let value = dict["EnableIpDnsPtrRecord"] as? Bool {
                self.enableIpDnsPtrRecord = value
            }
            if let value = dict["HostnameType"] as? String {
                self.hostnameType = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var cpuOptions: RunInstancesRequest.CpuOptions?

    public var hibernationOptions: RunInstancesRequest.HibernationOptions?

    public var privatePoolOptions: RunInstancesRequest.PrivatePoolOptions?

    public var schedulerOptions: RunInstancesRequest.SchedulerOptions?

    public var securityOptions: RunInstancesRequest.SecurityOptions?

    public var systemDisk: RunInstancesRequest.SystemDisk?

    public var affinity: String?

    public var amount: Int32?

    public var arn: [RunInstancesRequest.Arn]?

    public var autoPay: Bool?

    public var autoReleaseTime: String?

    public var autoRenew: Bool?

    public var autoRenewPeriod: Int32?

    public var clientToken: String?

    public var creditSpecification: String?

    public var dataDisk: [RunInstancesRequest.DataDisk]?

    public var dedicatedHostId: String?

    public var deletionProtection: Bool?

    public var deploymentSetGroupNo: Int32?

    public var deploymentSetId: String?

    public var description_: String?

    public var dryRun: Bool?

    public var hostName: String?

    public var hostNames: [String]?

    public var hpcClusterId: String?

    public var httpEndpoint: String?

    public var httpPutResponseHopLimit: Int32?

    public var httpTokens: String?

    public var imageFamily: String?

    public var imageId: String?

    public var imageOptions: RunInstancesRequest.ImageOptions?

    public var instanceChargeType: String?

    public var instanceName: String?

    public var instanceType: String?

    public var internetChargeType: String?

    public var internetMaxBandwidthIn: Int32?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var ipv6Address: [String]?

    public var ipv6AddressCount: Int32?

    public var isp: String?

    public var keyPairName: String?

    public var launchTemplateId: String?

    public var launchTemplateName: String?

    public var launchTemplateVersion: Int64?

    public var minAmount: Int32?

    public var networkInterface: [RunInstancesRequest.NetworkInterface]?

    public var networkInterfaceQueueNumber: Int32?

    public var networkOptions: RunInstancesRequest.NetworkOptions?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var password: String?

    public var passwordInherit: Bool?

    public var period: Int32?

    public var periodUnit: String?

    public var privateDnsNameOptions: RunInstancesRequest.PrivateDnsNameOptions?

    public var privateIpAddress: String?

    public var ramRoleName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityEnhancementStrategy: String?

    public var securityGroupId: String?

    public var securityGroupIds: [String]?

    public var spotDuration: Int32?

    public var spotInterruptionBehavior: String?

    public var spotPriceLimit: Double?

    public var spotStrategy: String?

    public var storageSetId: String?

    public var storageSetPartitionNumber: Int32?

    public var tag: [RunInstancesRequest.Tag]?

    public var tenancy: String?

    public var uniqueSuffix: Bool?

    public var userData: String?

    public var vSwitchId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.cpuOptions?.validate()
        try self.hibernationOptions?.validate()
        try self.privatePoolOptions?.validate()
        try self.schedulerOptions?.validate()
        try self.securityOptions?.validate()
        try self.systemDisk?.validate()
        try self.imageOptions?.validate()
        try self.networkOptions?.validate()
        try self.privateDnsNameOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cpuOptions != nil {
            map["CpuOptions"] = self.cpuOptions?.toMap()
        }
        if self.hibernationOptions != nil {
            map["HibernationOptions"] = self.hibernationOptions?.toMap()
        }
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.schedulerOptions != nil {
            map["SchedulerOptions"] = self.schedulerOptions?.toMap()
        }
        if self.securityOptions != nil {
            map["SecurityOptions"] = self.securityOptions?.toMap()
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.affinity != nil {
            map["Affinity"] = self.affinity!
        }
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.arn != nil {
            var tmp : [Any] = []
            for k in self.arn! {
                tmp.append(k.toMap())
            }
            map["Arn"] = tmp
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoReleaseTime != nil {
            map["AutoReleaseTime"] = self.autoReleaseTime!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewPeriod != nil {
            map["AutoRenewPeriod"] = self.autoRenewPeriod!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.creditSpecification != nil {
            map["CreditSpecification"] = self.creditSpecification!
        }
        if self.dataDisk != nil {
            var tmp : [Any] = []
            for k in self.dataDisk! {
                tmp.append(k.toMap())
            }
            map["DataDisk"] = tmp
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.deploymentSetGroupNo != nil {
            map["DeploymentSetGroupNo"] = self.deploymentSetGroupNo!
        }
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.hostNames != nil {
            map["HostNames"] = self.hostNames!
        }
        if self.hpcClusterId != nil {
            map["HpcClusterId"] = self.hpcClusterId!
        }
        if self.httpEndpoint != nil {
            map["HttpEndpoint"] = self.httpEndpoint!
        }
        if self.httpPutResponseHopLimit != nil {
            map["HttpPutResponseHopLimit"] = self.httpPutResponseHopLimit!
        }
        if self.httpTokens != nil {
            map["HttpTokens"] = self.httpTokens!
        }
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageOptions != nil {
            map["ImageOptions"] = self.imageOptions?.toMap()
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthIn != nil {
            map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.ipv6Address != nil {
            map["Ipv6Address"] = self.ipv6Address!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateName != nil {
            map["LaunchTemplateName"] = self.launchTemplateName!
        }
        if self.launchTemplateVersion != nil {
            map["LaunchTemplateVersion"] = self.launchTemplateVersion!
        }
        if self.minAmount != nil {
            map["MinAmount"] = self.minAmount!
        }
        if self.networkInterface != nil {
            var tmp : [Any] = []
            for k in self.networkInterface! {
                tmp.append(k.toMap())
            }
            map["NetworkInterface"] = tmp
        }
        if self.networkInterfaceQueueNumber != nil {
            map["NetworkInterfaceQueueNumber"] = self.networkInterfaceQueueNumber!
        }
        if self.networkOptions != nil {
            map["NetworkOptions"] = self.networkOptions?.toMap()
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.privateDnsNameOptions != nil {
            map["PrivateDnsNameOptions"] = self.privateDnsNameOptions?.toMap()
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityEnhancementStrategy != nil {
            map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds!
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.spotInterruptionBehavior != nil {
            map["SpotInterruptionBehavior"] = self.spotInterruptionBehavior!
        }
        if self.spotPriceLimit != nil {
            map["SpotPriceLimit"] = self.spotPriceLimit!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        if self.storageSetPartitionNumber != nil {
            map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.tenancy != nil {
            map["Tenancy"] = self.tenancy!
        }
        if self.uniqueSuffix != nil {
            map["UniqueSuffix"] = self.uniqueSuffix!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CpuOptions"] as? [String: Any?] {
            var model = RunInstancesRequest.CpuOptions()
            model.fromMap(value)
            self.cpuOptions = model
        }
        if let value = dict["HibernationOptions"] as? [String: Any?] {
            var model = RunInstancesRequest.HibernationOptions()
            model.fromMap(value)
            self.hibernationOptions = model
        }
        if let value = dict["PrivatePoolOptions"] as? [String: Any?] {
            var model = RunInstancesRequest.PrivatePoolOptions()
            model.fromMap(value)
            self.privatePoolOptions = model
        }
        if let value = dict["SchedulerOptions"] as? [String: Any?] {
            var model = RunInstancesRequest.SchedulerOptions()
            model.fromMap(value)
            self.schedulerOptions = model
        }
        if let value = dict["SecurityOptions"] as? [String: Any?] {
            var model = RunInstancesRequest.SecurityOptions()
            model.fromMap(value)
            self.securityOptions = model
        }
        if let value = dict["SystemDisk"] as? [String: Any?] {
            var model = RunInstancesRequest.SystemDisk()
            model.fromMap(value)
            self.systemDisk = model
        }
        if let value = dict["Affinity"] as? String {
            self.affinity = value
        }
        if let value = dict["Amount"] as? Int32 {
            self.amount = value
        }
        if let value = dict["Arn"] as? [Any?] {
            var tmp : [RunInstancesRequest.Arn] = []
            for v in value {
                if v != nil {
                    var model = RunInstancesRequest.Arn()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.arn = tmp
        }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["AutoReleaseTime"] as? String {
            self.autoReleaseTime = value
        }
        if let value = dict["AutoRenew"] as? Bool {
            self.autoRenew = value
        }
        if let value = dict["AutoRenewPeriod"] as? Int32 {
            self.autoRenewPeriod = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CreditSpecification"] as? String {
            self.creditSpecification = value
        }
        if let value = dict["DataDisk"] as? [Any?] {
            var tmp : [RunInstancesRequest.DataDisk] = []
            for v in value {
                if v != nil {
                    var model = RunInstancesRequest.DataDisk()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.dataDisk = tmp
        }
        if let value = dict["DedicatedHostId"] as? String {
            self.dedicatedHostId = value
        }
        if let value = dict["DeletionProtection"] as? Bool {
            self.deletionProtection = value
        }
        if let value = dict["DeploymentSetGroupNo"] as? Int32 {
            self.deploymentSetGroupNo = value
        }
        if let value = dict["DeploymentSetId"] as? String {
            self.deploymentSetId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["HostName"] as? String {
            self.hostName = value
        }
        if let value = dict["HostNames"] as? [String] {
            self.hostNames = value
        }
        if let value = dict["HpcClusterId"] as? String {
            self.hpcClusterId = value
        }
        if let value = dict["HttpEndpoint"] as? String {
            self.httpEndpoint = value
        }
        if let value = dict["HttpPutResponseHopLimit"] as? Int32 {
            self.httpPutResponseHopLimit = value
        }
        if let value = dict["HttpTokens"] as? String {
            self.httpTokens = value
        }
        if let value = dict["ImageFamily"] as? String {
            self.imageFamily = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["ImageOptions"] as? [String: Any?] {
            var model = RunInstancesRequest.ImageOptions()
            model.fromMap(value)
            self.imageOptions = model
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["InternetChargeType"] as? String {
            self.internetChargeType = value
        }
        if let value = dict["InternetMaxBandwidthIn"] as? Int32 {
            self.internetMaxBandwidthIn = value
        }
        if let value = dict["InternetMaxBandwidthOut"] as? Int32 {
            self.internetMaxBandwidthOut = value
        }
        if let value = dict["IoOptimized"] as? String {
            self.ioOptimized = value
        }
        if let value = dict["Ipv6Address"] as? [String] {
            self.ipv6Address = value
        }
        if let value = dict["Ipv6AddressCount"] as? Int32 {
            self.ipv6AddressCount = value
        }
        if let value = dict["Isp"] as? String {
            self.isp = value
        }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["LaunchTemplateId"] as? String {
            self.launchTemplateId = value
        }
        if let value = dict["LaunchTemplateName"] as? String {
            self.launchTemplateName = value
        }
        if let value = dict["LaunchTemplateVersion"] as? Int64 {
            self.launchTemplateVersion = value
        }
        if let value = dict["MinAmount"] as? Int32 {
            self.minAmount = value
        }
        if let value = dict["NetworkInterface"] as? [Any?] {
            var tmp : [RunInstancesRequest.NetworkInterface] = []
            for v in value {
                if v != nil {
                    var model = RunInstancesRequest.NetworkInterface()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.networkInterface = tmp
        }
        if let value = dict["NetworkInterfaceQueueNumber"] as? Int32 {
            self.networkInterfaceQueueNumber = value
        }
        if let value = dict["NetworkOptions"] as? [String: Any?] {
            var model = RunInstancesRequest.NetworkOptions()
            model.fromMap(value)
            self.networkOptions = model
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Password"] as? String {
            self.password = value
        }
        if let value = dict["PasswordInherit"] as? Bool {
            self.passwordInherit = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PeriodUnit"] as? String {
            self.periodUnit = value
        }
        if let value = dict["PrivateDnsNameOptions"] as? [String: Any?] {
            var model = RunInstancesRequest.PrivateDnsNameOptions()
            model.fromMap(value)
            self.privateDnsNameOptions = model
        }
        if let value = dict["PrivateIpAddress"] as? String {
            self.privateIpAddress = value
        }
        if let value = dict["RamRoleName"] as? String {
            self.ramRoleName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityEnhancementStrategy"] as? String {
            self.securityEnhancementStrategy = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SecurityGroupIds"] as? [String] {
            self.securityGroupIds = value
        }
        if let value = dict["SpotDuration"] as? Int32 {
            self.spotDuration = value
        }
        if let value = dict["SpotInterruptionBehavior"] as? String {
            self.spotInterruptionBehavior = value
        }
        if let value = dict["SpotPriceLimit"] as? Double {
            self.spotPriceLimit = value
        }
        if let value = dict["SpotStrategy"] as? String {
            self.spotStrategy = value
        }
        if let value = dict["StorageSetId"] as? String {
            self.storageSetId = value
        }
        if let value = dict["StorageSetPartitionNumber"] as? Int32 {
            self.storageSetPartitionNumber = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [RunInstancesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = RunInstancesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["Tenancy"] as? String {
            self.tenancy = value
        }
        if let value = dict["UniqueSuffix"] as? Bool {
            self.uniqueSuffix = value
        }
        if let value = dict["UserData"] as? String {
            self.userData = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class RunInstancesResponseBody : Tea.TeaModel {
    public class InstanceIdSets : Tea.TeaModel {
        public var instanceIdSet: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceIdSet != nil {
                map["InstanceIdSet"] = self.instanceIdSet!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceIdSet"] as? [String] {
                self.instanceIdSet = value
            }
        }
    }
    public var instanceIdSets: RunInstancesResponseBody.InstanceIdSets?

    public var orderId: String?

    public var requestId: String?

    public var tradePrice: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceIdSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIdSets != nil {
            map["InstanceIdSets"] = self.instanceIdSets?.toMap()
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tradePrice != nil {
            map["TradePrice"] = self.tradePrice!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceIdSets"] as? [String: Any?] {
            var model = RunInstancesResponseBody.InstanceIdSets()
            model.fromMap(value)
            self.instanceIdSets = model
        }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TradePrice"] as? Double {
            self.tradePrice = value
        }
    }
}

public class RunInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RunInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RunInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SendFileRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var content: String?

    public var contentType: String?

    public var description_: String?

    public var fileGroup: String?

    public var fileMode: String?

    public var fileOwner: String?

    public var instanceId: [String]?

    public var name: String?

    public var overwrite: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [SendFileRequest.Tag]?

    public var targetDir: String?

    public var timeout: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.contentType != nil {
            map["ContentType"] = self.contentType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.fileGroup != nil {
            map["FileGroup"] = self.fileGroup!
        }
        if self.fileMode != nil {
            map["FileMode"] = self.fileMode!
        }
        if self.fileOwner != nil {
            map["FileOwner"] = self.fileOwner!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.overwrite != nil {
            map["Overwrite"] = self.overwrite!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.targetDir != nil {
            map["TargetDir"] = self.targetDir!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Content"] as? String {
            self.content = value
        }
        if let value = dict["ContentType"] as? String {
            self.contentType = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["FileGroup"] as? String {
            self.fileGroup = value
        }
        if let value = dict["FileMode"] as? String {
            self.fileMode = value
        }
        if let value = dict["FileOwner"] as? String {
            self.fileOwner = value
        }
        if let value = dict["InstanceId"] as? [String] {
            self.instanceId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Overwrite"] as? Bool {
            self.overwrite = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [SendFileRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = SendFileRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["TargetDir"] as? String {
            self.targetDir = value
        }
        if let value = dict["Timeout"] as? Int64 {
            self.timeout = value
        }
    }
}

public class SendFileResponseBody : Tea.TeaModel {
    public var invokeId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.invokeId != nil {
            map["InvokeId"] = self.invokeId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InvokeId"] as? String {
            self.invokeId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SendFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SendFileResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartImagePipelineExecutionRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class TemplateTag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var imagePipelineId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [StartImagePipelineExecutionRequest.Tag]?

    public var templateTag: [StartImagePipelineExecutionRequest.TemplateTag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.imagePipelineId != nil {
            map["ImagePipelineId"] = self.imagePipelineId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.templateTag != nil {
            var tmp : [Any] = []
            for k in self.templateTag! {
                tmp.append(k.toMap())
            }
            map["TemplateTag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ImagePipelineId"] as? String {
            self.imagePipelineId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [StartImagePipelineExecutionRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = StartImagePipelineExecutionRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["TemplateTag"] as? [Any?] {
            var tmp : [StartImagePipelineExecutionRequest.TemplateTag] = []
            for v in value {
                if v != nil {
                    var model = StartImagePipelineExecutionRequest.TemplateTag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.templateTag = tmp
        }
    }
}

public class StartImagePipelineExecutionResponseBody : Tea.TeaModel {
    public var executionId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.executionId != nil {
            map["ExecutionId"] = self.executionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ExecutionId"] as? String {
            self.executionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StartImagePipelineExecutionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartImagePipelineExecutionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartImagePipelineExecutionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartInstanceRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var initLocalDisk: Bool?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.initLocalDisk != nil {
            map["InitLocalDisk"] = self.initLocalDisk!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["InitLocalDisk"] as? Bool {
            self.initLocalDisk = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class StartInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StartInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartInstancesRequest : Tea.TeaModel {
    public var batchOptimization: String?

    public var dryRun: Bool?

    public var instanceId: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchOptimization != nil {
            map["BatchOptimization"] = self.batchOptimization!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BatchOptimization"] as? String {
            self.batchOptimization = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["InstanceId"] as? [String] {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class StartInstancesResponseBody : Tea.TeaModel {
    public class InstanceResponses : Tea.TeaModel {
        public class InstanceResponse : Tea.TeaModel {
            public var code: String?

            public var currentStatus: String?

            public var instanceId: String?

            public var message: String?

            public var previousStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.currentStatus != nil {
                    map["CurrentStatus"] = self.currentStatus!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.previousStatus != nil {
                    map["PreviousStatus"] = self.previousStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Code"] as? String {
                    self.code = value
                }
                if let value = dict["CurrentStatus"] as? String {
                    self.currentStatus = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["Message"] as? String {
                    self.message = value
                }
                if let value = dict["PreviousStatus"] as? String {
                    self.previousStatus = value
                }
            }
        }
        public var instanceResponse: [StartInstancesResponseBody.InstanceResponses.InstanceResponse]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceResponse != nil {
                var tmp : [Any] = []
                for k in self.instanceResponse! {
                    tmp.append(k.toMap())
                }
                map["InstanceResponse"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceResponse"] as? [Any?] {
                var tmp : [StartInstancesResponseBody.InstanceResponses.InstanceResponse] = []
                for v in value {
                    if v != nil {
                        var model = StartInstancesResponseBody.InstanceResponses.InstanceResponse()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instanceResponse = tmp
            }
        }
    }
    public var instanceResponses: StartInstancesResponseBody.InstanceResponses?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceResponses?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceResponses != nil {
            map["InstanceResponses"] = self.instanceResponses?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceResponses"] as? [String: Any?] {
            var model = StartInstancesResponseBody.InstanceResponses()
            model.fromMap(value)
            self.instanceResponses = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StartInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartTerminalSessionRequest : Tea.TeaModel {
    public var commandLine: String?

    public var connectionType: String?

    public var instanceId: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var portNumber: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var targetServer: String?

    public var username: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandLine != nil {
            map["CommandLine"] = self.commandLine!
        }
        if self.connectionType != nil {
            map["ConnectionType"] = self.connectionType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.portNumber != nil {
            map["PortNumber"] = self.portNumber!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.targetServer != nil {
            map["TargetServer"] = self.targetServer!
        }
        if self.username != nil {
            map["Username"] = self.username!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CommandLine"] as? String {
            self.commandLine = value
        }
        if let value = dict["ConnectionType"] as? String {
            self.connectionType = value
        }
        if let value = dict["InstanceId"] as? [String] {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PortNumber"] as? Int32 {
            self.portNumber = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TargetServer"] as? String {
            self.targetServer = value
        }
        if let value = dict["Username"] as? String {
            self.username = value
        }
    }
}

public class StartTerminalSessionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var securityToken: String?

    public var sessionId: String?

    public var webSocketUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.sessionId != nil {
            map["SessionId"] = self.sessionId!
        }
        if self.webSocketUrl != nil {
            map["WebSocketUrl"] = self.webSocketUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["SessionId"] as? String {
            self.sessionId = value
        }
        if let value = dict["WebSocketUrl"] as? String {
            self.webSocketUrl = value
        }
    }
}

public class StartTerminalSessionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartTerminalSessionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartTerminalSessionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopInstanceRequest : Tea.TeaModel {
    public var confirmStop: Bool?

    public var dryRun: Bool?

    public var forceStop: Bool?

    public var hibernate: Bool?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var stoppedMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.confirmStop != nil {
            map["ConfirmStop"] = self.confirmStop!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.forceStop != nil {
            map["ForceStop"] = self.forceStop!
        }
        if self.hibernate != nil {
            map["Hibernate"] = self.hibernate!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.stoppedMode != nil {
            map["StoppedMode"] = self.stoppedMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfirmStop"] as? Bool {
            self.confirmStop = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["ForceStop"] as? Bool {
            self.forceStop = value
        }
        if let value = dict["Hibernate"] as? Bool {
            self.hibernate = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StoppedMode"] as? String {
            self.stoppedMode = value
        }
    }
}

public class StopInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StopInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopInstancesRequest : Tea.TeaModel {
    public var batchOptimization: String?

    public var dryRun: Bool?

    public var forceStop: Bool?

    public var instanceId: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var stoppedMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchOptimization != nil {
            map["BatchOptimization"] = self.batchOptimization!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.forceStop != nil {
            map["ForceStop"] = self.forceStop!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.stoppedMode != nil {
            map["StoppedMode"] = self.stoppedMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BatchOptimization"] as? String {
            self.batchOptimization = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["ForceStop"] as? Bool {
            self.forceStop = value
        }
        if let value = dict["InstanceId"] as? [String] {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StoppedMode"] as? String {
            self.stoppedMode = value
        }
    }
}

public class StopInstancesResponseBody : Tea.TeaModel {
    public class InstanceResponses : Tea.TeaModel {
        public class InstanceResponse : Tea.TeaModel {
            public var code: String?

            public var currentStatus: String?

            public var instanceId: String?

            public var message: String?

            public var previousStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.currentStatus != nil {
                    map["CurrentStatus"] = self.currentStatus!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.previousStatus != nil {
                    map["PreviousStatus"] = self.previousStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Code"] as? String {
                    self.code = value
                }
                if let value = dict["CurrentStatus"] as? String {
                    self.currentStatus = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["Message"] as? String {
                    self.message = value
                }
                if let value = dict["PreviousStatus"] as? String {
                    self.previousStatus = value
                }
            }
        }
        public var instanceResponse: [StopInstancesResponseBody.InstanceResponses.InstanceResponse]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceResponse != nil {
                var tmp : [Any] = []
                for k in self.instanceResponse! {
                    tmp.append(k.toMap())
                }
                map["InstanceResponse"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceResponse"] as? [Any?] {
                var tmp : [StopInstancesResponseBody.InstanceResponses.InstanceResponse] = []
                for v in value {
                    if v != nil {
                        var model = StopInstancesResponseBody.InstanceResponses.InstanceResponse()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instanceResponse = tmp
            }
        }
    }
    public var instanceResponses: StopInstancesResponseBody.InstanceResponses?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceResponses?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceResponses != nil {
            map["InstanceResponses"] = self.instanceResponses?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceResponses"] as? [String: Any?] {
            var model = StopInstancesResponseBody.InstanceResponses()
            model.fromMap(value)
            self.instanceResponses = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StopInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopInvocationRequest : Tea.TeaModel {
    public var instanceId: [String]?

    public var invokeId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.invokeId != nil {
            map["InvokeId"] = self.invokeId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? [String] {
            self.instanceId = value
        }
        if let value = dict["InvokeId"] as? String {
            self.invokeId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class StopInvocationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StopInvocationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopInvocationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopInvocationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceType: String?

    public var tag: [TagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [TagResourcesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = TagResourcesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TerminatePhysicalConnectionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userCidr: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PhysicalConnectionId"] as? String {
            self.physicalConnectionId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["UserCidr"] as? String {
            self.userCidr = value
        }
    }
}

public class TerminatePhysicalConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class TerminatePhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TerminatePhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TerminatePhysicalConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TerminateVirtualBorderRouterRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userCidr: String?

    public var vbrId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["UserCidr"] as? String {
            self.userCidr = value
        }
        if let value = dict["VbrId"] as? String {
            self.vbrId = value
        }
    }
}

public class TerminateVirtualBorderRouterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class TerminateVirtualBorderRouterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TerminateVirtualBorderRouterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TerminateVirtualBorderRouterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UnassignIpv6AddressesRequest : Tea.TeaModel {
    public var ipv6Address: [String]?

    public var ipv6Prefix: [String]?

    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6Address != nil {
            map["Ipv6Address"] = self.ipv6Address!
        }
        if self.ipv6Prefix != nil {
            map["Ipv6Prefix"] = self.ipv6Prefix!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ipv6Address"] as? [String] {
            self.ipv6Address = value
        }
        if let value = dict["Ipv6Prefix"] as? [String] {
            self.ipv6Prefix = value
        }
        if let value = dict["NetworkInterfaceId"] as? String {
            self.networkInterfaceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class UnassignIpv6AddressesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UnassignIpv6AddressesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnassignIpv6AddressesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UnassignIpv6AddressesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UnassignPrivateIpAddressesRequest : Tea.TeaModel {
    public var ipv4Prefix: [String]?

    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var privateIpAddress: [String]?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv4Prefix != nil {
            map["Ipv4Prefix"] = self.ipv4Prefix!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ipv4Prefix"] as? [String] {
            self.ipv4Prefix = value
        }
        if let value = dict["NetworkInterfaceId"] as? String {
            self.networkInterfaceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PrivateIpAddress"] as? [String] {
            self.privateIpAddress = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class UnassignPrivateIpAddressesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UnassignPrivateIpAddressesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnassignPrivateIpAddressesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UnassignPrivateIpAddressesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UnassociateEipAddressRequest : Tea.TeaModel {
    public var allocationId: String?

    public var instanceId: String?

    public var instanceType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AllocationId"] as? String {
            self.allocationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class UnassociateEipAddressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UnassociateEipAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnassociateEipAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UnassociateEipAddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UnassociateHaVipRequest : Tea.TeaModel {
    public var clientToken: String?

    public var force: String?

    public var haVipId: String?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.haVipId != nil {
            map["HaVipId"] = self.haVipId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Force"] as? String {
            self.force = value
        }
        if let value = dict["HaVipId"] as? String {
            self.haVipId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class UnassociateHaVipResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UnassociateHaVipResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnassociateHaVipResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UnassociateHaVipResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public var all: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tagKey: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["All"] as? Bool {
            self.all = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["TagKey"] as? [String] {
            self.tagKey = value
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UntagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}
