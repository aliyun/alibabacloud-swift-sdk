import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class DataExtraInfoSubCondsValue : Tea.TeaModel {
    public var tenantName: String?

    public var database: String?

    public var destDatabase: String?

    public var tableName: String?

    public var destName: String?

    public var whereClause: String?

    public var filterColumns: [String]?

    public var shardColumns: [String]?

    public var logicTableId: String?

    public var sourceEndpointId: String?

    public var sourceClientId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantName != nil {
            map["TenantName"] = self.tenantName!
        }
        if self.database != nil {
            map["Database"] = self.database!
        }
        if self.destDatabase != nil {
            map["DestDatabase"] = self.destDatabase!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.destName != nil {
            map["DestName"] = self.destName!
        }
        if self.whereClause != nil {
            map["WhereClause"] = self.whereClause!
        }
        if self.filterColumns != nil {
            map["FilterColumns"] = self.filterColumns!
        }
        if self.shardColumns != nil {
            map["ShardColumns"] = self.shardColumns!
        }
        if self.logicTableId != nil {
            map["LogicTableId"] = self.logicTableId!
        }
        if self.sourceEndpointId != nil {
            map["SourceEndpointId"] = self.sourceEndpointId!
        }
        if self.sourceClientId != nil {
            map["SourceClientId"] = self.sourceClientId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantName") {
            self.tenantName = dict["TenantName"] as! String
        }
        if dict.keys.contains("Database") {
            self.database = dict["Database"] as! String
        }
        if dict.keys.contains("DestDatabase") {
            self.destDatabase = dict["DestDatabase"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("DestName") {
            self.destName = dict["DestName"] as! String
        }
        if dict.keys.contains("WhereClause") {
            self.whereClause = dict["WhereClause"] as! String
        }
        if dict.keys.contains("FilterColumns") {
            self.filterColumns = dict["FilterColumns"] as! [String]
        }
        if dict.keys.contains("ShardColumns") {
            self.shardColumns = dict["ShardColumns"] as! [String]
        }
        if dict.keys.contains("LogicTableId") {
            self.logicTableId = dict["LogicTableId"] as! String
        }
        if dict.keys.contains("SourceEndpointId") {
            self.sourceEndpointId = dict["SourceEndpointId"] as! String
        }
        if dict.keys.contains("SourceClientId") {
            self.sourceClientId = dict["SourceClientId"] as! String
        }
    }
}

public class DataExtraInfoSubDbsValue : Tea.TeaModel {
    public class Tables : Tea.TeaModel {
        public class Columns : Tea.TeaModel {
            public var columnName: String?

            public var position: Int32?

            public var columnType: String?

            public var recordFieldType: String?

            public var rawColumnType: String?

            public var columnKey: String?

            public var nullable: Bool?

            public var defaultValue: String?

            public var dataLength: Int64?

            public var dataPrecision: Int32?

            public var dataScale: Int32?

            public var encoding: String?

            public var columnComment: String?

            public var isGenerateField: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.position != nil {
                    map["Position"] = self.position!
                }
                if self.columnType != nil {
                    map["ColumnType"] = self.columnType!
                }
                if self.recordFieldType != nil {
                    map["RecordFieldType"] = self.recordFieldType!
                }
                if self.rawColumnType != nil {
                    map["RawColumnType"] = self.rawColumnType!
                }
                if self.columnKey != nil {
                    map["ColumnKey"] = self.columnKey!
                }
                if self.nullable != nil {
                    map["Nullable"] = self.nullable!
                }
                if self.defaultValue != nil {
                    map["DefaultValue"] = self.defaultValue!
                }
                if self.dataLength != nil {
                    map["DataLength"] = self.dataLength!
                }
                if self.dataPrecision != nil {
                    map["DataPrecision"] = self.dataPrecision!
                }
                if self.dataScale != nil {
                    map["DataScale"] = self.dataScale!
                }
                if self.encoding != nil {
                    map["Encoding"] = self.encoding!
                }
                if self.columnComment != nil {
                    map["ColumnComment"] = self.columnComment!
                }
                if self.isGenerateField != nil {
                    map["IsGenerateField"] = self.isGenerateField!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ColumnName") {
                    self.columnName = dict["ColumnName"] as! String
                }
                if dict.keys.contains("Position") {
                    self.position = dict["Position"] as! Int32
                }
                if dict.keys.contains("ColumnType") {
                    self.columnType = dict["ColumnType"] as! String
                }
                if dict.keys.contains("RecordFieldType") {
                    self.recordFieldType = dict["RecordFieldType"] as! String
                }
                if dict.keys.contains("RawColumnType") {
                    self.rawColumnType = dict["RawColumnType"] as! String
                }
                if dict.keys.contains("ColumnKey") {
                    self.columnKey = dict["ColumnKey"] as! String
                }
                if dict.keys.contains("Nullable") {
                    self.nullable = dict["Nullable"] as! Bool
                }
                if dict.keys.contains("DefaultValue") {
                    self.defaultValue = dict["DefaultValue"] as! String
                }
                if dict.keys.contains("DataLength") {
                    self.dataLength = dict["DataLength"] as! Int64
                }
                if dict.keys.contains("DataPrecision") {
                    self.dataPrecision = dict["DataPrecision"] as! Int32
                }
                if dict.keys.contains("DataScale") {
                    self.dataScale = dict["DataScale"] as! Int32
                }
                if dict.keys.contains("Encoding") {
                    self.encoding = dict["Encoding"] as! String
                }
                if dict.keys.contains("ColumnComment") {
                    self.columnComment = dict["ColumnComment"] as! String
                }
                if dict.keys.contains("IsGenerateField") {
                    self.isGenerateField = dict["IsGenerateField"] as! Bool
                }
            }
        }
        public var tableId: String?

        public var database: String?

        public var tableName: String?

        public var mappingTableName: String?

        public var instance: String?

        public var columns: [DataExtraInfoSubDbsValue.Tables.Columns]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tableId != nil {
                map["TableId"] = self.tableId!
            }
            if self.database != nil {
                map["Database"] = self.database!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            if self.mappingTableName != nil {
                map["MappingTableName"] = self.mappingTableName!
            }
            if self.instance != nil {
                map["Instance"] = self.instance!
            }
            if self.columns != nil {
                var tmp : [Any] = []
                for k in self.columns! {
                    tmp.append(k.toMap())
                }
                map["Columns"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TableId") {
                self.tableId = dict["TableId"] as! String
            }
            if dict.keys.contains("Database") {
                self.database = dict["Database"] as! String
            }
            if dict.keys.contains("TableName") {
                self.tableName = dict["TableName"] as! String
            }
            if dict.keys.contains("MappingTableName") {
                self.mappingTableName = dict["MappingTableName"] as! String
            }
            if dict.keys.contains("Instance") {
                self.instance = dict["Instance"] as! String
            }
            if dict.keys.contains("Columns") {
                var tmp : [DataExtraInfoSubDbsValue.Tables.Columns] = []
                for v in dict["Columns"] as! [Any] {
                    var model = DataExtraInfoSubDbsValue.Tables.Columns()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.columns = tmp
            }
        }
    }
    public var clusterName: String?

    public var tenantName: String?

    public var databaseId: String?

    public var databaseName: String?

    public var mappingDatabaseName: String?

    public var sourceClientId: String?

    public var tables: [DataExtraInfoSubDbsValue.Tables]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.tenantName != nil {
            map["TenantName"] = self.tenantName!
        }
        if self.databaseId != nil {
            map["DatabaseId"] = self.databaseId!
        }
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.mappingDatabaseName != nil {
            map["MappingDatabaseName"] = self.mappingDatabaseName!
        }
        if self.sourceClientId != nil {
            map["SourceClientId"] = self.sourceClientId!
        }
        if self.tables != nil {
            var tmp : [Any] = []
            for k in self.tables! {
                tmp.append(k.toMap())
            }
            map["Tables"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterName") {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("TenantName") {
            self.tenantName = dict["TenantName"] as! String
        }
        if dict.keys.contains("DatabaseId") {
            self.databaseId = dict["DatabaseId"] as! String
        }
        if dict.keys.contains("DatabaseName") {
            self.databaseName = dict["DatabaseName"] as! String
        }
        if dict.keys.contains("MappingDatabaseName") {
            self.mappingDatabaseName = dict["MappingDatabaseName"] as! String
        }
        if dict.keys.contains("SourceClientId") {
            self.sourceClientId = dict["SourceClientId"] as! String
        }
        if dict.keys.contains("Tables") {
            var tmp : [DataExtraInfoSubDbsValue.Tables] = []
            for v in dict["Tables"] as! [Any] {
                var model = DataExtraInfoSubDbsValue.Tables()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tables = tmp
        }
    }
}

public class BatchKillProcessListRequest : Tea.TeaModel {
    public var instanceId: String?

    public var sessionList: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.sessionList != nil {
            map["SessionList"] = self.sessionList!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SessionList") {
            self.sessionList = dict["SessionList"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class BatchKillProcessListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var data: [BatchKillProcessListResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [BatchKillProcessListResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = BatchKillProcessListResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BatchKillProcessListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchKillProcessListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BatchKillProcessListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelProjectModifyRecordRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class CancelProjectModifyRecordResponseBody : Tea.TeaModel {
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: Any?

    public var errorDetail: CancelProjectModifyRecordResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("ErrorDetail") {
            var model = CancelProjectModifyRecordResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class CancelProjectModifyRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelProjectModifyRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelProjectModifyRecordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateBackupSetDownloadLinkRequest : Tea.TeaModel {
    public var backupSetId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupSetId != nil {
            map["BackupSetId"] = self.backupSetId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackupSetId") {
            self.backupSetId = dict["BackupSetId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class CreateBackupSetDownloadLinkResponseBody : Tea.TeaModel {
    public var downloadTaskId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.downloadTaskId != nil {
            map["DownloadTaskId"] = self.downloadTaskId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DownloadTaskId") {
            self.downloadTaskId = dict["DownloadTaskId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateBackupSetDownloadLinkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBackupSetDownloadLinkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateBackupSetDownloadLinkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDatabaseRequest : Tea.TeaModel {
    public var clientToken: String?

    public var collation: String?

    public var databaseName: String?

    public var description_: String?

    public var encoding: String?

    public var instanceId: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.collation != nil {
            map["Collation"] = self.collation!
        }
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.encoding != nil {
            map["Encoding"] = self.encoding!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Collation") {
            self.collation = dict["Collation"] as! String
        }
        if dict.keys.contains("DatabaseName") {
            self.databaseName = dict["DatabaseName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Encoding") {
            self.encoding = dict["Encoding"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class CreateDatabaseResponseBody : Tea.TeaModel {
    public var databaseName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatabaseName") {
            self.databaseName = dict["DatabaseName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDatabaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateInstanceRequest : Tea.TeaModel {
    public var autoRenew: Bool?

    public var autoRenewPeriod: Int64?

    public var chargeType: String?

    public var cpuArch: String?

    public var diskSize: Int64?

    public var diskType: String?

    public var dryRun: Bool?

    public var instanceClass: String?

    public var instanceName: String?

    public var isolationOptimization: String?

    public var obVersion: String?

    public var period: Int64?

    public var periodUnit: String?

    public var primaryInstance: String?

    public var primaryRegion: String?

    public var replicaMode: String?

    public var resourceGroupId: String?

    public var series: String?

    public var zones: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewPeriod != nil {
            map["AutoRenewPeriod"] = self.autoRenewPeriod!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.cpuArch != nil {
            map["CpuArch"] = self.cpuArch!
        }
        if self.diskSize != nil {
            map["DiskSize"] = self.diskSize!
        }
        if self.diskType != nil {
            map["DiskType"] = self.diskType!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.instanceClass != nil {
            map["InstanceClass"] = self.instanceClass!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.isolationOptimization != nil {
            map["IsolationOptimization"] = self.isolationOptimization!
        }
        if self.obVersion != nil {
            map["ObVersion"] = self.obVersion!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.primaryInstance != nil {
            map["PrimaryInstance"] = self.primaryInstance!
        }
        if self.primaryRegion != nil {
            map["PrimaryRegion"] = self.primaryRegion!
        }
        if self.replicaMode != nil {
            map["ReplicaMode"] = self.replicaMode!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.series != nil {
            map["Series"] = self.series!
        }
        if self.zones != nil {
            map["Zones"] = self.zones!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("AutoRenewPeriod") {
            self.autoRenewPeriod = dict["AutoRenewPeriod"] as! Int64
        }
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("CpuArch") {
            self.cpuArch = dict["CpuArch"] as! String
        }
        if dict.keys.contains("DiskSize") {
            self.diskSize = dict["DiskSize"] as! Int64
        }
        if dict.keys.contains("DiskType") {
            self.diskType = dict["DiskType"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("InstanceClass") {
            self.instanceClass = dict["InstanceClass"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("IsolationOptimization") {
            self.isolationOptimization = dict["IsolationOptimization"] as! String
        }
        if dict.keys.contains("ObVersion") {
            self.obVersion = dict["ObVersion"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int64
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PrimaryInstance") {
            self.primaryInstance = dict["PrimaryInstance"] as! String
        }
        if dict.keys.contains("PrimaryRegion") {
            self.primaryRegion = dict["PrimaryRegion"] as! String
        }
        if dict.keys.contains("ReplicaMode") {
            self.replicaMode = dict["ReplicaMode"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Series") {
            self.series = dict["Series"] as! String
        }
        if dict.keys.contains("Zones") {
            self.zones = dict["Zones"] as! String
        }
    }
}

public class CreateInstanceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var dryRunResult: Bool?

        public var instanceId: String?

        public var orderId: String?

        public var resourceGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dryRunResult != nil {
                map["DryRunResult"] = self.dryRunResult!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.orderId != nil {
                map["OrderId"] = self.orderId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DryRunResult") {
                self.dryRunResult = dict["DryRunResult"] as! Bool
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("OrderId") {
                self.orderId = dict["OrderId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
        }
    }
    public var data: CreateInstanceResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = CreateInstanceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLabelRequest : Tea.TeaModel {
    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
    }
}

public class CreateLabelResponseBody : Tea.TeaModel {
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: String?

    public var errorDetail: CreateLabelResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("ErrorDetail") {
            var model = CreateLabelResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class CreateLabelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLabelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLabelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMySqlDataSourceRequest : Tea.TeaModel {
    public var description_: String?

    public var dgInstanceId: String?

    public var instanceId: String?

    public var ip: String?

    public var name: String?

    public var password: String?

    public var port: Int32?

    public var schema: String?

    public var type: String?

    public var useSsl: Bool?

    public var userName: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dgInstanceId != nil {
            map["DgInstanceId"] = self.dgInstanceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.useSsl != nil {
            map["UseSsl"] = self.useSsl!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DgInstanceId") {
            self.dgInstanceId = dict["DgInstanceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Ip") {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("Port") {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("Schema") {
            self.schema = dict["Schema"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UseSsl") {
            self.useSsl = dict["UseSsl"] as! Bool
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class CreateMySqlDataSourceResponseBody : Tea.TeaModel {
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: String?

    public var errorDetail: CreateMySqlDataSourceResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("ErrorDetail") {
            var model = CreateMySqlDataSourceResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class CreateMySqlDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMySqlDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateMySqlDataSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOceanBaseDataSourceRequest : Tea.TeaModel {
    public var cluster: String?

    public var configUrl: String?

    public var description_: String?

    public var drcPassword: String?

    public var drcUserName: String?

    public var innerDrcPassword: String?

    public var ip: String?

    public var logProxyIp: String?

    public var logProxyPort: String?

    public var name: String?

    public var password: String?

    public var port: Int32?

    public var tenant: String?

    public var type: String?

    public var userName: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cluster != nil {
            map["Cluster"] = self.cluster!
        }
        if self.configUrl != nil {
            map["ConfigUrl"] = self.configUrl!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.drcPassword != nil {
            map["DrcPassword"] = self.drcPassword!
        }
        if self.drcUserName != nil {
            map["DrcUserName"] = self.drcUserName!
        }
        if self.innerDrcPassword != nil {
            map["InnerDrcPassword"] = self.innerDrcPassword!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.logProxyIp != nil {
            map["LogProxyIp"] = self.logProxyIp!
        }
        if self.logProxyPort != nil {
            map["LogProxyPort"] = self.logProxyPort!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.tenant != nil {
            map["Tenant"] = self.tenant!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cluster") {
            self.cluster = dict["Cluster"] as! String
        }
        if dict.keys.contains("ConfigUrl") {
            self.configUrl = dict["ConfigUrl"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DrcPassword") {
            self.drcPassword = dict["DrcPassword"] as! String
        }
        if dict.keys.contains("DrcUserName") {
            self.drcUserName = dict["DrcUserName"] as! String
        }
        if dict.keys.contains("InnerDrcPassword") {
            self.innerDrcPassword = dict["InnerDrcPassword"] as! String
        }
        if dict.keys.contains("Ip") {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("LogProxyIp") {
            self.logProxyIp = dict["LogProxyIp"] as! String
        }
        if dict.keys.contains("LogProxyPort") {
            self.logProxyPort = dict["LogProxyPort"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("Port") {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("Tenant") {
            self.tenant = dict["Tenant"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class CreateOceanBaseDataSourceResponseBody : Tea.TeaModel {
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: String?

    public var errorDetail: CreateOceanBaseDataSourceResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("ErrorDetail") {
            var model = CreateOceanBaseDataSourceResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class CreateOceanBaseDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOceanBaseDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateOceanBaseDataSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOmsMysqlDataSourceRequest : Tea.TeaModel {
    public var description_: String?

    public var dgDatabaseId: String?

    public var instanceId: String?

    public var ip: String?

    public var name: String?

    public var password: String?

    public var port: String?

    public var schema: String?

    public var type: String?

    public var username: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dgDatabaseId != nil {
            map["DgDatabaseId"] = self.dgDatabaseId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.username != nil {
            map["Username"] = self.username!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DgDatabaseId") {
            self.dgDatabaseId = dict["DgDatabaseId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Ip") {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("Port") {
            self.port = dict["Port"] as! String
        }
        if dict.keys.contains("Schema") {
            self.schema = dict["Schema"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("Username") {
            self.username = dict["Username"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class CreateOmsMysqlDataSourceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var endpointId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endpointId != nil {
                map["EndpointId"] = self.endpointId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndpointId") {
                self.endpointId = dict["EndpointId"] as! String
            }
        }
    }
    public var data: CreateOmsMysqlDataSourceResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = CreateOmsMysqlDataSourceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateOmsMysqlDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOmsMysqlDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateOmsMysqlDataSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateProjectRequest : Tea.TeaModel {
    public class CommonTransferConfig : Tea.TeaModel {
        public class CustomColumns : Tea.TeaModel {
            public var columnName: String?

            public var expression: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.expression != nil {
                    map["Expression"] = self.expression!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ColumnName") {
                    self.columnName = dict["ColumnName"] as! String
                }
                if dict.keys.contains("Expression") {
                    self.expression = dict["Expression"] as! String
                }
            }
        }
        public var activeActive: Bool?

        public var customColumns: [CreateProjectRequest.CommonTransferConfig.CustomColumns]?

        public var dataWorksBusinessName: String?

        public var datahubTopicType: String?

        public var mqPartition: Int32?

        public var mqPartitionMode: String?

        public var mqSerializerType: String?

        public var rocketMqEnableMsgTrace: Bool?

        public var rocketMqMsgTags: String?

        public var rocketMqProducerGroup: String?

        public var rocketMqSendMsgTimeout: Int64?

        public var sinkStoreFormat: String?

        public var sourceStoreFormat: String?

        public var syncSchema: Bool?

        public var syncSchemaColumnName: String?

        public var tableCategory: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activeActive != nil {
                map["ActiveActive"] = self.activeActive!
            }
            if self.customColumns != nil {
                var tmp : [Any] = []
                for k in self.customColumns! {
                    tmp.append(k.toMap())
                }
                map["CustomColumns"] = tmp
            }
            if self.dataWorksBusinessName != nil {
                map["DataWorksBusinessName"] = self.dataWorksBusinessName!
            }
            if self.datahubTopicType != nil {
                map["DatahubTopicType"] = self.datahubTopicType!
            }
            if self.mqPartition != nil {
                map["MqPartition"] = self.mqPartition!
            }
            if self.mqPartitionMode != nil {
                map["MqPartitionMode"] = self.mqPartitionMode!
            }
            if self.mqSerializerType != nil {
                map["MqSerializerType"] = self.mqSerializerType!
            }
            if self.rocketMqEnableMsgTrace != nil {
                map["RocketMqEnableMsgTrace"] = self.rocketMqEnableMsgTrace!
            }
            if self.rocketMqMsgTags != nil {
                map["RocketMqMsgTags"] = self.rocketMqMsgTags!
            }
            if self.rocketMqProducerGroup != nil {
                map["RocketMqProducerGroup"] = self.rocketMqProducerGroup!
            }
            if self.rocketMqSendMsgTimeout != nil {
                map["RocketMqSendMsgTimeout"] = self.rocketMqSendMsgTimeout!
            }
            if self.sinkStoreFormat != nil {
                map["SinkStoreFormat"] = self.sinkStoreFormat!
            }
            if self.sourceStoreFormat != nil {
                map["SourceStoreFormat"] = self.sourceStoreFormat!
            }
            if self.syncSchema != nil {
                map["SyncSchema"] = self.syncSchema!
            }
            if self.syncSchemaColumnName != nil {
                map["SyncSchemaColumnName"] = self.syncSchemaColumnName!
            }
            if self.tableCategory != nil {
                map["TableCategory"] = self.tableCategory!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActiveActive") {
                self.activeActive = dict["ActiveActive"] as! Bool
            }
            if dict.keys.contains("CustomColumns") {
                var tmp : [CreateProjectRequest.CommonTransferConfig.CustomColumns] = []
                for v in dict["CustomColumns"] as! [Any] {
                    var model = CreateProjectRequest.CommonTransferConfig.CustomColumns()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.customColumns = tmp
            }
            if dict.keys.contains("DataWorksBusinessName") {
                self.dataWorksBusinessName = dict["DataWorksBusinessName"] as! String
            }
            if dict.keys.contains("DatahubTopicType") {
                self.datahubTopicType = dict["DatahubTopicType"] as! String
            }
            if dict.keys.contains("MqPartition") {
                self.mqPartition = dict["MqPartition"] as! Int32
            }
            if dict.keys.contains("MqPartitionMode") {
                self.mqPartitionMode = dict["MqPartitionMode"] as! String
            }
            if dict.keys.contains("MqSerializerType") {
                self.mqSerializerType = dict["MqSerializerType"] as! String
            }
            if dict.keys.contains("RocketMqEnableMsgTrace") {
                self.rocketMqEnableMsgTrace = dict["RocketMqEnableMsgTrace"] as! Bool
            }
            if dict.keys.contains("RocketMqMsgTags") {
                self.rocketMqMsgTags = dict["RocketMqMsgTags"] as! String
            }
            if dict.keys.contains("RocketMqProducerGroup") {
                self.rocketMqProducerGroup = dict["RocketMqProducerGroup"] as! String
            }
            if dict.keys.contains("RocketMqSendMsgTimeout") {
                self.rocketMqSendMsgTimeout = dict["RocketMqSendMsgTimeout"] as! Int64
            }
            if dict.keys.contains("SinkStoreFormat") {
                self.sinkStoreFormat = dict["SinkStoreFormat"] as! String
            }
            if dict.keys.contains("SourceStoreFormat") {
                self.sourceStoreFormat = dict["SourceStoreFormat"] as! String
            }
            if dict.keys.contains("SyncSchema") {
                self.syncSchema = dict["SyncSchema"] as! Bool
            }
            if dict.keys.contains("SyncSchemaColumnName") {
                self.syncSchemaColumnName = dict["SyncSchemaColumnName"] as! String
            }
            if dict.keys.contains("TableCategory") {
                self.tableCategory = dict["TableCategory"] as! String
            }
        }
    }
    public class FullTransferConfig : Tea.TeaModel {
        public var allowDestTableNotEmpty: Bool?

        public var fullTransferSpeedMode: String?

        public var fullVerifySpeedMode: String?

        public var nonePkUkTruncateDstTable: Bool?

        public var readWorkerNum: Int32?

        public var throttleIOPS: Int32?

        public var throttleRps: Int32?

        public var writeWorkerNum: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowDestTableNotEmpty != nil {
                map["AllowDestTableNotEmpty"] = self.allowDestTableNotEmpty!
            }
            if self.fullTransferSpeedMode != nil {
                map["FullTransferSpeedMode"] = self.fullTransferSpeedMode!
            }
            if self.fullVerifySpeedMode != nil {
                map["FullVerifySpeedMode"] = self.fullVerifySpeedMode!
            }
            if self.nonePkUkTruncateDstTable != nil {
                map["NonePkUkTruncateDstTable"] = self.nonePkUkTruncateDstTable!
            }
            if self.readWorkerNum != nil {
                map["ReadWorkerNum"] = self.readWorkerNum!
            }
            if self.throttleIOPS != nil {
                map["ThrottleIOPS"] = self.throttleIOPS!
            }
            if self.throttleRps != nil {
                map["ThrottleRps"] = self.throttleRps!
            }
            if self.writeWorkerNum != nil {
                map["WriteWorkerNum"] = self.writeWorkerNum!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AllowDestTableNotEmpty") {
                self.allowDestTableNotEmpty = dict["AllowDestTableNotEmpty"] as! Bool
            }
            if dict.keys.contains("FullTransferSpeedMode") {
                self.fullTransferSpeedMode = dict["FullTransferSpeedMode"] as! String
            }
            if dict.keys.contains("FullVerifySpeedMode") {
                self.fullVerifySpeedMode = dict["FullVerifySpeedMode"] as! String
            }
            if dict.keys.contains("NonePkUkTruncateDstTable") {
                self.nonePkUkTruncateDstTable = dict["NonePkUkTruncateDstTable"] as! Bool
            }
            if dict.keys.contains("ReadWorkerNum") {
                self.readWorkerNum = dict["ReadWorkerNum"] as! Int32
            }
            if dict.keys.contains("ThrottleIOPS") {
                self.throttleIOPS = dict["ThrottleIOPS"] as! Int32
            }
            if dict.keys.contains("ThrottleRps") {
                self.throttleRps = dict["ThrottleRps"] as! Int32
            }
            if dict.keys.contains("WriteWorkerNum") {
                self.writeWorkerNum = dict["WriteWorkerNum"] as! Int32
            }
        }
    }
    public class IncrTransferConfig : Tea.TeaModel {
        public var enableIncrSyncStatistics: Bool?

        public var enableSequencingWithinTxn: Bool?

        public var incrSyncConcurrency: Int32?

        public var recordTypeWhiteList: [String]?

        public var startTimestamp: String?

        public var storeLogKeptHour: Int32?

        public var supportDDLTypes: [String]?

        public var throttleIOPS: Int32?

        public var throttleRps: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableIncrSyncStatistics != nil {
                map["EnableIncrSyncStatistics"] = self.enableIncrSyncStatistics!
            }
            if self.enableSequencingWithinTxn != nil {
                map["EnableSequencingWithinTxn"] = self.enableSequencingWithinTxn!
            }
            if self.incrSyncConcurrency != nil {
                map["IncrSyncConcurrency"] = self.incrSyncConcurrency!
            }
            if self.recordTypeWhiteList != nil {
                map["RecordTypeWhiteList"] = self.recordTypeWhiteList!
            }
            if self.startTimestamp != nil {
                map["StartTimestamp"] = self.startTimestamp!
            }
            if self.storeLogKeptHour != nil {
                map["StoreLogKeptHour"] = self.storeLogKeptHour!
            }
            if self.supportDDLTypes != nil {
                map["SupportDDLTypes"] = self.supportDDLTypes!
            }
            if self.throttleIOPS != nil {
                map["ThrottleIOPS"] = self.throttleIOPS!
            }
            if self.throttleRps != nil {
                map["ThrottleRps"] = self.throttleRps!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableIncrSyncStatistics") {
                self.enableIncrSyncStatistics = dict["EnableIncrSyncStatistics"] as! Bool
            }
            if dict.keys.contains("EnableSequencingWithinTxn") {
                self.enableSequencingWithinTxn = dict["EnableSequencingWithinTxn"] as! Bool
            }
            if dict.keys.contains("IncrSyncConcurrency") {
                self.incrSyncConcurrency = dict["IncrSyncConcurrency"] as! Int32
            }
            if dict.keys.contains("RecordTypeWhiteList") {
                self.recordTypeWhiteList = dict["RecordTypeWhiteList"] as! [String]
            }
            if dict.keys.contains("StartTimestamp") {
                self.startTimestamp = dict["StartTimestamp"] as! String
            }
            if dict.keys.contains("StoreLogKeptHour") {
                self.storeLogKeptHour = dict["StoreLogKeptHour"] as! Int32
            }
            if dict.keys.contains("SupportDDLTypes") {
                self.supportDDLTypes = dict["SupportDDLTypes"] as! [String]
            }
            if dict.keys.contains("ThrottleIOPS") {
                self.throttleIOPS = dict["ThrottleIOPS"] as! Int32
            }
            if dict.keys.contains("ThrottleRps") {
                self.throttleRps = dict["ThrottleRps"] as! Int32
            }
        }
    }
    public class ReverseIncrTransferConfig : Tea.TeaModel {
        public var enableIncrSyncStatistics: Bool?

        public var enableSequencingWithinTxn: Bool?

        public var incrSyncConcurrency: Int32?

        public var recordTypeWhiteList: [String]?

        public var startTimestamp: String?

        public var storeLogKeptHour: Int32?

        public var supportDDLTypes: [String]?

        public var throttleIOPS: Int32?

        public var throttleRps: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableIncrSyncStatistics != nil {
                map["EnableIncrSyncStatistics"] = self.enableIncrSyncStatistics!
            }
            if self.enableSequencingWithinTxn != nil {
                map["EnableSequencingWithinTxn"] = self.enableSequencingWithinTxn!
            }
            if self.incrSyncConcurrency != nil {
                map["IncrSyncConcurrency"] = self.incrSyncConcurrency!
            }
            if self.recordTypeWhiteList != nil {
                map["RecordTypeWhiteList"] = self.recordTypeWhiteList!
            }
            if self.startTimestamp != nil {
                map["StartTimestamp"] = self.startTimestamp!
            }
            if self.storeLogKeptHour != nil {
                map["StoreLogKeptHour"] = self.storeLogKeptHour!
            }
            if self.supportDDLTypes != nil {
                map["SupportDDLTypes"] = self.supportDDLTypes!
            }
            if self.throttleIOPS != nil {
                map["ThrottleIOPS"] = self.throttleIOPS!
            }
            if self.throttleRps != nil {
                map["ThrottleRps"] = self.throttleRps!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableIncrSyncStatistics") {
                self.enableIncrSyncStatistics = dict["EnableIncrSyncStatistics"] as! Bool
            }
            if dict.keys.contains("EnableSequencingWithinTxn") {
                self.enableSequencingWithinTxn = dict["EnableSequencingWithinTxn"] as! Bool
            }
            if dict.keys.contains("IncrSyncConcurrency") {
                self.incrSyncConcurrency = dict["IncrSyncConcurrency"] as! Int32
            }
            if dict.keys.contains("RecordTypeWhiteList") {
                self.recordTypeWhiteList = dict["RecordTypeWhiteList"] as! [String]
            }
            if dict.keys.contains("StartTimestamp") {
                self.startTimestamp = dict["StartTimestamp"] as! String
            }
            if dict.keys.contains("StoreLogKeptHour") {
                self.storeLogKeptHour = dict["StoreLogKeptHour"] as! Int32
            }
            if dict.keys.contains("SupportDDLTypes") {
                self.supportDDLTypes = dict["SupportDDLTypes"] as! [String]
            }
            if dict.keys.contains("ThrottleIOPS") {
                self.throttleIOPS = dict["ThrottleIOPS"] as! Int32
            }
            if dict.keys.contains("ThrottleRps") {
                self.throttleRps = dict["ThrottleRps"] as! Int32
            }
        }
    }
    public class StructTransferConfig : Tea.TeaModel {
        public var byteCharConvertStrategy: String?

        public var deferIndexCreation: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.byteCharConvertStrategy != nil {
                map["ByteCharConvertStrategy"] = self.byteCharConvertStrategy!
            }
            if self.deferIndexCreation != nil {
                map["DeferIndexCreation"] = self.deferIndexCreation!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ByteCharConvertStrategy") {
                self.byteCharConvertStrategy = dict["ByteCharConvertStrategy"] as! String
            }
            if dict.keys.contains("DeferIndexCreation") {
                self.deferIndexCreation = dict["DeferIndexCreation"] as! Bool
            }
        }
    }
    public class TransferMapping : Tea.TeaModel {
        public class Databases : Tea.TeaModel {
            public class SpecificTables : Tea.TeaModel {
                public class AdbTableSchema : Tea.TeaModel {
                    public var distributedKeys: [String]?

                    public var partitionLifeCycle: String?

                    public var partitionStatement: String?

                    public var primaryKeys: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.distributedKeys != nil {
                            map["DistributedKeys"] = self.distributedKeys!
                        }
                        if self.partitionLifeCycle != nil {
                            map["PartitionLifeCycle"] = self.partitionLifeCycle!
                        }
                        if self.partitionStatement != nil {
                            map["PartitionStatement"] = self.partitionStatement!
                        }
                        if self.primaryKeys != nil {
                            map["PrimaryKeys"] = self.primaryKeys!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DistributedKeys") {
                            self.distributedKeys = dict["DistributedKeys"] as! [String]
                        }
                        if dict.keys.contains("PartitionLifeCycle") {
                            self.partitionLifeCycle = dict["PartitionLifeCycle"] as! String
                        }
                        if dict.keys.contains("PartitionStatement") {
                            self.partitionStatement = dict["PartitionStatement"] as! String
                        }
                        if dict.keys.contains("PrimaryKeys") {
                            self.primaryKeys = dict["PrimaryKeys"] as! [String]
                        }
                    }
                }
                public var adbTableSchema: CreateProjectRequest.TransferMapping.Databases.SpecificTables.AdbTableSchema?

                public var filterColumns: [String]?

                public var id: String?

                public var mappedName: String?

                public var name: String?

                public var shardColumns: [String]?

                public var whereClause: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.adbTableSchema?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adbTableSchema != nil {
                        map["AdbTableSchema"] = self.adbTableSchema?.toMap()
                    }
                    if self.filterColumns != nil {
                        map["FilterColumns"] = self.filterColumns!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.mappedName != nil {
                        map["MappedName"] = self.mappedName!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.shardColumns != nil {
                        map["ShardColumns"] = self.shardColumns!
                    }
                    if self.whereClause != nil {
                        map["WhereClause"] = self.whereClause!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AdbTableSchema") {
                        var model = CreateProjectRequest.TransferMapping.Databases.SpecificTables.AdbTableSchema()
                        model.fromMap(dict["AdbTableSchema"] as! [String: Any])
                        self.adbTableSchema = model
                    }
                    if dict.keys.contains("FilterColumns") {
                        self.filterColumns = dict["FilterColumns"] as! [String]
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("MappedName") {
                        self.mappedName = dict["MappedName"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("ShardColumns") {
                        self.shardColumns = dict["ShardColumns"] as! [String]
                    }
                    if dict.keys.contains("WhereClause") {
                        self.whereClause = dict["WhereClause"] as! String
                    }
                }
            }
            public class SpecificViews : Tea.TeaModel {
                public class AdbTableSchema : Tea.TeaModel {
                    public var distributedKeys: [String]?

                    public var partitionLifeCycle: String?

                    public var partitionStatement: String?

                    public var primaryKeys: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.distributedKeys != nil {
                            map["DistributedKeys"] = self.distributedKeys!
                        }
                        if self.partitionLifeCycle != nil {
                            map["PartitionLifeCycle"] = self.partitionLifeCycle!
                        }
                        if self.partitionStatement != nil {
                            map["PartitionStatement"] = self.partitionStatement!
                        }
                        if self.primaryKeys != nil {
                            map["PrimaryKeys"] = self.primaryKeys!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DistributedKeys") {
                            self.distributedKeys = dict["DistributedKeys"] as! [String]
                        }
                        if dict.keys.contains("PartitionLifeCycle") {
                            self.partitionLifeCycle = dict["PartitionLifeCycle"] as! String
                        }
                        if dict.keys.contains("PartitionStatement") {
                            self.partitionStatement = dict["PartitionStatement"] as! String
                        }
                        if dict.keys.contains("PrimaryKeys") {
                            self.primaryKeys = dict["PrimaryKeys"] as! [String]
                        }
                    }
                }
                public var adbTableSchema: CreateProjectRequest.TransferMapping.Databases.SpecificViews.AdbTableSchema?

                public var filterColumns: [String]?

                public var id: String?

                public var mappedName: String?

                public var name: String?

                public var shardColumns: [String]?

                public var whereClause: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.adbTableSchema?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adbTableSchema != nil {
                        map["AdbTableSchema"] = self.adbTableSchema?.toMap()
                    }
                    if self.filterColumns != nil {
                        map["FilterColumns"] = self.filterColumns!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.mappedName != nil {
                        map["MappedName"] = self.mappedName!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.shardColumns != nil {
                        map["ShardColumns"] = self.shardColumns!
                    }
                    if self.whereClause != nil {
                        map["WhereClause"] = self.whereClause!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AdbTableSchema") {
                        var model = CreateProjectRequest.TransferMapping.Databases.SpecificViews.AdbTableSchema()
                        model.fromMap(dict["AdbTableSchema"] as! [String: Any])
                        self.adbTableSchema = model
                    }
                    if dict.keys.contains("FilterColumns") {
                        self.filterColumns = dict["FilterColumns"] as! [String]
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("MappedName") {
                        self.mappedName = dict["MappedName"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("ShardColumns") {
                        self.shardColumns = dict["ShardColumns"] as! [String]
                    }
                    if dict.keys.contains("WhereClause") {
                        self.whereClause = dict["WhereClause"] as! String
                    }
                }
            }
            public class Tables : Tea.TeaModel {
                public class AdbTableSchema : Tea.TeaModel {
                    public var distributedKeys: [String]?

                    public var partitionLifeCycle: String?

                    public var partitionStatement: String?

                    public var primaryKeys: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.distributedKeys != nil {
                            map["DistributedKeys"] = self.distributedKeys!
                        }
                        if self.partitionLifeCycle != nil {
                            map["PartitionLifeCycle"] = self.partitionLifeCycle!
                        }
                        if self.partitionStatement != nil {
                            map["PartitionStatement"] = self.partitionStatement!
                        }
                        if self.primaryKeys != nil {
                            map["PrimaryKeys"] = self.primaryKeys!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DistributedKeys") {
                            self.distributedKeys = dict["DistributedKeys"] as! [String]
                        }
                        if dict.keys.contains("PartitionLifeCycle") {
                            self.partitionLifeCycle = dict["PartitionLifeCycle"] as! String
                        }
                        if dict.keys.contains("PartitionStatement") {
                            self.partitionStatement = dict["PartitionStatement"] as! String
                        }
                        if dict.keys.contains("PrimaryKeys") {
                            self.primaryKeys = dict["PrimaryKeys"] as! [String]
                        }
                    }
                }
                public var adbTableSchema: CreateProjectRequest.TransferMapping.Databases.Tables.AdbTableSchema?

                public var filterColumns: [String]?

                public var id: String?

                public var mappedName: String?

                public var name: String?

                public var shardColumns: [String]?

                public var whereClause: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.adbTableSchema?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adbTableSchema != nil {
                        map["AdbTableSchema"] = self.adbTableSchema?.toMap()
                    }
                    if self.filterColumns != nil {
                        map["FilterColumns"] = self.filterColumns!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.mappedName != nil {
                        map["MappedName"] = self.mappedName!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.shardColumns != nil {
                        map["ShardColumns"] = self.shardColumns!
                    }
                    if self.whereClause != nil {
                        map["WhereClause"] = self.whereClause!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AdbTableSchema") {
                        var model = CreateProjectRequest.TransferMapping.Databases.Tables.AdbTableSchema()
                        model.fromMap(dict["AdbTableSchema"] as! [String: Any])
                        self.adbTableSchema = model
                    }
                    if dict.keys.contains("FilterColumns") {
                        self.filterColumns = dict["FilterColumns"] as! [String]
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("MappedName") {
                        self.mappedName = dict["MappedName"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("ShardColumns") {
                        self.shardColumns = dict["ShardColumns"] as! [String]
                    }
                    if dict.keys.contains("WhereClause") {
                        self.whereClause = dict["WhereClause"] as! String
                    }
                }
            }
            public class Views : Tea.TeaModel {
                public class AdbTableSchema : Tea.TeaModel {
                    public var distributedKeys: [String]?

                    public var partitionLifeCycle: String?

                    public var partitionStatement: String?

                    public var primaryKeys: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.distributedKeys != nil {
                            map["DistributedKeys"] = self.distributedKeys!
                        }
                        if self.partitionLifeCycle != nil {
                            map["PartitionLifeCycle"] = self.partitionLifeCycle!
                        }
                        if self.partitionStatement != nil {
                            map["PartitionStatement"] = self.partitionStatement!
                        }
                        if self.primaryKeys != nil {
                            map["PrimaryKeys"] = self.primaryKeys!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DistributedKeys") {
                            self.distributedKeys = dict["DistributedKeys"] as! [String]
                        }
                        if dict.keys.contains("PartitionLifeCycle") {
                            self.partitionLifeCycle = dict["PartitionLifeCycle"] as! String
                        }
                        if dict.keys.contains("PartitionStatement") {
                            self.partitionStatement = dict["PartitionStatement"] as! String
                        }
                        if dict.keys.contains("PrimaryKeys") {
                            self.primaryKeys = dict["PrimaryKeys"] as! [String]
                        }
                    }
                }
                public var adbTableSchema: CreateProjectRequest.TransferMapping.Databases.Views.AdbTableSchema?

                public var filterColumns: [String]?

                public var id: String?

                public var mappedName: String?

                public var name: String?

                public var shardColumns: [String]?

                public var whereClause: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.adbTableSchema?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adbTableSchema != nil {
                        map["AdbTableSchema"] = self.adbTableSchema?.toMap()
                    }
                    if self.filterColumns != nil {
                        map["FilterColumns"] = self.filterColumns!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.mappedName != nil {
                        map["MappedName"] = self.mappedName!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.shardColumns != nil {
                        map["ShardColumns"] = self.shardColumns!
                    }
                    if self.whereClause != nil {
                        map["WhereClause"] = self.whereClause!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AdbTableSchema") {
                        var model = CreateProjectRequest.TransferMapping.Databases.Views.AdbTableSchema()
                        model.fromMap(dict["AdbTableSchema"] as! [String: Any])
                        self.adbTableSchema = model
                    }
                    if dict.keys.contains("FilterColumns") {
                        self.filterColumns = dict["FilterColumns"] as! [String]
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("MappedName") {
                        self.mappedName = dict["MappedName"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("ShardColumns") {
                        self.shardColumns = dict["ShardColumns"] as! [String]
                    }
                    if dict.keys.contains("WhereClause") {
                        self.whereClause = dict["WhereClause"] as! String
                    }
                }
            }
            public var clusterName: String?

            public var id: String?

            public var mappedName: String?

            public var name: String?

            public var specificTables: [CreateProjectRequest.TransferMapping.Databases.SpecificTables]?

            public var specificViews: [CreateProjectRequest.TransferMapping.Databases.SpecificViews]?

            public var tables: [CreateProjectRequest.TransferMapping.Databases.Tables]?

            public var tenantName: String?

            public var views: [CreateProjectRequest.TransferMapping.Databases.Views]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterName != nil {
                    map["ClusterName"] = self.clusterName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.mappedName != nil {
                    map["MappedName"] = self.mappedName!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.specificTables != nil {
                    var tmp : [Any] = []
                    for k in self.specificTables! {
                        tmp.append(k.toMap())
                    }
                    map["SpecificTables"] = tmp
                }
                if self.specificViews != nil {
                    var tmp : [Any] = []
                    for k in self.specificViews! {
                        tmp.append(k.toMap())
                    }
                    map["SpecificViews"] = tmp
                }
                if self.tables != nil {
                    var tmp : [Any] = []
                    for k in self.tables! {
                        tmp.append(k.toMap())
                    }
                    map["Tables"] = tmp
                }
                if self.tenantName != nil {
                    map["TenantName"] = self.tenantName!
                }
                if self.views != nil {
                    var tmp : [Any] = []
                    for k in self.views! {
                        tmp.append(k.toMap())
                    }
                    map["Views"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterName") {
                    self.clusterName = dict["ClusterName"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("MappedName") {
                    self.mappedName = dict["MappedName"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("SpecificTables") {
                    var tmp : [CreateProjectRequest.TransferMapping.Databases.SpecificTables] = []
                    for v in dict["SpecificTables"] as! [Any] {
                        var model = CreateProjectRequest.TransferMapping.Databases.SpecificTables()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.specificTables = tmp
                }
                if dict.keys.contains("SpecificViews") {
                    var tmp : [CreateProjectRequest.TransferMapping.Databases.SpecificViews] = []
                    for v in dict["SpecificViews"] as! [Any] {
                        var model = CreateProjectRequest.TransferMapping.Databases.SpecificViews()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.specificViews = tmp
                }
                if dict.keys.contains("Tables") {
                    var tmp : [CreateProjectRequest.TransferMapping.Databases.Tables] = []
                    for v in dict["Tables"] as! [Any] {
                        var model = CreateProjectRequest.TransferMapping.Databases.Tables()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tables = tmp
                }
                if dict.keys.contains("TenantName") {
                    self.tenantName = dict["TenantName"] as! String
                }
                if dict.keys.contains("Views") {
                    var tmp : [CreateProjectRequest.TransferMapping.Databases.Views] = []
                    for v in dict["Views"] as! [Any] {
                        var model = CreateProjectRequest.TransferMapping.Databases.Views()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.views = tmp
                }
            }
        }
        public class DatabasesBlack : Tea.TeaModel {
            public class SpecificTables : Tea.TeaModel {
                public class AdbTableSchema : Tea.TeaModel {
                    public var distributedKeys: [String]?

                    public var partitionLifeCycle: String?

                    public var partitionStatement: String?

                    public var primaryKeys: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.distributedKeys != nil {
                            map["DistributedKeys"] = self.distributedKeys!
                        }
                        if self.partitionLifeCycle != nil {
                            map["PartitionLifeCycle"] = self.partitionLifeCycle!
                        }
                        if self.partitionStatement != nil {
                            map["PartitionStatement"] = self.partitionStatement!
                        }
                        if self.primaryKeys != nil {
                            map["PrimaryKeys"] = self.primaryKeys!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DistributedKeys") {
                            self.distributedKeys = dict["DistributedKeys"] as! [String]
                        }
                        if dict.keys.contains("PartitionLifeCycle") {
                            self.partitionLifeCycle = dict["PartitionLifeCycle"] as! String
                        }
                        if dict.keys.contains("PartitionStatement") {
                            self.partitionStatement = dict["PartitionStatement"] as! String
                        }
                        if dict.keys.contains("PrimaryKeys") {
                            self.primaryKeys = dict["PrimaryKeys"] as! [String]
                        }
                    }
                }
                public var adbTableSchema: CreateProjectRequest.TransferMapping.DatabasesBlack.SpecificTables.AdbTableSchema?

                public var filterColumns: [String]?

                public var id: String?

                public var mappedName: String?

                public var name: String?

                public var shardColumns: [String]?

                public var whereClause: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.adbTableSchema?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adbTableSchema != nil {
                        map["AdbTableSchema"] = self.adbTableSchema?.toMap()
                    }
                    if self.filterColumns != nil {
                        map["FilterColumns"] = self.filterColumns!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.mappedName != nil {
                        map["MappedName"] = self.mappedName!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.shardColumns != nil {
                        map["ShardColumns"] = self.shardColumns!
                    }
                    if self.whereClause != nil {
                        map["WhereClause"] = self.whereClause!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AdbTableSchema") {
                        var model = CreateProjectRequest.TransferMapping.DatabasesBlack.SpecificTables.AdbTableSchema()
                        model.fromMap(dict["AdbTableSchema"] as! [String: Any])
                        self.adbTableSchema = model
                    }
                    if dict.keys.contains("FilterColumns") {
                        self.filterColumns = dict["FilterColumns"] as! [String]
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("MappedName") {
                        self.mappedName = dict["MappedName"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("ShardColumns") {
                        self.shardColumns = dict["ShardColumns"] as! [String]
                    }
                    if dict.keys.contains("WhereClause") {
                        self.whereClause = dict["WhereClause"] as! String
                    }
                }
            }
            public class SpecificViews : Tea.TeaModel {
                public class AdbTableSchema : Tea.TeaModel {
                    public var distributedKeys: [String]?

                    public var partitionLifeCycle: String?

                    public var partitionStatement: String?

                    public var primaryKeys: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.distributedKeys != nil {
                            map["DistributedKeys"] = self.distributedKeys!
                        }
                        if self.partitionLifeCycle != nil {
                            map["PartitionLifeCycle"] = self.partitionLifeCycle!
                        }
                        if self.partitionStatement != nil {
                            map["PartitionStatement"] = self.partitionStatement!
                        }
                        if self.primaryKeys != nil {
                            map["PrimaryKeys"] = self.primaryKeys!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DistributedKeys") {
                            self.distributedKeys = dict["DistributedKeys"] as! [String]
                        }
                        if dict.keys.contains("PartitionLifeCycle") {
                            self.partitionLifeCycle = dict["PartitionLifeCycle"] as! String
                        }
                        if dict.keys.contains("PartitionStatement") {
                            self.partitionStatement = dict["PartitionStatement"] as! String
                        }
                        if dict.keys.contains("PrimaryKeys") {
                            self.primaryKeys = dict["PrimaryKeys"] as! [String]
                        }
                    }
                }
                public var adbTableSchema: CreateProjectRequest.TransferMapping.DatabasesBlack.SpecificViews.AdbTableSchema?

                public var filterColumns: [String]?

                public var id: String?

                public var mappedName: String?

                public var name: String?

                public var shardColumns: [String]?

                public var whereClause: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.adbTableSchema?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adbTableSchema != nil {
                        map["AdbTableSchema"] = self.adbTableSchema?.toMap()
                    }
                    if self.filterColumns != nil {
                        map["FilterColumns"] = self.filterColumns!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.mappedName != nil {
                        map["MappedName"] = self.mappedName!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.shardColumns != nil {
                        map["ShardColumns"] = self.shardColumns!
                    }
                    if self.whereClause != nil {
                        map["WhereClause"] = self.whereClause!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AdbTableSchema") {
                        var model = CreateProjectRequest.TransferMapping.DatabasesBlack.SpecificViews.AdbTableSchema()
                        model.fromMap(dict["AdbTableSchema"] as! [String: Any])
                        self.adbTableSchema = model
                    }
                    if dict.keys.contains("FilterColumns") {
                        self.filterColumns = dict["FilterColumns"] as! [String]
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("MappedName") {
                        self.mappedName = dict["MappedName"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("ShardColumns") {
                        self.shardColumns = dict["ShardColumns"] as! [String]
                    }
                    if dict.keys.contains("WhereClause") {
                        self.whereClause = dict["WhereClause"] as! String
                    }
                }
            }
            public class Tables : Tea.TeaModel {
                public class AdbTableSchema : Tea.TeaModel {
                    public var distributedKeys: [String]?

                    public var partitionLifeCycle: String?

                    public var partitionStatement: String?

                    public var primaryKeys: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.distributedKeys != nil {
                            map["DistributedKeys"] = self.distributedKeys!
                        }
                        if self.partitionLifeCycle != nil {
                            map["PartitionLifeCycle"] = self.partitionLifeCycle!
                        }
                        if self.partitionStatement != nil {
                            map["PartitionStatement"] = self.partitionStatement!
                        }
                        if self.primaryKeys != nil {
                            map["PrimaryKeys"] = self.primaryKeys!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DistributedKeys") {
                            self.distributedKeys = dict["DistributedKeys"] as! [String]
                        }
                        if dict.keys.contains("PartitionLifeCycle") {
                            self.partitionLifeCycle = dict["PartitionLifeCycle"] as! String
                        }
                        if dict.keys.contains("PartitionStatement") {
                            self.partitionStatement = dict["PartitionStatement"] as! String
                        }
                        if dict.keys.contains("PrimaryKeys") {
                            self.primaryKeys = dict["PrimaryKeys"] as! [String]
                        }
                    }
                }
                public var adbTableSchema: CreateProjectRequest.TransferMapping.DatabasesBlack.Tables.AdbTableSchema?

                public var filterColumns: [String]?

                public var id: String?

                public var mappedName: String?

                public var name: String?

                public var shardColumns: [String]?

                public var whereClause: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.adbTableSchema?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adbTableSchema != nil {
                        map["AdbTableSchema"] = self.adbTableSchema?.toMap()
                    }
                    if self.filterColumns != nil {
                        map["FilterColumns"] = self.filterColumns!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.mappedName != nil {
                        map["MappedName"] = self.mappedName!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.shardColumns != nil {
                        map["ShardColumns"] = self.shardColumns!
                    }
                    if self.whereClause != nil {
                        map["WhereClause"] = self.whereClause!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AdbTableSchema") {
                        var model = CreateProjectRequest.TransferMapping.DatabasesBlack.Tables.AdbTableSchema()
                        model.fromMap(dict["AdbTableSchema"] as! [String: Any])
                        self.adbTableSchema = model
                    }
                    if dict.keys.contains("FilterColumns") {
                        self.filterColumns = dict["FilterColumns"] as! [String]
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("MappedName") {
                        self.mappedName = dict["MappedName"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("ShardColumns") {
                        self.shardColumns = dict["ShardColumns"] as! [String]
                    }
                    if dict.keys.contains("WhereClause") {
                        self.whereClause = dict["WhereClause"] as! String
                    }
                }
            }
            public class Views : Tea.TeaModel {
                public class AdbTableSchema : Tea.TeaModel {
                    public var distributedKeys: [String]?

                    public var partitionLifeCycle: String?

                    public var partitionStatement: String?

                    public var primaryKeys: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.distributedKeys != nil {
                            map["DistributedKeys"] = self.distributedKeys!
                        }
                        if self.partitionLifeCycle != nil {
                            map["PartitionLifeCycle"] = self.partitionLifeCycle!
                        }
                        if self.partitionStatement != nil {
                            map["PartitionStatement"] = self.partitionStatement!
                        }
                        if self.primaryKeys != nil {
                            map["PrimaryKeys"] = self.primaryKeys!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DistributedKeys") {
                            self.distributedKeys = dict["DistributedKeys"] as! [String]
                        }
                        if dict.keys.contains("PartitionLifeCycle") {
                            self.partitionLifeCycle = dict["PartitionLifeCycle"] as! String
                        }
                        if dict.keys.contains("PartitionStatement") {
                            self.partitionStatement = dict["PartitionStatement"] as! String
                        }
                        if dict.keys.contains("PrimaryKeys") {
                            self.primaryKeys = dict["PrimaryKeys"] as! [String]
                        }
                    }
                }
                public var adbTableSchema: CreateProjectRequest.TransferMapping.DatabasesBlack.Views.AdbTableSchema?

                public var filterColumns: [String]?

                public var id: String?

                public var mappedName: String?

                public var name: String?

                public var shardColumns: [String]?

                public var whereClause: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.adbTableSchema?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adbTableSchema != nil {
                        map["AdbTableSchema"] = self.adbTableSchema?.toMap()
                    }
                    if self.filterColumns != nil {
                        map["FilterColumns"] = self.filterColumns!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.mappedName != nil {
                        map["MappedName"] = self.mappedName!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.shardColumns != nil {
                        map["ShardColumns"] = self.shardColumns!
                    }
                    if self.whereClause != nil {
                        map["WhereClause"] = self.whereClause!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AdbTableSchema") {
                        var model = CreateProjectRequest.TransferMapping.DatabasesBlack.Views.AdbTableSchema()
                        model.fromMap(dict["AdbTableSchema"] as! [String: Any])
                        self.adbTableSchema = model
                    }
                    if dict.keys.contains("FilterColumns") {
                        self.filterColumns = dict["FilterColumns"] as! [String]
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("MappedName") {
                        self.mappedName = dict["MappedName"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("ShardColumns") {
                        self.shardColumns = dict["ShardColumns"] as! [String]
                    }
                    if dict.keys.contains("WhereClause") {
                        self.whereClause = dict["WhereClause"] as! String
                    }
                }
            }
            public var clusterName: String?

            public var id: String?

            public var mappedName: String?

            public var name: String?

            public var specificTables: [CreateProjectRequest.TransferMapping.DatabasesBlack.SpecificTables]?

            public var specificViews: [CreateProjectRequest.TransferMapping.DatabasesBlack.SpecificViews]?

            public var tables: [CreateProjectRequest.TransferMapping.DatabasesBlack.Tables]?

            public var tenantName: String?

            public var views: [CreateProjectRequest.TransferMapping.DatabasesBlack.Views]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterName != nil {
                    map["ClusterName"] = self.clusterName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.mappedName != nil {
                    map["MappedName"] = self.mappedName!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.specificTables != nil {
                    var tmp : [Any] = []
                    for k in self.specificTables! {
                        tmp.append(k.toMap())
                    }
                    map["SpecificTables"] = tmp
                }
                if self.specificViews != nil {
                    var tmp : [Any] = []
                    for k in self.specificViews! {
                        tmp.append(k.toMap())
                    }
                    map["SpecificViews"] = tmp
                }
                if self.tables != nil {
                    var tmp : [Any] = []
                    for k in self.tables! {
                        tmp.append(k.toMap())
                    }
                    map["Tables"] = tmp
                }
                if self.tenantName != nil {
                    map["TenantName"] = self.tenantName!
                }
                if self.views != nil {
                    var tmp : [Any] = []
                    for k in self.views! {
                        tmp.append(k.toMap())
                    }
                    map["Views"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterName") {
                    self.clusterName = dict["ClusterName"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("MappedName") {
                    self.mappedName = dict["MappedName"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("SpecificTables") {
                    var tmp : [CreateProjectRequest.TransferMapping.DatabasesBlack.SpecificTables] = []
                    for v in dict["SpecificTables"] as! [Any] {
                        var model = CreateProjectRequest.TransferMapping.DatabasesBlack.SpecificTables()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.specificTables = tmp
                }
                if dict.keys.contains("SpecificViews") {
                    var tmp : [CreateProjectRequest.TransferMapping.DatabasesBlack.SpecificViews] = []
                    for v in dict["SpecificViews"] as! [Any] {
                        var model = CreateProjectRequest.TransferMapping.DatabasesBlack.SpecificViews()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.specificViews = tmp
                }
                if dict.keys.contains("Tables") {
                    var tmp : [CreateProjectRequest.TransferMapping.DatabasesBlack.Tables] = []
                    for v in dict["Tables"] as! [Any] {
                        var model = CreateProjectRequest.TransferMapping.DatabasesBlack.Tables()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tables = tmp
                }
                if dict.keys.contains("TenantName") {
                    self.tenantName = dict["TenantName"] as! String
                }
                if dict.keys.contains("Views") {
                    var tmp : [CreateProjectRequest.TransferMapping.DatabasesBlack.Views] = []
                    for v in dict["Views"] as! [Any] {
                        var model = CreateProjectRequest.TransferMapping.DatabasesBlack.Views()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.views = tmp
                }
            }
        }
        public var databases: [CreateProjectRequest.TransferMapping.Databases]?

        public var databasesBlack: [CreateProjectRequest.TransferMapping.DatabasesBlack]?

        public var mode: String?

        public var tableAndViewBlackList: [String]?

        public var tableAndViewWhiteList: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.databases != nil {
                var tmp : [Any] = []
                for k in self.databases! {
                    tmp.append(k.toMap())
                }
                map["Databases"] = tmp
            }
            if self.databasesBlack != nil {
                var tmp : [Any] = []
                for k in self.databasesBlack! {
                    tmp.append(k.toMap())
                }
                map["DatabasesBlack"] = tmp
            }
            if self.mode != nil {
                map["Mode"] = self.mode!
            }
            if self.tableAndViewBlackList != nil {
                map["TableAndViewBlackList"] = self.tableAndViewBlackList!
            }
            if self.tableAndViewWhiteList != nil {
                map["TableAndViewWhiteList"] = self.tableAndViewWhiteList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Databases") {
                var tmp : [CreateProjectRequest.TransferMapping.Databases] = []
                for v in dict["Databases"] as! [Any] {
                    var model = CreateProjectRequest.TransferMapping.Databases()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.databases = tmp
            }
            if dict.keys.contains("DatabasesBlack") {
                var tmp : [CreateProjectRequest.TransferMapping.DatabasesBlack] = []
                for v in dict["DatabasesBlack"] as! [Any] {
                    var model = CreateProjectRequest.TransferMapping.DatabasesBlack()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.databasesBlack = tmp
            }
            if dict.keys.contains("Mode") {
                self.mode = dict["Mode"] as! String
            }
            if dict.keys.contains("TableAndViewBlackList") {
                self.tableAndViewBlackList = dict["TableAndViewBlackList"] as! [String]
            }
            if dict.keys.contains("TableAndViewWhiteList") {
                self.tableAndViewWhiteList = dict["TableAndViewWhiteList"] as! [String]
            }
        }
    }
    public var commonTransferConfig: CreateProjectRequest.CommonTransferConfig?

    public var enableFullTransfer: Bool?

    public var enableFullVerify: Bool?

    public var enableIncrTransfer: Bool?

    public var enableReverseIncrTransfer: Bool?

    public var enableStructTransfer: Bool?

    public var fullTransferConfig: CreateProjectRequest.FullTransferConfig?

    public var id: String?

    public var incrTransferConfig: CreateProjectRequest.IncrTransferConfig?

    public var labelIds: [String]?

    public var name: String?

    public var ossKey: String?

    public var reverseIncrTransferConfig: CreateProjectRequest.ReverseIncrTransferConfig?

    public var sinkEndpointId: String?

    public var sourceEndpointId: String?

    public var structTransferConfig: CreateProjectRequest.StructTransferConfig?

    public var transferMapping: CreateProjectRequest.TransferMapping?

    public var type: String?

    public var useOss: Bool?

    public var workerGradeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.commonTransferConfig?.validate()
        try self.fullTransferConfig?.validate()
        try self.incrTransferConfig?.validate()
        try self.reverseIncrTransferConfig?.validate()
        try self.structTransferConfig?.validate()
        try self.transferMapping?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonTransferConfig != nil {
            map["CommonTransferConfig"] = self.commonTransferConfig?.toMap()
        }
        if self.enableFullTransfer != nil {
            map["EnableFullTransfer"] = self.enableFullTransfer!
        }
        if self.enableFullVerify != nil {
            map["EnableFullVerify"] = self.enableFullVerify!
        }
        if self.enableIncrTransfer != nil {
            map["EnableIncrTransfer"] = self.enableIncrTransfer!
        }
        if self.enableReverseIncrTransfer != nil {
            map["EnableReverseIncrTransfer"] = self.enableReverseIncrTransfer!
        }
        if self.enableStructTransfer != nil {
            map["EnableStructTransfer"] = self.enableStructTransfer!
        }
        if self.fullTransferConfig != nil {
            map["FullTransferConfig"] = self.fullTransferConfig?.toMap()
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.incrTransferConfig != nil {
            map["IncrTransferConfig"] = self.incrTransferConfig?.toMap()
        }
        if self.labelIds != nil {
            map["LabelIds"] = self.labelIds!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ossKey != nil {
            map["OssKey"] = self.ossKey!
        }
        if self.reverseIncrTransferConfig != nil {
            map["ReverseIncrTransferConfig"] = self.reverseIncrTransferConfig?.toMap()
        }
        if self.sinkEndpointId != nil {
            map["SinkEndpointId"] = self.sinkEndpointId!
        }
        if self.sourceEndpointId != nil {
            map["SourceEndpointId"] = self.sourceEndpointId!
        }
        if self.structTransferConfig != nil {
            map["StructTransferConfig"] = self.structTransferConfig?.toMap()
        }
        if self.transferMapping != nil {
            map["TransferMapping"] = self.transferMapping?.toMap()
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.useOss != nil {
            map["UseOss"] = self.useOss!
        }
        if self.workerGradeId != nil {
            map["WorkerGradeId"] = self.workerGradeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommonTransferConfig") {
            var model = CreateProjectRequest.CommonTransferConfig()
            model.fromMap(dict["CommonTransferConfig"] as! [String: Any])
            self.commonTransferConfig = model
        }
        if dict.keys.contains("EnableFullTransfer") {
            self.enableFullTransfer = dict["EnableFullTransfer"] as! Bool
        }
        if dict.keys.contains("EnableFullVerify") {
            self.enableFullVerify = dict["EnableFullVerify"] as! Bool
        }
        if dict.keys.contains("EnableIncrTransfer") {
            self.enableIncrTransfer = dict["EnableIncrTransfer"] as! Bool
        }
        if dict.keys.contains("EnableReverseIncrTransfer") {
            self.enableReverseIncrTransfer = dict["EnableReverseIncrTransfer"] as! Bool
        }
        if dict.keys.contains("EnableStructTransfer") {
            self.enableStructTransfer = dict["EnableStructTransfer"] as! Bool
        }
        if dict.keys.contains("FullTransferConfig") {
            var model = CreateProjectRequest.FullTransferConfig()
            model.fromMap(dict["FullTransferConfig"] as! [String: Any])
            self.fullTransferConfig = model
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("IncrTransferConfig") {
            var model = CreateProjectRequest.IncrTransferConfig()
            model.fromMap(dict["IncrTransferConfig"] as! [String: Any])
            self.incrTransferConfig = model
        }
        if dict.keys.contains("LabelIds") {
            self.labelIds = dict["LabelIds"] as! [String]
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OssKey") {
            self.ossKey = dict["OssKey"] as! String
        }
        if dict.keys.contains("ReverseIncrTransferConfig") {
            var model = CreateProjectRequest.ReverseIncrTransferConfig()
            model.fromMap(dict["ReverseIncrTransferConfig"] as! [String: Any])
            self.reverseIncrTransferConfig = model
        }
        if dict.keys.contains("SinkEndpointId") {
            self.sinkEndpointId = dict["SinkEndpointId"] as! String
        }
        if dict.keys.contains("SourceEndpointId") {
            self.sourceEndpointId = dict["SourceEndpointId"] as! String
        }
        if dict.keys.contains("StructTransferConfig") {
            var model = CreateProjectRequest.StructTransferConfig()
            model.fromMap(dict["StructTransferConfig"] as! [String: Any])
            self.structTransferConfig = model
        }
        if dict.keys.contains("TransferMapping") {
            var model = CreateProjectRequest.TransferMapping()
            model.fromMap(dict["TransferMapping"] as! [String: Any])
            self.transferMapping = model
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UseOss") {
            self.useOss = dict["UseOss"] as! Bool
        }
        if dict.keys.contains("WorkerGradeId") {
            self.workerGradeId = dict["WorkerGradeId"] as! String
        }
    }
}

public class CreateProjectShrinkRequest : Tea.TeaModel {
    public var commonTransferConfigShrink: String?

    public var enableFullTransfer: Bool?

    public var enableFullVerify: Bool?

    public var enableIncrTransfer: Bool?

    public var enableReverseIncrTransfer: Bool?

    public var enableStructTransfer: Bool?

    public var fullTransferConfigShrink: String?

    public var id: String?

    public var incrTransferConfigShrink: String?

    public var labelIdsShrink: String?

    public var name: String?

    public var ossKey: String?

    public var reverseIncrTransferConfigShrink: String?

    public var sinkEndpointId: String?

    public var sourceEndpointId: String?

    public var structTransferConfigShrink: String?

    public var transferMappingShrink: String?

    public var type: String?

    public var useOss: Bool?

    public var workerGradeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonTransferConfigShrink != nil {
            map["CommonTransferConfig"] = self.commonTransferConfigShrink!
        }
        if self.enableFullTransfer != nil {
            map["EnableFullTransfer"] = self.enableFullTransfer!
        }
        if self.enableFullVerify != nil {
            map["EnableFullVerify"] = self.enableFullVerify!
        }
        if self.enableIncrTransfer != nil {
            map["EnableIncrTransfer"] = self.enableIncrTransfer!
        }
        if self.enableReverseIncrTransfer != nil {
            map["EnableReverseIncrTransfer"] = self.enableReverseIncrTransfer!
        }
        if self.enableStructTransfer != nil {
            map["EnableStructTransfer"] = self.enableStructTransfer!
        }
        if self.fullTransferConfigShrink != nil {
            map["FullTransferConfig"] = self.fullTransferConfigShrink!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.incrTransferConfigShrink != nil {
            map["IncrTransferConfig"] = self.incrTransferConfigShrink!
        }
        if self.labelIdsShrink != nil {
            map["LabelIds"] = self.labelIdsShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ossKey != nil {
            map["OssKey"] = self.ossKey!
        }
        if self.reverseIncrTransferConfigShrink != nil {
            map["ReverseIncrTransferConfig"] = self.reverseIncrTransferConfigShrink!
        }
        if self.sinkEndpointId != nil {
            map["SinkEndpointId"] = self.sinkEndpointId!
        }
        if self.sourceEndpointId != nil {
            map["SourceEndpointId"] = self.sourceEndpointId!
        }
        if self.structTransferConfigShrink != nil {
            map["StructTransferConfig"] = self.structTransferConfigShrink!
        }
        if self.transferMappingShrink != nil {
            map["TransferMapping"] = self.transferMappingShrink!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.useOss != nil {
            map["UseOss"] = self.useOss!
        }
        if self.workerGradeId != nil {
            map["WorkerGradeId"] = self.workerGradeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommonTransferConfig") {
            self.commonTransferConfigShrink = dict["CommonTransferConfig"] as! String
        }
        if dict.keys.contains("EnableFullTransfer") {
            self.enableFullTransfer = dict["EnableFullTransfer"] as! Bool
        }
        if dict.keys.contains("EnableFullVerify") {
            self.enableFullVerify = dict["EnableFullVerify"] as! Bool
        }
        if dict.keys.contains("EnableIncrTransfer") {
            self.enableIncrTransfer = dict["EnableIncrTransfer"] as! Bool
        }
        if dict.keys.contains("EnableReverseIncrTransfer") {
            self.enableReverseIncrTransfer = dict["EnableReverseIncrTransfer"] as! Bool
        }
        if dict.keys.contains("EnableStructTransfer") {
            self.enableStructTransfer = dict["EnableStructTransfer"] as! Bool
        }
        if dict.keys.contains("FullTransferConfig") {
            self.fullTransferConfigShrink = dict["FullTransferConfig"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("IncrTransferConfig") {
            self.incrTransferConfigShrink = dict["IncrTransferConfig"] as! String
        }
        if dict.keys.contains("LabelIds") {
            self.labelIdsShrink = dict["LabelIds"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OssKey") {
            self.ossKey = dict["OssKey"] as! String
        }
        if dict.keys.contains("ReverseIncrTransferConfig") {
            self.reverseIncrTransferConfigShrink = dict["ReverseIncrTransferConfig"] as! String
        }
        if dict.keys.contains("SinkEndpointId") {
            self.sinkEndpointId = dict["SinkEndpointId"] as! String
        }
        if dict.keys.contains("SourceEndpointId") {
            self.sourceEndpointId = dict["SourceEndpointId"] as! String
        }
        if dict.keys.contains("StructTransferConfig") {
            self.structTransferConfigShrink = dict["StructTransferConfig"] as! String
        }
        if dict.keys.contains("TransferMapping") {
            self.transferMappingShrink = dict["TransferMapping"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UseOss") {
            self.useOss = dict["UseOss"] as! Bool
        }
        if dict.keys.contains("WorkerGradeId") {
            self.workerGradeId = dict["WorkerGradeId"] as! String
        }
    }
}

public class CreateProjectResponseBody : Tea.TeaModel {
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: String?

    public var errorDetail: CreateProjectResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("ErrorDetail") {
            var model = CreateProjectResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class CreateProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateProjectModifyRecordsRequest : Tea.TeaModel {
    public class Databases : Tea.TeaModel {
        public class SpecificTables : Tea.TeaModel {
            public class AdbTableSchema : Tea.TeaModel {
                public var distributedKeys: [String]?

                public var partitionLifeCycle: String?

                public var partitionStatement: String?

                public var primaryKeys: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.distributedKeys != nil {
                        map["DistributedKeys"] = self.distributedKeys!
                    }
                    if self.partitionLifeCycle != nil {
                        map["PartitionLifeCycle"] = self.partitionLifeCycle!
                    }
                    if self.partitionStatement != nil {
                        map["PartitionStatement"] = self.partitionStatement!
                    }
                    if self.primaryKeys != nil {
                        map["PrimaryKeys"] = self.primaryKeys!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DistributedKeys") {
                        self.distributedKeys = dict["DistributedKeys"] as! [String]
                    }
                    if dict.keys.contains("PartitionLifeCycle") {
                        self.partitionLifeCycle = dict["PartitionLifeCycle"] as! String
                    }
                    if dict.keys.contains("PartitionStatement") {
                        self.partitionStatement = dict["PartitionStatement"] as! String
                    }
                    if dict.keys.contains("PrimaryKeys") {
                        self.primaryKeys = dict["PrimaryKeys"] as! [String]
                    }
                }
            }
            public var adbTableSchema: CreateProjectModifyRecordsRequest.Databases.SpecificTables.AdbTableSchema?

            public var filterColumns: [String]?

            public var id: String?

            public var mappedName: String?

            public var name: String?

            public var shardColumns: [String]?

            public var whereClause: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.adbTableSchema?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.adbTableSchema != nil {
                    map["AdbTableSchema"] = self.adbTableSchema?.toMap()
                }
                if self.filterColumns != nil {
                    map["FilterColumns"] = self.filterColumns!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.mappedName != nil {
                    map["MappedName"] = self.mappedName!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.shardColumns != nil {
                    map["ShardColumns"] = self.shardColumns!
                }
                if self.whereClause != nil {
                    map["WhereClause"] = self.whereClause!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdbTableSchema") {
                    var model = CreateProjectModifyRecordsRequest.Databases.SpecificTables.AdbTableSchema()
                    model.fromMap(dict["AdbTableSchema"] as! [String: Any])
                    self.adbTableSchema = model
                }
                if dict.keys.contains("FilterColumns") {
                    self.filterColumns = dict["FilterColumns"] as! [String]
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("MappedName") {
                    self.mappedName = dict["MappedName"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ShardColumns") {
                    self.shardColumns = dict["ShardColumns"] as! [String]
                }
                if dict.keys.contains("WhereClause") {
                    self.whereClause = dict["WhereClause"] as! String
                }
            }
        }
        public class SpecificViews : Tea.TeaModel {
            public class AdbTableSchema : Tea.TeaModel {
                public var distributedKeys: [String]?

                public var partitionLifeCycle: String?

                public var partitionStatement: String?

                public var primaryKeys: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.distributedKeys != nil {
                        map["DistributedKeys"] = self.distributedKeys!
                    }
                    if self.partitionLifeCycle != nil {
                        map["PartitionLifeCycle"] = self.partitionLifeCycle!
                    }
                    if self.partitionStatement != nil {
                        map["PartitionStatement"] = self.partitionStatement!
                    }
                    if self.primaryKeys != nil {
                        map["PrimaryKeys"] = self.primaryKeys!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DistributedKeys") {
                        self.distributedKeys = dict["DistributedKeys"] as! [String]
                    }
                    if dict.keys.contains("PartitionLifeCycle") {
                        self.partitionLifeCycle = dict["PartitionLifeCycle"] as! String
                    }
                    if dict.keys.contains("PartitionStatement") {
                        self.partitionStatement = dict["PartitionStatement"] as! String
                    }
                    if dict.keys.contains("PrimaryKeys") {
                        self.primaryKeys = dict["PrimaryKeys"] as! [String]
                    }
                }
            }
            public var adbTableSchema: CreateProjectModifyRecordsRequest.Databases.SpecificViews.AdbTableSchema?

            public var filterColumns: [String]?

            public var id: String?

            public var mappedName: String?

            public var name: String?

            public var shardColumns: [String]?

            public var whereClause: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.adbTableSchema?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.adbTableSchema != nil {
                    map["AdbTableSchema"] = self.adbTableSchema?.toMap()
                }
                if self.filterColumns != nil {
                    map["FilterColumns"] = self.filterColumns!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.mappedName != nil {
                    map["MappedName"] = self.mappedName!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.shardColumns != nil {
                    map["ShardColumns"] = self.shardColumns!
                }
                if self.whereClause != nil {
                    map["WhereClause"] = self.whereClause!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdbTableSchema") {
                    var model = CreateProjectModifyRecordsRequest.Databases.SpecificViews.AdbTableSchema()
                    model.fromMap(dict["AdbTableSchema"] as! [String: Any])
                    self.adbTableSchema = model
                }
                if dict.keys.contains("FilterColumns") {
                    self.filterColumns = dict["FilterColumns"] as! [String]
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("MappedName") {
                    self.mappedName = dict["MappedName"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ShardColumns") {
                    self.shardColumns = dict["ShardColumns"] as! [String]
                }
                if dict.keys.contains("WhereClause") {
                    self.whereClause = dict["WhereClause"] as! String
                }
            }
        }
        public class Tables : Tea.TeaModel {
            public class AdbTableSchema : Tea.TeaModel {
                public var distributedKeys: [String]?

                public var partitionLifeCycle: String?

                public var partitionStatement: String?

                public var primaryKeys: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.distributedKeys != nil {
                        map["DistributedKeys"] = self.distributedKeys!
                    }
                    if self.partitionLifeCycle != nil {
                        map["PartitionLifeCycle"] = self.partitionLifeCycle!
                    }
                    if self.partitionStatement != nil {
                        map["PartitionStatement"] = self.partitionStatement!
                    }
                    if self.primaryKeys != nil {
                        map["PrimaryKeys"] = self.primaryKeys!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DistributedKeys") {
                        self.distributedKeys = dict["DistributedKeys"] as! [String]
                    }
                    if dict.keys.contains("PartitionLifeCycle") {
                        self.partitionLifeCycle = dict["PartitionLifeCycle"] as! String
                    }
                    if dict.keys.contains("PartitionStatement") {
                        self.partitionStatement = dict["PartitionStatement"] as! String
                    }
                    if dict.keys.contains("PrimaryKeys") {
                        self.primaryKeys = dict["PrimaryKeys"] as! [String]
                    }
                }
            }
            public var adbTableSchema: CreateProjectModifyRecordsRequest.Databases.Tables.AdbTableSchema?

            public var filterColumns: [String]?

            public var id: String?

            public var mappedName: String?

            public var name: String?

            public var shardColumns: [String]?

            public var whereClause: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.adbTableSchema?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.adbTableSchema != nil {
                    map["AdbTableSchema"] = self.adbTableSchema?.toMap()
                }
                if self.filterColumns != nil {
                    map["FilterColumns"] = self.filterColumns!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.mappedName != nil {
                    map["MappedName"] = self.mappedName!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.shardColumns != nil {
                    map["ShardColumns"] = self.shardColumns!
                }
                if self.whereClause != nil {
                    map["WhereClause"] = self.whereClause!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdbTableSchema") {
                    var model = CreateProjectModifyRecordsRequest.Databases.Tables.AdbTableSchema()
                    model.fromMap(dict["AdbTableSchema"] as! [String: Any])
                    self.adbTableSchema = model
                }
                if dict.keys.contains("FilterColumns") {
                    self.filterColumns = dict["FilterColumns"] as! [String]
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("MappedName") {
                    self.mappedName = dict["MappedName"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ShardColumns") {
                    self.shardColumns = dict["ShardColumns"] as! [String]
                }
                if dict.keys.contains("WhereClause") {
                    self.whereClause = dict["WhereClause"] as! String
                }
            }
        }
        public class Views : Tea.TeaModel {
            public class AdbTableSchema : Tea.TeaModel {
                public var distributedKeys: [String]?

                public var partitionLifeCycle: String?

                public var partitionStatement: String?

                public var primaryKeys: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.distributedKeys != nil {
                        map["DistributedKeys"] = self.distributedKeys!
                    }
                    if self.partitionLifeCycle != nil {
                        map["PartitionLifeCycle"] = self.partitionLifeCycle!
                    }
                    if self.partitionStatement != nil {
                        map["PartitionStatement"] = self.partitionStatement!
                    }
                    if self.primaryKeys != nil {
                        map["PrimaryKeys"] = self.primaryKeys!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DistributedKeys") {
                        self.distributedKeys = dict["DistributedKeys"] as! [String]
                    }
                    if dict.keys.contains("PartitionLifeCycle") {
                        self.partitionLifeCycle = dict["PartitionLifeCycle"] as! String
                    }
                    if dict.keys.contains("PartitionStatement") {
                        self.partitionStatement = dict["PartitionStatement"] as! String
                    }
                    if dict.keys.contains("PrimaryKeys") {
                        self.primaryKeys = dict["PrimaryKeys"] as! [String]
                    }
                }
            }
            public var adbTableSchema: CreateProjectModifyRecordsRequest.Databases.Views.AdbTableSchema?

            public var filterColumns: [String]?

            public var id: String?

            public var mappedName: String?

            public var name: String?

            public var shardColumns: [String]?

            public var whereClause: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.adbTableSchema?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.adbTableSchema != nil {
                    map["AdbTableSchema"] = self.adbTableSchema?.toMap()
                }
                if self.filterColumns != nil {
                    map["FilterColumns"] = self.filterColumns!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.mappedName != nil {
                    map["MappedName"] = self.mappedName!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.shardColumns != nil {
                    map["ShardColumns"] = self.shardColumns!
                }
                if self.whereClause != nil {
                    map["WhereClause"] = self.whereClause!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdbTableSchema") {
                    var model = CreateProjectModifyRecordsRequest.Databases.Views.AdbTableSchema()
                    model.fromMap(dict["AdbTableSchema"] as! [String: Any])
                    self.adbTableSchema = model
                }
                if dict.keys.contains("FilterColumns") {
                    self.filterColumns = dict["FilterColumns"] as! [String]
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("MappedName") {
                    self.mappedName = dict["MappedName"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ShardColumns") {
                    self.shardColumns = dict["ShardColumns"] as! [String]
                }
                if dict.keys.contains("WhereClause") {
                    self.whereClause = dict["WhereClause"] as! String
                }
            }
        }
        public var id: String?

        public var mappedName: String?

        public var name: String?

        public var specificTables: [CreateProjectModifyRecordsRequest.Databases.SpecificTables]?

        public var specificViews: [CreateProjectModifyRecordsRequest.Databases.SpecificViews]?

        public var tables: [CreateProjectModifyRecordsRequest.Databases.Tables]?

        public var views: [CreateProjectModifyRecordsRequest.Databases.Views]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.mappedName != nil {
                map["MappedName"] = self.mappedName!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.specificTables != nil {
                var tmp : [Any] = []
                for k in self.specificTables! {
                    tmp.append(k.toMap())
                }
                map["SpecificTables"] = tmp
            }
            if self.specificViews != nil {
                var tmp : [Any] = []
                for k in self.specificViews! {
                    tmp.append(k.toMap())
                }
                map["SpecificViews"] = tmp
            }
            if self.tables != nil {
                var tmp : [Any] = []
                for k in self.tables! {
                    tmp.append(k.toMap())
                }
                map["Tables"] = tmp
            }
            if self.views != nil {
                var tmp : [Any] = []
                for k in self.views! {
                    tmp.append(k.toMap())
                }
                map["Views"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("MappedName") {
                self.mappedName = dict["MappedName"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("SpecificTables") {
                var tmp : [CreateProjectModifyRecordsRequest.Databases.SpecificTables] = []
                for v in dict["SpecificTables"] as! [Any] {
                    var model = CreateProjectModifyRecordsRequest.Databases.SpecificTables()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.specificTables = tmp
            }
            if dict.keys.contains("SpecificViews") {
                var tmp : [CreateProjectModifyRecordsRequest.Databases.SpecificViews] = []
                for v in dict["SpecificViews"] as! [Any] {
                    var model = CreateProjectModifyRecordsRequest.Databases.SpecificViews()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.specificViews = tmp
            }
            if dict.keys.contains("Tables") {
                var tmp : [CreateProjectModifyRecordsRequest.Databases.Tables] = []
                for v in dict["Tables"] as! [Any] {
                    var model = CreateProjectModifyRecordsRequest.Databases.Tables()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tables = tmp
            }
            if dict.keys.contains("Views") {
                var tmp : [CreateProjectModifyRecordsRequest.Databases.Views] = []
                for v in dict["Views"] as! [Any] {
                    var model = CreateProjectModifyRecordsRequest.Databases.Views()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.views = tmp
            }
        }
    }
    public var databases: [CreateProjectModifyRecordsRequest.Databases]?

    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databases != nil {
            var tmp : [Any] = []
            for k in self.databases! {
                tmp.append(k.toMap())
            }
            map["Databases"] = tmp
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Databases") {
            var tmp : [CreateProjectModifyRecordsRequest.Databases] = []
            for v in dict["Databases"] as! [Any] {
                var model = CreateProjectModifyRecordsRequest.Databases()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.databases = tmp
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class CreateProjectModifyRecordsShrinkRequest : Tea.TeaModel {
    public var databasesShrink: String?

    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databasesShrink != nil {
            map["Databases"] = self.databasesShrink!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Databases") {
            self.databasesShrink = dict["Databases"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class CreateProjectModifyRecordsResponseBody : Tea.TeaModel {
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: Int64?

    public var errorDetail: CreateProjectModifyRecordsResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Int64
        }
        if dict.keys.contains("ErrorDetail") {
            var model = CreateProjectModifyRecordsResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class CreateProjectModifyRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateProjectModifyRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateProjectModifyRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateRdsPostgreSQLDataSourceRequest : Tea.TeaModel {
    public var databaseName: String?

    public var description_: String?

    public var instanceId: String?

    public var name: String?

    public var password: String?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatabaseName") {
            self.databaseName = dict["DatabaseName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
    }
}

public class CreateRdsPostgreSQLDataSourceResponseBody : Tea.TeaModel {
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: String?

    public var errorDetail: CreateRdsPostgreSQLDataSourceResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("ErrorDetail") {
            var model = CreateRdsPostgreSQLDataSourceResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class CreateRdsPostgreSQLDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRdsPostgreSQLDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateRdsPostgreSQLDataSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSecurityIpGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var securityIpGroupName: String?

    public var securityIps: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.securityIpGroupName != nil {
            map["SecurityIpGroupName"] = self.securityIpGroupName!
        }
        if self.securityIps != nil {
            map["SecurityIps"] = self.securityIps!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SecurityIpGroupName") {
            self.securityIpGroupName = dict["SecurityIpGroupName"] as! String
        }
        if dict.keys.contains("SecurityIps") {
            self.securityIps = dict["SecurityIps"] as! String
        }
    }
}

public class CreateSecurityIpGroupResponseBody : Tea.TeaModel {
    public class SecurityIpGroup : Tea.TeaModel {
        public var instanceId: String?

        public var securityIpGroupName: String?

        public var securityIps: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.securityIpGroupName != nil {
                map["SecurityIpGroupName"] = self.securityIpGroupName!
            }
            if self.securityIps != nil {
                map["SecurityIps"] = self.securityIps!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("SecurityIpGroupName") {
                self.securityIpGroupName = dict["SecurityIpGroupName"] as! String
            }
            if dict.keys.contains("SecurityIps") {
                self.securityIps = dict["SecurityIps"] as! String
            }
        }
    }
    public var requestId: String?

    public var securityIpGroup: CreateSecurityIpGroupResponseBody.SecurityIpGroup?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.securityIpGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityIpGroup != nil {
            map["SecurityIpGroup"] = self.securityIpGroup?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityIpGroup") {
            var model = CreateSecurityIpGroupResponseBody.SecurityIpGroup()
            model.fromMap(dict["SecurityIpGroup"] as! [String: Any])
            self.securityIpGroup = model
        }
    }
}

public class CreateSecurityIpGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSecurityIpGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSecurityIpGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTagRequest : Tea.TeaModel {
    public var clientToken: String?

    public var key: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.key != nil {
            map["Key"] = self.key!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Key") {
            self.key = dict["Key"] as! String
        }
    }
}

public class CreateTagResponseBody : Tea.TeaModel {
    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateTagResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTagValueRequest : Tea.TeaModel {
    public var clientToken: String?

    public var key: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Key") {
            self.key = dict["Key"] as! String
        }
        if dict.keys.contains("Value") {
            self.value = dict["Value"] as! String
        }
    }
}

public class CreateTagValueResponseBody : Tea.TeaModel {
    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateTagValueResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTagValueResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateTagValueResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTenantRequest : Tea.TeaModel {
    public var charset: String?

    public var cpu: Int32?

    public var createParams: [String: String]?

    public var description_: String?

    public var instanceId: String?

    public var logDisk: Int64?

    public var memory: Int32?

    public var primaryZone: String?

    public var readOnlyZoneList: String?

    public var tenantMode: String?

    public var tenantName: String?

    public var timeZone: String?

    public var unitNum: Int32?

    public var userVSwitchId: String?

    public var userVpcId: String?

    public var userVpcOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.charset != nil {
            map["Charset"] = self.charset!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.createParams != nil {
            map["CreateParams"] = self.createParams!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.logDisk != nil {
            map["LogDisk"] = self.logDisk!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.primaryZone != nil {
            map["PrimaryZone"] = self.primaryZone!
        }
        if self.readOnlyZoneList != nil {
            map["ReadOnlyZoneList"] = self.readOnlyZoneList!
        }
        if self.tenantMode != nil {
            map["TenantMode"] = self.tenantMode!
        }
        if self.tenantName != nil {
            map["TenantName"] = self.tenantName!
        }
        if self.timeZone != nil {
            map["TimeZone"] = self.timeZone!
        }
        if self.unitNum != nil {
            map["UnitNum"] = self.unitNum!
        }
        if self.userVSwitchId != nil {
            map["UserVSwitchId"] = self.userVSwitchId!
        }
        if self.userVpcId != nil {
            map["UserVpcId"] = self.userVpcId!
        }
        if self.userVpcOwnerId != nil {
            map["UserVpcOwnerId"] = self.userVpcOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Charset") {
            self.charset = dict["Charset"] as! String
        }
        if dict.keys.contains("Cpu") {
            self.cpu = dict["Cpu"] as! Int32
        }
        if dict.keys.contains("CreateParams") {
            self.createParams = dict["CreateParams"] as! [String: String]
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("LogDisk") {
            self.logDisk = dict["LogDisk"] as! Int64
        }
        if dict.keys.contains("Memory") {
            self.memory = dict["Memory"] as! Int32
        }
        if dict.keys.contains("PrimaryZone") {
            self.primaryZone = dict["PrimaryZone"] as! String
        }
        if dict.keys.contains("ReadOnlyZoneList") {
            self.readOnlyZoneList = dict["ReadOnlyZoneList"] as! String
        }
        if dict.keys.contains("TenantMode") {
            self.tenantMode = dict["TenantMode"] as! String
        }
        if dict.keys.contains("TenantName") {
            self.tenantName = dict["TenantName"] as! String
        }
        if dict.keys.contains("TimeZone") {
            self.timeZone = dict["TimeZone"] as! String
        }
        if dict.keys.contains("UnitNum") {
            self.unitNum = dict["UnitNum"] as! Int32
        }
        if dict.keys.contains("UserVSwitchId") {
            self.userVSwitchId = dict["UserVSwitchId"] as! String
        }
        if dict.keys.contains("UserVpcId") {
            self.userVpcId = dict["UserVpcId"] as! String
        }
        if dict.keys.contains("UserVpcOwnerId") {
            self.userVpcOwnerId = dict["UserVpcOwnerId"] as! String
        }
    }
}

public class CreateTenantShrinkRequest : Tea.TeaModel {
    public var charset: String?

    public var cpu: Int32?

    public var createParamsShrink: String?

    public var description_: String?

    public var instanceId: String?

    public var logDisk: Int64?

    public var memory: Int32?

    public var primaryZone: String?

    public var readOnlyZoneList: String?

    public var tenantMode: String?

    public var tenantName: String?

    public var timeZone: String?

    public var unitNum: Int32?

    public var userVSwitchId: String?

    public var userVpcId: String?

    public var userVpcOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.charset != nil {
            map["Charset"] = self.charset!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.createParamsShrink != nil {
            map["CreateParams"] = self.createParamsShrink!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.logDisk != nil {
            map["LogDisk"] = self.logDisk!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.primaryZone != nil {
            map["PrimaryZone"] = self.primaryZone!
        }
        if self.readOnlyZoneList != nil {
            map["ReadOnlyZoneList"] = self.readOnlyZoneList!
        }
        if self.tenantMode != nil {
            map["TenantMode"] = self.tenantMode!
        }
        if self.tenantName != nil {
            map["TenantName"] = self.tenantName!
        }
        if self.timeZone != nil {
            map["TimeZone"] = self.timeZone!
        }
        if self.unitNum != nil {
            map["UnitNum"] = self.unitNum!
        }
        if self.userVSwitchId != nil {
            map["UserVSwitchId"] = self.userVSwitchId!
        }
        if self.userVpcId != nil {
            map["UserVpcId"] = self.userVpcId!
        }
        if self.userVpcOwnerId != nil {
            map["UserVpcOwnerId"] = self.userVpcOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Charset") {
            self.charset = dict["Charset"] as! String
        }
        if dict.keys.contains("Cpu") {
            self.cpu = dict["Cpu"] as! Int32
        }
        if dict.keys.contains("CreateParams") {
            self.createParamsShrink = dict["CreateParams"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("LogDisk") {
            self.logDisk = dict["LogDisk"] as! Int64
        }
        if dict.keys.contains("Memory") {
            self.memory = dict["Memory"] as! Int32
        }
        if dict.keys.contains("PrimaryZone") {
            self.primaryZone = dict["PrimaryZone"] as! String
        }
        if dict.keys.contains("ReadOnlyZoneList") {
            self.readOnlyZoneList = dict["ReadOnlyZoneList"] as! String
        }
        if dict.keys.contains("TenantMode") {
            self.tenantMode = dict["TenantMode"] as! String
        }
        if dict.keys.contains("TenantName") {
            self.tenantName = dict["TenantName"] as! String
        }
        if dict.keys.contains("TimeZone") {
            self.timeZone = dict["TimeZone"] as! String
        }
        if dict.keys.contains("UnitNum") {
            self.unitNum = dict["UnitNum"] as! Int32
        }
        if dict.keys.contains("UserVSwitchId") {
            self.userVSwitchId = dict["UserVSwitchId"] as! String
        }
        if dict.keys.contains("UserVpcId") {
            self.userVpcId = dict["UserVpcId"] as! String
        }
        if dict.keys.contains("UserVpcOwnerId") {
            self.userVpcOwnerId = dict["UserVpcOwnerId"] as! String
        }
    }
}

public class CreateTenantResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class CreateTenantResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTenantResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateTenantResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTenantReadOnlyConnectionRequest : Tea.TeaModel {
    public var instanceId: String?

    public var tenantId: String?

    public var vSwitchId: String?

    public var vpcId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateTenantReadOnlyConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateTenantReadOnlyConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTenantReadOnlyConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateTenantReadOnlyConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTenantSecurityIpGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var securityIpGroupName: String?

    public var securityIps: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.securityIpGroupName != nil {
            map["SecurityIpGroupName"] = self.securityIpGroupName!
        }
        if self.securityIps != nil {
            map["SecurityIps"] = self.securityIps!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SecurityIpGroupName") {
            self.securityIpGroupName = dict["SecurityIpGroupName"] as! String
        }
        if dict.keys.contains("SecurityIps") {
            self.securityIps = dict["SecurityIps"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class CreateTenantSecurityIpGroupResponseBody : Tea.TeaModel {
    public class SecurityIpGroup : Tea.TeaModel {
        public var instanceId: String?

        public var securityIpGroupName: String?

        public var securityIps: String?

        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.securityIpGroupName != nil {
                map["SecurityIpGroupName"] = self.securityIpGroupName!
            }
            if self.securityIps != nil {
                map["SecurityIps"] = self.securityIps!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("SecurityIpGroupName") {
                self.securityIpGroupName = dict["SecurityIpGroupName"] as! String
            }
            if dict.keys.contains("SecurityIps") {
                self.securityIps = dict["SecurityIps"] as! String
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! String
            }
        }
    }
    public var requestId: String?

    public var securityIpGroup: CreateTenantSecurityIpGroupResponseBody.SecurityIpGroup?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.securityIpGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityIpGroup != nil {
            map["SecurityIpGroup"] = self.securityIpGroup?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityIpGroup") {
            var model = CreateTenantSecurityIpGroupResponseBody.SecurityIpGroup()
            model.fromMap(dict["SecurityIpGroup"] as! [String: Any])
            self.securityIpGroup = model
        }
    }
}

public class CreateTenantSecurityIpGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTenantSecurityIpGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateTenantSecurityIpGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTenantUserRequest : Tea.TeaModel {
    public var description_: String?

    public var encryptionType: String?

    public var instanceId: String?

    public var roles: String?

    public var tenantId: String?

    public var userName: String?

    public var userPassword: String?

    public var userType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.encryptionType != nil {
            map["EncryptionType"] = self.encryptionType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.roles != nil {
            map["Roles"] = self.roles!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        if self.userPassword != nil {
            map["UserPassword"] = self.userPassword!
        }
        if self.userType != nil {
            map["UserType"] = self.userType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EncryptionType") {
            self.encryptionType = dict["EncryptionType"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Roles") {
            self.roles = dict["Roles"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
        if dict.keys.contains("UserPassword") {
            self.userPassword = dict["UserPassword"] as! String
        }
        if dict.keys.contains("UserType") {
            self.userType = dict["UserType"] as! String
        }
    }
}

public class CreateTenantUserResponseBody : Tea.TeaModel {
    public class TenantUser : Tea.TeaModel {
        public class Roles : Tea.TeaModel {
            public var database: String?

            public var role: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.database != nil {
                    map["Database"] = self.database!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Database") {
                    self.database = dict["Database"] as! String
                }
                if dict.keys.contains("Role") {
                    self.role = dict["Role"] as! String
                }
            }
        }
        public var roles: [CreateTenantUserResponseBody.TenantUser.Roles]?

        public var userName: String?

        public var userStatus: String?

        public var userType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.roles != nil {
                var tmp : [Any] = []
                for k in self.roles! {
                    tmp.append(k.toMap())
                }
                map["Roles"] = tmp
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            if self.userStatus != nil {
                map["UserStatus"] = self.userStatus!
            }
            if self.userType != nil {
                map["UserType"] = self.userType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Roles") {
                var tmp : [CreateTenantUserResponseBody.TenantUser.Roles] = []
                for v in dict["Roles"] as! [Any] {
                    var model = CreateTenantUserResponseBody.TenantUser.Roles()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.roles = tmp
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
            if dict.keys.contains("UserStatus") {
                self.userStatus = dict["UserStatus"] as! String
            }
            if dict.keys.contains("UserType") {
                self.userType = dict["UserType"] as! String
            }
        }
    }
    public var requestId: String?

    public var tenantUser: CreateTenantUserResponseBody.TenantUser?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantUser?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tenantUser != nil {
            map["TenantUser"] = self.tenantUser?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TenantUser") {
            var model = CreateTenantUserResponseBody.TenantUser()
            model.fromMap(dict["TenantUser"] as! [String: Any])
            self.tenantUser = model
        }
    }
}

public class CreateTenantUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTenantUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateTenantUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDataSourceRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class DeleteDataSourceResponseBody : Tea.TeaModel {
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: Any?

    public var errorDetail: DeleteDataSourceResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("ErrorDetail") {
            var model = DeleteDataSourceResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DeleteDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDataSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDatabasesRequest : Tea.TeaModel {
    public var databaseNames: String?

    public var instanceId: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databaseNames != nil {
            map["DatabaseNames"] = self.databaseNames!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatabaseNames") {
            self.databaseNames = dict["DatabaseNames"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DeleteDatabasesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDatabasesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDatabasesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDatabasesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteInstancesRequest : Tea.TeaModel {
    public var backupRetainMode: String?

    public var dryRun: Bool?

    public var instanceIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupRetainMode != nil {
            map["BackupRetainMode"] = self.backupRetainMode!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackupRetainMode") {
            self.backupRetainMode = dict["BackupRetainMode"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
    }
}

public class DeleteInstancesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var dryRunResult: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dryRunResult != nil {
                map["DryRunResult"] = self.dryRunResult!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DryRunResult") {
                self.dryRunResult = dict["DryRunResult"] as! Bool
            }
        }
    }
    public var data: DeleteInstancesResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DeleteInstancesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteProjectRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class DeleteProjectResponseBody : Tea.TeaModel {
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: Any?

    public var errorDetail: DeleteProjectResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("ErrorDetail") {
            var model = DeleteProjectResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DeleteProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSecurityIpGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var securityIpGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.securityIpGroupName != nil {
            map["SecurityIpGroupName"] = self.securityIpGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SecurityIpGroupName") {
            self.securityIpGroupName = dict["SecurityIpGroupName"] as! String
        }
    }
}

public class DeleteSecurityIpGroupResponseBody : Tea.TeaModel {
    public class SecurityIpGroup : Tea.TeaModel {
        public var instanceId: String?

        public var securityIpGroupName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.securityIpGroupName != nil {
                map["SecurityIpGroupName"] = self.securityIpGroupName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("SecurityIpGroupName") {
                self.securityIpGroupName = dict["SecurityIpGroupName"] as! String
            }
        }
    }
    public var requestId: String?

    public var securityIpGroup: DeleteSecurityIpGroupResponseBody.SecurityIpGroup?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.securityIpGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityIpGroup != nil {
            map["SecurityIpGroup"] = self.securityIpGroup?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityIpGroup") {
            var model = DeleteSecurityIpGroupResponseBody.SecurityIpGroup()
            model.fromMap(dict["SecurityIpGroup"] as! [String: Any])
            self.securityIpGroup = model
        }
    }
}

public class DeleteSecurityIpGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSecurityIpGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSecurityIpGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTagRequest : Tea.TeaModel {
    public var key: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.key != nil {
            map["Key"] = self.key!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Key") {
            self.key = dict["Key"] as! String
        }
    }
}

public class DeleteTagResponseBody : Tea.TeaModel {
    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTagResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTagValueRequest : Tea.TeaModel {
    public var key: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Key") {
            self.key = dict["Key"] as! String
        }
        if dict.keys.contains("Value") {
            self.value = dict["Value"] as! String
        }
    }
}

public class DeleteTagValueResponseBody : Tea.TeaModel {
    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteTagValueResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTagValueResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTagValueResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTenantSecurityIpGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var securityIpGroupName: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.securityIpGroupName != nil {
            map["SecurityIpGroupName"] = self.securityIpGroupName!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SecurityIpGroupName") {
            self.securityIpGroupName = dict["SecurityIpGroupName"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DeleteTenantSecurityIpGroupResponseBody : Tea.TeaModel {
    public class SecurityIpGroup : Tea.TeaModel {
        public var instanceId: String?

        public var securityIpGroupName: String?

        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.securityIpGroupName != nil {
                map["SecurityIpGroupName"] = self.securityIpGroupName!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("SecurityIpGroupName") {
                self.securityIpGroupName = dict["SecurityIpGroupName"] as! String
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! String
            }
        }
    }
    public var requestId: String?

    public var securityIpGroup: DeleteTenantSecurityIpGroupResponseBody.SecurityIpGroup?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.securityIpGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityIpGroup != nil {
            map["SecurityIpGroup"] = self.securityIpGroup?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityIpGroup") {
            var model = DeleteTenantSecurityIpGroupResponseBody.SecurityIpGroup()
            model.fromMap(dict["SecurityIpGroup"] as! [String: Any])
            self.securityIpGroup = model
        }
    }
}

public class DeleteTenantSecurityIpGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTenantSecurityIpGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTenantSecurityIpGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTenantUsersRequest : Tea.TeaModel {
    public var instanceId: String?

    public var tenantId: String?

    public var users: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.users != nil {
            map["Users"] = self.users!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("Users") {
            self.users = dict["Users"] as! String
        }
    }
}

public class DeleteTenantUsersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteTenantUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTenantUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTenantUsersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTenantsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var tenantIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.tenantIds != nil {
            map["TenantIds"] = self.tenantIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TenantIds") {
            self.tenantIds = dict["TenantIds"] as! String
        }
    }
}

public class DeleteTenantsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var tenantIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tenantIds != nil {
            map["TenantIds"] = self.tenantIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TenantIds") {
            self.tenantIds = dict["TenantIds"] as! [String]
        }
    }
}

public class DeleteTenantsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTenantsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTenantsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAnomalySQLListRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var dbName: String?

    public var endTime: String?

    public var filterCondition: [String: Any]?

    public var instanceId: String?

    public var nodeIp: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var SQLId: String?

    public var searchKeyWord: String?

    public var searchParameter: String?

    public var searchRule: String?

    public var searchValue: String?

    public var sortColumn: String?

    public var sortOrder: String?

    public var startTime: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.filterCondition != nil {
            map["FilterCondition"] = self.filterCondition!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeIp != nil {
            map["NodeIp"] = self.nodeIp!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.SQLId != nil {
            map["SQLId"] = self.SQLId!
        }
        if self.searchKeyWord != nil {
            map["SearchKeyWord"] = self.searchKeyWord!
        }
        if self.searchParameter != nil {
            map["SearchParameter"] = self.searchParameter!
        }
        if self.searchRule != nil {
            map["SearchRule"] = self.searchRule!
        }
        if self.searchValue != nil {
            map["SearchValue"] = self.searchValue!
        }
        if self.sortColumn != nil {
            map["SortColumn"] = self.sortColumn!
        }
        if self.sortOrder != nil {
            map["SortOrder"] = self.sortOrder!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("FilterCondition") {
            self.filterCondition = dict["FilterCondition"] as! [String: Any]
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeIp") {
            self.nodeIp = dict["NodeIp"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SQLId") {
            self.SQLId = dict["SQLId"] as! String
        }
        if dict.keys.contains("SearchKeyWord") {
            self.searchKeyWord = dict["SearchKeyWord"] as! String
        }
        if dict.keys.contains("SearchParameter") {
            self.searchParameter = dict["SearchParameter"] as! String
        }
        if dict.keys.contains("SearchRule") {
            self.searchRule = dict["SearchRule"] as! String
        }
        if dict.keys.contains("SearchValue") {
            self.searchValue = dict["SearchValue"] as! String
        }
        if dict.keys.contains("SortColumn") {
            self.sortColumn = dict["SortColumn"] as! String
        }
        if dict.keys.contains("SortOrder") {
            self.sortOrder = dict["SortOrder"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DescribeAnomalySQLListShrinkRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var dbName: String?

    public var endTime: String?

    public var filterConditionShrink: String?

    public var instanceId: String?

    public var nodeIp: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var SQLId: String?

    public var searchKeyWord: String?

    public var searchParameter: String?

    public var searchRule: String?

    public var searchValue: String?

    public var sortColumn: String?

    public var sortOrder: String?

    public var startTime: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.filterConditionShrink != nil {
            map["FilterCondition"] = self.filterConditionShrink!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeIp != nil {
            map["NodeIp"] = self.nodeIp!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.SQLId != nil {
            map["SQLId"] = self.SQLId!
        }
        if self.searchKeyWord != nil {
            map["SearchKeyWord"] = self.searchKeyWord!
        }
        if self.searchParameter != nil {
            map["SearchParameter"] = self.searchParameter!
        }
        if self.searchRule != nil {
            map["SearchRule"] = self.searchRule!
        }
        if self.searchValue != nil {
            map["SearchValue"] = self.searchValue!
        }
        if self.sortColumn != nil {
            map["SortColumn"] = self.sortColumn!
        }
        if self.sortOrder != nil {
            map["SortOrder"] = self.sortOrder!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("FilterCondition") {
            self.filterConditionShrink = dict["FilterCondition"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeIp") {
            self.nodeIp = dict["NodeIp"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SQLId") {
            self.SQLId = dict["SQLId"] as! String
        }
        if dict.keys.contains("SearchKeyWord") {
            self.searchKeyWord = dict["SearchKeyWord"] as! String
        }
        if dict.keys.contains("SearchParameter") {
            self.searchParameter = dict["SearchParameter"] as! String
        }
        if dict.keys.contains("SearchRule") {
            self.searchRule = dict["SearchRule"] as! String
        }
        if dict.keys.contains("SearchValue") {
            self.searchValue = dict["SearchValue"] as! String
        }
        if dict.keys.contains("SortColumn") {
            self.sortColumn = dict["SortColumn"] as! String
        }
        if dict.keys.contains("SortOrder") {
            self.sortOrder = dict["SortOrder"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DescribeAnomalySQLListResponseBody : Tea.TeaModel {
    public class AnomalySQLList : Tea.TeaModel {
        public var cpuTime: Double?

        public var dbName: String?

        public var diagnosis: String?

        public var diagnosisRule: String?

        public var executions: Int64?

        public var key: Int64?

        public var requestTime: Double?

        public var requestTimeUTCString: String?

        public var SQLId: String?

        public var SQLText: String?

        public var suggestion: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cpuTime != nil {
                map["CpuTime"] = self.cpuTime!
            }
            if self.dbName != nil {
                map["DbName"] = self.dbName!
            }
            if self.diagnosis != nil {
                map["Diagnosis"] = self.diagnosis!
            }
            if self.diagnosisRule != nil {
                map["DiagnosisRule"] = self.diagnosisRule!
            }
            if self.executions != nil {
                map["Executions"] = self.executions!
            }
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.requestTime != nil {
                map["RequestTime"] = self.requestTime!
            }
            if self.requestTimeUTCString != nil {
                map["RequestTimeUTCString"] = self.requestTimeUTCString!
            }
            if self.SQLId != nil {
                map["SQLId"] = self.SQLId!
            }
            if self.SQLText != nil {
                map["SQLText"] = self.SQLText!
            }
            if self.suggestion != nil {
                map["Suggestion"] = self.suggestion!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CpuTime") {
                self.cpuTime = dict["CpuTime"] as! Double
            }
            if dict.keys.contains("DbName") {
                self.dbName = dict["DbName"] as! String
            }
            if dict.keys.contains("Diagnosis") {
                self.diagnosis = dict["Diagnosis"] as! String
            }
            if dict.keys.contains("DiagnosisRule") {
                self.diagnosisRule = dict["DiagnosisRule"] as! String
            }
            if dict.keys.contains("Executions") {
                self.executions = dict["Executions"] as! Int64
            }
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! Int64
            }
            if dict.keys.contains("RequestTime") {
                self.requestTime = dict["RequestTime"] as! Double
            }
            if dict.keys.contains("RequestTimeUTCString") {
                self.requestTimeUTCString = dict["RequestTimeUTCString"] as! String
            }
            if dict.keys.contains("SQLId") {
                self.SQLId = dict["SQLId"] as! String
            }
            if dict.keys.contains("SQLText") {
                self.SQLText = dict["SQLText"] as! String
            }
            if dict.keys.contains("Suggestion") {
                self.suggestion = dict["Suggestion"] as! String
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public var anomalySQLList: [DescribeAnomalySQLListResponseBody.AnomalySQLList]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.anomalySQLList != nil {
            var tmp : [Any] = []
            for k in self.anomalySQLList! {
                tmp.append(k.toMap())
            }
            map["AnomalySQLList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AnomalySQLList") {
            var tmp : [DescribeAnomalySQLListResponseBody.AnomalySQLList] = []
            for v in dict["AnomalySQLList"] as! [Any] {
                var model = DescribeAnomalySQLListResponseBody.AnomalySQLList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.anomalySQLList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeAnomalySQLListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAnomalySQLListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAnomalySQLListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAvailableCpuResourceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var modifyType: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.modifyType != nil {
            map["ModifyType"] = self.modifyType!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ModifyType") {
            self.modifyType = dict["ModifyType"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DescribeAvailableCpuResourceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var comment: String?

        public var maxCpu: Int64?

        public var minCpu: Int64?

        public var reviewCode: String?

        public var unitNum: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.maxCpu != nil {
                map["MaxCpu"] = self.maxCpu!
            }
            if self.minCpu != nil {
                map["MinCpu"] = self.minCpu!
            }
            if self.reviewCode != nil {
                map["ReviewCode"] = self.reviewCode!
            }
            if self.unitNum != nil {
                map["UnitNum"] = self.unitNum!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Comment") {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("MaxCpu") {
                self.maxCpu = dict["MaxCpu"] as! Int64
            }
            if dict.keys.contains("MinCpu") {
                self.minCpu = dict["MinCpu"] as! Int64
            }
            if dict.keys.contains("ReviewCode") {
                self.reviewCode = dict["ReviewCode"] as! String
            }
            if dict.keys.contains("UnitNum") {
                self.unitNum = dict["UnitNum"] as! Int64
            }
        }
    }
    public var data: [DescribeAvailableCpuResourceResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [DescribeAvailableCpuResourceResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeAvailableCpuResourceResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAvailableCpuResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAvailableCpuResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAvailableCpuResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAvailableMemResourceRequest : Tea.TeaModel {
    public var cpuNum: Int64?

    public var instanceId: String?

    public var tenantId: String?

    public var unitNum: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cpuNum != nil {
            map["CpuNum"] = self.cpuNum!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.unitNum != nil {
            map["UnitNum"] = self.unitNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CpuNum") {
            self.cpuNum = dict["CpuNum"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("UnitNum") {
            self.unitNum = dict["UnitNum"] as! Int64
        }
    }
}

public class DescribeAvailableMemResourceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var maxMem: Int64?

        public var minMem: Int64?

        public var safeMem: String?

        public var usedMem: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.maxMem != nil {
                map["MaxMem"] = self.maxMem!
            }
            if self.minMem != nil {
                map["MinMem"] = self.minMem!
            }
            if self.safeMem != nil {
                map["SafeMem"] = self.safeMem!
            }
            if self.usedMem != nil {
                map["UsedMem"] = self.usedMem!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MaxMem") {
                self.maxMem = dict["MaxMem"] as! Int64
            }
            if dict.keys.contains("MinMem") {
                self.minMem = dict["MinMem"] as! Int64
            }
            if dict.keys.contains("SafeMem") {
                self.safeMem = dict["SafeMem"] as! String
            }
            if dict.keys.contains("UsedMem") {
                self.usedMem = dict["UsedMem"] as! Int64
            }
        }
    }
    public var data: DescribeAvailableMemResourceResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DescribeAvailableMemResourceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAvailableMemResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAvailableMemResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAvailableMemResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAvailableSpecRequest : Tea.TeaModel {
    public var instanceId: String?

    public var spec: String?

    public var upgradeType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.upgradeType != nil {
            map["UpgradeType"] = self.upgradeType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
        if dict.keys.contains("UpgradeType") {
            self.upgradeType = dict["UpgradeType"] as! String
        }
    }
}

public class DescribeAvailableSpecResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AvailableSpecifications : Tea.TeaModel {
            public class DiskSizeRange : Tea.TeaModel {
                public var max: Int64?

                public var min: Int64?

                public var step: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.max != nil {
                        map["Max"] = self.max!
                    }
                    if self.min != nil {
                        map["Min"] = self.min!
                    }
                    if self.step != nil {
                        map["Step"] = self.step!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Max") {
                        self.max = dict["Max"] as! Int64
                    }
                    if dict.keys.contains("Min") {
                        self.min = dict["Min"] as! Int64
                    }
                    if dict.keys.contains("Step") {
                        self.step = dict["Step"] as! Int64
                    }
                }
            }
            public class LogDiskSizeRange : Tea.TeaModel {
                public var max: Int64?

                public var min: Int64?

                public var step: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.max != nil {
                        map["Max"] = self.max!
                    }
                    if self.min != nil {
                        map["Min"] = self.min!
                    }
                    if self.step != nil {
                        map["Step"] = self.step!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Max") {
                        self.max = dict["Max"] as! Int64
                    }
                    if dict.keys.contains("Min") {
                        self.min = dict["Min"] as! Int64
                    }
                    if dict.keys.contains("Step") {
                        self.step = dict["Step"] as! Int64
                    }
                }
            }
            public var diskSizeRange: DescribeAvailableSpecResponseBody.Data.AvailableSpecifications.DiskSizeRange?

            public var diskTypes: [String]?

            public var instanceClass: String?

            public var logDiskSizeRange: DescribeAvailableSpecResponseBody.Data.AvailableSpecifications.LogDiskSizeRange?

            public var nodeNum: [Int32]?

            public var spec: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.diskSizeRange?.validate()
                try self.logDiskSizeRange?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskSizeRange != nil {
                    map["DiskSizeRange"] = self.diskSizeRange?.toMap()
                }
                if self.diskTypes != nil {
                    map["DiskTypes"] = self.diskTypes!
                }
                if self.instanceClass != nil {
                    map["InstanceClass"] = self.instanceClass!
                }
                if self.logDiskSizeRange != nil {
                    map["LogDiskSizeRange"] = self.logDiskSizeRange?.toMap()
                }
                if self.nodeNum != nil {
                    map["NodeNum"] = self.nodeNum!
                }
                if self.spec != nil {
                    map["Spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DiskSizeRange") {
                    var model = DescribeAvailableSpecResponseBody.Data.AvailableSpecifications.DiskSizeRange()
                    model.fromMap(dict["DiskSizeRange"] as! [String: Any])
                    self.diskSizeRange = model
                }
                if dict.keys.contains("DiskTypes") {
                    self.diskTypes = dict["DiskTypes"] as! [String]
                }
                if dict.keys.contains("InstanceClass") {
                    self.instanceClass = dict["InstanceClass"] as! String
                }
                if dict.keys.contains("LogDiskSizeRange") {
                    var model = DescribeAvailableSpecResponseBody.Data.AvailableSpecifications.LogDiskSizeRange()
                    model.fromMap(dict["LogDiskSizeRange"] as! [String: Any])
                    self.logDiskSizeRange = model
                }
                if dict.keys.contains("NodeNum") {
                    self.nodeNum = dict["NodeNum"] as! [Int32]
                }
                if dict.keys.contains("Spec") {
                    self.spec = dict["Spec"] as! String
                }
            }
        }
        public var availableSpecifications: [DescribeAvailableSpecResponseBody.Data.AvailableSpecifications]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.availableSpecifications != nil {
                var tmp : [Any] = []
                for k in self.availableSpecifications! {
                    tmp.append(k.toMap())
                }
                map["AvailableSpecifications"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvailableSpecifications") {
                var tmp : [DescribeAvailableSpecResponseBody.Data.AvailableSpecifications] = []
                for v in dict["AvailableSpecifications"] as! [Any] {
                    var model = DescribeAvailableSpecResponseBody.Data.AvailableSpecifications()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.availableSpecifications = tmp
            }
        }
    }
    public var data: DescribeAvailableSpecResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DescribeAvailableSpecResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAvailableSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAvailableSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAvailableSpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAvailableZoneRequest : Tea.TeaModel {
    public var cpuArch: String?

    public var deployType: String?

    public var instanceType: String?

    public var obVersion: String?

    public var series: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cpuArch != nil {
            map["CpuArch"] = self.cpuArch!
        }
        if self.deployType != nil {
            map["DeployType"] = self.deployType!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.obVersion != nil {
            map["ObVersion"] = self.obVersion!
        }
        if self.series != nil {
            map["Series"] = self.series!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CpuArch") {
            self.cpuArch = dict["CpuArch"] as! String
        }
        if dict.keys.contains("DeployType") {
            self.deployType = dict["DeployType"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("ObVersion") {
            self.obVersion = dict["ObVersion"] as! String
        }
        if dict.keys.contains("Series") {
            self.series = dict["Series"] as! String
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
    }
}

public class DescribeAvailableZoneResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AvailableZones : Tea.TeaModel {
            public class SupportSpecifications : Tea.TeaModel {
                public class DiskSizeRange : Tea.TeaModel {
                    public var max: Int64?

                    public var min: Int64?

                    public var step: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.max != nil {
                            map["Max"] = self.max!
                        }
                        if self.min != nil {
                            map["Min"] = self.min!
                        }
                        if self.step != nil {
                            map["Step"] = self.step!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Max") {
                            self.max = dict["Max"] as! Int64
                        }
                        if dict.keys.contains("Min") {
                            self.min = dict["Min"] as! Int64
                        }
                        if dict.keys.contains("Step") {
                            self.step = dict["Step"] as! Int64
                        }
                    }
                }
                public class SupportEngineVersions : Tea.TeaModel {
                    public var obVersion: String?

                    public var supportIsolationOptimization: Bool?

                    public var supportReplicaModes: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.obVersion != nil {
                            map["ObVersion"] = self.obVersion!
                        }
                        if self.supportIsolationOptimization != nil {
                            map["SupportIsolationOptimization"] = self.supportIsolationOptimization!
                        }
                        if self.supportReplicaModes != nil {
                            map["SupportReplicaModes"] = self.supportReplicaModes!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ObVersion") {
                            self.obVersion = dict["ObVersion"] as! String
                        }
                        if dict.keys.contains("SupportIsolationOptimization") {
                            self.supportIsolationOptimization = dict["SupportIsolationOptimization"] as! Bool
                        }
                        if dict.keys.contains("SupportReplicaModes") {
                            self.supportReplicaModes = dict["SupportReplicaModes"] as! [String]
                        }
                    }
                }
                public var diskSizeRange: DescribeAvailableZoneResponseBody.Data.AvailableZones.SupportSpecifications.DiskSizeRange?

                public var diskTypes: [String]?

                public var instanceClass: String?

                public var spec: String?

                public var supportEngineVersions: [DescribeAvailableZoneResponseBody.Data.AvailableZones.SupportSpecifications.SupportEngineVersions]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.diskSizeRange?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.diskSizeRange != nil {
                        map["DiskSizeRange"] = self.diskSizeRange?.toMap()
                    }
                    if self.diskTypes != nil {
                        map["DiskTypes"] = self.diskTypes!
                    }
                    if self.instanceClass != nil {
                        map["InstanceClass"] = self.instanceClass!
                    }
                    if self.spec != nil {
                        map["Spec"] = self.spec!
                    }
                    if self.supportEngineVersions != nil {
                        var tmp : [Any] = []
                        for k in self.supportEngineVersions! {
                            tmp.append(k.toMap())
                        }
                        map["SupportEngineVersions"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DiskSizeRange") {
                        var model = DescribeAvailableZoneResponseBody.Data.AvailableZones.SupportSpecifications.DiskSizeRange()
                        model.fromMap(dict["DiskSizeRange"] as! [String: Any])
                        self.diskSizeRange = model
                    }
                    if dict.keys.contains("DiskTypes") {
                        self.diskTypes = dict["DiskTypes"] as! [String]
                    }
                    if dict.keys.contains("InstanceClass") {
                        self.instanceClass = dict["InstanceClass"] as! String
                    }
                    if dict.keys.contains("Spec") {
                        self.spec = dict["Spec"] as! String
                    }
                    if dict.keys.contains("SupportEngineVersions") {
                        var tmp : [DescribeAvailableZoneResponseBody.Data.AvailableZones.SupportSpecifications.SupportEngineVersions] = []
                        for v in dict["SupportEngineVersions"] as! [Any] {
                            var model = DescribeAvailableZoneResponseBody.Data.AvailableZones.SupportSpecifications.SupportEngineVersions()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.supportEngineVersions = tmp
                    }
                }
            }
            public var channel: String?

            public var cpuArch: String?

            public var deployType: String?

            public var instanceType: String?

            public var region: String?

            public var series: String?

            public var supportSpecifications: [DescribeAvailableZoneResponseBody.Data.AvailableZones.SupportSpecifications]?

            public var zones: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channel != nil {
                    map["Channel"] = self.channel!
                }
                if self.cpuArch != nil {
                    map["CpuArch"] = self.cpuArch!
                }
                if self.deployType != nil {
                    map["DeployType"] = self.deployType!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.series != nil {
                    map["Series"] = self.series!
                }
                if self.supportSpecifications != nil {
                    var tmp : [Any] = []
                    for k in self.supportSpecifications! {
                        tmp.append(k.toMap())
                    }
                    map["SupportSpecifications"] = tmp
                }
                if self.zones != nil {
                    map["Zones"] = self.zones!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Channel") {
                    self.channel = dict["Channel"] as! String
                }
                if dict.keys.contains("CpuArch") {
                    self.cpuArch = dict["CpuArch"] as! String
                }
                if dict.keys.contains("DeployType") {
                    self.deployType = dict["DeployType"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("Series") {
                    self.series = dict["Series"] as! String
                }
                if dict.keys.contains("SupportSpecifications") {
                    var tmp : [DescribeAvailableZoneResponseBody.Data.AvailableZones.SupportSpecifications] = []
                    for v in dict["SupportSpecifications"] as! [Any] {
                        var model = DescribeAvailableZoneResponseBody.Data.AvailableZones.SupportSpecifications()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.supportSpecifications = tmp
                }
                if dict.keys.contains("Zones") {
                    self.zones = dict["Zones"] as! String
                }
            }
        }
        public var availableZones: [DescribeAvailableZoneResponseBody.Data.AvailableZones]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.availableZones != nil {
                var tmp : [Any] = []
                for k in self.availableZones! {
                    tmp.append(k.toMap())
                }
                map["AvailableZones"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvailableZones") {
                var tmp : [DescribeAvailableZoneResponseBody.Data.AvailableZones] = []
                for v in dict["AvailableZones"] as! [Any] {
                    var model = DescribeAvailableZoneResponseBody.Data.AvailableZones()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.availableZones = tmp
            }
        }
    }
    public var data: DescribeAvailableZoneResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DescribeAvailableZoneResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAvailableZoneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAvailableZoneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAvailableZoneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBackupSetDownloadLinkRequest : Tea.TeaModel {
    public var downloadTaskId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.downloadTaskId != nil {
            map["DownloadTaskId"] = self.downloadTaskId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DownloadTaskId") {
            self.downloadTaskId = dict["DownloadTaskId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DescribeBackupSetDownloadLinkResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var backupRestorableTime: String?

        public var backupSetId: String?

        public var downloadTaskCreateTime: String?

        public var downloadTaskId: Int64?

        public var downloadTaskStatus: String?

        public var internalUrl: String?

        public var urlAliveTime: Int64?

        public var urlExpiredTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.backupRestorableTime != nil {
                map["BackupRestorableTime"] = self.backupRestorableTime!
            }
            if self.backupSetId != nil {
                map["BackupSetId"] = self.backupSetId!
            }
            if self.downloadTaskCreateTime != nil {
                map["DownloadTaskCreateTime"] = self.downloadTaskCreateTime!
            }
            if self.downloadTaskId != nil {
                map["DownloadTaskId"] = self.downloadTaskId!
            }
            if self.downloadTaskStatus != nil {
                map["DownloadTaskStatus"] = self.downloadTaskStatus!
            }
            if self.internalUrl != nil {
                map["InternalUrl"] = self.internalUrl!
            }
            if self.urlAliveTime != nil {
                map["UrlAliveTime"] = self.urlAliveTime!
            }
            if self.urlExpiredTime != nil {
                map["UrlExpiredTime"] = self.urlExpiredTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BackupRestorableTime") {
                self.backupRestorableTime = dict["BackupRestorableTime"] as! String
            }
            if dict.keys.contains("BackupSetId") {
                self.backupSetId = dict["BackupSetId"] as! String
            }
            if dict.keys.contains("DownloadTaskCreateTime") {
                self.downloadTaskCreateTime = dict["DownloadTaskCreateTime"] as! String
            }
            if dict.keys.contains("DownloadTaskId") {
                self.downloadTaskId = dict["DownloadTaskId"] as! Int64
            }
            if dict.keys.contains("DownloadTaskStatus") {
                self.downloadTaskStatus = dict["DownloadTaskStatus"] as! String
            }
            if dict.keys.contains("InternalUrl") {
                self.internalUrl = dict["InternalUrl"] as! String
            }
            if dict.keys.contains("UrlAliveTime") {
                self.urlAliveTime = dict["UrlAliveTime"] as! Int64
            }
            if dict.keys.contains("UrlExpiredTime") {
                self.urlExpiredTime = dict["UrlExpiredTime"] as! String
            }
        }
    }
    public var data: DescribeBackupSetDownloadLinkResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DescribeBackupSetDownloadLinkResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeBackupSetDownloadLinkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBackupSetDownloadLinkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeBackupSetDownloadLinkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCharsetRequest : Tea.TeaModel {
    public var instanceId: String?

    public var series: String?

    public var tenantMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.series != nil {
            map["Series"] = self.series!
        }
        if self.tenantMode != nil {
            map["TenantMode"] = self.tenantMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Series") {
            self.series = dict["Series"] as! String
        }
        if dict.keys.contains("TenantMode") {
            self.tenantMode = dict["TenantMode"] as! String
        }
    }
}

public class DescribeCharsetResponseBody : Tea.TeaModel {
    public class Charset : Tea.TeaModel {
        public var charset: String?

        public var collations: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.charset != nil {
                map["Charset"] = self.charset!
            }
            if self.collations != nil {
                map["Collations"] = self.collations!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Charset") {
                self.charset = dict["Charset"] as! String
            }
            if dict.keys.contains("Collations") {
                self.collations = dict["Collations"] as! [String]
            }
        }
    }
    public var charset: [DescribeCharsetResponseBody.Charset]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.charset != nil {
            var tmp : [Any] = []
            for k in self.charset! {
                tmp.append(k.toMap())
            }
            map["Charset"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Charset") {
            var tmp : [DescribeCharsetResponseBody.Charset] = []
            for v in dict["Charset"] as! [Any] {
                var model = DescribeCharsetResponseBody.Charset()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.charset = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeCharsetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCharsetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCharsetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDataBackupSetRequest : Tea.TeaModel {
    public var backupObjectType: String?

    public var endTime: String?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupObjectType != nil {
            map["BackupObjectType"] = self.backupObjectType!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackupObjectType") {
            self.backupObjectType = dict["BackupObjectType"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeDataBackupSetResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class BackupObjects : Tea.TeaModel {
            public class DatabaseTablesList : Tea.TeaModel {
                public var database: String?

                public var tables: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.database != nil {
                        map["Database"] = self.database!
                    }
                    if self.tables != nil {
                        map["Tables"] = self.tables!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Database") {
                        self.database = dict["Database"] as! String
                    }
                    if dict.keys.contains("Tables") {
                        self.tables = dict["Tables"] as! [String]
                    }
                }
            }
            public var clusterName: String?

            public var databaseTablesList: [DescribeDataBackupSetResponseBody.Data.BackupObjects.DatabaseTablesList]?

            public var tenantName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterName != nil {
                    map["ClusterName"] = self.clusterName!
                }
                if self.databaseTablesList != nil {
                    var tmp : [Any] = []
                    for k in self.databaseTablesList! {
                        tmp.append(k.toMap())
                    }
                    map["DatabaseTablesList"] = tmp
                }
                if self.tenantName != nil {
                    map["TenantName"] = self.tenantName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterName") {
                    self.clusterName = dict["ClusterName"] as! String
                }
                if dict.keys.contains("DatabaseTablesList") {
                    var tmp : [DescribeDataBackupSetResponseBody.Data.BackupObjects.DatabaseTablesList] = []
                    for v in dict["DatabaseTablesList"] as! [Any] {
                        var model = DescribeDataBackupSetResponseBody.Data.BackupObjects.DatabaseTablesList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.databaseTablesList = tmp
                }
                if dict.keys.contains("TenantName") {
                    self.tenantName = dict["TenantName"] as! String
                }
            }
        }
        public class BackupResults : Tea.TeaModel {
            public class TableBackupResults : Tea.TeaModel {
                public var database: String?

                public var message: String?

                public var status: String?

                public var table: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.database != nil {
                        map["Database"] = self.database!
                    }
                    if self.message != nil {
                        map["Message"] = self.message!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.table != nil {
                        map["Table"] = self.table!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Database") {
                        self.database = dict["Database"] as! String
                    }
                    if dict.keys.contains("Message") {
                        self.message = dict["Message"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                    if dict.keys.contains("Table") {
                        self.table = dict["Table"] as! String
                    }
                }
            }
            public var clusterName: String?

            public var tableBackupResults: [DescribeDataBackupSetResponseBody.Data.BackupResults.TableBackupResults]?

            public var tenantName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterName != nil {
                    map["ClusterName"] = self.clusterName!
                }
                if self.tableBackupResults != nil {
                    var tmp : [Any] = []
                    for k in self.tableBackupResults! {
                        tmp.append(k.toMap())
                    }
                    map["TableBackupResults"] = tmp
                }
                if self.tenantName != nil {
                    map["TenantName"] = self.tenantName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterName") {
                    self.clusterName = dict["ClusterName"] as! String
                }
                if dict.keys.contains("TableBackupResults") {
                    var tmp : [DescribeDataBackupSetResponseBody.Data.BackupResults.TableBackupResults] = []
                    for v in dict["TableBackupResults"] as! [Any] {
                        var model = DescribeDataBackupSetResponseBody.Data.BackupResults.TableBackupResults()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tableBackupResults = tmp
                }
                if dict.keys.contains("TenantName") {
                    self.tenantName = dict["TenantName"] as! String
                }
            }
        }
        public var backupObjectType: String?

        public var backupObjects: [DescribeDataBackupSetResponseBody.Data.BackupObjects]?

        public var backupResults: [DescribeDataBackupSetResponseBody.Data.BackupResults]?

        public var checkpoint: String?

        public var dataSize: Int32?

        public var dataVersion: Int32?

        public var downloadTaskId: Int64?

        public var downloadTaskStatus: String?

        public var endTime: String?

        public var method: String?

        public var policy: String?

        public var progress: String?

        public var setId: Int32?

        public var startTime: String?

        public var status: String?

        public var storageClass: String?

        public var type: String?

        public var validity: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.backupObjectType != nil {
                map["BackupObjectType"] = self.backupObjectType!
            }
            if self.backupObjects != nil {
                var tmp : [Any] = []
                for k in self.backupObjects! {
                    tmp.append(k.toMap())
                }
                map["BackupObjects"] = tmp
            }
            if self.backupResults != nil {
                var tmp : [Any] = []
                for k in self.backupResults! {
                    tmp.append(k.toMap())
                }
                map["BackupResults"] = tmp
            }
            if self.checkpoint != nil {
                map["Checkpoint"] = self.checkpoint!
            }
            if self.dataSize != nil {
                map["DataSize"] = self.dataSize!
            }
            if self.dataVersion != nil {
                map["DataVersion"] = self.dataVersion!
            }
            if self.downloadTaskId != nil {
                map["DownloadTaskId"] = self.downloadTaskId!
            }
            if self.downloadTaskStatus != nil {
                map["DownloadTaskStatus"] = self.downloadTaskStatus!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.method != nil {
                map["Method"] = self.method!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.setId != nil {
                map["SetId"] = self.setId!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageClass != nil {
                map["StorageClass"] = self.storageClass!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.validity != nil {
                map["Validity"] = self.validity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BackupObjectType") {
                self.backupObjectType = dict["BackupObjectType"] as! String
            }
            if dict.keys.contains("BackupObjects") {
                var tmp : [DescribeDataBackupSetResponseBody.Data.BackupObjects] = []
                for v in dict["BackupObjects"] as! [Any] {
                    var model = DescribeDataBackupSetResponseBody.Data.BackupObjects()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.backupObjects = tmp
            }
            if dict.keys.contains("BackupResults") {
                var tmp : [DescribeDataBackupSetResponseBody.Data.BackupResults] = []
                for v in dict["BackupResults"] as! [Any] {
                    var model = DescribeDataBackupSetResponseBody.Data.BackupResults()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.backupResults = tmp
            }
            if dict.keys.contains("Checkpoint") {
                self.checkpoint = dict["Checkpoint"] as! String
            }
            if dict.keys.contains("DataSize") {
                self.dataSize = dict["DataSize"] as! Int32
            }
            if dict.keys.contains("DataVersion") {
                self.dataVersion = dict["DataVersion"] as! Int32
            }
            if dict.keys.contains("DownloadTaskId") {
                self.downloadTaskId = dict["DownloadTaskId"] as! Int64
            }
            if dict.keys.contains("DownloadTaskStatus") {
                self.downloadTaskStatus = dict["DownloadTaskStatus"] as! String
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("Method") {
                self.method = dict["Method"] as! String
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("Progress") {
                self.progress = dict["Progress"] as! String
            }
            if dict.keys.contains("SetId") {
                self.setId = dict["SetId"] as! Int32
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageClass") {
                self.storageClass = dict["StorageClass"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Validity") {
                self.validity = dict["Validity"] as! String
            }
        }
    }
    public var data: [DescribeDataBackupSetResponseBody.Data]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [DescribeDataBackupSetResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeDataBackupSetResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeDataBackupSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDataBackupSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDataBackupSetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDatabasesRequest : Tea.TeaModel {
    public var databaseName: String?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchKey: String?

    public var tenantId: String?

    public var withTables: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.withTables != nil {
            map["WithTables"] = self.withTables!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatabaseName") {
            self.databaseName = dict["DatabaseName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchKey") {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WithTables") {
            self.withTables = dict["WithTables"] as! Bool
        }
    }
}

public class DescribeDatabasesResponseBody : Tea.TeaModel {
    public class Databases : Tea.TeaModel {
        public class Tables : Tea.TeaModel {
            public var tableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TableName") {
                    self.tableName = dict["TableName"] as! String
                }
            }
        }
        public class Users : Tea.TeaModel {
            public var privileges: String?

            public var role: String?

            public var userName: String?

            public var userType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.privileges != nil {
                    map["Privileges"] = self.privileges!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                if self.userType != nil {
                    map["UserType"] = self.userType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Privileges") {
                    self.privileges = dict["Privileges"] as! String
                }
                if dict.keys.contains("Role") {
                    self.role = dict["Role"] as! String
                }
                if dict.keys.contains("UserName") {
                    self.userName = dict["UserName"] as! String
                }
                if dict.keys.contains("UserType") {
                    self.userType = dict["UserType"] as! String
                }
            }
        }
        public var collation: String?

        public var createTime: String?

        public var dataSize: Double?

        public var databaseName: String?

        public var dbType: String?

        public var description_: String?

        public var encoding: String?

        public var instanceId: String?

        public var requiredSize: Double?

        public var status: String?

        public var tables: [DescribeDatabasesResponseBody.Databases.Tables]?

        public var tenantId: String?

        public var tenantName: String?

        public var users: [DescribeDatabasesResponseBody.Databases.Users]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.collation != nil {
                map["Collation"] = self.collation!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.dataSize != nil {
                map["DataSize"] = self.dataSize!
            }
            if self.databaseName != nil {
                map["DatabaseName"] = self.databaseName!
            }
            if self.dbType != nil {
                map["DbType"] = self.dbType!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.encoding != nil {
                map["Encoding"] = self.encoding!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.requiredSize != nil {
                map["RequiredSize"] = self.requiredSize!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tables != nil {
                var tmp : [Any] = []
                for k in self.tables! {
                    tmp.append(k.toMap())
                }
                map["Tables"] = tmp
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.tenantName != nil {
                map["TenantName"] = self.tenantName!
            }
            if self.users != nil {
                var tmp : [Any] = []
                for k in self.users! {
                    tmp.append(k.toMap())
                }
                map["Users"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Collation") {
                self.collation = dict["Collation"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DataSize") {
                self.dataSize = dict["DataSize"] as! Double
            }
            if dict.keys.contains("DatabaseName") {
                self.databaseName = dict["DatabaseName"] as! String
            }
            if dict.keys.contains("DbType") {
                self.dbType = dict["DbType"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Encoding") {
                self.encoding = dict["Encoding"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("RequiredSize") {
                self.requiredSize = dict["RequiredSize"] as! Double
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Tables") {
                var tmp : [DescribeDatabasesResponseBody.Databases.Tables] = []
                for v in dict["Tables"] as! [Any] {
                    var model = DescribeDatabasesResponseBody.Databases.Tables()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tables = tmp
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! String
            }
            if dict.keys.contains("TenantName") {
                self.tenantName = dict["TenantName"] as! String
            }
            if dict.keys.contains("Users") {
                var tmp : [DescribeDatabasesResponseBody.Databases.Users] = []
                for v in dict["Users"] as! [Any] {
                    var model = DescribeDatabasesResponseBody.Databases.Users()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.users = tmp
            }
        }
    }
    public var databases: [DescribeDatabasesResponseBody.Databases]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databases != nil {
            var tmp : [Any] = []
            for k in self.databases! {
                tmp.append(k.toMap())
            }
            map["Databases"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Databases") {
            var tmp : [DescribeDatabasesResponseBody.Databases] = []
            for v in dict["Databases"] as! [Any] {
                var model = DescribeDatabasesResponseBody.Databases()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.databases = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeDatabasesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDatabasesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDatabasesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var maxConnectionLimit: String?

    public var pageNumber: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maxConnectionLimit != nil {
            map["MaxConnectionLimit"] = self.maxConnectionLimit!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MaxConnectionLimit") {
            self.maxConnectionLimit = dict["MaxConnectionLimit"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
    }
}

public class DescribeInstanceResponseBody : Tea.TeaModel {
    public class Instance : Tea.TeaModel {
        public class DataDiskAutoScaleConfig : Tea.TeaModel {
            public var autoScale: Bool?

            public var maxDiskSize: Int64?

            public var scaleStepInMerge: Int64?

            public var scaleStepInNormal: Int64?

            public var upperMergeThreshold: Int64?

            public var upperScaleStep: String?

            public var upperScaleStrategy: String?

            public var upperThreshold: Int64?

            public var upperbound: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoScale != nil {
                    map["AutoScale"] = self.autoScale!
                }
                if self.maxDiskSize != nil {
                    map["MaxDiskSize"] = self.maxDiskSize!
                }
                if self.scaleStepInMerge != nil {
                    map["ScaleStepInMerge"] = self.scaleStepInMerge!
                }
                if self.scaleStepInNormal != nil {
                    map["ScaleStepInNormal"] = self.scaleStepInNormal!
                }
                if self.upperMergeThreshold != nil {
                    map["UpperMergeThreshold"] = self.upperMergeThreshold!
                }
                if self.upperScaleStep != nil {
                    map["UpperScaleStep"] = self.upperScaleStep!
                }
                if self.upperScaleStrategy != nil {
                    map["UpperScaleStrategy"] = self.upperScaleStrategy!
                }
                if self.upperThreshold != nil {
                    map["UpperThreshold"] = self.upperThreshold!
                }
                if self.upperbound != nil {
                    map["Upperbound"] = self.upperbound!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutoScale") {
                    self.autoScale = dict["AutoScale"] as! Bool
                }
                if dict.keys.contains("MaxDiskSize") {
                    self.maxDiskSize = dict["MaxDiskSize"] as! Int64
                }
                if dict.keys.contains("ScaleStepInMerge") {
                    self.scaleStepInMerge = dict["ScaleStepInMerge"] as! Int64
                }
                if dict.keys.contains("ScaleStepInNormal") {
                    self.scaleStepInNormal = dict["ScaleStepInNormal"] as! Int64
                }
                if dict.keys.contains("UpperMergeThreshold") {
                    self.upperMergeThreshold = dict["UpperMergeThreshold"] as! Int64
                }
                if dict.keys.contains("UpperScaleStep") {
                    self.upperScaleStep = dict["UpperScaleStep"] as! String
                }
                if dict.keys.contains("UpperScaleStrategy") {
                    self.upperScaleStrategy = dict["UpperScaleStrategy"] as! String
                }
                if dict.keys.contains("UpperThreshold") {
                    self.upperThreshold = dict["UpperThreshold"] as! Int64
                }
                if dict.keys.contains("Upperbound") {
                    self.upperbound = dict["Upperbound"] as! Int64
                }
            }
        }
        public class ReadOnlyResource : Tea.TeaModel {
            public class CapacityUnit : Tea.TeaModel {
                public var maxCapacityUnit: Int32?

                public var minCapacityUnit: Int32?

                public var usedCapacityUnit: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxCapacityUnit != nil {
                        map["MaxCapacityUnit"] = self.maxCapacityUnit!
                    }
                    if self.minCapacityUnit != nil {
                        map["MinCapacityUnit"] = self.minCapacityUnit!
                    }
                    if self.usedCapacityUnit != nil {
                        map["UsedCapacityUnit"] = self.usedCapacityUnit!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MaxCapacityUnit") {
                        self.maxCapacityUnit = dict["MaxCapacityUnit"] as! Int32
                    }
                    if dict.keys.contains("MinCapacityUnit") {
                        self.minCapacityUnit = dict["MinCapacityUnit"] as! Int32
                    }
                    if dict.keys.contains("UsedCapacityUnit") {
                        self.usedCapacityUnit = dict["UsedCapacityUnit"] as! String
                    }
                }
            }
            public class Cpu : Tea.TeaModel {
                public var originalTotalCpu: Int64?

                public var totalCpu: Int64?

                public var unitCpu: Int64?

                public var usedCpu: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.originalTotalCpu != nil {
                        map["OriginalTotalCpu"] = self.originalTotalCpu!
                    }
                    if self.totalCpu != nil {
                        map["TotalCpu"] = self.totalCpu!
                    }
                    if self.unitCpu != nil {
                        map["UnitCpu"] = self.unitCpu!
                    }
                    if self.usedCpu != nil {
                        map["UsedCpu"] = self.usedCpu!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OriginalTotalCpu") {
                        self.originalTotalCpu = dict["OriginalTotalCpu"] as! Int64
                    }
                    if dict.keys.contains("TotalCpu") {
                        self.totalCpu = dict["TotalCpu"] as! Int64
                    }
                    if dict.keys.contains("UnitCpu") {
                        self.unitCpu = dict["UnitCpu"] as! Int64
                    }
                    if dict.keys.contains("UsedCpu") {
                        self.usedCpu = dict["UsedCpu"] as! Int64
                    }
                }
            }
            public class DiskSize : Tea.TeaModel {
                public var dataUsedSize: Double?

                public var maxDiskSize: Double?

                public var maxDiskUsedObServer: [String]?

                public var maxDiskUsedPercent: Double?

                public var originalTotalDiskSize: Int64?

                public var totalDiskSize: Int64?

                public var unitDiskSize: Int64?

                public var usedDiskSize: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dataUsedSize != nil {
                        map["DataUsedSize"] = self.dataUsedSize!
                    }
                    if self.maxDiskSize != nil {
                        map["MaxDiskSize"] = self.maxDiskSize!
                    }
                    if self.maxDiskUsedObServer != nil {
                        map["MaxDiskUsedObServer"] = self.maxDiskUsedObServer!
                    }
                    if self.maxDiskUsedPercent != nil {
                        map["MaxDiskUsedPercent"] = self.maxDiskUsedPercent!
                    }
                    if self.originalTotalDiskSize != nil {
                        map["OriginalTotalDiskSize"] = self.originalTotalDiskSize!
                    }
                    if self.totalDiskSize != nil {
                        map["TotalDiskSize"] = self.totalDiskSize!
                    }
                    if self.unitDiskSize != nil {
                        map["UnitDiskSize"] = self.unitDiskSize!
                    }
                    if self.usedDiskSize != nil {
                        map["UsedDiskSize"] = self.usedDiskSize!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DataUsedSize") {
                        self.dataUsedSize = dict["DataUsedSize"] as! Double
                    }
                    if dict.keys.contains("MaxDiskSize") {
                        self.maxDiskSize = dict["MaxDiskSize"] as! Double
                    }
                    if dict.keys.contains("MaxDiskUsedObServer") {
                        self.maxDiskUsedObServer = dict["MaxDiskUsedObServer"] as! [String]
                    }
                    if dict.keys.contains("MaxDiskUsedPercent") {
                        self.maxDiskUsedPercent = dict["MaxDiskUsedPercent"] as! Double
                    }
                    if dict.keys.contains("OriginalTotalDiskSize") {
                        self.originalTotalDiskSize = dict["OriginalTotalDiskSize"] as! Int64
                    }
                    if dict.keys.contains("TotalDiskSize") {
                        self.totalDiskSize = dict["TotalDiskSize"] as! Int64
                    }
                    if dict.keys.contains("UnitDiskSize") {
                        self.unitDiskSize = dict["UnitDiskSize"] as! Int64
                    }
                    if dict.keys.contains("UsedDiskSize") {
                        self.usedDiskSize = dict["UsedDiskSize"] as! Int64
                    }
                }
            }
            public class LogDiskSize : Tea.TeaModel {
                public var logAssignedSize: String?

                public var maxLogAssignedObServer: [String]?

                public var maxLogAssignedPercent: String?

                public var totalDiskSize: Int64?

                public var unitDiskSize: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.logAssignedSize != nil {
                        map["LogAssignedSize"] = self.logAssignedSize!
                    }
                    if self.maxLogAssignedObServer != nil {
                        map["MaxLogAssignedObServer"] = self.maxLogAssignedObServer!
                    }
                    if self.maxLogAssignedPercent != nil {
                        map["MaxLogAssignedPercent"] = self.maxLogAssignedPercent!
                    }
                    if self.totalDiskSize != nil {
                        map["TotalDiskSize"] = self.totalDiskSize!
                    }
                    if self.unitDiskSize != nil {
                        map["UnitDiskSize"] = self.unitDiskSize!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LogAssignedSize") {
                        self.logAssignedSize = dict["LogAssignedSize"] as! String
                    }
                    if dict.keys.contains("MaxLogAssignedObServer") {
                        self.maxLogAssignedObServer = dict["MaxLogAssignedObServer"] as! [String]
                    }
                    if dict.keys.contains("MaxLogAssignedPercent") {
                        self.maxLogAssignedPercent = dict["MaxLogAssignedPercent"] as! String
                    }
                    if dict.keys.contains("TotalDiskSize") {
                        self.totalDiskSize = dict["TotalDiskSize"] as! Int64
                    }
                    if dict.keys.contains("UnitDiskSize") {
                        self.unitDiskSize = dict["UnitDiskSize"] as! Int64
                    }
                }
            }
            public class Memory : Tea.TeaModel {
                public var originalTotalMemory: Int64?

                public var totalMemory: Int64?

                public var unitMemory: Int64?

                public var usedMemory: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.originalTotalMemory != nil {
                        map["OriginalTotalMemory"] = self.originalTotalMemory!
                    }
                    if self.totalMemory != nil {
                        map["TotalMemory"] = self.totalMemory!
                    }
                    if self.unitMemory != nil {
                        map["UnitMemory"] = self.unitMemory!
                    }
                    if self.usedMemory != nil {
                        map["UsedMemory"] = self.usedMemory!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OriginalTotalMemory") {
                        self.originalTotalMemory = dict["OriginalTotalMemory"] as! Int64
                    }
                    if dict.keys.contains("TotalMemory") {
                        self.totalMemory = dict["TotalMemory"] as! Int64
                    }
                    if dict.keys.contains("UnitMemory") {
                        self.unitMemory = dict["UnitMemory"] as! Int64
                    }
                    if dict.keys.contains("UsedMemory") {
                        self.usedMemory = dict["UsedMemory"] as! Int64
                    }
                }
            }
            public var capacityUnit: DescribeInstanceResponseBody.Instance.ReadOnlyResource.CapacityUnit?

            public var cpu: DescribeInstanceResponseBody.Instance.ReadOnlyResource.Cpu?

            public var diskSize: DescribeInstanceResponseBody.Instance.ReadOnlyResource.DiskSize?

            public var logDiskSize: DescribeInstanceResponseBody.Instance.ReadOnlyResource.LogDiskSize?

            public var memory: DescribeInstanceResponseBody.Instance.ReadOnlyResource.Memory?

            public var unitCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.capacityUnit?.validate()
                try self.cpu?.validate()
                try self.diskSize?.validate()
                try self.logDiskSize?.validate()
                try self.memory?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.capacityUnit != nil {
                    map["CapacityUnit"] = self.capacityUnit?.toMap()
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu?.toMap()
                }
                if self.diskSize != nil {
                    map["DiskSize"] = self.diskSize?.toMap()
                }
                if self.logDiskSize != nil {
                    map["LogDiskSize"] = self.logDiskSize?.toMap()
                }
                if self.memory != nil {
                    map["Memory"] = self.memory?.toMap()
                }
                if self.unitCount != nil {
                    map["UnitCount"] = self.unitCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CapacityUnit") {
                    var model = DescribeInstanceResponseBody.Instance.ReadOnlyResource.CapacityUnit()
                    model.fromMap(dict["CapacityUnit"] as! [String: Any])
                    self.capacityUnit = model
                }
                if dict.keys.contains("Cpu") {
                    var model = DescribeInstanceResponseBody.Instance.ReadOnlyResource.Cpu()
                    model.fromMap(dict["Cpu"] as! [String: Any])
                    self.cpu = model
                }
                if dict.keys.contains("DiskSize") {
                    var model = DescribeInstanceResponseBody.Instance.ReadOnlyResource.DiskSize()
                    model.fromMap(dict["DiskSize"] as! [String: Any])
                    self.diskSize = model
                }
                if dict.keys.contains("LogDiskSize") {
                    var model = DescribeInstanceResponseBody.Instance.ReadOnlyResource.LogDiskSize()
                    model.fromMap(dict["LogDiskSize"] as! [String: Any])
                    self.logDiskSize = model
                }
                if dict.keys.contains("Memory") {
                    var model = DescribeInstanceResponseBody.Instance.ReadOnlyResource.Memory()
                    model.fromMap(dict["Memory"] as! [String: Any])
                    self.memory = model
                }
                if dict.keys.contains("UnitCount") {
                    self.unitCount = dict["UnitCount"] as! Int64
                }
            }
        }
        public class Resource : Tea.TeaModel {
            public class CapacityUnit : Tea.TeaModel {
                public var maxCapacityUnit: Int32?

                public var minCapacityUnit: Int32?

                public var usedCapacityUnit: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxCapacityUnit != nil {
                        map["MaxCapacityUnit"] = self.maxCapacityUnit!
                    }
                    if self.minCapacityUnit != nil {
                        map["MinCapacityUnit"] = self.minCapacityUnit!
                    }
                    if self.usedCapacityUnit != nil {
                        map["UsedCapacityUnit"] = self.usedCapacityUnit!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MaxCapacityUnit") {
                        self.maxCapacityUnit = dict["MaxCapacityUnit"] as! Int32
                    }
                    if dict.keys.contains("MinCapacityUnit") {
                        self.minCapacityUnit = dict["MinCapacityUnit"] as! Int32
                    }
                    if dict.keys.contains("UsedCapacityUnit") {
                        self.usedCapacityUnit = dict["UsedCapacityUnit"] as! String
                    }
                }
            }
            public class Cpu : Tea.TeaModel {
                public var originalTotalCpu: Int64?

                public var totalCpu: Int64?

                public var unitCpu: Int64?

                public var usedCpu: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.originalTotalCpu != nil {
                        map["OriginalTotalCpu"] = self.originalTotalCpu!
                    }
                    if self.totalCpu != nil {
                        map["TotalCpu"] = self.totalCpu!
                    }
                    if self.unitCpu != nil {
                        map["UnitCpu"] = self.unitCpu!
                    }
                    if self.usedCpu != nil {
                        map["UsedCpu"] = self.usedCpu!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OriginalTotalCpu") {
                        self.originalTotalCpu = dict["OriginalTotalCpu"] as! Int64
                    }
                    if dict.keys.contains("TotalCpu") {
                        self.totalCpu = dict["TotalCpu"] as! Int64
                    }
                    if dict.keys.contains("UnitCpu") {
                        self.unitCpu = dict["UnitCpu"] as! Int64
                    }
                    if dict.keys.contains("UsedCpu") {
                        self.usedCpu = dict["UsedCpu"] as! Int64
                    }
                }
            }
            public class DiskSize : Tea.TeaModel {
                public var dataUsedSize: Double?

                public var maxDiskSize: Double?

                public var maxDiskUsedObServer: [String]?

                public var maxDiskUsedPercent: Double?

                public var originalTotalDiskSize: Int64?

                public var totalDiskSize: Int64?

                public var unitDiskSize: Int64?

                public var usedDiskSize: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dataUsedSize != nil {
                        map["DataUsedSize"] = self.dataUsedSize!
                    }
                    if self.maxDiskSize != nil {
                        map["MaxDiskSize"] = self.maxDiskSize!
                    }
                    if self.maxDiskUsedObServer != nil {
                        map["MaxDiskUsedObServer"] = self.maxDiskUsedObServer!
                    }
                    if self.maxDiskUsedPercent != nil {
                        map["MaxDiskUsedPercent"] = self.maxDiskUsedPercent!
                    }
                    if self.originalTotalDiskSize != nil {
                        map["OriginalTotalDiskSize"] = self.originalTotalDiskSize!
                    }
                    if self.totalDiskSize != nil {
                        map["TotalDiskSize"] = self.totalDiskSize!
                    }
                    if self.unitDiskSize != nil {
                        map["UnitDiskSize"] = self.unitDiskSize!
                    }
                    if self.usedDiskSize != nil {
                        map["UsedDiskSize"] = self.usedDiskSize!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DataUsedSize") {
                        self.dataUsedSize = dict["DataUsedSize"] as! Double
                    }
                    if dict.keys.contains("MaxDiskSize") {
                        self.maxDiskSize = dict["MaxDiskSize"] as! Double
                    }
                    if dict.keys.contains("MaxDiskUsedObServer") {
                        self.maxDiskUsedObServer = dict["MaxDiskUsedObServer"] as! [String]
                    }
                    if dict.keys.contains("MaxDiskUsedPercent") {
                        self.maxDiskUsedPercent = dict["MaxDiskUsedPercent"] as! Double
                    }
                    if dict.keys.contains("OriginalTotalDiskSize") {
                        self.originalTotalDiskSize = dict["OriginalTotalDiskSize"] as! Int64
                    }
                    if dict.keys.contains("TotalDiskSize") {
                        self.totalDiskSize = dict["TotalDiskSize"] as! Int64
                    }
                    if dict.keys.contains("UnitDiskSize") {
                        self.unitDiskSize = dict["UnitDiskSize"] as! Int64
                    }
                    if dict.keys.contains("UsedDiskSize") {
                        self.usedDiskSize = dict["UsedDiskSize"] as! Int64
                    }
                }
            }
            public class LogDiskSize : Tea.TeaModel {
                public var logAssignedSize: String?

                public var maxLogAssignedObServer: [String]?

                public var maxLogAssignedPercent: String?

                public var originalTotalDiskSize: Int32?

                public var totalDiskSize: Int64?

                public var unitDiskSize: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.logAssignedSize != nil {
                        map["LogAssignedSize"] = self.logAssignedSize!
                    }
                    if self.maxLogAssignedObServer != nil {
                        map["MaxLogAssignedObServer"] = self.maxLogAssignedObServer!
                    }
                    if self.maxLogAssignedPercent != nil {
                        map["MaxLogAssignedPercent"] = self.maxLogAssignedPercent!
                    }
                    if self.originalTotalDiskSize != nil {
                        map["OriginalTotalDiskSize"] = self.originalTotalDiskSize!
                    }
                    if self.totalDiskSize != nil {
                        map["TotalDiskSize"] = self.totalDiskSize!
                    }
                    if self.unitDiskSize != nil {
                        map["UnitDiskSize"] = self.unitDiskSize!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LogAssignedSize") {
                        self.logAssignedSize = dict["LogAssignedSize"] as! String
                    }
                    if dict.keys.contains("MaxLogAssignedObServer") {
                        self.maxLogAssignedObServer = dict["MaxLogAssignedObServer"] as! [String]
                    }
                    if dict.keys.contains("MaxLogAssignedPercent") {
                        self.maxLogAssignedPercent = dict["MaxLogAssignedPercent"] as! String
                    }
                    if dict.keys.contains("OriginalTotalDiskSize") {
                        self.originalTotalDiskSize = dict["OriginalTotalDiskSize"] as! Int32
                    }
                    if dict.keys.contains("TotalDiskSize") {
                        self.totalDiskSize = dict["TotalDiskSize"] as! Int64
                    }
                    if dict.keys.contains("UnitDiskSize") {
                        self.unitDiskSize = dict["UnitDiskSize"] as! Int64
                    }
                }
            }
            public class Memory : Tea.TeaModel {
                public var originalTotalMemory: Int64?

                public var totalMemory: Int64?

                public var unitMemory: Int64?

                public var usedMemory: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.originalTotalMemory != nil {
                        map["OriginalTotalMemory"] = self.originalTotalMemory!
                    }
                    if self.totalMemory != nil {
                        map["TotalMemory"] = self.totalMemory!
                    }
                    if self.unitMemory != nil {
                        map["UnitMemory"] = self.unitMemory!
                    }
                    if self.usedMemory != nil {
                        map["UsedMemory"] = self.usedMemory!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OriginalTotalMemory") {
                        self.originalTotalMemory = dict["OriginalTotalMemory"] as! Int64
                    }
                    if dict.keys.contains("TotalMemory") {
                        self.totalMemory = dict["TotalMemory"] as! Int64
                    }
                    if dict.keys.contains("UnitMemory") {
                        self.unitMemory = dict["UnitMemory"] as! Int64
                    }
                    if dict.keys.contains("UsedMemory") {
                        self.usedMemory = dict["UsedMemory"] as! Int64
                    }
                }
            }
            public var capacityUnit: DescribeInstanceResponseBody.Instance.Resource.CapacityUnit?

            public var cpu: DescribeInstanceResponseBody.Instance.Resource.Cpu?

            public var diskSize: DescribeInstanceResponseBody.Instance.Resource.DiskSize?

            public var logDiskSize: DescribeInstanceResponseBody.Instance.Resource.LogDiskSize?

            public var memory: DescribeInstanceResponseBody.Instance.Resource.Memory?

            public var unitCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.capacityUnit?.validate()
                try self.cpu?.validate()
                try self.diskSize?.validate()
                try self.logDiskSize?.validate()
                try self.memory?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.capacityUnit != nil {
                    map["CapacityUnit"] = self.capacityUnit?.toMap()
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu?.toMap()
                }
                if self.diskSize != nil {
                    map["DiskSize"] = self.diskSize?.toMap()
                }
                if self.logDiskSize != nil {
                    map["LogDiskSize"] = self.logDiskSize?.toMap()
                }
                if self.memory != nil {
                    map["Memory"] = self.memory?.toMap()
                }
                if self.unitCount != nil {
                    map["UnitCount"] = self.unitCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CapacityUnit") {
                    var model = DescribeInstanceResponseBody.Instance.Resource.CapacityUnit()
                    model.fromMap(dict["CapacityUnit"] as! [String: Any])
                    self.capacityUnit = model
                }
                if dict.keys.contains("Cpu") {
                    var model = DescribeInstanceResponseBody.Instance.Resource.Cpu()
                    model.fromMap(dict["Cpu"] as! [String: Any])
                    self.cpu = model
                }
                if dict.keys.contains("DiskSize") {
                    var model = DescribeInstanceResponseBody.Instance.Resource.DiskSize()
                    model.fromMap(dict["DiskSize"] as! [String: Any])
                    self.diskSize = model
                }
                if dict.keys.contains("LogDiskSize") {
                    var model = DescribeInstanceResponseBody.Instance.Resource.LogDiskSize()
                    model.fromMap(dict["LogDiskSize"] as! [String: Any])
                    self.logDiskSize = model
                }
                if dict.keys.contains("Memory") {
                    var model = DescribeInstanceResponseBody.Instance.Resource.Memory()
                    model.fromMap(dict["Memory"] as! [String: Any])
                    self.memory = model
                }
                if dict.keys.contains("UnitCount") {
                    self.unitCount = dict["UnitCount"] as! Int64
                }
            }
        }
        public class TenantCreatable : Tea.TeaModel {
            public var disableCreateTenantReason: String?

            public var enableCreateTenant: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.disableCreateTenantReason != nil {
                    map["DisableCreateTenantReason"] = self.disableCreateTenantReason!
                }
                if self.enableCreateTenant != nil {
                    map["EnableCreateTenant"] = self.enableCreateTenant!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisableCreateTenantReason") {
                    self.disableCreateTenantReason = dict["DisableCreateTenantReason"] as! String
                }
                if dict.keys.contains("EnableCreateTenant") {
                    self.enableCreateTenant = dict["EnableCreateTenant"] as! Bool
                }
            }
        }
        public var allowModifyInternetAddressConnectionLimit: Bool?

        public var autoRenewal: Bool?

        public var autoUpgradeObVersion: Bool?

        public var availableZones: [String]?

        public var cpuArchitecture: String?

        public var createTime: String?

        public var dataDiskAutoScale: Bool?

        public var dataDiskAutoScaleConfig: DescribeInstanceResponseBody.Instance.DataDiskAutoScaleConfig?

        public var dataMergeTime: String?

        public var deployMode: String?

        public var deployType: String?

        public var diskType: String?

        public var enableIsolationOptimization: Bool?

        public var enableProxyService: Bool?

        public var enableReadOnlyReplica: Bool?

        public var enableReadOnlyReplicaManagement: Bool?

        public var enableUpgradeLogDisk: Bool?

        public var exclusiveUnitNumLimit: Int32?

        public var expireTime: String?

        public var inTempCapacityStatus: Bool?

        public var instanceClass: String?

        public var instanceId: String?

        public var instanceName: String?

        public var instanceRole: String?

        public var isLatestObVersion: Bool?

        public var isTrustEcs: Bool?

        public var isolationOptimization: Bool?

        public var maintainTime: String?

        public var nodeNum: String?

        public var obRpmVersion: String?

        public var payType: String?

        public var primaryInstance: String?

        public var primaryRegion: String?

        public var proxyClusterId: String?

        public var proxyServiceStatus: String?

        public var readOnlyResource: DescribeInstanceResponseBody.Instance.ReadOnlyResource?

        public var replicaMode: String?

        public var resource: DescribeInstanceResponseBody.Instance.Resource?

        public var series: String?

        public var sharedUnitNumLimit: Int32?

        public var specType: String?

        public var status: String?

        public var tenantCreatable: DescribeInstanceResponseBody.Instance.TenantCreatable?

        public var unitSpec: String?

        public var version: String?

        public var zones: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.dataDiskAutoScaleConfig?.validate()
            try self.readOnlyResource?.validate()
            try self.resource?.validate()
            try self.tenantCreatable?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowModifyInternetAddressConnectionLimit != nil {
                map["AllowModifyInternetAddressConnectionLimit"] = self.allowModifyInternetAddressConnectionLimit!
            }
            if self.autoRenewal != nil {
                map["AutoRenewal"] = self.autoRenewal!
            }
            if self.autoUpgradeObVersion != nil {
                map["AutoUpgradeObVersion"] = self.autoUpgradeObVersion!
            }
            if self.availableZones != nil {
                map["AvailableZones"] = self.availableZones!
            }
            if self.cpuArchitecture != nil {
                map["CpuArchitecture"] = self.cpuArchitecture!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.dataDiskAutoScale != nil {
                map["DataDiskAutoScale"] = self.dataDiskAutoScale!
            }
            if self.dataDiskAutoScaleConfig != nil {
                map["DataDiskAutoScaleConfig"] = self.dataDiskAutoScaleConfig?.toMap()
            }
            if self.dataMergeTime != nil {
                map["DataMergeTime"] = self.dataMergeTime!
            }
            if self.deployMode != nil {
                map["DeployMode"] = self.deployMode!
            }
            if self.deployType != nil {
                map["DeployType"] = self.deployType!
            }
            if self.diskType != nil {
                map["DiskType"] = self.diskType!
            }
            if self.enableIsolationOptimization != nil {
                map["EnableIsolationOptimization"] = self.enableIsolationOptimization!
            }
            if self.enableProxyService != nil {
                map["EnableProxyService"] = self.enableProxyService!
            }
            if self.enableReadOnlyReplica != nil {
                map["EnableReadOnlyReplica"] = self.enableReadOnlyReplica!
            }
            if self.enableReadOnlyReplicaManagement != nil {
                map["EnableReadOnlyReplicaManagement"] = self.enableReadOnlyReplicaManagement!
            }
            if self.enableUpgradeLogDisk != nil {
                map["EnableUpgradeLogDisk"] = self.enableUpgradeLogDisk!
            }
            if self.exclusiveUnitNumLimit != nil {
                map["ExclusiveUnitNumLimit"] = self.exclusiveUnitNumLimit!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.inTempCapacityStatus != nil {
                map["InTempCapacityStatus"] = self.inTempCapacityStatus!
            }
            if self.instanceClass != nil {
                map["InstanceClass"] = self.instanceClass!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.instanceRole != nil {
                map["InstanceRole"] = self.instanceRole!
            }
            if self.isLatestObVersion != nil {
                map["IsLatestObVersion"] = self.isLatestObVersion!
            }
            if self.isTrustEcs != nil {
                map["IsTrustEcs"] = self.isTrustEcs!
            }
            if self.isolationOptimization != nil {
                map["IsolationOptimization"] = self.isolationOptimization!
            }
            if self.maintainTime != nil {
                map["MaintainTime"] = self.maintainTime!
            }
            if self.nodeNum != nil {
                map["NodeNum"] = self.nodeNum!
            }
            if self.obRpmVersion != nil {
                map["ObRpmVersion"] = self.obRpmVersion!
            }
            if self.payType != nil {
                map["PayType"] = self.payType!
            }
            if self.primaryInstance != nil {
                map["PrimaryInstance"] = self.primaryInstance!
            }
            if self.primaryRegion != nil {
                map["PrimaryRegion"] = self.primaryRegion!
            }
            if self.proxyClusterId != nil {
                map["ProxyClusterId"] = self.proxyClusterId!
            }
            if self.proxyServiceStatus != nil {
                map["ProxyServiceStatus"] = self.proxyServiceStatus!
            }
            if self.readOnlyResource != nil {
                map["ReadOnlyResource"] = self.readOnlyResource?.toMap()
            }
            if self.replicaMode != nil {
                map["ReplicaMode"] = self.replicaMode!
            }
            if self.resource != nil {
                map["Resource"] = self.resource?.toMap()
            }
            if self.series != nil {
                map["Series"] = self.series!
            }
            if self.sharedUnitNumLimit != nil {
                map["SharedUnitNumLimit"] = self.sharedUnitNumLimit!
            }
            if self.specType != nil {
                map["SpecType"] = self.specType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tenantCreatable != nil {
                map["TenantCreatable"] = self.tenantCreatable?.toMap()
            }
            if self.unitSpec != nil {
                map["UnitSpec"] = self.unitSpec!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            if self.zones != nil {
                map["Zones"] = self.zones!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AllowModifyInternetAddressConnectionLimit") {
                self.allowModifyInternetAddressConnectionLimit = dict["AllowModifyInternetAddressConnectionLimit"] as! Bool
            }
            if dict.keys.contains("AutoRenewal") {
                self.autoRenewal = dict["AutoRenewal"] as! Bool
            }
            if dict.keys.contains("AutoUpgradeObVersion") {
                self.autoUpgradeObVersion = dict["AutoUpgradeObVersion"] as! Bool
            }
            if dict.keys.contains("AvailableZones") {
                self.availableZones = dict["AvailableZones"] as! [String]
            }
            if dict.keys.contains("CpuArchitecture") {
                self.cpuArchitecture = dict["CpuArchitecture"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DataDiskAutoScale") {
                self.dataDiskAutoScale = dict["DataDiskAutoScale"] as! Bool
            }
            if dict.keys.contains("DataDiskAutoScaleConfig") {
                var model = DescribeInstanceResponseBody.Instance.DataDiskAutoScaleConfig()
                model.fromMap(dict["DataDiskAutoScaleConfig"] as! [String: Any])
                self.dataDiskAutoScaleConfig = model
            }
            if dict.keys.contains("DataMergeTime") {
                self.dataMergeTime = dict["DataMergeTime"] as! String
            }
            if dict.keys.contains("DeployMode") {
                self.deployMode = dict["DeployMode"] as! String
            }
            if dict.keys.contains("DeployType") {
                self.deployType = dict["DeployType"] as! String
            }
            if dict.keys.contains("DiskType") {
                self.diskType = dict["DiskType"] as! String
            }
            if dict.keys.contains("EnableIsolationOptimization") {
                self.enableIsolationOptimization = dict["EnableIsolationOptimization"] as! Bool
            }
            if dict.keys.contains("EnableProxyService") {
                self.enableProxyService = dict["EnableProxyService"] as! Bool
            }
            if dict.keys.contains("EnableReadOnlyReplica") {
                self.enableReadOnlyReplica = dict["EnableReadOnlyReplica"] as! Bool
            }
            if dict.keys.contains("EnableReadOnlyReplicaManagement") {
                self.enableReadOnlyReplicaManagement = dict["EnableReadOnlyReplicaManagement"] as! Bool
            }
            if dict.keys.contains("EnableUpgradeLogDisk") {
                self.enableUpgradeLogDisk = dict["EnableUpgradeLogDisk"] as! Bool
            }
            if dict.keys.contains("ExclusiveUnitNumLimit") {
                self.exclusiveUnitNumLimit = dict["ExclusiveUnitNumLimit"] as! Int32
            }
            if dict.keys.contains("ExpireTime") {
                self.expireTime = dict["ExpireTime"] as! String
            }
            if dict.keys.contains("InTempCapacityStatus") {
                self.inTempCapacityStatus = dict["InTempCapacityStatus"] as! Bool
            }
            if dict.keys.contains("InstanceClass") {
                self.instanceClass = dict["InstanceClass"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InstanceRole") {
                self.instanceRole = dict["InstanceRole"] as! String
            }
            if dict.keys.contains("IsLatestObVersion") {
                self.isLatestObVersion = dict["IsLatestObVersion"] as! Bool
            }
            if dict.keys.contains("IsTrustEcs") {
                self.isTrustEcs = dict["IsTrustEcs"] as! Bool
            }
            if dict.keys.contains("IsolationOptimization") {
                self.isolationOptimization = dict["IsolationOptimization"] as! Bool
            }
            if dict.keys.contains("MaintainTime") {
                self.maintainTime = dict["MaintainTime"] as! String
            }
            if dict.keys.contains("NodeNum") {
                self.nodeNum = dict["NodeNum"] as! String
            }
            if dict.keys.contains("ObRpmVersion") {
                self.obRpmVersion = dict["ObRpmVersion"] as! String
            }
            if dict.keys.contains("PayType") {
                self.payType = dict["PayType"] as! String
            }
            if dict.keys.contains("PrimaryInstance") {
                self.primaryInstance = dict["PrimaryInstance"] as! String
            }
            if dict.keys.contains("PrimaryRegion") {
                self.primaryRegion = dict["PrimaryRegion"] as! String
            }
            if dict.keys.contains("ProxyClusterId") {
                self.proxyClusterId = dict["ProxyClusterId"] as! String
            }
            if dict.keys.contains("ProxyServiceStatus") {
                self.proxyServiceStatus = dict["ProxyServiceStatus"] as! String
            }
            if dict.keys.contains("ReadOnlyResource") {
                var model = DescribeInstanceResponseBody.Instance.ReadOnlyResource()
                model.fromMap(dict["ReadOnlyResource"] as! [String: Any])
                self.readOnlyResource = model
            }
            if dict.keys.contains("ReplicaMode") {
                self.replicaMode = dict["ReplicaMode"] as! String
            }
            if dict.keys.contains("Resource") {
                var model = DescribeInstanceResponseBody.Instance.Resource()
                model.fromMap(dict["Resource"] as! [String: Any])
                self.resource = model
            }
            if dict.keys.contains("Series") {
                self.series = dict["Series"] as! String
            }
            if dict.keys.contains("SharedUnitNumLimit") {
                self.sharedUnitNumLimit = dict["SharedUnitNumLimit"] as! Int32
            }
            if dict.keys.contains("SpecType") {
                self.specType = dict["SpecType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TenantCreatable") {
                var model = DescribeInstanceResponseBody.Instance.TenantCreatable()
                model.fromMap(dict["TenantCreatable"] as! [String: Any])
                self.tenantCreatable = model
            }
            if dict.keys.contains("UnitSpec") {
                self.unitSpec = dict["UnitSpec"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
            if dict.keys.contains("Zones") {
                self.zones = dict["Zones"] as! [String]
            }
        }
    }
    public var instance: DescribeInstanceResponseBody.Instance?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instance?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instance != nil {
            map["Instance"] = self.instance?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Instance") {
            var model = DescribeInstanceResponseBody.Instance()
            model.fromMap(dict["Instance"] as! [String: Any])
            self.instance = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceCreatableZoneRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DescribeInstanceCreatableZoneResponseBody : Tea.TeaModel {
    public class ZoneList : Tea.TeaModel {
        public var isInCluster: Bool?

        public var zone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.isInCluster != nil {
                map["IsInCluster"] = self.isInCluster!
            }
            if self.zone != nil {
                map["Zone"] = self.zone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IsInCluster") {
                self.isInCluster = dict["IsInCluster"] as! Bool
            }
            if dict.keys.contains("Zone") {
                self.zone = dict["Zone"] as! String
            }
        }
    }
    public var requestId: String?

    public var zoneList: [DescribeInstanceCreatableZoneResponseBody.ZoneList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.zoneList != nil {
            var tmp : [Any] = []
            for k in self.zoneList! {
                tmp.append(k.toMap())
            }
            map["ZoneList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ZoneList") {
            var tmp : [DescribeInstanceCreatableZoneResponseBody.ZoneList] = []
            for v in dict["ZoneList"] as! [Any] {
                var model = DescribeInstanceCreatableZoneResponseBody.ZoneList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.zoneList = tmp
        }
    }
}

public class DescribeInstanceCreatableZoneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceCreatableZoneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceCreatableZoneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceSSLRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DescribeInstanceSSLResponseBody : Tea.TeaModel {
    public class InstanceSSL : Tea.TeaModel {
        public var caUrl: String?

        public var enableSSL: String?

        public var forceSSL: String?

        public var forceSSLSupport: Bool?

        public var instanceId: String?

        public var status: String?

        public var validPeriod: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.caUrl != nil {
                map["CaUrl"] = self.caUrl!
            }
            if self.enableSSL != nil {
                map["EnableSSL"] = self.enableSSL!
            }
            if self.forceSSL != nil {
                map["ForceSSL"] = self.forceSSL!
            }
            if self.forceSSLSupport != nil {
                map["ForceSSLSupport"] = self.forceSSLSupport!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.validPeriod != nil {
                map["ValidPeriod"] = self.validPeriod!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CaUrl") {
                self.caUrl = dict["CaUrl"] as! String
            }
            if dict.keys.contains("EnableSSL") {
                self.enableSSL = dict["EnableSSL"] as! String
            }
            if dict.keys.contains("ForceSSL") {
                self.forceSSL = dict["ForceSSL"] as! String
            }
            if dict.keys.contains("ForceSSLSupport") {
                self.forceSSLSupport = dict["ForceSSLSupport"] as! Bool
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("ValidPeriod") {
                self.validPeriod = dict["ValidPeriod"] as! String
            }
        }
    }
    public var instanceSSL: DescribeInstanceSSLResponseBody.InstanceSSL?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceSSL?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceSSL != nil {
            map["InstanceSSL"] = self.instanceSSL?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceSSL") {
            var model = DescribeInstanceSSLResponseBody.InstanceSSL()
            model.fromMap(dict["InstanceSSL"] as! [String: Any])
            self.instanceSSL = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstanceSSLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceSSLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceSSLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceSecurityConfigsRequest : Tea.TeaModel {
    public var checkId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkId != nil {
            map["CheckId"] = self.checkId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckId") {
            self.checkId = dict["CheckId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DescribeInstanceSecurityConfigsResponseBody : Tea.TeaModel {
    public class InstanceSecurityConfigs : Tea.TeaModel {
        public class SecurityConfigs : Tea.TeaModel {
            public var configDescription: String?

            public var configGroup: String?

            public var configName: String?

            public var risk: Bool?

            public var riskDescription: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configDescription != nil {
                    map["ConfigDescription"] = self.configDescription!
                }
                if self.configGroup != nil {
                    map["ConfigGroup"] = self.configGroup!
                }
                if self.configName != nil {
                    map["ConfigName"] = self.configName!
                }
                if self.risk != nil {
                    map["Risk"] = self.risk!
                }
                if self.riskDescription != nil {
                    map["RiskDescription"] = self.riskDescription!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConfigDescription") {
                    self.configDescription = dict["ConfigDescription"] as! String
                }
                if dict.keys.contains("ConfigGroup") {
                    self.configGroup = dict["ConfigGroup"] as! String
                }
                if dict.keys.contains("ConfigName") {
                    self.configName = dict["ConfigName"] as! String
                }
                if dict.keys.contains("Risk") {
                    self.risk = dict["Risk"] as! Bool
                }
                if dict.keys.contains("RiskDescription") {
                    self.riskDescription = dict["RiskDescription"] as! String
                }
            }
        }
        public var checkId: String?

        public var checkTime: String?

        public var instanceId: String?

        public var securityConfigs: [DescribeInstanceSecurityConfigsResponseBody.InstanceSecurityConfigs.SecurityConfigs]?

        public var totalCheckCount: Int32?

        public var totalRiskCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkId != nil {
                map["CheckId"] = self.checkId!
            }
            if self.checkTime != nil {
                map["CheckTime"] = self.checkTime!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.securityConfigs != nil {
                var tmp : [Any] = []
                for k in self.securityConfigs! {
                    tmp.append(k.toMap())
                }
                map["SecurityConfigs"] = tmp
            }
            if self.totalCheckCount != nil {
                map["TotalCheckCount"] = self.totalCheckCount!
            }
            if self.totalRiskCount != nil {
                map["TotalRiskCount"] = self.totalRiskCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CheckId") {
                self.checkId = dict["CheckId"] as! String
            }
            if dict.keys.contains("CheckTime") {
                self.checkTime = dict["CheckTime"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("SecurityConfigs") {
                var tmp : [DescribeInstanceSecurityConfigsResponseBody.InstanceSecurityConfigs.SecurityConfigs] = []
                for v in dict["SecurityConfigs"] as! [Any] {
                    var model = DescribeInstanceSecurityConfigsResponseBody.InstanceSecurityConfigs.SecurityConfigs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.securityConfigs = tmp
            }
            if dict.keys.contains("TotalCheckCount") {
                self.totalCheckCount = dict["TotalCheckCount"] as! Int32
            }
            if dict.keys.contains("TotalRiskCount") {
                self.totalRiskCount = dict["TotalRiskCount"] as! Int32
            }
        }
    }
    public var instanceSecurityConfigs: DescribeInstanceSecurityConfigsResponseBody.InstanceSecurityConfigs?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceSecurityConfigs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceSecurityConfigs != nil {
            map["InstanceSecurityConfigs"] = self.instanceSecurityConfigs?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceSecurityConfigs") {
            var model = DescribeInstanceSecurityConfigsResponseBody.InstanceSecurityConfigs()
            model.fromMap(dict["InstanceSecurityConfigs"] as! [String: Any])
            self.instanceSecurityConfigs = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstanceSecurityConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceSecurityConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceSecurityConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceTagsRequest : Tea.TeaModel {
    public var instanceIds: String?

    public var tags: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
    }
}

public class DescribeInstanceTagsResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public var resourceId: String?

        public var resourceType: String?

        public var tag: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! String
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
            if dict.keys.contains("Tag") {
                self.tag = dict["Tag"] as! String
            }
        }
    }
    public var requestId: String?

    public var tagResources: [DescribeInstanceTagsResponseBody.TagResources]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            var tmp : [Any] = []
            for k in self.tagResources! {
                tmp.append(k.toMap())
            }
            map["TagResources"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagResources") {
            var tmp : [DescribeInstanceTagsResponseBody.TagResources] = []
            for v in dict["TagResources"] as! [Any] {
                var model = DescribeInstanceTagsResponseBody.TagResources()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tagResources = tmp
        }
    }
}

public class DescribeInstanceTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceTenantModesRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DescribeInstanceTenantModesResponseBody : Tea.TeaModel {
    public var instanceModes: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceModes != nil {
            map["InstanceModes"] = self.instanceModes!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceModes") {
            self.instanceModes = dict["InstanceModes"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstanceTenantModesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceTenantModesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceTenantModesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceTopologyRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DescribeInstanceTopologyResponseBody : Tea.TeaModel {
    public class InstanceTopology : Tea.TeaModel {
        public class Replicas : Tea.TeaModel {
            public class ReplicaResource : Tea.TeaModel {
                public class Cpu : Tea.TeaModel {
                    public var totalCpu: Int32?

                    public var usedCpu: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.totalCpu != nil {
                            map["TotalCpu"] = self.totalCpu!
                        }
                        if self.usedCpu != nil {
                            map["UsedCpu"] = self.usedCpu!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TotalCpu") {
                            self.totalCpu = dict["TotalCpu"] as! Int32
                        }
                        if dict.keys.contains("UsedCpu") {
                            self.usedCpu = dict["UsedCpu"] as! Int32
                        }
                    }
                }
                public class DiskSize : Tea.TeaModel {
                    public var totalDiskSize: Int64?

                    public var usedDiskSize: Double?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.totalDiskSize != nil {
                            map["TotalDiskSize"] = self.totalDiskSize!
                        }
                        if self.usedDiskSize != nil {
                            map["UsedDiskSize"] = self.usedDiskSize!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TotalDiskSize") {
                            self.totalDiskSize = dict["TotalDiskSize"] as! Int64
                        }
                        if dict.keys.contains("UsedDiskSize") {
                            self.usedDiskSize = dict["UsedDiskSize"] as! Double
                        }
                    }
                }
                public class Memory : Tea.TeaModel {
                    public var totalMemory: Int64?

                    public var usedMemory: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.totalMemory != nil {
                            map["TotalMemory"] = self.totalMemory!
                        }
                        if self.usedMemory != nil {
                            map["UsedMemory"] = self.usedMemory!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TotalMemory") {
                            self.totalMemory = dict["TotalMemory"] as! Int64
                        }
                        if dict.keys.contains("UsedMemory") {
                            self.usedMemory = dict["UsedMemory"] as! Int64
                        }
                    }
                }
                public var cpu: DescribeInstanceTopologyResponseBody.InstanceTopology.Replicas.ReplicaResource.Cpu?

                public var diskSize: DescribeInstanceTopologyResponseBody.InstanceTopology.Replicas.ReplicaResource.DiskSize?

                public var memory: DescribeInstanceTopologyResponseBody.InstanceTopology.Replicas.ReplicaResource.Memory?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.cpu?.validate()
                    try self.diskSize?.validate()
                    try self.memory?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cpu != nil {
                        map["Cpu"] = self.cpu?.toMap()
                    }
                    if self.diskSize != nil {
                        map["DiskSize"] = self.diskSize?.toMap()
                    }
                    if self.memory != nil {
                        map["Memory"] = self.memory?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Cpu") {
                        var model = DescribeInstanceTopologyResponseBody.InstanceTopology.Replicas.ReplicaResource.Cpu()
                        model.fromMap(dict["Cpu"] as! [String: Any])
                        self.cpu = model
                    }
                    if dict.keys.contains("DiskSize") {
                        var model = DescribeInstanceTopologyResponseBody.InstanceTopology.Replicas.ReplicaResource.DiskSize()
                        model.fromMap(dict["DiskSize"] as! [String: Any])
                        self.diskSize = model
                    }
                    if dict.keys.contains("Memory") {
                        var model = DescribeInstanceTopologyResponseBody.InstanceTopology.Replicas.ReplicaResource.Memory()
                        model.fromMap(dict["Memory"] as! [String: Any])
                        self.memory = model
                    }
                }
            }
            public var logicalZone: String?

            public var nodeNum: Int32?

            public var replicaResource: DescribeInstanceTopologyResponseBody.InstanceTopology.Replicas.ReplicaResource?

            public var replicaType: String?

            public var status: String?

            public var zoneLogicalId: Int32?

            public var zoneLogicalName: String?

            public var zoneRegionName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.replicaResource?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.logicalZone != nil {
                    map["LogicalZone"] = self.logicalZone!
                }
                if self.nodeNum != nil {
                    map["NodeNum"] = self.nodeNum!
                }
                if self.replicaResource != nil {
                    map["ReplicaResource"] = self.replicaResource?.toMap()
                }
                if self.replicaType != nil {
                    map["ReplicaType"] = self.replicaType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.zoneLogicalId != nil {
                    map["ZoneLogicalId"] = self.zoneLogicalId!
                }
                if self.zoneLogicalName != nil {
                    map["ZoneLogicalName"] = self.zoneLogicalName!
                }
                if self.zoneRegionName != nil {
                    map["ZoneRegionName"] = self.zoneRegionName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LogicalZone") {
                    self.logicalZone = dict["LogicalZone"] as! String
                }
                if dict.keys.contains("NodeNum") {
                    self.nodeNum = dict["NodeNum"] as! Int32
                }
                if dict.keys.contains("ReplicaResource") {
                    var model = DescribeInstanceTopologyResponseBody.InstanceTopology.Replicas.ReplicaResource()
                    model.fromMap(dict["ReplicaResource"] as! [String: Any])
                    self.replicaResource = model
                }
                if dict.keys.contains("ReplicaType") {
                    self.replicaType = dict["ReplicaType"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("ZoneLogicalId") {
                    self.zoneLogicalId = dict["ZoneLogicalId"] as! Int32
                }
                if dict.keys.contains("ZoneLogicalName") {
                    self.zoneLogicalName = dict["ZoneLogicalName"] as! String
                }
                if dict.keys.contains("ZoneRegionName") {
                    self.zoneRegionName = dict["ZoneRegionName"] as! String
                }
            }
        }
        public class Tenants : Tea.TeaModel {
            public class TenantZones : Tea.TeaModel {
                public class Units : Tea.TeaModel {
                    public var enableCancelMigrateUnit: Bool?

                    public var enableMigrateUnit: Bool?

                    public var manualMigrate: Bool?

                    public var nodeId: String?

                    public var replicaType: String?

                    public var unitCpu: Double?

                    public var unitDataSize: Int64?

                    public var unitId: String?

                    public var unitMemory: Double?

                    public var unitStatus: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.enableCancelMigrateUnit != nil {
                            map["EnableCancelMigrateUnit"] = self.enableCancelMigrateUnit!
                        }
                        if self.enableMigrateUnit != nil {
                            map["EnableMigrateUnit"] = self.enableMigrateUnit!
                        }
                        if self.manualMigrate != nil {
                            map["ManualMigrate"] = self.manualMigrate!
                        }
                        if self.nodeId != nil {
                            map["NodeId"] = self.nodeId!
                        }
                        if self.replicaType != nil {
                            map["ReplicaType"] = self.replicaType!
                        }
                        if self.unitCpu != nil {
                            map["UnitCpu"] = self.unitCpu!
                        }
                        if self.unitDataSize != nil {
                            map["UnitDataSize"] = self.unitDataSize!
                        }
                        if self.unitId != nil {
                            map["UnitId"] = self.unitId!
                        }
                        if self.unitMemory != nil {
                            map["UnitMemory"] = self.unitMemory!
                        }
                        if self.unitStatus != nil {
                            map["UnitStatus"] = self.unitStatus!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("EnableCancelMigrateUnit") {
                            self.enableCancelMigrateUnit = dict["EnableCancelMigrateUnit"] as! Bool
                        }
                        if dict.keys.contains("EnableMigrateUnit") {
                            self.enableMigrateUnit = dict["EnableMigrateUnit"] as! Bool
                        }
                        if dict.keys.contains("ManualMigrate") {
                            self.manualMigrate = dict["ManualMigrate"] as! Bool
                        }
                        if dict.keys.contains("NodeId") {
                            self.nodeId = dict["NodeId"] as! String
                        }
                        if dict.keys.contains("ReplicaType") {
                            self.replicaType = dict["ReplicaType"] as! String
                        }
                        if dict.keys.contains("UnitCpu") {
                            self.unitCpu = dict["UnitCpu"] as! Double
                        }
                        if dict.keys.contains("UnitDataSize") {
                            self.unitDataSize = dict["UnitDataSize"] as! Int64
                        }
                        if dict.keys.contains("UnitId") {
                            self.unitId = dict["UnitId"] as! String
                        }
                        if dict.keys.contains("UnitMemory") {
                            self.unitMemory = dict["UnitMemory"] as! Double
                        }
                        if dict.keys.contains("UnitStatus") {
                            self.unitStatus = dict["UnitStatus"] as! String
                        }
                    }
                }
                public var isPrimaryTenantZone: Bool?

                public var logicalZone: String?

                public var replicaType: String?

                public var tenantZoneId: String?

                public var tenantZoneRole: String?

                public var units: [DescribeInstanceTopologyResponseBody.InstanceTopology.Tenants.TenantZones.Units]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.isPrimaryTenantZone != nil {
                        map["IsPrimaryTenantZone"] = self.isPrimaryTenantZone!
                    }
                    if self.logicalZone != nil {
                        map["LogicalZone"] = self.logicalZone!
                    }
                    if self.replicaType != nil {
                        map["ReplicaType"] = self.replicaType!
                    }
                    if self.tenantZoneId != nil {
                        map["TenantZoneId"] = self.tenantZoneId!
                    }
                    if self.tenantZoneRole != nil {
                        map["TenantZoneRole"] = self.tenantZoneRole!
                    }
                    if self.units != nil {
                        var tmp : [Any] = []
                        for k in self.units! {
                            tmp.append(k.toMap())
                        }
                        map["Units"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IsPrimaryTenantZone") {
                        self.isPrimaryTenantZone = dict["IsPrimaryTenantZone"] as! Bool
                    }
                    if dict.keys.contains("LogicalZone") {
                        self.logicalZone = dict["LogicalZone"] as! String
                    }
                    if dict.keys.contains("ReplicaType") {
                        self.replicaType = dict["ReplicaType"] as! String
                    }
                    if dict.keys.contains("TenantZoneId") {
                        self.tenantZoneId = dict["TenantZoneId"] as! String
                    }
                    if dict.keys.contains("TenantZoneRole") {
                        self.tenantZoneRole = dict["TenantZoneRole"] as! String
                    }
                    if dict.keys.contains("Units") {
                        var tmp : [DescribeInstanceTopologyResponseBody.InstanceTopology.Tenants.TenantZones.Units] = []
                        for v in dict["Units"] as! [Any] {
                            var model = DescribeInstanceTopologyResponseBody.InstanceTopology.Tenants.TenantZones.Units()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.units = tmp
                    }
                }
            }
            public var primaryZoneDeployType: String?

            public var tenantCpu: Double?

            public var tenantDeployType: String?

            public var tenantDiskSize: Double?

            public var tenantId: String?

            public var tenantMemory: Double?

            public var tenantMode: String?

            public var tenantName: String?

            public var tenantStatus: String?

            public var tenantUnitCpu: Double?

            public var tenantUnitMemory: Double?

            public var tenantUnitNum: Int32?

            public var tenantZones: [DescribeInstanceTopologyResponseBody.InstanceTopology.Tenants.TenantZones]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.primaryZoneDeployType != nil {
                    map["PrimaryZoneDeployType"] = self.primaryZoneDeployType!
                }
                if self.tenantCpu != nil {
                    map["TenantCpu"] = self.tenantCpu!
                }
                if self.tenantDeployType != nil {
                    map["TenantDeployType"] = self.tenantDeployType!
                }
                if self.tenantDiskSize != nil {
                    map["TenantDiskSize"] = self.tenantDiskSize!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                if self.tenantMemory != nil {
                    map["TenantMemory"] = self.tenantMemory!
                }
                if self.tenantMode != nil {
                    map["TenantMode"] = self.tenantMode!
                }
                if self.tenantName != nil {
                    map["TenantName"] = self.tenantName!
                }
                if self.tenantStatus != nil {
                    map["TenantStatus"] = self.tenantStatus!
                }
                if self.tenantUnitCpu != nil {
                    map["TenantUnitCpu"] = self.tenantUnitCpu!
                }
                if self.tenantUnitMemory != nil {
                    map["TenantUnitMemory"] = self.tenantUnitMemory!
                }
                if self.tenantUnitNum != nil {
                    map["TenantUnitNum"] = self.tenantUnitNum!
                }
                if self.tenantZones != nil {
                    var tmp : [Any] = []
                    for k in self.tenantZones! {
                        tmp.append(k.toMap())
                    }
                    map["TenantZones"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PrimaryZoneDeployType") {
                    self.primaryZoneDeployType = dict["PrimaryZoneDeployType"] as! String
                }
                if dict.keys.contains("TenantCpu") {
                    self.tenantCpu = dict["TenantCpu"] as! Double
                }
                if dict.keys.contains("TenantDeployType") {
                    self.tenantDeployType = dict["TenantDeployType"] as! String
                }
                if dict.keys.contains("TenantDiskSize") {
                    self.tenantDiskSize = dict["TenantDiskSize"] as! Double
                }
                if dict.keys.contains("TenantId") {
                    self.tenantId = dict["TenantId"] as! String
                }
                if dict.keys.contains("TenantMemory") {
                    self.tenantMemory = dict["TenantMemory"] as! Double
                }
                if dict.keys.contains("TenantMode") {
                    self.tenantMode = dict["TenantMode"] as! String
                }
                if dict.keys.contains("TenantName") {
                    self.tenantName = dict["TenantName"] as! String
                }
                if dict.keys.contains("TenantStatus") {
                    self.tenantStatus = dict["TenantStatus"] as! String
                }
                if dict.keys.contains("TenantUnitCpu") {
                    self.tenantUnitCpu = dict["TenantUnitCpu"] as! Double
                }
                if dict.keys.contains("TenantUnitMemory") {
                    self.tenantUnitMemory = dict["TenantUnitMemory"] as! Double
                }
                if dict.keys.contains("TenantUnitNum") {
                    self.tenantUnitNum = dict["TenantUnitNum"] as! Int32
                }
                if dict.keys.contains("TenantZones") {
                    var tmp : [DescribeInstanceTopologyResponseBody.InstanceTopology.Tenants.TenantZones] = []
                    for v in dict["TenantZones"] as! [Any] {
                        var model = DescribeInstanceTopologyResponseBody.InstanceTopology.Tenants.TenantZones()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tenantZones = tmp
                }
            }
        }
        public class Zones : Tea.TeaModel {
            public class Nodes : Tea.TeaModel {
                public class NodeResource : Tea.TeaModel {
                    public class Cpu : Tea.TeaModel {
                        public var totalCpu: Int32?

                        public var usedCpu: Double?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.totalCpu != nil {
                                map["TotalCpu"] = self.totalCpu!
                            }
                            if self.usedCpu != nil {
                                map["UsedCpu"] = self.usedCpu!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("TotalCpu") {
                                self.totalCpu = dict["TotalCpu"] as! Int32
                            }
                            if dict.keys.contains("UsedCpu") {
                                self.usedCpu = dict["UsedCpu"] as! Double
                            }
                        }
                    }
                    public class DiskSize : Tea.TeaModel {
                        public var totalDiskSize: Double?

                        public var usedDiskSize: Double?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.totalDiskSize != nil {
                                map["TotalDiskSize"] = self.totalDiskSize!
                            }
                            if self.usedDiskSize != nil {
                                map["UsedDiskSize"] = self.usedDiskSize!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("TotalDiskSize") {
                                self.totalDiskSize = dict["TotalDiskSize"] as! Double
                            }
                            if dict.keys.contains("UsedDiskSize") {
                                self.usedDiskSize = dict["UsedDiskSize"] as! Double
                            }
                        }
                    }
                    public class Memory : Tea.TeaModel {
                        public var totalMemory: Int64?

                        public var usedMemory: Double?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.totalMemory != nil {
                                map["TotalMemory"] = self.totalMemory!
                            }
                            if self.usedMemory != nil {
                                map["UsedMemory"] = self.usedMemory!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("TotalMemory") {
                                self.totalMemory = dict["TotalMemory"] as! Int64
                            }
                            if dict.keys.contains("UsedMemory") {
                                self.usedMemory = dict["UsedMemory"] as! Double
                            }
                        }
                    }
                    public var cpu: DescribeInstanceTopologyResponseBody.InstanceTopology.Zones.Nodes.NodeResource.Cpu?

                    public var diskSize: DescribeInstanceTopologyResponseBody.InstanceTopology.Zones.Nodes.NodeResource.DiskSize?

                    public var memory: DescribeInstanceTopologyResponseBody.InstanceTopology.Zones.Nodes.NodeResource.Memory?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.cpu?.validate()
                        try self.diskSize?.validate()
                        try self.memory?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cpu != nil {
                            map["Cpu"] = self.cpu?.toMap()
                        }
                        if self.diskSize != nil {
                            map["DiskSize"] = self.diskSize?.toMap()
                        }
                        if self.memory != nil {
                            map["Memory"] = self.memory?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Cpu") {
                            var model = DescribeInstanceTopologyResponseBody.InstanceTopology.Zones.Nodes.NodeResource.Cpu()
                            model.fromMap(dict["Cpu"] as! [String: Any])
                            self.cpu = model
                        }
                        if dict.keys.contains("DiskSize") {
                            var model = DescribeInstanceTopologyResponseBody.InstanceTopology.Zones.Nodes.NodeResource.DiskSize()
                            model.fromMap(dict["DiskSize"] as! [String: Any])
                            self.diskSize = model
                        }
                        if dict.keys.contains("Memory") {
                            var model = DescribeInstanceTopologyResponseBody.InstanceTopology.Zones.Nodes.NodeResource.Memory()
                            model.fromMap(dict["Memory"] as! [String: Any])
                            self.memory = model
                        }
                    }
                }
                public var fullCopyId: Int64?

                public var logicalZone: String?

                public var nodeCopyId: Int64?

                public var nodeId: String?

                public var nodeResource: [DescribeInstanceTopologyResponseBody.InstanceTopology.Zones.Nodes.NodeResource]?

                public var nodeStatus: String?

                public var readOnlyCopyId: Int64?

                public var replicaType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fullCopyId != nil {
                        map["FullCopyId"] = self.fullCopyId!
                    }
                    if self.logicalZone != nil {
                        map["LogicalZone"] = self.logicalZone!
                    }
                    if self.nodeCopyId != nil {
                        map["NodeCopyId"] = self.nodeCopyId!
                    }
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    if self.nodeResource != nil {
                        var tmp : [Any] = []
                        for k in self.nodeResource! {
                            tmp.append(k.toMap())
                        }
                        map["NodeResource"] = tmp
                    }
                    if self.nodeStatus != nil {
                        map["NodeStatus"] = self.nodeStatus!
                    }
                    if self.readOnlyCopyId != nil {
                        map["ReadOnlyCopyId"] = self.readOnlyCopyId!
                    }
                    if self.replicaType != nil {
                        map["ReplicaType"] = self.replicaType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FullCopyId") {
                        self.fullCopyId = dict["FullCopyId"] as! Int64
                    }
                    if dict.keys.contains("LogicalZone") {
                        self.logicalZone = dict["LogicalZone"] as! String
                    }
                    if dict.keys.contains("NodeCopyId") {
                        self.nodeCopyId = dict["NodeCopyId"] as! Int64
                    }
                    if dict.keys.contains("NodeId") {
                        self.nodeId = dict["NodeId"] as! String
                    }
                    if dict.keys.contains("NodeResource") {
                        var tmp : [DescribeInstanceTopologyResponseBody.InstanceTopology.Zones.Nodes.NodeResource] = []
                        for v in dict["NodeResource"] as! [Any] {
                            var model = DescribeInstanceTopologyResponseBody.InstanceTopology.Zones.Nodes.NodeResource()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.nodeResource = tmp
                    }
                    if dict.keys.contains("NodeStatus") {
                        self.nodeStatus = dict["NodeStatus"] as! String
                    }
                    if dict.keys.contains("ReadOnlyCopyId") {
                        self.readOnlyCopyId = dict["ReadOnlyCopyId"] as! Int64
                    }
                    if dict.keys.contains("ReplicaType") {
                        self.replicaType = dict["ReplicaType"] as! String
                    }
                }
            }
            public class ZoneResource : Tea.TeaModel {
                public class DiskSize : Tea.TeaModel {
                    public var maxDiskUsedObServer: [String]?

                    public var maxDiskUsedPercent: Double?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.maxDiskUsedObServer != nil {
                            map["MaxDiskUsedObServer"] = self.maxDiskUsedObServer!
                        }
                        if self.maxDiskUsedPercent != nil {
                            map["MaxDiskUsedPercent"] = self.maxDiskUsedPercent!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("MaxDiskUsedObServer") {
                            self.maxDiskUsedObServer = dict["MaxDiskUsedObServer"] as! [String]
                        }
                        if dict.keys.contains("MaxDiskUsedPercent") {
                            self.maxDiskUsedPercent = dict["MaxDiskUsedPercent"] as! Double
                        }
                    }
                }
                public var diskSize: DescribeInstanceTopologyResponseBody.InstanceTopology.Zones.ZoneResource.DiskSize?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.diskSize?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.diskSize != nil {
                        map["DiskSize"] = self.diskSize?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DiskSize") {
                        var model = DescribeInstanceTopologyResponseBody.InstanceTopology.Zones.ZoneResource.DiskSize()
                        model.fromMap(dict["DiskSize"] as! [String: Any])
                        self.diskSize = model
                    }
                }
            }
            public var nodes: [DescribeInstanceTopologyResponseBody.InstanceTopology.Zones.Nodes]?

            public var region: String?

            public var zoneDisk: String?

            public var zoneId: String?

            public var zoneResource: DescribeInstanceTopologyResponseBody.InstanceTopology.Zones.ZoneResource?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.zoneResource?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.nodes != nil {
                    var tmp : [Any] = []
                    for k in self.nodes! {
                        tmp.append(k.toMap())
                    }
                    map["Nodes"] = tmp
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.zoneDisk != nil {
                    map["ZoneDisk"] = self.zoneDisk!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                if self.zoneResource != nil {
                    map["ZoneResource"] = self.zoneResource?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Nodes") {
                    var tmp : [DescribeInstanceTopologyResponseBody.InstanceTopology.Zones.Nodes] = []
                    for v in dict["Nodes"] as! [Any] {
                        var model = DescribeInstanceTopologyResponseBody.InstanceTopology.Zones.Nodes()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.nodes = tmp
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("ZoneDisk") {
                    self.zoneDisk = dict["ZoneDisk"] as! String
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
                if dict.keys.contains("ZoneResource") {
                    var model = DescribeInstanceTopologyResponseBody.InstanceTopology.Zones.ZoneResource()
                    model.fromMap(dict["ZoneResource"] as! [String: Any])
                    self.zoneResource = model
                }
            }
        }
        public var replicas: [DescribeInstanceTopologyResponseBody.InstanceTopology.Replicas]?

        public var tenants: [DescribeInstanceTopologyResponseBody.InstanceTopology.Tenants]?

        public var zones: [DescribeInstanceTopologyResponseBody.InstanceTopology.Zones]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.replicas != nil {
                var tmp : [Any] = []
                for k in self.replicas! {
                    tmp.append(k.toMap())
                }
                map["Replicas"] = tmp
            }
            if self.tenants != nil {
                var tmp : [Any] = []
                for k in self.tenants! {
                    tmp.append(k.toMap())
                }
                map["Tenants"] = tmp
            }
            if self.zones != nil {
                var tmp : [Any] = []
                for k in self.zones! {
                    tmp.append(k.toMap())
                }
                map["Zones"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Replicas") {
                var tmp : [DescribeInstanceTopologyResponseBody.InstanceTopology.Replicas] = []
                for v in dict["Replicas"] as! [Any] {
                    var model = DescribeInstanceTopologyResponseBody.InstanceTopology.Replicas()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.replicas = tmp
            }
            if dict.keys.contains("Tenants") {
                var tmp : [DescribeInstanceTopologyResponseBody.InstanceTopology.Tenants] = []
                for v in dict["Tenants"] as! [Any] {
                    var model = DescribeInstanceTopologyResponseBody.InstanceTopology.Tenants()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tenants = tmp
            }
            if dict.keys.contains("Zones") {
                var tmp : [DescribeInstanceTopologyResponseBody.InstanceTopology.Zones] = []
                for v in dict["Zones"] as! [Any] {
                    var model = DescribeInstanceTopologyResponseBody.InstanceTopology.Zones()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.zones = tmp
            }
        }
    }
    public var instanceTopology: DescribeInstanceTopologyResponseBody.InstanceTopology?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceTopology?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceTopology != nil {
            map["InstanceTopology"] = self.instanceTopology?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceTopology") {
            var model = DescribeInstanceTopologyResponseBody.InstanceTopology()
            model.fromMap(dict["InstanceTopology"] as! [String: Any])
            self.instanceTopology = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstanceTopologyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceTopologyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceTopologyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstancesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var instanceName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceGroupId: String?

    public var searchKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SearchKey") {
            self.searchKey = dict["SearchKey"] as! String
        }
    }
}

public class DescribeInstancesResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public class DataDiskAutoScaleConfig : Tea.TeaModel {
            public var autoScale: Bool?

            public var maxDiskSize: Int64?

            public var scaleStepInMerge: Double?

            public var scaleStepInNormal: Double?

            public var upperMergeThreshold: Double?

            public var upperScaleStrategy: String?

            public var upperThreshold: Double?

            public var upperbound: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoScale != nil {
                    map["AutoScale"] = self.autoScale!
                }
                if self.maxDiskSize != nil {
                    map["MaxDiskSize"] = self.maxDiskSize!
                }
                if self.scaleStepInMerge != nil {
                    map["ScaleStepInMerge"] = self.scaleStepInMerge!
                }
                if self.scaleStepInNormal != nil {
                    map["ScaleStepInNormal"] = self.scaleStepInNormal!
                }
                if self.upperMergeThreshold != nil {
                    map["UpperMergeThreshold"] = self.upperMergeThreshold!
                }
                if self.upperScaleStrategy != nil {
                    map["UpperScaleStrategy"] = self.upperScaleStrategy!
                }
                if self.upperThreshold != nil {
                    map["UpperThreshold"] = self.upperThreshold!
                }
                if self.upperbound != nil {
                    map["Upperbound"] = self.upperbound!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutoScale") {
                    self.autoScale = dict["AutoScale"] as! Bool
                }
                if dict.keys.contains("MaxDiskSize") {
                    self.maxDiskSize = dict["MaxDiskSize"] as! Int64
                }
                if dict.keys.contains("ScaleStepInMerge") {
                    self.scaleStepInMerge = dict["ScaleStepInMerge"] as! Double
                }
                if dict.keys.contains("ScaleStepInNormal") {
                    self.scaleStepInNormal = dict["ScaleStepInNormal"] as! Double
                }
                if dict.keys.contains("UpperMergeThreshold") {
                    self.upperMergeThreshold = dict["UpperMergeThreshold"] as! Double
                }
                if dict.keys.contains("UpperScaleStrategy") {
                    self.upperScaleStrategy = dict["UpperScaleStrategy"] as! String
                }
                if dict.keys.contains("UpperThreshold") {
                    self.upperThreshold = dict["UpperThreshold"] as! Double
                }
                if dict.keys.contains("Upperbound") {
                    self.upperbound = dict["Upperbound"] as! Double
                }
            }
        }
        public class Resource : Tea.TeaModel {
            public class CapacityUnit : Tea.TeaModel {
                public var maxCapacityUnit: Int32?

                public var minCapacityUnit: Int32?

                public var usedCapacityUnit: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxCapacityUnit != nil {
                        map["MaxCapacityUnit"] = self.maxCapacityUnit!
                    }
                    if self.minCapacityUnit != nil {
                        map["MinCapacityUnit"] = self.minCapacityUnit!
                    }
                    if self.usedCapacityUnit != nil {
                        map["UsedCapacityUnit"] = self.usedCapacityUnit!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MaxCapacityUnit") {
                        self.maxCapacityUnit = dict["MaxCapacityUnit"] as! Int32
                    }
                    if dict.keys.contains("MinCapacityUnit") {
                        self.minCapacityUnit = dict["MinCapacityUnit"] as! Int32
                    }
                    if dict.keys.contains("UsedCapacityUnit") {
                        self.usedCapacityUnit = dict["UsedCapacityUnit"] as! Int32
                    }
                }
            }
            public class Cpu : Tea.TeaModel {
                public var originalTotalCpu: Double?

                public var totalCpu: Double?

                public var unitCpu: Double?

                public var usedCpu: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.originalTotalCpu != nil {
                        map["OriginalTotalCpu"] = self.originalTotalCpu!
                    }
                    if self.totalCpu != nil {
                        map["TotalCpu"] = self.totalCpu!
                    }
                    if self.unitCpu != nil {
                        map["UnitCpu"] = self.unitCpu!
                    }
                    if self.usedCpu != nil {
                        map["UsedCpu"] = self.usedCpu!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OriginalTotalCpu") {
                        self.originalTotalCpu = dict["OriginalTotalCpu"] as! Double
                    }
                    if dict.keys.contains("TotalCpu") {
                        self.totalCpu = dict["TotalCpu"] as! Double
                    }
                    if dict.keys.contains("UnitCpu") {
                        self.unitCpu = dict["UnitCpu"] as! Double
                    }
                    if dict.keys.contains("UsedCpu") {
                        self.usedCpu = dict["UsedCpu"] as! Double
                    }
                }
            }
            public class DiskSize : Tea.TeaModel {
                public var originalTotalDiskSize: Double?

                public var totalDiskSize: Double?

                public var unitDiskSize: Double?

                public var usedDiskSize: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.originalTotalDiskSize != nil {
                        map["OriginalTotalDiskSize"] = self.originalTotalDiskSize!
                    }
                    if self.totalDiskSize != nil {
                        map["TotalDiskSize"] = self.totalDiskSize!
                    }
                    if self.unitDiskSize != nil {
                        map["UnitDiskSize"] = self.unitDiskSize!
                    }
                    if self.usedDiskSize != nil {
                        map["UsedDiskSize"] = self.usedDiskSize!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OriginalTotalDiskSize") {
                        self.originalTotalDiskSize = dict["OriginalTotalDiskSize"] as! Double
                    }
                    if dict.keys.contains("TotalDiskSize") {
                        self.totalDiskSize = dict["TotalDiskSize"] as! Double
                    }
                    if dict.keys.contains("UnitDiskSize") {
                        self.unitDiskSize = dict["UnitDiskSize"] as! Double
                    }
                    if dict.keys.contains("UsedDiskSize") {
                        self.usedDiskSize = dict["UsedDiskSize"] as! Int64
                    }
                }
            }
            public class Memory : Tea.TeaModel {
                public var originalTotalMemory: Double?

                public var totalMemory: Double?

                public var unitMemory: Int64?

                public var usedMemory: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.originalTotalMemory != nil {
                        map["OriginalTotalMemory"] = self.originalTotalMemory!
                    }
                    if self.totalMemory != nil {
                        map["TotalMemory"] = self.totalMemory!
                    }
                    if self.unitMemory != nil {
                        map["UnitMemory"] = self.unitMemory!
                    }
                    if self.usedMemory != nil {
                        map["UsedMemory"] = self.usedMemory!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OriginalTotalMemory") {
                        self.originalTotalMemory = dict["OriginalTotalMemory"] as! Double
                    }
                    if dict.keys.contains("TotalMemory") {
                        self.totalMemory = dict["TotalMemory"] as! Double
                    }
                    if dict.keys.contains("UnitMemory") {
                        self.unitMemory = dict["UnitMemory"] as! Int64
                    }
                    if dict.keys.contains("UsedMemory") {
                        self.usedMemory = dict["UsedMemory"] as! Int64
                    }
                }
            }
            public var capacityUnit: DescribeInstancesResponseBody.Instances.Resource.CapacityUnit?

            public var cpu: DescribeInstancesResponseBody.Instances.Resource.Cpu?

            public var diskSize: DescribeInstancesResponseBody.Instances.Resource.DiskSize?

            public var memory: DescribeInstancesResponseBody.Instances.Resource.Memory?

            public var unitCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.capacityUnit?.validate()
                try self.cpu?.validate()
                try self.diskSize?.validate()
                try self.memory?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.capacityUnit != nil {
                    map["CapacityUnit"] = self.capacityUnit?.toMap()
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu?.toMap()
                }
                if self.diskSize != nil {
                    map["DiskSize"] = self.diskSize?.toMap()
                }
                if self.memory != nil {
                    map["Memory"] = self.memory?.toMap()
                }
                if self.unitCount != nil {
                    map["UnitCount"] = self.unitCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CapacityUnit") {
                    var model = DescribeInstancesResponseBody.Instances.Resource.CapacityUnit()
                    model.fromMap(dict["CapacityUnit"] as! [String: Any])
                    self.capacityUnit = model
                }
                if dict.keys.contains("Cpu") {
                    var model = DescribeInstancesResponseBody.Instances.Resource.Cpu()
                    model.fromMap(dict["Cpu"] as! [String: Any])
                    self.cpu = model
                }
                if dict.keys.contains("DiskSize") {
                    var model = DescribeInstancesResponseBody.Instances.Resource.DiskSize()
                    model.fromMap(dict["DiskSize"] as! [String: Any])
                    self.diskSize = model
                }
                if dict.keys.contains("Memory") {
                    var model = DescribeInstancesResponseBody.Instances.Resource.Memory()
                    model.fromMap(dict["Memory"] as! [String: Any])
                    self.memory = model
                }
                if dict.keys.contains("UnitCount") {
                    self.unitCount = dict["UnitCount"] as! Int64
                }
            }
        }
        public var availableZones: [String]?

        public var commodityCode: String?

        public var cpu: Int32?

        public var cpuArchitecture: String?

        public var createTime: String?

        public var dataDiskAutoScaleConfig: DescribeInstancesResponseBody.Instances.DataDiskAutoScaleConfig?

        public var deployMode: String?

        public var deployType: String?

        public var diskSize: String?

        public var diskType: String?

        public var enableReadOnlyReplicaManagement: Bool?

        public var enableUpgradeNodes: Bool?

        public var expireSeconds: Int32?

        public var expireTime: String?

        public var inTempCapacityStatus: Bool?

        public var instanceClass: String?

        public var instanceId: String?

        public var instanceName: String?

        public var instanceRole: String?

        public var instanceType: String?

        public var maintainTime: String?

        public var mem: Int64?

        public var payType: String?

        public var resource: DescribeInstancesResponseBody.Instances.Resource?

        public var resourceGroupId: String?

        public var series: String?

        public var specType: String?

        public var state: String?

        public var usedDiskSize: Int64?

        public var version: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.dataDiskAutoScaleConfig?.validate()
            try self.resource?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.availableZones != nil {
                map["AvailableZones"] = self.availableZones!
            }
            if self.commodityCode != nil {
                map["CommodityCode"] = self.commodityCode!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.cpuArchitecture != nil {
                map["CpuArchitecture"] = self.cpuArchitecture!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.dataDiskAutoScaleConfig != nil {
                map["DataDiskAutoScaleConfig"] = self.dataDiskAutoScaleConfig?.toMap()
            }
            if self.deployMode != nil {
                map["DeployMode"] = self.deployMode!
            }
            if self.deployType != nil {
                map["DeployType"] = self.deployType!
            }
            if self.diskSize != nil {
                map["DiskSize"] = self.diskSize!
            }
            if self.diskType != nil {
                map["DiskType"] = self.diskType!
            }
            if self.enableReadOnlyReplicaManagement != nil {
                map["EnableReadOnlyReplicaManagement"] = self.enableReadOnlyReplicaManagement!
            }
            if self.enableUpgradeNodes != nil {
                map["EnableUpgradeNodes"] = self.enableUpgradeNodes!
            }
            if self.expireSeconds != nil {
                map["ExpireSeconds"] = self.expireSeconds!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.inTempCapacityStatus != nil {
                map["InTempCapacityStatus"] = self.inTempCapacityStatus!
            }
            if self.instanceClass != nil {
                map["InstanceClass"] = self.instanceClass!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.instanceRole != nil {
                map["InstanceRole"] = self.instanceRole!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.maintainTime != nil {
                map["MaintainTime"] = self.maintainTime!
            }
            if self.mem != nil {
                map["Mem"] = self.mem!
            }
            if self.payType != nil {
                map["PayType"] = self.payType!
            }
            if self.resource != nil {
                map["Resource"] = self.resource?.toMap()
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.series != nil {
                map["Series"] = self.series!
            }
            if self.specType != nil {
                map["SpecType"] = self.specType!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.usedDiskSize != nil {
                map["UsedDiskSize"] = self.usedDiskSize!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvailableZones") {
                self.availableZones = dict["AvailableZones"] as! [String]
            }
            if dict.keys.contains("CommodityCode") {
                self.commodityCode = dict["CommodityCode"] as! String
            }
            if dict.keys.contains("Cpu") {
                self.cpu = dict["Cpu"] as! Int32
            }
            if dict.keys.contains("CpuArchitecture") {
                self.cpuArchitecture = dict["CpuArchitecture"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DataDiskAutoScaleConfig") {
                var model = DescribeInstancesResponseBody.Instances.DataDiskAutoScaleConfig()
                model.fromMap(dict["DataDiskAutoScaleConfig"] as! [String: Any])
                self.dataDiskAutoScaleConfig = model
            }
            if dict.keys.contains("DeployMode") {
                self.deployMode = dict["DeployMode"] as! String
            }
            if dict.keys.contains("DeployType") {
                self.deployType = dict["DeployType"] as! String
            }
            if dict.keys.contains("DiskSize") {
                self.diskSize = dict["DiskSize"] as! String
            }
            if dict.keys.contains("DiskType") {
                self.diskType = dict["DiskType"] as! String
            }
            if dict.keys.contains("EnableReadOnlyReplicaManagement") {
                self.enableReadOnlyReplicaManagement = dict["EnableReadOnlyReplicaManagement"] as! Bool
            }
            if dict.keys.contains("EnableUpgradeNodes") {
                self.enableUpgradeNodes = dict["EnableUpgradeNodes"] as! Bool
            }
            if dict.keys.contains("ExpireSeconds") {
                self.expireSeconds = dict["ExpireSeconds"] as! Int32
            }
            if dict.keys.contains("ExpireTime") {
                self.expireTime = dict["ExpireTime"] as! String
            }
            if dict.keys.contains("InTempCapacityStatus") {
                self.inTempCapacityStatus = dict["InTempCapacityStatus"] as! Bool
            }
            if dict.keys.contains("InstanceClass") {
                self.instanceClass = dict["InstanceClass"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InstanceRole") {
                self.instanceRole = dict["InstanceRole"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("MaintainTime") {
                self.maintainTime = dict["MaintainTime"] as! String
            }
            if dict.keys.contains("Mem") {
                self.mem = dict["Mem"] as! Int64
            }
            if dict.keys.contains("PayType") {
                self.payType = dict["PayType"] as! String
            }
            if dict.keys.contains("Resource") {
                var model = DescribeInstancesResponseBody.Instances.Resource()
                model.fromMap(dict["Resource"] as! [String: Any])
                self.resource = model
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Series") {
                self.series = dict["Series"] as! String
            }
            if dict.keys.contains("SpecType") {
                self.specType = dict["SpecType"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("UsedDiskSize") {
                self.usedDiskSize = dict["UsedDiskSize"] as! Int64
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var instances: [DescribeInstancesResponseBody.Instances]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            var tmp : [Any] = []
            for k in self.instances! {
                tmp.append(k.toMap())
            }
            map["Instances"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Instances") {
            var tmp : [DescribeInstancesResponseBody.Instances] = []
            for v in dict["Instances"] as! [Any] {
                var model = DescribeInstancesResponseBody.Instances()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instances = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMetricsDataRequest : Tea.TeaModel {
    public var endTime: String?

    public var groupByLabels: String?

    public var instanceId: String?

    public var labels: String?

    public var limit: String?

    public var metrics: String?

    public var replicaType: String?

    public var sortMetricKey: String?

    public var sortOrder: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.groupByLabels != nil {
            map["GroupByLabels"] = self.groupByLabels!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.labels != nil {
            map["Labels"] = self.labels!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.metrics != nil {
            map["Metrics"] = self.metrics!
        }
        if self.replicaType != nil {
            map["ReplicaType"] = self.replicaType!
        }
        if self.sortMetricKey != nil {
            map["SortMetricKey"] = self.sortMetricKey!
        }
        if self.sortOrder != nil {
            map["SortOrder"] = self.sortOrder!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("GroupByLabels") {
            self.groupByLabels = dict["GroupByLabels"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Labels") {
            self.labels = dict["Labels"] as! String
        }
        if dict.keys.contains("Limit") {
            self.limit = dict["Limit"] as! String
        }
        if dict.keys.contains("Metrics") {
            self.metrics = dict["Metrics"] as! String
        }
        if dict.keys.contains("ReplicaType") {
            self.replicaType = dict["ReplicaType"] as! String
        }
        if dict.keys.contains("SortMetricKey") {
            self.sortMetricKey = dict["SortMetricKey"] as! String
        }
        if dict.keys.contains("SortOrder") {
            self.sortOrder = dict["SortOrder"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeMetricsDataResponseBody : Tea.TeaModel {
    public var data: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMetricsDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMetricsDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMetricsDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNodeMetricsRequest : Tea.TeaModel {
    public var endTime: String?

    public var instanceId: String?

    public var metrics: String?

    public var nodeIdList: String?

    public var nodeName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTime: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.metrics != nil {
            map["Metrics"] = self.metrics!
        }
        if self.nodeIdList != nil {
            map["NodeIdList"] = self.nodeIdList!
        }
        if self.nodeName != nil {
            map["NodeName"] = self.nodeName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Metrics") {
            self.metrics = dict["Metrics"] as! String
        }
        if dict.keys.contains("NodeIdList") {
            self.nodeIdList = dict["NodeIdList"] as! String
        }
        if dict.keys.contains("NodeName") {
            self.nodeName = dict["NodeName"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DescribeNodeMetricsResponseBody : Tea.TeaModel {
    public var nodeMetrics: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeMetrics != nil {
            map["NodeMetrics"] = self.nodeMetrics!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeMetrics") {
            self.nodeMetrics = dict["NodeMetrics"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeNodeMetricsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNodeMetricsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNodeMetricsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOasAnomalySQLListRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var current: Int64?

    public var dbName: String?

    public var dynamicSql: Bool?

    public var endTime: String?

    public var filterCondition: String?

    public var instanceId: String?

    public var mergeDynamicSql: Bool?

    public var nodeIp: String?

    public var pageSize: Int64?

    public var searchKeyWord: String?

    public var searchParam: String?

    public var searchRule: String?

    public var searchValue: String?

    public var sqlId: String?

    public var sqlTextLength: Int64?

    public var startTime: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.current != nil {
            map["Current"] = self.current!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.dynamicSql != nil {
            map["DynamicSql"] = self.dynamicSql!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.filterCondition != nil {
            map["FilterCondition"] = self.filterCondition!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mergeDynamicSql != nil {
            map["MergeDynamicSql"] = self.mergeDynamicSql!
        }
        if self.nodeIp != nil {
            map["NodeIp"] = self.nodeIp!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchKeyWord != nil {
            map["SearchKeyWord"] = self.searchKeyWord!
        }
        if self.searchParam != nil {
            map["SearchParam"] = self.searchParam!
        }
        if self.searchRule != nil {
            map["SearchRule"] = self.searchRule!
        }
        if self.searchValue != nil {
            map["SearchValue"] = self.searchValue!
        }
        if self.sqlId != nil {
            map["SqlId"] = self.sqlId!
        }
        if self.sqlTextLength != nil {
            map["SqlTextLength"] = self.sqlTextLength!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("Current") {
            self.current = dict["Current"] as! Int64
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("DynamicSql") {
            self.dynamicSql = dict["DynamicSql"] as! Bool
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("FilterCondition") {
            self.filterCondition = dict["FilterCondition"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MergeDynamicSql") {
            self.mergeDynamicSql = dict["MergeDynamicSql"] as! Bool
        }
        if dict.keys.contains("NodeIp") {
            self.nodeIp = dict["NodeIp"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SearchKeyWord") {
            self.searchKeyWord = dict["SearchKeyWord"] as! String
        }
        if dict.keys.contains("SearchParam") {
            self.searchParam = dict["SearchParam"] as! String
        }
        if dict.keys.contains("SearchRule") {
            self.searchRule = dict["SearchRule"] as! String
        }
        if dict.keys.contains("SearchValue") {
            self.searchValue = dict["SearchValue"] as! String
        }
        if dict.keys.contains("SqlId") {
            self.sqlId = dict["SqlId"] as! String
        }
        if dict.keys.contains("SqlTextLength") {
            self.sqlTextLength = dict["SqlTextLength"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DescribeOasAnomalySQLListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SqlList : Tea.TeaModel {
            public var avgCpuTime: Double?

            public var avgDbTime: Double?

            public var avgElapsedTime: Double?

            public var avgGetPlanTime: Double?

            public var avgLogicalReads: Double?

            public var avgRetryCount: Double?

            public var cpuTime: Double?

            public var dbName: String?

            public var diagTypes: [String]?

            public var diagnosis: String?

            public var executions: Double?

            public var lastExecutedTime: Double?

            public var riskLevel: String?

            public var sqlId: String?

            public var sqlTextShort: String?

            public var suggestion: String?

            public var sumDbTime: Double?

            public var sumElapsedTime: String?

            public var sumRetryCount: Double?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avgCpuTime != nil {
                    map["AvgCpuTime"] = self.avgCpuTime!
                }
                if self.avgDbTime != nil {
                    map["AvgDbTime"] = self.avgDbTime!
                }
                if self.avgElapsedTime != nil {
                    map["AvgElapsedTime"] = self.avgElapsedTime!
                }
                if self.avgGetPlanTime != nil {
                    map["AvgGetPlanTime"] = self.avgGetPlanTime!
                }
                if self.avgLogicalReads != nil {
                    map["AvgLogicalReads"] = self.avgLogicalReads!
                }
                if self.avgRetryCount != nil {
                    map["AvgRetryCount"] = self.avgRetryCount!
                }
                if self.cpuTime != nil {
                    map["CpuTime"] = self.cpuTime!
                }
                if self.dbName != nil {
                    map["DbName"] = self.dbName!
                }
                if self.diagTypes != nil {
                    map["DiagTypes"] = self.diagTypes!
                }
                if self.diagnosis != nil {
                    map["Diagnosis"] = self.diagnosis!
                }
                if self.executions != nil {
                    map["Executions"] = self.executions!
                }
                if self.lastExecutedTime != nil {
                    map["LastExecutedTime"] = self.lastExecutedTime!
                }
                if self.riskLevel != nil {
                    map["RiskLevel"] = self.riskLevel!
                }
                if self.sqlId != nil {
                    map["SqlId"] = self.sqlId!
                }
                if self.sqlTextShort != nil {
                    map["SqlTextShort"] = self.sqlTextShort!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                if self.sumDbTime != nil {
                    map["SumDbTime"] = self.sumDbTime!
                }
                if self.sumElapsedTime != nil {
                    map["SumElapsedTime"] = self.sumElapsedTime!
                }
                if self.sumRetryCount != nil {
                    map["SumRetryCount"] = self.sumRetryCount!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvgCpuTime") {
                    self.avgCpuTime = dict["AvgCpuTime"] as! Double
                }
                if dict.keys.contains("AvgDbTime") {
                    self.avgDbTime = dict["AvgDbTime"] as! Double
                }
                if dict.keys.contains("AvgElapsedTime") {
                    self.avgElapsedTime = dict["AvgElapsedTime"] as! Double
                }
                if dict.keys.contains("AvgGetPlanTime") {
                    self.avgGetPlanTime = dict["AvgGetPlanTime"] as! Double
                }
                if dict.keys.contains("AvgLogicalReads") {
                    self.avgLogicalReads = dict["AvgLogicalReads"] as! Double
                }
                if dict.keys.contains("AvgRetryCount") {
                    self.avgRetryCount = dict["AvgRetryCount"] as! Double
                }
                if dict.keys.contains("CpuTime") {
                    self.cpuTime = dict["CpuTime"] as! Double
                }
                if dict.keys.contains("DbName") {
                    self.dbName = dict["DbName"] as! String
                }
                if dict.keys.contains("DiagTypes") {
                    self.diagTypes = dict["DiagTypes"] as! [String]
                }
                if dict.keys.contains("Diagnosis") {
                    self.diagnosis = dict["Diagnosis"] as! String
                }
                if dict.keys.contains("Executions") {
                    self.executions = dict["Executions"] as! Double
                }
                if dict.keys.contains("LastExecutedTime") {
                    self.lastExecutedTime = dict["LastExecutedTime"] as! Double
                }
                if dict.keys.contains("RiskLevel") {
                    self.riskLevel = dict["RiskLevel"] as! String
                }
                if dict.keys.contains("SqlId") {
                    self.sqlId = dict["SqlId"] as! String
                }
                if dict.keys.contains("SqlTextShort") {
                    self.sqlTextShort = dict["SqlTextShort"] as! String
                }
                if dict.keys.contains("Suggestion") {
                    self.suggestion = dict["Suggestion"] as! String
                }
                if dict.keys.contains("SumDbTime") {
                    self.sumDbTime = dict["SumDbTime"] as! Double
                }
                if dict.keys.contains("SumElapsedTime") {
                    self.sumElapsedTime = dict["SumElapsedTime"] as! String
                }
                if dict.keys.contains("SumRetryCount") {
                    self.sumRetryCount = dict["SumRetryCount"] as! Double
                }
                if dict.keys.contains("UserName") {
                    self.userName = dict["UserName"] as! String
                }
            }
        }
        public var avgCpuTime: Double?

        public var avgDbTime: Double?

        public var avgElapsedTime: Double?

        public var avgGetPlanTime: Double?

        public var avgLogicalReads: Double?

        public var avgRetryCount: Double?

        public var cpuTime: Double?

        public var dbName: String?

        public var diagTypes: [String]?

        public var diagnosis: String?

        public var dynamicSql: Bool?

        public var executions: Double?

        public var lastExecutedTime: Double?

        public var riskLevel: String?

        public var sqlId: String?

        public var sqlList: [DescribeOasAnomalySQLListResponseBody.Data.SqlList]?

        public var sqlTextShort: String?

        public var suggestion: String?

        public var sumDbTime: Double?

        public var sumElapsedTime: String?

        public var sumRetryCount: Double?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avgCpuTime != nil {
                map["AvgCpuTime"] = self.avgCpuTime!
            }
            if self.avgDbTime != nil {
                map["AvgDbTime"] = self.avgDbTime!
            }
            if self.avgElapsedTime != nil {
                map["AvgElapsedTime"] = self.avgElapsedTime!
            }
            if self.avgGetPlanTime != nil {
                map["AvgGetPlanTime"] = self.avgGetPlanTime!
            }
            if self.avgLogicalReads != nil {
                map["AvgLogicalReads"] = self.avgLogicalReads!
            }
            if self.avgRetryCount != nil {
                map["AvgRetryCount"] = self.avgRetryCount!
            }
            if self.cpuTime != nil {
                map["CpuTime"] = self.cpuTime!
            }
            if self.dbName != nil {
                map["DbName"] = self.dbName!
            }
            if self.diagTypes != nil {
                map["DiagTypes"] = self.diagTypes!
            }
            if self.diagnosis != nil {
                map["Diagnosis"] = self.diagnosis!
            }
            if self.dynamicSql != nil {
                map["DynamicSql"] = self.dynamicSql!
            }
            if self.executions != nil {
                map["Executions"] = self.executions!
            }
            if self.lastExecutedTime != nil {
                map["LastExecutedTime"] = self.lastExecutedTime!
            }
            if self.riskLevel != nil {
                map["RiskLevel"] = self.riskLevel!
            }
            if self.sqlId != nil {
                map["SqlId"] = self.sqlId!
            }
            if self.sqlList != nil {
                var tmp : [Any] = []
                for k in self.sqlList! {
                    tmp.append(k.toMap())
                }
                map["SqlList"] = tmp
            }
            if self.sqlTextShort != nil {
                map["SqlTextShort"] = self.sqlTextShort!
            }
            if self.suggestion != nil {
                map["Suggestion"] = self.suggestion!
            }
            if self.sumDbTime != nil {
                map["SumDbTime"] = self.sumDbTime!
            }
            if self.sumElapsedTime != nil {
                map["SumElapsedTime"] = self.sumElapsedTime!
            }
            if self.sumRetryCount != nil {
                map["SumRetryCount"] = self.sumRetryCount!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvgCpuTime") {
                self.avgCpuTime = dict["AvgCpuTime"] as! Double
            }
            if dict.keys.contains("AvgDbTime") {
                self.avgDbTime = dict["AvgDbTime"] as! Double
            }
            if dict.keys.contains("AvgElapsedTime") {
                self.avgElapsedTime = dict["AvgElapsedTime"] as! Double
            }
            if dict.keys.contains("AvgGetPlanTime") {
                self.avgGetPlanTime = dict["AvgGetPlanTime"] as! Double
            }
            if dict.keys.contains("AvgLogicalReads") {
                self.avgLogicalReads = dict["AvgLogicalReads"] as! Double
            }
            if dict.keys.contains("AvgRetryCount") {
                self.avgRetryCount = dict["AvgRetryCount"] as! Double
            }
            if dict.keys.contains("CpuTime") {
                self.cpuTime = dict["CpuTime"] as! Double
            }
            if dict.keys.contains("DbName") {
                self.dbName = dict["DbName"] as! String
            }
            if dict.keys.contains("DiagTypes") {
                self.diagTypes = dict["DiagTypes"] as! [String]
            }
            if dict.keys.contains("Diagnosis") {
                self.diagnosis = dict["Diagnosis"] as! String
            }
            if dict.keys.contains("DynamicSql") {
                self.dynamicSql = dict["DynamicSql"] as! Bool
            }
            if dict.keys.contains("Executions") {
                self.executions = dict["Executions"] as! Double
            }
            if dict.keys.contains("LastExecutedTime") {
                self.lastExecutedTime = dict["LastExecutedTime"] as! Double
            }
            if dict.keys.contains("RiskLevel") {
                self.riskLevel = dict["RiskLevel"] as! String
            }
            if dict.keys.contains("SqlId") {
                self.sqlId = dict["SqlId"] as! String
            }
            if dict.keys.contains("SqlList") {
                var tmp : [DescribeOasAnomalySQLListResponseBody.Data.SqlList] = []
                for v in dict["SqlList"] as! [Any] {
                    var model = DescribeOasAnomalySQLListResponseBody.Data.SqlList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sqlList = tmp
            }
            if dict.keys.contains("SqlTextShort") {
                self.sqlTextShort = dict["SqlTextShort"] as! String
            }
            if dict.keys.contains("Suggestion") {
                self.suggestion = dict["Suggestion"] as! String
            }
            if dict.keys.contains("SumDbTime") {
                self.sumDbTime = dict["SumDbTime"] as! Double
            }
            if dict.keys.contains("SumElapsedTime") {
                self.sumElapsedTime = dict["SumElapsedTime"] as! String
            }
            if dict.keys.contains("SumRetryCount") {
                self.sumRetryCount = dict["SumRetryCount"] as! Double
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public var data: [DescribeOasAnomalySQLListResponseBody.Data]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [DescribeOasAnomalySQLListResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeOasAnomalySQLListResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeOasAnomalySQLListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOasAnomalySQLListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOasAnomalySQLListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOasSQLDetailsRequest : Tea.TeaModel {
    public var dbName: String?

    public var dynamicSql: Bool?

    public var endTime: String?

    public var instanceId: String?

    public var sqlId: String?

    public var startTime: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.dynamicSql != nil {
            map["DynamicSql"] = self.dynamicSql!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.sqlId != nil {
            map["SqlId"] = self.sqlId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("DynamicSql") {
            self.dynamicSql = dict["DynamicSql"] as! Bool
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SqlId") {
            self.sqlId = dict["SqlId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DescribeOasSQLDetailsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var dbName: String?

        public var fulltext: String?

        public var statement: String?

        public var tables: [String]?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dbName != nil {
                map["DbName"] = self.dbName!
            }
            if self.fulltext != nil {
                map["Fulltext"] = self.fulltext!
            }
            if self.statement != nil {
                map["Statement"] = self.statement!
            }
            if self.tables != nil {
                map["Tables"] = self.tables!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DbName") {
                self.dbName = dict["DbName"] as! String
            }
            if dict.keys.contains("Fulltext") {
                self.fulltext = dict["Fulltext"] as! String
            }
            if dict.keys.contains("Statement") {
                self.statement = dict["Statement"] as! String
            }
            if dict.keys.contains("Tables") {
                self.tables = dict["Tables"] as! [String]
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public var data: DescribeOasSQLDetailsResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DescribeOasSQLDetailsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeOasSQLDetailsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOasSQLDetailsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOasSQLDetailsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOasSQLHistoryListRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var dbName: String?

    public var dynamicSql: Bool?

    public var endTime: String?

    public var instanceId: String?

    public var nodeIp: String?

    public var sqlId: String?

    public var startTime: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.dynamicSql != nil {
            map["DynamicSql"] = self.dynamicSql!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeIp != nil {
            map["NodeIp"] = self.nodeIp!
        }
        if self.sqlId != nil {
            map["SqlId"] = self.sqlId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("DynamicSql") {
            self.dynamicSql = dict["DynamicSql"] as! Bool
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeIp") {
            self.nodeIp = dict["NodeIp"] as! String
        }
        if dict.keys.contains("SqlId") {
            self.sqlId = dict["SqlId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DescribeOasSQLHistoryListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var avgAffectedRows: Int64?

        public var avgApplicationWaitTime: Double?

        public var avgBlockCacheHit: Int64?

        public var avgBlockIndexCacheHit: Int64?

        public var avgBloomFilterCacheHit: Int64?

        public var avgConcurrencyWaitTime: Double?

        public var avgCpuTime: Double?

        public var avgDbTime: Double?

        public var avgDecodeTime: Double?

        public var avgDiskReads: Int64?

        public var avgElapsedTime: Double?

        public var avgExecuteTime: Double?

        public var avgExecutorRpcCount: Double?

        public var avgExpectedWorkerCount: Double?

        public var avgGetPlanTime: Double?

        public var avgLogicalReads: Int64?

        public var avgMemstoreReadRows: Int64?

        public var avgNetTime: Double?

        public var avgNetWaitTime: Double?

        public var avgPartitionCount: Double?

        public var avgQueueTime: Double?

        public var avgReturnRows: Int64?

        public var avgRowCacheHit: Int64?

        public var avgRpcCount: Int64?

        public var avgScheduleTime: Double?

        public var avgSsstoreReadRows: Int64?

        public var avgUsedWorkerCount: Double?

        public var avgUserIoWaitTime: Double?

        public var avgWaitCount: Double?

        public var avgWaitTime: Double?

        public var dbName: String?

        public var distPlanPercentage: Double?

        public var execPs: Double?

        public var executions: Int64?

        public var failCount: Int64?

        public var failPercentage: Double?

        public var localPlanPercentage: Double?

        public var maxAffectedRows: Double?

        public var maxApplicationWaitTime: Double?

        public var maxConcurrencyWaitTime: Double?

        public var maxCpuTime: Double?

        public var maxDiskReads: Double?

        public var maxElapsedTime: Double?

        public var maxReturnRows: Double?

        public var maxUserIoWaitTime: Double?

        public var maxWaitTime: Double?

        public var missPlanPercentage: Double?

        public var missPlans: Int64?

        public var remotePlanPercentage: Double?

        public var remotePlans: Int64?

        public var retCode4012Count: Double?

        public var retCode4013Count: Double?

        public var retCode5001Count: Double?

        public var retCode5024Count: Double?

        public var retCode5167Count: Double?

        public var retCode5217Count: Double?

        public var retCode6002Count: Double?

        public var retryCount: Int64?

        public var SQLId: String?

        public var server: String?

        public var strongConsistencyPercentage: Double?

        public var sumDbTime: Double?

        public var sumElapsedTime: Double?

        public var sumLogicalReads: Double?

        public var sumWaitTime: Double?

        public var tableScanPercentage: Double?

        public var timestamp: String?

        public var userName: String?

        public var weakConsistencyPercentage: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avgAffectedRows != nil {
                map["AvgAffectedRows"] = self.avgAffectedRows!
            }
            if self.avgApplicationWaitTime != nil {
                map["AvgApplicationWaitTime"] = self.avgApplicationWaitTime!
            }
            if self.avgBlockCacheHit != nil {
                map["AvgBlockCacheHit"] = self.avgBlockCacheHit!
            }
            if self.avgBlockIndexCacheHit != nil {
                map["AvgBlockIndexCacheHit"] = self.avgBlockIndexCacheHit!
            }
            if self.avgBloomFilterCacheHit != nil {
                map["AvgBloomFilterCacheHit"] = self.avgBloomFilterCacheHit!
            }
            if self.avgConcurrencyWaitTime != nil {
                map["AvgConcurrencyWaitTime"] = self.avgConcurrencyWaitTime!
            }
            if self.avgCpuTime != nil {
                map["AvgCpuTime"] = self.avgCpuTime!
            }
            if self.avgDbTime != nil {
                map["AvgDbTime"] = self.avgDbTime!
            }
            if self.avgDecodeTime != nil {
                map["AvgDecodeTime"] = self.avgDecodeTime!
            }
            if self.avgDiskReads != nil {
                map["AvgDiskReads"] = self.avgDiskReads!
            }
            if self.avgElapsedTime != nil {
                map["AvgElapsedTime"] = self.avgElapsedTime!
            }
            if self.avgExecuteTime != nil {
                map["AvgExecuteTime"] = self.avgExecuteTime!
            }
            if self.avgExecutorRpcCount != nil {
                map["AvgExecutorRpcCount"] = self.avgExecutorRpcCount!
            }
            if self.avgExpectedWorkerCount != nil {
                map["AvgExpectedWorkerCount"] = self.avgExpectedWorkerCount!
            }
            if self.avgGetPlanTime != nil {
                map["AvgGetPlanTime"] = self.avgGetPlanTime!
            }
            if self.avgLogicalReads != nil {
                map["AvgLogicalReads"] = self.avgLogicalReads!
            }
            if self.avgMemstoreReadRows != nil {
                map["AvgMemstoreReadRows"] = self.avgMemstoreReadRows!
            }
            if self.avgNetTime != nil {
                map["AvgNetTime"] = self.avgNetTime!
            }
            if self.avgNetWaitTime != nil {
                map["AvgNetWaitTime"] = self.avgNetWaitTime!
            }
            if self.avgPartitionCount != nil {
                map["AvgPartitionCount"] = self.avgPartitionCount!
            }
            if self.avgQueueTime != nil {
                map["AvgQueueTime"] = self.avgQueueTime!
            }
            if self.avgReturnRows != nil {
                map["AvgReturnRows"] = self.avgReturnRows!
            }
            if self.avgRowCacheHit != nil {
                map["AvgRowCacheHit"] = self.avgRowCacheHit!
            }
            if self.avgRpcCount != nil {
                map["AvgRpcCount"] = self.avgRpcCount!
            }
            if self.avgScheduleTime != nil {
                map["AvgScheduleTime"] = self.avgScheduleTime!
            }
            if self.avgSsstoreReadRows != nil {
                map["AvgSsstoreReadRows"] = self.avgSsstoreReadRows!
            }
            if self.avgUsedWorkerCount != nil {
                map["AvgUsedWorkerCount"] = self.avgUsedWorkerCount!
            }
            if self.avgUserIoWaitTime != nil {
                map["AvgUserIoWaitTime"] = self.avgUserIoWaitTime!
            }
            if self.avgWaitCount != nil {
                map["AvgWaitCount"] = self.avgWaitCount!
            }
            if self.avgWaitTime != nil {
                map["AvgWaitTime"] = self.avgWaitTime!
            }
            if self.dbName != nil {
                map["DbName"] = self.dbName!
            }
            if self.distPlanPercentage != nil {
                map["DistPlanPercentage"] = self.distPlanPercentage!
            }
            if self.execPs != nil {
                map["ExecPs"] = self.execPs!
            }
            if self.executions != nil {
                map["Executions"] = self.executions!
            }
            if self.failCount != nil {
                map["FailCount"] = self.failCount!
            }
            if self.failPercentage != nil {
                map["FailPercentage"] = self.failPercentage!
            }
            if self.localPlanPercentage != nil {
                map["LocalPlanPercentage"] = self.localPlanPercentage!
            }
            if self.maxAffectedRows != nil {
                map["MaxAffectedRows"] = self.maxAffectedRows!
            }
            if self.maxApplicationWaitTime != nil {
                map["MaxApplicationWaitTime"] = self.maxApplicationWaitTime!
            }
            if self.maxConcurrencyWaitTime != nil {
                map["MaxConcurrencyWaitTime"] = self.maxConcurrencyWaitTime!
            }
            if self.maxCpuTime != nil {
                map["MaxCpuTime"] = self.maxCpuTime!
            }
            if self.maxDiskReads != nil {
                map["MaxDiskReads"] = self.maxDiskReads!
            }
            if self.maxElapsedTime != nil {
                map["MaxElapsedTime"] = self.maxElapsedTime!
            }
            if self.maxReturnRows != nil {
                map["MaxReturnRows"] = self.maxReturnRows!
            }
            if self.maxUserIoWaitTime != nil {
                map["MaxUserIoWaitTime"] = self.maxUserIoWaitTime!
            }
            if self.maxWaitTime != nil {
                map["MaxWaitTime"] = self.maxWaitTime!
            }
            if self.missPlanPercentage != nil {
                map["MissPlanPercentage"] = self.missPlanPercentage!
            }
            if self.missPlans != nil {
                map["MissPlans"] = self.missPlans!
            }
            if self.remotePlanPercentage != nil {
                map["RemotePlanPercentage"] = self.remotePlanPercentage!
            }
            if self.remotePlans != nil {
                map["RemotePlans"] = self.remotePlans!
            }
            if self.retCode4012Count != nil {
                map["RetCode4012Count"] = self.retCode4012Count!
            }
            if self.retCode4013Count != nil {
                map["RetCode4013Count"] = self.retCode4013Count!
            }
            if self.retCode5001Count != nil {
                map["RetCode5001Count"] = self.retCode5001Count!
            }
            if self.retCode5024Count != nil {
                map["RetCode5024Count"] = self.retCode5024Count!
            }
            if self.retCode5167Count != nil {
                map["RetCode5167Count"] = self.retCode5167Count!
            }
            if self.retCode5217Count != nil {
                map["RetCode5217Count"] = self.retCode5217Count!
            }
            if self.retCode6002Count != nil {
                map["RetCode6002Count"] = self.retCode6002Count!
            }
            if self.retryCount != nil {
                map["RetryCount"] = self.retryCount!
            }
            if self.SQLId != nil {
                map["SQLId"] = self.SQLId!
            }
            if self.server != nil {
                map["Server"] = self.server!
            }
            if self.strongConsistencyPercentage != nil {
                map["StrongConsistencyPercentage"] = self.strongConsistencyPercentage!
            }
            if self.sumDbTime != nil {
                map["SumDbTime"] = self.sumDbTime!
            }
            if self.sumElapsedTime != nil {
                map["SumElapsedTime"] = self.sumElapsedTime!
            }
            if self.sumLogicalReads != nil {
                map["SumLogicalReads"] = self.sumLogicalReads!
            }
            if self.sumWaitTime != nil {
                map["SumWaitTime"] = self.sumWaitTime!
            }
            if self.tableScanPercentage != nil {
                map["TableScanPercentage"] = self.tableScanPercentage!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            if self.weakConsistencyPercentage != nil {
                map["WeakConsistencyPercentage"] = self.weakConsistencyPercentage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvgAffectedRows") {
                self.avgAffectedRows = dict["AvgAffectedRows"] as! Int64
            }
            if dict.keys.contains("AvgApplicationWaitTime") {
                self.avgApplicationWaitTime = dict["AvgApplicationWaitTime"] as! Double
            }
            if dict.keys.contains("AvgBlockCacheHit") {
                self.avgBlockCacheHit = dict["AvgBlockCacheHit"] as! Int64
            }
            if dict.keys.contains("AvgBlockIndexCacheHit") {
                self.avgBlockIndexCacheHit = dict["AvgBlockIndexCacheHit"] as! Int64
            }
            if dict.keys.contains("AvgBloomFilterCacheHit") {
                self.avgBloomFilterCacheHit = dict["AvgBloomFilterCacheHit"] as! Int64
            }
            if dict.keys.contains("AvgConcurrencyWaitTime") {
                self.avgConcurrencyWaitTime = dict["AvgConcurrencyWaitTime"] as! Double
            }
            if dict.keys.contains("AvgCpuTime") {
                self.avgCpuTime = dict["AvgCpuTime"] as! Double
            }
            if dict.keys.contains("AvgDbTime") {
                self.avgDbTime = dict["AvgDbTime"] as! Double
            }
            if dict.keys.contains("AvgDecodeTime") {
                self.avgDecodeTime = dict["AvgDecodeTime"] as! Double
            }
            if dict.keys.contains("AvgDiskReads") {
                self.avgDiskReads = dict["AvgDiskReads"] as! Int64
            }
            if dict.keys.contains("AvgElapsedTime") {
                self.avgElapsedTime = dict["AvgElapsedTime"] as! Double
            }
            if dict.keys.contains("AvgExecuteTime") {
                self.avgExecuteTime = dict["AvgExecuteTime"] as! Double
            }
            if dict.keys.contains("AvgExecutorRpcCount") {
                self.avgExecutorRpcCount = dict["AvgExecutorRpcCount"] as! Double
            }
            if dict.keys.contains("AvgExpectedWorkerCount") {
                self.avgExpectedWorkerCount = dict["AvgExpectedWorkerCount"] as! Double
            }
            if dict.keys.contains("AvgGetPlanTime") {
                self.avgGetPlanTime = dict["AvgGetPlanTime"] as! Double
            }
            if dict.keys.contains("AvgLogicalReads") {
                self.avgLogicalReads = dict["AvgLogicalReads"] as! Int64
            }
            if dict.keys.contains("AvgMemstoreReadRows") {
                self.avgMemstoreReadRows = dict["AvgMemstoreReadRows"] as! Int64
            }
            if dict.keys.contains("AvgNetTime") {
                self.avgNetTime = dict["AvgNetTime"] as! Double
            }
            if dict.keys.contains("AvgNetWaitTime") {
                self.avgNetWaitTime = dict["AvgNetWaitTime"] as! Double
            }
            if dict.keys.contains("AvgPartitionCount") {
                self.avgPartitionCount = dict["AvgPartitionCount"] as! Double
            }
            if dict.keys.contains("AvgQueueTime") {
                self.avgQueueTime = dict["AvgQueueTime"] as! Double
            }
            if dict.keys.contains("AvgReturnRows") {
                self.avgReturnRows = dict["AvgReturnRows"] as! Int64
            }
            if dict.keys.contains("AvgRowCacheHit") {
                self.avgRowCacheHit = dict["AvgRowCacheHit"] as! Int64
            }
            if dict.keys.contains("AvgRpcCount") {
                self.avgRpcCount = dict["AvgRpcCount"] as! Int64
            }
            if dict.keys.contains("AvgScheduleTime") {
                self.avgScheduleTime = dict["AvgScheduleTime"] as! Double
            }
            if dict.keys.contains("AvgSsstoreReadRows") {
                self.avgSsstoreReadRows = dict["AvgSsstoreReadRows"] as! Int64
            }
            if dict.keys.contains("AvgUsedWorkerCount") {
                self.avgUsedWorkerCount = dict["AvgUsedWorkerCount"] as! Double
            }
            if dict.keys.contains("AvgUserIoWaitTime") {
                self.avgUserIoWaitTime = dict["AvgUserIoWaitTime"] as! Double
            }
            if dict.keys.contains("AvgWaitCount") {
                self.avgWaitCount = dict["AvgWaitCount"] as! Double
            }
            if dict.keys.contains("AvgWaitTime") {
                self.avgWaitTime = dict["AvgWaitTime"] as! Double
            }
            if dict.keys.contains("DbName") {
                self.dbName = dict["DbName"] as! String
            }
            if dict.keys.contains("DistPlanPercentage") {
                self.distPlanPercentage = dict["DistPlanPercentage"] as! Double
            }
            if dict.keys.contains("ExecPs") {
                self.execPs = dict["ExecPs"] as! Double
            }
            if dict.keys.contains("Executions") {
                self.executions = dict["Executions"] as! Int64
            }
            if dict.keys.contains("FailCount") {
                self.failCount = dict["FailCount"] as! Int64
            }
            if dict.keys.contains("FailPercentage") {
                self.failPercentage = dict["FailPercentage"] as! Double
            }
            if dict.keys.contains("LocalPlanPercentage") {
                self.localPlanPercentage = dict["LocalPlanPercentage"] as! Double
            }
            if dict.keys.contains("MaxAffectedRows") {
                self.maxAffectedRows = dict["MaxAffectedRows"] as! Double
            }
            if dict.keys.contains("MaxApplicationWaitTime") {
                self.maxApplicationWaitTime = dict["MaxApplicationWaitTime"] as! Double
            }
            if dict.keys.contains("MaxConcurrencyWaitTime") {
                self.maxConcurrencyWaitTime = dict["MaxConcurrencyWaitTime"] as! Double
            }
            if dict.keys.contains("MaxCpuTime") {
                self.maxCpuTime = dict["MaxCpuTime"] as! Double
            }
            if dict.keys.contains("MaxDiskReads") {
                self.maxDiskReads = dict["MaxDiskReads"] as! Double
            }
            if dict.keys.contains("MaxElapsedTime") {
                self.maxElapsedTime = dict["MaxElapsedTime"] as! Double
            }
            if dict.keys.contains("MaxReturnRows") {
                self.maxReturnRows = dict["MaxReturnRows"] as! Double
            }
            if dict.keys.contains("MaxUserIoWaitTime") {
                self.maxUserIoWaitTime = dict["MaxUserIoWaitTime"] as! Double
            }
            if dict.keys.contains("MaxWaitTime") {
                self.maxWaitTime = dict["MaxWaitTime"] as! Double
            }
            if dict.keys.contains("MissPlanPercentage") {
                self.missPlanPercentage = dict["MissPlanPercentage"] as! Double
            }
            if dict.keys.contains("MissPlans") {
                self.missPlans = dict["MissPlans"] as! Int64
            }
            if dict.keys.contains("RemotePlanPercentage") {
                self.remotePlanPercentage = dict["RemotePlanPercentage"] as! Double
            }
            if dict.keys.contains("RemotePlans") {
                self.remotePlans = dict["RemotePlans"] as! Int64
            }
            if dict.keys.contains("RetCode4012Count") {
                self.retCode4012Count = dict["RetCode4012Count"] as! Double
            }
            if dict.keys.contains("RetCode4013Count") {
                self.retCode4013Count = dict["RetCode4013Count"] as! Double
            }
            if dict.keys.contains("RetCode5001Count") {
                self.retCode5001Count = dict["RetCode5001Count"] as! Double
            }
            if dict.keys.contains("RetCode5024Count") {
                self.retCode5024Count = dict["RetCode5024Count"] as! Double
            }
            if dict.keys.contains("RetCode5167Count") {
                self.retCode5167Count = dict["RetCode5167Count"] as! Double
            }
            if dict.keys.contains("RetCode5217Count") {
                self.retCode5217Count = dict["RetCode5217Count"] as! Double
            }
            if dict.keys.contains("RetCode6002Count") {
                self.retCode6002Count = dict["RetCode6002Count"] as! Double
            }
            if dict.keys.contains("RetryCount") {
                self.retryCount = dict["RetryCount"] as! Int64
            }
            if dict.keys.contains("SQLId") {
                self.SQLId = dict["SQLId"] as! String
            }
            if dict.keys.contains("Server") {
                self.server = dict["Server"] as! String
            }
            if dict.keys.contains("StrongConsistencyPercentage") {
                self.strongConsistencyPercentage = dict["StrongConsistencyPercentage"] as! Double
            }
            if dict.keys.contains("SumDbTime") {
                self.sumDbTime = dict["SumDbTime"] as! Double
            }
            if dict.keys.contains("SumElapsedTime") {
                self.sumElapsedTime = dict["SumElapsedTime"] as! Double
            }
            if dict.keys.contains("SumLogicalReads") {
                self.sumLogicalReads = dict["SumLogicalReads"] as! Double
            }
            if dict.keys.contains("SumWaitTime") {
                self.sumWaitTime = dict["SumWaitTime"] as! Double
            }
            if dict.keys.contains("TableScanPercentage") {
                self.tableScanPercentage = dict["TableScanPercentage"] as! Double
            }
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! String
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
            if dict.keys.contains("WeakConsistencyPercentage") {
                self.weakConsistencyPercentage = dict["WeakConsistencyPercentage"] as! Double
            }
        }
    }
    public var data: [DescribeOasSQLHistoryListResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [DescribeOasSQLHistoryListResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeOasSQLHistoryListResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeOasSQLHistoryListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOasSQLHistoryListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOasSQLHistoryListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOasSQLPlansRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var dbName: String?

    public var dynamicSql: Bool?

    public var endTime: String?

    public var instanceId: String?

    public var planUnionHash: String?

    public var returnBriefInfo: Bool?

    public var sqlId: String?

    public var startTime: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.dynamicSql != nil {
            map["DynamicSql"] = self.dynamicSql!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.planUnionHash != nil {
            map["PlanUnionHash"] = self.planUnionHash!
        }
        if self.returnBriefInfo != nil {
            map["ReturnBriefInfo"] = self.returnBriefInfo!
        }
        if self.sqlId != nil {
            map["SqlId"] = self.sqlId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("DynamicSql") {
            self.dynamicSql = dict["DynamicSql"] as! Bool
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PlanUnionHash") {
            self.planUnionHash = dict["PlanUnionHash"] as! String
        }
        if dict.keys.contains("ReturnBriefInfo") {
            self.returnBriefInfo = dict["ReturnBriefInfo"] as! Bool
        }
        if dict.keys.contains("SqlId") {
            self.sqlId = dict["SqlId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DescribeOasSQLPlansResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class PlanExplain : Tea.TeaModel {
            public var planJsonString: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.planJsonString != nil {
                    map["PlanJsonString"] = self.planJsonString!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PlanJsonString") {
                    self.planJsonString = dict["PlanJsonString"] as! String
                }
            }
        }
        public class Plans : Tea.TeaModel {
            public var avgApplicationWaitTime: Double?

            public var avgBufferGets: Double?

            public var avgConcurrencyWaitTime: Double?

            public var avgCpuTime: Double?

            public var avgDiskReads: Double?

            public var avgDiskWrites: Double?

            public var avgElapsedTime: Double?

            public var avgRowProcessed: Double?

            public var avgUserIoWaitTime: Double?

            public var collectTimeUs: Int64?

            public var delayedLargeQueryPercentage: Double?

            public var execPs: Double?

            public var executions: Int64?

            public var firstLoadTime: String?

            public var firstLoadTimeUs: Int64?

            public var hitDiagnosis: Bool?

            public var hitPercentage: Double?

            public var largeQueryPercentage: Double?

            public var mergedVersion: Int64?

            public var obDbId: Int64?

            public var obServerId: Int64?

            public var outlineData: String?

            public var outlineId: Int64?

            public var planHash: String?

            public var planId: Int64?

            public var planSize: Int64?

            public var planType: String?

            public var planUnionHash: String?

            public var schemaVersion: Int64?

            public var server: String?

            public var serverId: Int64?

            public var sqlId: String?

            public var tableScan: Bool?

            public var timeoutPercentage: Double?

            public var uid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avgApplicationWaitTime != nil {
                    map["AvgApplicationWaitTime"] = self.avgApplicationWaitTime!
                }
                if self.avgBufferGets != nil {
                    map["AvgBufferGets"] = self.avgBufferGets!
                }
                if self.avgConcurrencyWaitTime != nil {
                    map["AvgConcurrencyWaitTime"] = self.avgConcurrencyWaitTime!
                }
                if self.avgCpuTime != nil {
                    map["AvgCpuTime"] = self.avgCpuTime!
                }
                if self.avgDiskReads != nil {
                    map["AvgDiskReads"] = self.avgDiskReads!
                }
                if self.avgDiskWrites != nil {
                    map["AvgDiskWrites"] = self.avgDiskWrites!
                }
                if self.avgElapsedTime != nil {
                    map["AvgElapsedTime"] = self.avgElapsedTime!
                }
                if self.avgRowProcessed != nil {
                    map["AvgRowProcessed"] = self.avgRowProcessed!
                }
                if self.avgUserIoWaitTime != nil {
                    map["AvgUserIoWaitTime"] = self.avgUserIoWaitTime!
                }
                if self.collectTimeUs != nil {
                    map["CollectTimeUs"] = self.collectTimeUs!
                }
                if self.delayedLargeQueryPercentage != nil {
                    map["DelayedLargeQueryPercentage"] = self.delayedLargeQueryPercentage!
                }
                if self.execPs != nil {
                    map["ExecPs"] = self.execPs!
                }
                if self.executions != nil {
                    map["Executions"] = self.executions!
                }
                if self.firstLoadTime != nil {
                    map["FirstLoadTime"] = self.firstLoadTime!
                }
                if self.firstLoadTimeUs != nil {
                    map["FirstLoadTimeUs"] = self.firstLoadTimeUs!
                }
                if self.hitDiagnosis != nil {
                    map["HitDiagnosis"] = self.hitDiagnosis!
                }
                if self.hitPercentage != nil {
                    map["HitPercentage"] = self.hitPercentage!
                }
                if self.largeQueryPercentage != nil {
                    map["LargeQueryPercentage"] = self.largeQueryPercentage!
                }
                if self.mergedVersion != nil {
                    map["MergedVersion"] = self.mergedVersion!
                }
                if self.obDbId != nil {
                    map["ObDbId"] = self.obDbId!
                }
                if self.obServerId != nil {
                    map["ObServerId"] = self.obServerId!
                }
                if self.outlineData != nil {
                    map["OutlineData"] = self.outlineData!
                }
                if self.outlineId != nil {
                    map["OutlineId"] = self.outlineId!
                }
                if self.planHash != nil {
                    map["PlanHash"] = self.planHash!
                }
                if self.planId != nil {
                    map["PlanId"] = self.planId!
                }
                if self.planSize != nil {
                    map["PlanSize"] = self.planSize!
                }
                if self.planType != nil {
                    map["PlanType"] = self.planType!
                }
                if self.planUnionHash != nil {
                    map["PlanUnionHash"] = self.planUnionHash!
                }
                if self.schemaVersion != nil {
                    map["SchemaVersion"] = self.schemaVersion!
                }
                if self.server != nil {
                    map["Server"] = self.server!
                }
                if self.serverId != nil {
                    map["ServerId"] = self.serverId!
                }
                if self.sqlId != nil {
                    map["SqlId"] = self.sqlId!
                }
                if self.tableScan != nil {
                    map["TableScan"] = self.tableScan!
                }
                if self.timeoutPercentage != nil {
                    map["TimeoutPercentage"] = self.timeoutPercentage!
                }
                if self.uid != nil {
                    map["Uid"] = self.uid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvgApplicationWaitTime") {
                    self.avgApplicationWaitTime = dict["AvgApplicationWaitTime"] as! Double
                }
                if dict.keys.contains("AvgBufferGets") {
                    self.avgBufferGets = dict["AvgBufferGets"] as! Double
                }
                if dict.keys.contains("AvgConcurrencyWaitTime") {
                    self.avgConcurrencyWaitTime = dict["AvgConcurrencyWaitTime"] as! Double
                }
                if dict.keys.contains("AvgCpuTime") {
                    self.avgCpuTime = dict["AvgCpuTime"] as! Double
                }
                if dict.keys.contains("AvgDiskReads") {
                    self.avgDiskReads = dict["AvgDiskReads"] as! Double
                }
                if dict.keys.contains("AvgDiskWrites") {
                    self.avgDiskWrites = dict["AvgDiskWrites"] as! Double
                }
                if dict.keys.contains("AvgElapsedTime") {
                    self.avgElapsedTime = dict["AvgElapsedTime"] as! Double
                }
                if dict.keys.contains("AvgRowProcessed") {
                    self.avgRowProcessed = dict["AvgRowProcessed"] as! Double
                }
                if dict.keys.contains("AvgUserIoWaitTime") {
                    self.avgUserIoWaitTime = dict["AvgUserIoWaitTime"] as! Double
                }
                if dict.keys.contains("CollectTimeUs") {
                    self.collectTimeUs = dict["CollectTimeUs"] as! Int64
                }
                if dict.keys.contains("DelayedLargeQueryPercentage") {
                    self.delayedLargeQueryPercentage = dict["DelayedLargeQueryPercentage"] as! Double
                }
                if dict.keys.contains("ExecPs") {
                    self.execPs = dict["ExecPs"] as! Double
                }
                if dict.keys.contains("Executions") {
                    self.executions = dict["Executions"] as! Int64
                }
                if dict.keys.contains("FirstLoadTime") {
                    self.firstLoadTime = dict["FirstLoadTime"] as! String
                }
                if dict.keys.contains("FirstLoadTimeUs") {
                    self.firstLoadTimeUs = dict["FirstLoadTimeUs"] as! Int64
                }
                if dict.keys.contains("HitDiagnosis") {
                    self.hitDiagnosis = dict["HitDiagnosis"] as! Bool
                }
                if dict.keys.contains("HitPercentage") {
                    self.hitPercentage = dict["HitPercentage"] as! Double
                }
                if dict.keys.contains("LargeQueryPercentage") {
                    self.largeQueryPercentage = dict["LargeQueryPercentage"] as! Double
                }
                if dict.keys.contains("MergedVersion") {
                    self.mergedVersion = dict["MergedVersion"] as! Int64
                }
                if dict.keys.contains("ObDbId") {
                    self.obDbId = dict["ObDbId"] as! Int64
                }
                if dict.keys.contains("ObServerId") {
                    self.obServerId = dict["ObServerId"] as! Int64
                }
                if dict.keys.contains("OutlineData") {
                    self.outlineData = dict["OutlineData"] as! String
                }
                if dict.keys.contains("OutlineId") {
                    self.outlineId = dict["OutlineId"] as! Int64
                }
                if dict.keys.contains("PlanHash") {
                    self.planHash = dict["PlanHash"] as! String
                }
                if dict.keys.contains("PlanId") {
                    self.planId = dict["PlanId"] as! Int64
                }
                if dict.keys.contains("PlanSize") {
                    self.planSize = dict["PlanSize"] as! Int64
                }
                if dict.keys.contains("PlanType") {
                    self.planType = dict["PlanType"] as! String
                }
                if dict.keys.contains("PlanUnionHash") {
                    self.planUnionHash = dict["PlanUnionHash"] as! String
                }
                if dict.keys.contains("SchemaVersion") {
                    self.schemaVersion = dict["SchemaVersion"] as! Int64
                }
                if dict.keys.contains("Server") {
                    self.server = dict["Server"] as! String
                }
                if dict.keys.contains("ServerId") {
                    self.serverId = dict["ServerId"] as! Int64
                }
                if dict.keys.contains("SqlId") {
                    self.sqlId = dict["SqlId"] as! String
                }
                if dict.keys.contains("TableScan") {
                    self.tableScan = dict["TableScan"] as! Bool
                }
                if dict.keys.contains("TimeoutPercentage") {
                    self.timeoutPercentage = dict["TimeoutPercentage"] as! Double
                }
                if dict.keys.contains("Uid") {
                    self.uid = dict["Uid"] as! String
                }
            }
        }
        public var avgCpuTime: Double?

        public var bounded: Bool?

        public var executions: Int64?

        public var firstLoadTime: String?

        public var hitDiagnosis: Bool?

        public var hitPercentage: Double?

        public var mergedVersion: Int64?

        public var planExplain: DescribeOasSQLPlansResponseBody.Data.PlanExplain?

        public var planHash: String?

        public var planType: String?

        public var planUnionHash: String?

        public var plans: [DescribeOasSQLPlansResponseBody.Data.Plans]?

        public var querySql: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.planExplain?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avgCpuTime != nil {
                map["AvgCpuTime"] = self.avgCpuTime!
            }
            if self.bounded != nil {
                map["Bounded"] = self.bounded!
            }
            if self.executions != nil {
                map["Executions"] = self.executions!
            }
            if self.firstLoadTime != nil {
                map["FirstLoadTime"] = self.firstLoadTime!
            }
            if self.hitDiagnosis != nil {
                map["HitDiagnosis"] = self.hitDiagnosis!
            }
            if self.hitPercentage != nil {
                map["HitPercentage"] = self.hitPercentage!
            }
            if self.mergedVersion != nil {
                map["MergedVersion"] = self.mergedVersion!
            }
            if self.planExplain != nil {
                map["PlanExplain"] = self.planExplain?.toMap()
            }
            if self.planHash != nil {
                map["PlanHash"] = self.planHash!
            }
            if self.planType != nil {
                map["PlanType"] = self.planType!
            }
            if self.planUnionHash != nil {
                map["PlanUnionHash"] = self.planUnionHash!
            }
            if self.plans != nil {
                var tmp : [Any] = []
                for k in self.plans! {
                    tmp.append(k.toMap())
                }
                map["Plans"] = tmp
            }
            if self.querySql != nil {
                map["QuerySql"] = self.querySql!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvgCpuTime") {
                self.avgCpuTime = dict["AvgCpuTime"] as! Double
            }
            if dict.keys.contains("Bounded") {
                self.bounded = dict["Bounded"] as! Bool
            }
            if dict.keys.contains("Executions") {
                self.executions = dict["Executions"] as! Int64
            }
            if dict.keys.contains("FirstLoadTime") {
                self.firstLoadTime = dict["FirstLoadTime"] as! String
            }
            if dict.keys.contains("HitDiagnosis") {
                self.hitDiagnosis = dict["HitDiagnosis"] as! Bool
            }
            if dict.keys.contains("HitPercentage") {
                self.hitPercentage = dict["HitPercentage"] as! Double
            }
            if dict.keys.contains("MergedVersion") {
                self.mergedVersion = dict["MergedVersion"] as! Int64
            }
            if dict.keys.contains("PlanExplain") {
                var model = DescribeOasSQLPlansResponseBody.Data.PlanExplain()
                model.fromMap(dict["PlanExplain"] as! [String: Any])
                self.planExplain = model
            }
            if dict.keys.contains("PlanHash") {
                self.planHash = dict["PlanHash"] as! String
            }
            if dict.keys.contains("PlanType") {
                self.planType = dict["PlanType"] as! String
            }
            if dict.keys.contains("PlanUnionHash") {
                self.planUnionHash = dict["PlanUnionHash"] as! String
            }
            if dict.keys.contains("Plans") {
                var tmp : [DescribeOasSQLPlansResponseBody.Data.Plans] = []
                for v in dict["Plans"] as! [Any] {
                    var model = DescribeOasSQLPlansResponseBody.Data.Plans()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.plans = tmp
            }
            if dict.keys.contains("QuerySql") {
                self.querySql = dict["QuerySql"] as! String
            }
        }
    }
    public var data: [DescribeOasSQLPlansResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [DescribeOasSQLPlansResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeOasSQLPlansResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeOasSQLPlansResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOasSQLPlansResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOasSQLPlansResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOasSlowSQLListRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var dbName: String?

    public var dynamicSql: Bool?

    public var endTime: String?

    public var filterCondition: String?

    public var instanceId: String?

    public var mergeDynamicSql: Bool?

    public var nodeIp: String?

    public var searchKeyWord: String?

    public var searchParam: String?

    public var searchRule: String?

    public var searchValue: String?

    public var sqlId: String?

    public var sqlTextLength: Int64?

    public var startTime: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.dynamicSql != nil {
            map["DynamicSql"] = self.dynamicSql!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.filterCondition != nil {
            map["FilterCondition"] = self.filterCondition!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mergeDynamicSql != nil {
            map["MergeDynamicSql"] = self.mergeDynamicSql!
        }
        if self.nodeIp != nil {
            map["NodeIp"] = self.nodeIp!
        }
        if self.searchKeyWord != nil {
            map["SearchKeyWord"] = self.searchKeyWord!
        }
        if self.searchParam != nil {
            map["SearchParam"] = self.searchParam!
        }
        if self.searchRule != nil {
            map["SearchRule"] = self.searchRule!
        }
        if self.searchValue != nil {
            map["SearchValue"] = self.searchValue!
        }
        if self.sqlId != nil {
            map["SqlId"] = self.sqlId!
        }
        if self.sqlTextLength != nil {
            map["SqlTextLength"] = self.sqlTextLength!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("DynamicSql") {
            self.dynamicSql = dict["DynamicSql"] as! Bool
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("FilterCondition") {
            self.filterCondition = dict["FilterCondition"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MergeDynamicSql") {
            self.mergeDynamicSql = dict["MergeDynamicSql"] as! Bool
        }
        if dict.keys.contains("NodeIp") {
            self.nodeIp = dict["NodeIp"] as! String
        }
        if dict.keys.contains("SearchKeyWord") {
            self.searchKeyWord = dict["SearchKeyWord"] as! String
        }
        if dict.keys.contains("SearchParam") {
            self.searchParam = dict["SearchParam"] as! String
        }
        if dict.keys.contains("SearchRule") {
            self.searchRule = dict["SearchRule"] as! String
        }
        if dict.keys.contains("SearchValue") {
            self.searchValue = dict["SearchValue"] as! String
        }
        if dict.keys.contains("SqlId") {
            self.sqlId = dict["SqlId"] as! String
        }
        if dict.keys.contains("SqlTextLength") {
            self.sqlTextLength = dict["SqlTextLength"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DescribeOasSlowSQLListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SqlList : Tea.TeaModel {
            public var avgAffectedRows: Double?

            public var avgApplicationWaitTime: Double?

            public var avgBlockCacheHit: Double?

            public var avgBlockIndexCacheHit: Double?

            public var avgBloomFilterCacheHit: Double?

            public var avgConcurrencyWaitTime: Double?

            public var avgCpuTime: Double?

            public var avgDbTime: Double?

            public var avgDecodeTime: Double?

            public var avgDiskReads: Double?

            public var avgElapsedTime: Double?

            public var avgExecuteTime: Double?

            public var avgExecutorRpcCount: Double?

            public var avgExpectedWorkerCount: Double?

            public var avgGetPlanTime: Double?

            public var avgLogicalReads: Double?

            public var avgMemstoreReadRows: Double?

            public var avgNetTime: Double?

            public var avgNetWaitTime: Double?

            public var avgPartitionCount: Double?

            public var avgQueueTime: Double?

            public var avgReturnRows: Double?

            public var avgRowCacheHit: Double?

            public var avgRpcCount: Double?

            public var avgScheduleTime: Double?

            public var avgSsstoreReadRows: Double?

            public var avgUsedWorkerCount: Double?

            public var avgUserIoWaitTime: Double?

            public var avgWaitCount: Double?

            public var avgWaitTime: Double?

            public var clientIp: String?

            public var dbName: String?

            public var distPlanPercentage: Double?

            public var execPs: Double?

            public var executions: Double?

            public var failCount: Double?

            public var failPercentage: Double?

            public var inner: Bool?

            public var localPlanPercentage: Double?

            public var maxAffectedRows: Double?

            public var maxApplicationWaitTime: Double?

            public var maxConcurrencyWaitTime: Double?

            public var maxCpuTime: Double?

            public var maxDiskReads: Double?

            public var maxElapsedTime: Double?

            public var maxReturnRows: Double?

            public var maxUserIoWaitTime: Double?

            public var maxWaitTime: Double?

            public var missPlanPercentage: Double?

            public var missPlans: Double?

            public var remotePlanPercentage: Double?

            public var remotePlans: Double?

            public var retCode4012Count: Int64?

            public var retCode4013Count: Int64?

            public var retCode5001Count: Int64?

            public var retCode5024Count: Int64?

            public var retCode5167Count: Int64?

            public var retCode5217Count: Int64?

            public var retCode6002Count: Int64?

            public var retryCount: Double?

            public var rpcCount: Double?

            public var server: String?

            public var serverIp: String?

            public var serverPort: Int64?

            public var sqlId: String?

            public var sqlTextShort: String?

            public var sqlType: String?

            public var strongConsistencyPercentage: Double?

            public var sumDbTime: Double?

            public var sumElapsedTime: Double?

            public var sumLogicalReads: Double?

            public var sumWaitTime: Double?

            public var tableScanPercentage: Double?

            public var totalWaitTime: Double?

            public var userName: String?

            public var waitEvent: String?

            public var weakConsistencyPercentage: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avgAffectedRows != nil {
                    map["AvgAffectedRows"] = self.avgAffectedRows!
                }
                if self.avgApplicationWaitTime != nil {
                    map["AvgApplicationWaitTime"] = self.avgApplicationWaitTime!
                }
                if self.avgBlockCacheHit != nil {
                    map["AvgBlockCacheHit"] = self.avgBlockCacheHit!
                }
                if self.avgBlockIndexCacheHit != nil {
                    map["AvgBlockIndexCacheHit"] = self.avgBlockIndexCacheHit!
                }
                if self.avgBloomFilterCacheHit != nil {
                    map["AvgBloomFilterCacheHit"] = self.avgBloomFilterCacheHit!
                }
                if self.avgConcurrencyWaitTime != nil {
                    map["AvgConcurrencyWaitTime"] = self.avgConcurrencyWaitTime!
                }
                if self.avgCpuTime != nil {
                    map["AvgCpuTime"] = self.avgCpuTime!
                }
                if self.avgDbTime != nil {
                    map["AvgDbTime"] = self.avgDbTime!
                }
                if self.avgDecodeTime != nil {
                    map["AvgDecodeTime"] = self.avgDecodeTime!
                }
                if self.avgDiskReads != nil {
                    map["AvgDiskReads"] = self.avgDiskReads!
                }
                if self.avgElapsedTime != nil {
                    map["AvgElapsedTime"] = self.avgElapsedTime!
                }
                if self.avgExecuteTime != nil {
                    map["AvgExecuteTime"] = self.avgExecuteTime!
                }
                if self.avgExecutorRpcCount != nil {
                    map["AvgExecutorRpcCount"] = self.avgExecutorRpcCount!
                }
                if self.avgExpectedWorkerCount != nil {
                    map["AvgExpectedWorkerCount"] = self.avgExpectedWorkerCount!
                }
                if self.avgGetPlanTime != nil {
                    map["AvgGetPlanTime"] = self.avgGetPlanTime!
                }
                if self.avgLogicalReads != nil {
                    map["AvgLogicalReads"] = self.avgLogicalReads!
                }
                if self.avgMemstoreReadRows != nil {
                    map["AvgMemstoreReadRows"] = self.avgMemstoreReadRows!
                }
                if self.avgNetTime != nil {
                    map["AvgNetTime"] = self.avgNetTime!
                }
                if self.avgNetWaitTime != nil {
                    map["AvgNetWaitTime"] = self.avgNetWaitTime!
                }
                if self.avgPartitionCount != nil {
                    map["AvgPartitionCount"] = self.avgPartitionCount!
                }
                if self.avgQueueTime != nil {
                    map["AvgQueueTime"] = self.avgQueueTime!
                }
                if self.avgReturnRows != nil {
                    map["AvgReturnRows"] = self.avgReturnRows!
                }
                if self.avgRowCacheHit != nil {
                    map["AvgRowCacheHit"] = self.avgRowCacheHit!
                }
                if self.avgRpcCount != nil {
                    map["AvgRpcCount"] = self.avgRpcCount!
                }
                if self.avgScheduleTime != nil {
                    map["AvgScheduleTime"] = self.avgScheduleTime!
                }
                if self.avgSsstoreReadRows != nil {
                    map["AvgSsstoreReadRows"] = self.avgSsstoreReadRows!
                }
                if self.avgUsedWorkerCount != nil {
                    map["AvgUsedWorkerCount"] = self.avgUsedWorkerCount!
                }
                if self.avgUserIoWaitTime != nil {
                    map["AvgUserIoWaitTime"] = self.avgUserIoWaitTime!
                }
                if self.avgWaitCount != nil {
                    map["AvgWaitCount"] = self.avgWaitCount!
                }
                if self.avgWaitTime != nil {
                    map["AvgWaitTime"] = self.avgWaitTime!
                }
                if self.clientIp != nil {
                    map["ClientIp"] = self.clientIp!
                }
                if self.dbName != nil {
                    map["DbName"] = self.dbName!
                }
                if self.distPlanPercentage != nil {
                    map["DistPlanPercentage"] = self.distPlanPercentage!
                }
                if self.execPs != nil {
                    map["ExecPs"] = self.execPs!
                }
                if self.executions != nil {
                    map["Executions"] = self.executions!
                }
                if self.failCount != nil {
                    map["FailCount"] = self.failCount!
                }
                if self.failPercentage != nil {
                    map["FailPercentage"] = self.failPercentage!
                }
                if self.inner != nil {
                    map["Inner"] = self.inner!
                }
                if self.localPlanPercentage != nil {
                    map["LocalPlanPercentage"] = self.localPlanPercentage!
                }
                if self.maxAffectedRows != nil {
                    map["MaxAffectedRows"] = self.maxAffectedRows!
                }
                if self.maxApplicationWaitTime != nil {
                    map["MaxApplicationWaitTime"] = self.maxApplicationWaitTime!
                }
                if self.maxConcurrencyWaitTime != nil {
                    map["MaxConcurrencyWaitTime"] = self.maxConcurrencyWaitTime!
                }
                if self.maxCpuTime != nil {
                    map["MaxCpuTime"] = self.maxCpuTime!
                }
                if self.maxDiskReads != nil {
                    map["MaxDiskReads"] = self.maxDiskReads!
                }
                if self.maxElapsedTime != nil {
                    map["MaxElapsedTime"] = self.maxElapsedTime!
                }
                if self.maxReturnRows != nil {
                    map["MaxReturnRows"] = self.maxReturnRows!
                }
                if self.maxUserIoWaitTime != nil {
                    map["MaxUserIoWaitTime"] = self.maxUserIoWaitTime!
                }
                if self.maxWaitTime != nil {
                    map["MaxWaitTime"] = self.maxWaitTime!
                }
                if self.missPlanPercentage != nil {
                    map["MissPlanPercentage"] = self.missPlanPercentage!
                }
                if self.missPlans != nil {
                    map["MissPlans"] = self.missPlans!
                }
                if self.remotePlanPercentage != nil {
                    map["RemotePlanPercentage"] = self.remotePlanPercentage!
                }
                if self.remotePlans != nil {
                    map["RemotePlans"] = self.remotePlans!
                }
                if self.retCode4012Count != nil {
                    map["RetCode4012Count"] = self.retCode4012Count!
                }
                if self.retCode4013Count != nil {
                    map["RetCode4013Count"] = self.retCode4013Count!
                }
                if self.retCode5001Count != nil {
                    map["RetCode5001Count"] = self.retCode5001Count!
                }
                if self.retCode5024Count != nil {
                    map["RetCode5024Count"] = self.retCode5024Count!
                }
                if self.retCode5167Count != nil {
                    map["RetCode5167Count"] = self.retCode5167Count!
                }
                if self.retCode5217Count != nil {
                    map["RetCode5217Count"] = self.retCode5217Count!
                }
                if self.retCode6002Count != nil {
                    map["RetCode6002Count"] = self.retCode6002Count!
                }
                if self.retryCount != nil {
                    map["RetryCount"] = self.retryCount!
                }
                if self.rpcCount != nil {
                    map["RpcCount"] = self.rpcCount!
                }
                if self.server != nil {
                    map["Server"] = self.server!
                }
                if self.serverIp != nil {
                    map["ServerIp"] = self.serverIp!
                }
                if self.serverPort != nil {
                    map["ServerPort"] = self.serverPort!
                }
                if self.sqlId != nil {
                    map["SqlId"] = self.sqlId!
                }
                if self.sqlTextShort != nil {
                    map["SqlTextShort"] = self.sqlTextShort!
                }
                if self.sqlType != nil {
                    map["SqlType"] = self.sqlType!
                }
                if self.strongConsistencyPercentage != nil {
                    map["StrongConsistencyPercentage"] = self.strongConsistencyPercentage!
                }
                if self.sumDbTime != nil {
                    map["SumDbTime"] = self.sumDbTime!
                }
                if self.sumElapsedTime != nil {
                    map["SumElapsedTime"] = self.sumElapsedTime!
                }
                if self.sumLogicalReads != nil {
                    map["SumLogicalReads"] = self.sumLogicalReads!
                }
                if self.sumWaitTime != nil {
                    map["SumWaitTime"] = self.sumWaitTime!
                }
                if self.tableScanPercentage != nil {
                    map["TableScanPercentage"] = self.tableScanPercentage!
                }
                if self.totalWaitTime != nil {
                    map["TotalWaitTime"] = self.totalWaitTime!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                if self.waitEvent != nil {
                    map["WaitEvent"] = self.waitEvent!
                }
                if self.weakConsistencyPercentage != nil {
                    map["WeakConsistencyPercentage"] = self.weakConsistencyPercentage!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvgAffectedRows") {
                    self.avgAffectedRows = dict["AvgAffectedRows"] as! Double
                }
                if dict.keys.contains("AvgApplicationWaitTime") {
                    self.avgApplicationWaitTime = dict["AvgApplicationWaitTime"] as! Double
                }
                if dict.keys.contains("AvgBlockCacheHit") {
                    self.avgBlockCacheHit = dict["AvgBlockCacheHit"] as! Double
                }
                if dict.keys.contains("AvgBlockIndexCacheHit") {
                    self.avgBlockIndexCacheHit = dict["AvgBlockIndexCacheHit"] as! Double
                }
                if dict.keys.contains("AvgBloomFilterCacheHit") {
                    self.avgBloomFilterCacheHit = dict["AvgBloomFilterCacheHit"] as! Double
                }
                if dict.keys.contains("AvgConcurrencyWaitTime") {
                    self.avgConcurrencyWaitTime = dict["AvgConcurrencyWaitTime"] as! Double
                }
                if dict.keys.contains("AvgCpuTime") {
                    self.avgCpuTime = dict["AvgCpuTime"] as! Double
                }
                if dict.keys.contains("AvgDbTime") {
                    self.avgDbTime = dict["AvgDbTime"] as! Double
                }
                if dict.keys.contains("AvgDecodeTime") {
                    self.avgDecodeTime = dict["AvgDecodeTime"] as! Double
                }
                if dict.keys.contains("AvgDiskReads") {
                    self.avgDiskReads = dict["AvgDiskReads"] as! Double
                }
                if dict.keys.contains("AvgElapsedTime") {
                    self.avgElapsedTime = dict["AvgElapsedTime"] as! Double
                }
                if dict.keys.contains("AvgExecuteTime") {
                    self.avgExecuteTime = dict["AvgExecuteTime"] as! Double
                }
                if dict.keys.contains("AvgExecutorRpcCount") {
                    self.avgExecutorRpcCount = dict["AvgExecutorRpcCount"] as! Double
                }
                if dict.keys.contains("AvgExpectedWorkerCount") {
                    self.avgExpectedWorkerCount = dict["AvgExpectedWorkerCount"] as! Double
                }
                if dict.keys.contains("AvgGetPlanTime") {
                    self.avgGetPlanTime = dict["AvgGetPlanTime"] as! Double
                }
                if dict.keys.contains("AvgLogicalReads") {
                    self.avgLogicalReads = dict["AvgLogicalReads"] as! Double
                }
                if dict.keys.contains("AvgMemstoreReadRows") {
                    self.avgMemstoreReadRows = dict["AvgMemstoreReadRows"] as! Double
                }
                if dict.keys.contains("AvgNetTime") {
                    self.avgNetTime = dict["AvgNetTime"] as! Double
                }
                if dict.keys.contains("AvgNetWaitTime") {
                    self.avgNetWaitTime = dict["AvgNetWaitTime"] as! Double
                }
                if dict.keys.contains("AvgPartitionCount") {
                    self.avgPartitionCount = dict["AvgPartitionCount"] as! Double
                }
                if dict.keys.contains("AvgQueueTime") {
                    self.avgQueueTime = dict["AvgQueueTime"] as! Double
                }
                if dict.keys.contains("AvgReturnRows") {
                    self.avgReturnRows = dict["AvgReturnRows"] as! Double
                }
                if dict.keys.contains("AvgRowCacheHit") {
                    self.avgRowCacheHit = dict["AvgRowCacheHit"] as! Double
                }
                if dict.keys.contains("AvgRpcCount") {
                    self.avgRpcCount = dict["AvgRpcCount"] as! Double
                }
                if dict.keys.contains("AvgScheduleTime") {
                    self.avgScheduleTime = dict["AvgScheduleTime"] as! Double
                }
                if dict.keys.contains("AvgSsstoreReadRows") {
                    self.avgSsstoreReadRows = dict["AvgSsstoreReadRows"] as! Double
                }
                if dict.keys.contains("AvgUsedWorkerCount") {
                    self.avgUsedWorkerCount = dict["AvgUsedWorkerCount"] as! Double
                }
                if dict.keys.contains("AvgUserIoWaitTime") {
                    self.avgUserIoWaitTime = dict["AvgUserIoWaitTime"] as! Double
                }
                if dict.keys.contains("AvgWaitCount") {
                    self.avgWaitCount = dict["AvgWaitCount"] as! Double
                }
                if dict.keys.contains("AvgWaitTime") {
                    self.avgWaitTime = dict["AvgWaitTime"] as! Double
                }
                if dict.keys.contains("ClientIp") {
                    self.clientIp = dict["ClientIp"] as! String
                }
                if dict.keys.contains("DbName") {
                    self.dbName = dict["DbName"] as! String
                }
                if dict.keys.contains("DistPlanPercentage") {
                    self.distPlanPercentage = dict["DistPlanPercentage"] as! Double
                }
                if dict.keys.contains("ExecPs") {
                    self.execPs = dict["ExecPs"] as! Double
                }
                if dict.keys.contains("Executions") {
                    self.executions = dict["Executions"] as! Double
                }
                if dict.keys.contains("FailCount") {
                    self.failCount = dict["FailCount"] as! Double
                }
                if dict.keys.contains("FailPercentage") {
                    self.failPercentage = dict["FailPercentage"] as! Double
                }
                if dict.keys.contains("Inner") {
                    self.inner = dict["Inner"] as! Bool
                }
                if dict.keys.contains("LocalPlanPercentage") {
                    self.localPlanPercentage = dict["LocalPlanPercentage"] as! Double
                }
                if dict.keys.contains("MaxAffectedRows") {
                    self.maxAffectedRows = dict["MaxAffectedRows"] as! Double
                }
                if dict.keys.contains("MaxApplicationWaitTime") {
                    self.maxApplicationWaitTime = dict["MaxApplicationWaitTime"] as! Double
                }
                if dict.keys.contains("MaxConcurrencyWaitTime") {
                    self.maxConcurrencyWaitTime = dict["MaxConcurrencyWaitTime"] as! Double
                }
                if dict.keys.contains("MaxCpuTime") {
                    self.maxCpuTime = dict["MaxCpuTime"] as! Double
                }
                if dict.keys.contains("MaxDiskReads") {
                    self.maxDiskReads = dict["MaxDiskReads"] as! Double
                }
                if dict.keys.contains("MaxElapsedTime") {
                    self.maxElapsedTime = dict["MaxElapsedTime"] as! Double
                }
                if dict.keys.contains("MaxReturnRows") {
                    self.maxReturnRows = dict["MaxReturnRows"] as! Double
                }
                if dict.keys.contains("MaxUserIoWaitTime") {
                    self.maxUserIoWaitTime = dict["MaxUserIoWaitTime"] as! Double
                }
                if dict.keys.contains("MaxWaitTime") {
                    self.maxWaitTime = dict["MaxWaitTime"] as! Double
                }
                if dict.keys.contains("MissPlanPercentage") {
                    self.missPlanPercentage = dict["MissPlanPercentage"] as! Double
                }
                if dict.keys.contains("MissPlans") {
                    self.missPlans = dict["MissPlans"] as! Double
                }
                if dict.keys.contains("RemotePlanPercentage") {
                    self.remotePlanPercentage = dict["RemotePlanPercentage"] as! Double
                }
                if dict.keys.contains("RemotePlans") {
                    self.remotePlans = dict["RemotePlans"] as! Double
                }
                if dict.keys.contains("RetCode4012Count") {
                    self.retCode4012Count = dict["RetCode4012Count"] as! Int64
                }
                if dict.keys.contains("RetCode4013Count") {
                    self.retCode4013Count = dict["RetCode4013Count"] as! Int64
                }
                if dict.keys.contains("RetCode5001Count") {
                    self.retCode5001Count = dict["RetCode5001Count"] as! Int64
                }
                if dict.keys.contains("RetCode5024Count") {
                    self.retCode5024Count = dict["RetCode5024Count"] as! Int64
                }
                if dict.keys.contains("RetCode5167Count") {
                    self.retCode5167Count = dict["RetCode5167Count"] as! Int64
                }
                if dict.keys.contains("RetCode5217Count") {
                    self.retCode5217Count = dict["RetCode5217Count"] as! Int64
                }
                if dict.keys.contains("RetCode6002Count") {
                    self.retCode6002Count = dict["RetCode6002Count"] as! Int64
                }
                if dict.keys.contains("RetryCount") {
                    self.retryCount = dict["RetryCount"] as! Double
                }
                if dict.keys.contains("RpcCount") {
                    self.rpcCount = dict["RpcCount"] as! Double
                }
                if dict.keys.contains("Server") {
                    self.server = dict["Server"] as! String
                }
                if dict.keys.contains("ServerIp") {
                    self.serverIp = dict["ServerIp"] as! String
                }
                if dict.keys.contains("ServerPort") {
                    self.serverPort = dict["ServerPort"] as! Int64
                }
                if dict.keys.contains("SqlId") {
                    self.sqlId = dict["SqlId"] as! String
                }
                if dict.keys.contains("SqlTextShort") {
                    self.sqlTextShort = dict["SqlTextShort"] as! String
                }
                if dict.keys.contains("SqlType") {
                    self.sqlType = dict["SqlType"] as! String
                }
                if dict.keys.contains("StrongConsistencyPercentage") {
                    self.strongConsistencyPercentage = dict["StrongConsistencyPercentage"] as! Double
                }
                if dict.keys.contains("SumDbTime") {
                    self.sumDbTime = dict["SumDbTime"] as! Double
                }
                if dict.keys.contains("SumElapsedTime") {
                    self.sumElapsedTime = dict["SumElapsedTime"] as! Double
                }
                if dict.keys.contains("SumLogicalReads") {
                    self.sumLogicalReads = dict["SumLogicalReads"] as! Double
                }
                if dict.keys.contains("SumWaitTime") {
                    self.sumWaitTime = dict["SumWaitTime"] as! Double
                }
                if dict.keys.contains("TableScanPercentage") {
                    self.tableScanPercentage = dict["TableScanPercentage"] as! Double
                }
                if dict.keys.contains("TotalWaitTime") {
                    self.totalWaitTime = dict["TotalWaitTime"] as! Double
                }
                if dict.keys.contains("UserName") {
                    self.userName = dict["UserName"] as! String
                }
                if dict.keys.contains("WaitEvent") {
                    self.waitEvent = dict["WaitEvent"] as! String
                }
                if dict.keys.contains("WeakConsistencyPercentage") {
                    self.weakConsistencyPercentage = dict["WeakConsistencyPercentage"] as! Double
                }
            }
        }
        public var avgAffectedRows: Double?

        public var avgApplicationWaitTime: Double?

        public var avgBlockCacheHit: Double?

        public var avgBlockIndexCacheHit: Double?

        public var avgBloomFilterCacheHit: Double?

        public var avgConcurrencyWaitTime: Double?

        public var avgCpuTime: Double?

        public var avgDbTime: Double?

        public var avgDecodeTime: Double?

        public var avgDiskReads: Double?

        public var avgElapsedTime: Double?

        public var avgExecuteTime: Double?

        public var avgExecutorRpcCount: Double?

        public var avgExpectedWorkerCount: Double?

        public var avgGetPlanTime: Double?

        public var avgLogicalReads: Double?

        public var avgMemstoreReadRows: Double?

        public var avgNetTime: Double?

        public var avgNetWaitTime: Double?

        public var avgPartitionCount: Double?

        public var avgQueueTime: Double?

        public var avgReturnRows: Double?

        public var avgRowCacheHit: Double?

        public var avgRpcCount: Double?

        public var avgScheduleTime: Double?

        public var avgSsstoreReadRows: Double?

        public var avgUsedWorkerCount: Double?

        public var avgUserIoWaitTime: Double?

        public var avgWaitCount: Double?

        public var avgWaitTime: Double?

        public var clientIp: String?

        public var dbName: String?

        public var distPlanPercentage: Double?

        public var dynamicSql: Bool?

        public var execPs: Double?

        public var executions: Double?

        public var failCount: Double?

        public var failPercentage: Double?

        public var inner: Bool?

        public var localPlanPercentage: Double?

        public var maxAffectedRows: Double?

        public var maxApplicationWaitTime: Double?

        public var maxConcurrencyWaitTime: Double?

        public var maxCpuTime: Double?

        public var maxDiskReads: Double?

        public var maxElapsedTime: Double?

        public var maxReturnRows: Double?

        public var maxUserIoWaitTime: Double?

        public var maxWaitTime: Double?

        public var missPlanPercentage: Double?

        public var missPlans: Double?

        public var remotePlanPercentage: Double?

        public var remotePlans: Double?

        public var retCode4012Count: Int64?

        public var retCode4013Count: Int64?

        public var retCode5001Count: Double?

        public var retCode5024Count: Double?

        public var retCode5167Count: Double?

        public var retCode5217Count: Double?

        public var retCode6002Count: Double?

        public var retryCount: Double?

        public var rpcCount: Double?

        public var server: String?

        public var serverIp: String?

        public var serverPort: Int64?

        public var sqlId: String?

        public var sqlList: [DescribeOasSlowSQLListResponseBody.Data.SqlList]?

        public var sqlTextShort: String?

        public var sqlType: String?

        public var strongConsistencyPercentage: Double?

        public var sumDbTime: Double?

        public var sumElapsedTime: Double?

        public var sumLogicalReads: Double?

        public var sumWaitTime: Double?

        public var tableScanPercentage: Double?

        public var totalWaitTime: Double?

        public var userName: String?

        public var waitEvent: String?

        public var weakConsistencyPercentage: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avgAffectedRows != nil {
                map["AvgAffectedRows"] = self.avgAffectedRows!
            }
            if self.avgApplicationWaitTime != nil {
                map["AvgApplicationWaitTime"] = self.avgApplicationWaitTime!
            }
            if self.avgBlockCacheHit != nil {
                map["AvgBlockCacheHit"] = self.avgBlockCacheHit!
            }
            if self.avgBlockIndexCacheHit != nil {
                map["AvgBlockIndexCacheHit"] = self.avgBlockIndexCacheHit!
            }
            if self.avgBloomFilterCacheHit != nil {
                map["AvgBloomFilterCacheHit"] = self.avgBloomFilterCacheHit!
            }
            if self.avgConcurrencyWaitTime != nil {
                map["AvgConcurrencyWaitTime"] = self.avgConcurrencyWaitTime!
            }
            if self.avgCpuTime != nil {
                map["AvgCpuTime"] = self.avgCpuTime!
            }
            if self.avgDbTime != nil {
                map["AvgDbTime"] = self.avgDbTime!
            }
            if self.avgDecodeTime != nil {
                map["AvgDecodeTime"] = self.avgDecodeTime!
            }
            if self.avgDiskReads != nil {
                map["AvgDiskReads"] = self.avgDiskReads!
            }
            if self.avgElapsedTime != nil {
                map["AvgElapsedTime"] = self.avgElapsedTime!
            }
            if self.avgExecuteTime != nil {
                map["AvgExecuteTime"] = self.avgExecuteTime!
            }
            if self.avgExecutorRpcCount != nil {
                map["AvgExecutorRpcCount"] = self.avgExecutorRpcCount!
            }
            if self.avgExpectedWorkerCount != nil {
                map["AvgExpectedWorkerCount"] = self.avgExpectedWorkerCount!
            }
            if self.avgGetPlanTime != nil {
                map["AvgGetPlanTime"] = self.avgGetPlanTime!
            }
            if self.avgLogicalReads != nil {
                map["AvgLogicalReads"] = self.avgLogicalReads!
            }
            if self.avgMemstoreReadRows != nil {
                map["AvgMemstoreReadRows"] = self.avgMemstoreReadRows!
            }
            if self.avgNetTime != nil {
                map["AvgNetTime"] = self.avgNetTime!
            }
            if self.avgNetWaitTime != nil {
                map["AvgNetWaitTime"] = self.avgNetWaitTime!
            }
            if self.avgPartitionCount != nil {
                map["AvgPartitionCount"] = self.avgPartitionCount!
            }
            if self.avgQueueTime != nil {
                map["AvgQueueTime"] = self.avgQueueTime!
            }
            if self.avgReturnRows != nil {
                map["AvgReturnRows"] = self.avgReturnRows!
            }
            if self.avgRowCacheHit != nil {
                map["AvgRowCacheHit"] = self.avgRowCacheHit!
            }
            if self.avgRpcCount != nil {
                map["AvgRpcCount"] = self.avgRpcCount!
            }
            if self.avgScheduleTime != nil {
                map["AvgScheduleTime"] = self.avgScheduleTime!
            }
            if self.avgSsstoreReadRows != nil {
                map["AvgSsstoreReadRows"] = self.avgSsstoreReadRows!
            }
            if self.avgUsedWorkerCount != nil {
                map["AvgUsedWorkerCount"] = self.avgUsedWorkerCount!
            }
            if self.avgUserIoWaitTime != nil {
                map["AvgUserIoWaitTime"] = self.avgUserIoWaitTime!
            }
            if self.avgWaitCount != nil {
                map["AvgWaitCount"] = self.avgWaitCount!
            }
            if self.avgWaitTime != nil {
                map["AvgWaitTime"] = self.avgWaitTime!
            }
            if self.clientIp != nil {
                map["ClientIp"] = self.clientIp!
            }
            if self.dbName != nil {
                map["DbName"] = self.dbName!
            }
            if self.distPlanPercentage != nil {
                map["DistPlanPercentage"] = self.distPlanPercentage!
            }
            if self.dynamicSql != nil {
                map["DynamicSql"] = self.dynamicSql!
            }
            if self.execPs != nil {
                map["ExecPs"] = self.execPs!
            }
            if self.executions != nil {
                map["Executions"] = self.executions!
            }
            if self.failCount != nil {
                map["FailCount"] = self.failCount!
            }
            if self.failPercentage != nil {
                map["FailPercentage"] = self.failPercentage!
            }
            if self.inner != nil {
                map["Inner"] = self.inner!
            }
            if self.localPlanPercentage != nil {
                map["LocalPlanPercentage"] = self.localPlanPercentage!
            }
            if self.maxAffectedRows != nil {
                map["MaxAffectedRows"] = self.maxAffectedRows!
            }
            if self.maxApplicationWaitTime != nil {
                map["MaxApplicationWaitTime"] = self.maxApplicationWaitTime!
            }
            if self.maxConcurrencyWaitTime != nil {
                map["MaxConcurrencyWaitTime"] = self.maxConcurrencyWaitTime!
            }
            if self.maxCpuTime != nil {
                map["MaxCpuTime"] = self.maxCpuTime!
            }
            if self.maxDiskReads != nil {
                map["MaxDiskReads"] = self.maxDiskReads!
            }
            if self.maxElapsedTime != nil {
                map["MaxElapsedTime"] = self.maxElapsedTime!
            }
            if self.maxReturnRows != nil {
                map["MaxReturnRows"] = self.maxReturnRows!
            }
            if self.maxUserIoWaitTime != nil {
                map["MaxUserIoWaitTime"] = self.maxUserIoWaitTime!
            }
            if self.maxWaitTime != nil {
                map["MaxWaitTime"] = self.maxWaitTime!
            }
            if self.missPlanPercentage != nil {
                map["MissPlanPercentage"] = self.missPlanPercentage!
            }
            if self.missPlans != nil {
                map["MissPlans"] = self.missPlans!
            }
            if self.remotePlanPercentage != nil {
                map["RemotePlanPercentage"] = self.remotePlanPercentage!
            }
            if self.remotePlans != nil {
                map["RemotePlans"] = self.remotePlans!
            }
            if self.retCode4012Count != nil {
                map["RetCode4012Count"] = self.retCode4012Count!
            }
            if self.retCode4013Count != nil {
                map["RetCode4013Count"] = self.retCode4013Count!
            }
            if self.retCode5001Count != nil {
                map["RetCode5001Count"] = self.retCode5001Count!
            }
            if self.retCode5024Count != nil {
                map["RetCode5024Count"] = self.retCode5024Count!
            }
            if self.retCode5167Count != nil {
                map["RetCode5167Count"] = self.retCode5167Count!
            }
            if self.retCode5217Count != nil {
                map["RetCode5217Count"] = self.retCode5217Count!
            }
            if self.retCode6002Count != nil {
                map["RetCode6002Count"] = self.retCode6002Count!
            }
            if self.retryCount != nil {
                map["RetryCount"] = self.retryCount!
            }
            if self.rpcCount != nil {
                map["RpcCount"] = self.rpcCount!
            }
            if self.server != nil {
                map["Server"] = self.server!
            }
            if self.serverIp != nil {
                map["ServerIp"] = self.serverIp!
            }
            if self.serverPort != nil {
                map["ServerPort"] = self.serverPort!
            }
            if self.sqlId != nil {
                map["SqlId"] = self.sqlId!
            }
            if self.sqlList != nil {
                var tmp : [Any] = []
                for k in self.sqlList! {
                    tmp.append(k.toMap())
                }
                map["SqlList"] = tmp
            }
            if self.sqlTextShort != nil {
                map["SqlTextShort"] = self.sqlTextShort!
            }
            if self.sqlType != nil {
                map["SqlType"] = self.sqlType!
            }
            if self.strongConsistencyPercentage != nil {
                map["StrongConsistencyPercentage"] = self.strongConsistencyPercentage!
            }
            if self.sumDbTime != nil {
                map["SumDbTime"] = self.sumDbTime!
            }
            if self.sumElapsedTime != nil {
                map["SumElapsedTime"] = self.sumElapsedTime!
            }
            if self.sumLogicalReads != nil {
                map["SumLogicalReads"] = self.sumLogicalReads!
            }
            if self.sumWaitTime != nil {
                map["SumWaitTime"] = self.sumWaitTime!
            }
            if self.tableScanPercentage != nil {
                map["TableScanPercentage"] = self.tableScanPercentage!
            }
            if self.totalWaitTime != nil {
                map["TotalWaitTime"] = self.totalWaitTime!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            if self.waitEvent != nil {
                map["WaitEvent"] = self.waitEvent!
            }
            if self.weakConsistencyPercentage != nil {
                map["WeakConsistencyPercentage"] = self.weakConsistencyPercentage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvgAffectedRows") {
                self.avgAffectedRows = dict["AvgAffectedRows"] as! Double
            }
            if dict.keys.contains("AvgApplicationWaitTime") {
                self.avgApplicationWaitTime = dict["AvgApplicationWaitTime"] as! Double
            }
            if dict.keys.contains("AvgBlockCacheHit") {
                self.avgBlockCacheHit = dict["AvgBlockCacheHit"] as! Double
            }
            if dict.keys.contains("AvgBlockIndexCacheHit") {
                self.avgBlockIndexCacheHit = dict["AvgBlockIndexCacheHit"] as! Double
            }
            if dict.keys.contains("AvgBloomFilterCacheHit") {
                self.avgBloomFilterCacheHit = dict["AvgBloomFilterCacheHit"] as! Double
            }
            if dict.keys.contains("AvgConcurrencyWaitTime") {
                self.avgConcurrencyWaitTime = dict["AvgConcurrencyWaitTime"] as! Double
            }
            if dict.keys.contains("AvgCpuTime") {
                self.avgCpuTime = dict["AvgCpuTime"] as! Double
            }
            if dict.keys.contains("AvgDbTime") {
                self.avgDbTime = dict["AvgDbTime"] as! Double
            }
            if dict.keys.contains("AvgDecodeTime") {
                self.avgDecodeTime = dict["AvgDecodeTime"] as! Double
            }
            if dict.keys.contains("AvgDiskReads") {
                self.avgDiskReads = dict["AvgDiskReads"] as! Double
            }
            if dict.keys.contains("AvgElapsedTime") {
                self.avgElapsedTime = dict["AvgElapsedTime"] as! Double
            }
            if dict.keys.contains("AvgExecuteTime") {
                self.avgExecuteTime = dict["AvgExecuteTime"] as! Double
            }
            if dict.keys.contains("AvgExecutorRpcCount") {
                self.avgExecutorRpcCount = dict["AvgExecutorRpcCount"] as! Double
            }
            if dict.keys.contains("AvgExpectedWorkerCount") {
                self.avgExpectedWorkerCount = dict["AvgExpectedWorkerCount"] as! Double
            }
            if dict.keys.contains("AvgGetPlanTime") {
                self.avgGetPlanTime = dict["AvgGetPlanTime"] as! Double
            }
            if dict.keys.contains("AvgLogicalReads") {
                self.avgLogicalReads = dict["AvgLogicalReads"] as! Double
            }
            if dict.keys.contains("AvgMemstoreReadRows") {
                self.avgMemstoreReadRows = dict["AvgMemstoreReadRows"] as! Double
            }
            if dict.keys.contains("AvgNetTime") {
                self.avgNetTime = dict["AvgNetTime"] as! Double
            }
            if dict.keys.contains("AvgNetWaitTime") {
                self.avgNetWaitTime = dict["AvgNetWaitTime"] as! Double
            }
            if dict.keys.contains("AvgPartitionCount") {
                self.avgPartitionCount = dict["AvgPartitionCount"] as! Double
            }
            if dict.keys.contains("AvgQueueTime") {
                self.avgQueueTime = dict["AvgQueueTime"] as! Double
            }
            if dict.keys.contains("AvgReturnRows") {
                self.avgReturnRows = dict["AvgReturnRows"] as! Double
            }
            if dict.keys.contains("AvgRowCacheHit") {
                self.avgRowCacheHit = dict["AvgRowCacheHit"] as! Double
            }
            if dict.keys.contains("AvgRpcCount") {
                self.avgRpcCount = dict["AvgRpcCount"] as! Double
            }
            if dict.keys.contains("AvgScheduleTime") {
                self.avgScheduleTime = dict["AvgScheduleTime"] as! Double
            }
            if dict.keys.contains("AvgSsstoreReadRows") {
                self.avgSsstoreReadRows = dict["AvgSsstoreReadRows"] as! Double
            }
            if dict.keys.contains("AvgUsedWorkerCount") {
                self.avgUsedWorkerCount = dict["AvgUsedWorkerCount"] as! Double
            }
            if dict.keys.contains("AvgUserIoWaitTime") {
                self.avgUserIoWaitTime = dict["AvgUserIoWaitTime"] as! Double
            }
            if dict.keys.contains("AvgWaitCount") {
                self.avgWaitCount = dict["AvgWaitCount"] as! Double
            }
            if dict.keys.contains("AvgWaitTime") {
                self.avgWaitTime = dict["AvgWaitTime"] as! Double
            }
            if dict.keys.contains("ClientIp") {
                self.clientIp = dict["ClientIp"] as! String
            }
            if dict.keys.contains("DbName") {
                self.dbName = dict["DbName"] as! String
            }
            if dict.keys.contains("DistPlanPercentage") {
                self.distPlanPercentage = dict["DistPlanPercentage"] as! Double
            }
            if dict.keys.contains("DynamicSql") {
                self.dynamicSql = dict["DynamicSql"] as! Bool
            }
            if dict.keys.contains("ExecPs") {
                self.execPs = dict["ExecPs"] as! Double
            }
            if dict.keys.contains("Executions") {
                self.executions = dict["Executions"] as! Double
            }
            if dict.keys.contains("FailCount") {
                self.failCount = dict["FailCount"] as! Double
            }
            if dict.keys.contains("FailPercentage") {
                self.failPercentage = dict["FailPercentage"] as! Double
            }
            if dict.keys.contains("Inner") {
                self.inner = dict["Inner"] as! Bool
            }
            if dict.keys.contains("LocalPlanPercentage") {
                self.localPlanPercentage = dict["LocalPlanPercentage"] as! Double
            }
            if dict.keys.contains("MaxAffectedRows") {
                self.maxAffectedRows = dict["MaxAffectedRows"] as! Double
            }
            if dict.keys.contains("MaxApplicationWaitTime") {
                self.maxApplicationWaitTime = dict["MaxApplicationWaitTime"] as! Double
            }
            if dict.keys.contains("MaxConcurrencyWaitTime") {
                self.maxConcurrencyWaitTime = dict["MaxConcurrencyWaitTime"] as! Double
            }
            if dict.keys.contains("MaxCpuTime") {
                self.maxCpuTime = dict["MaxCpuTime"] as! Double
            }
            if dict.keys.contains("MaxDiskReads") {
                self.maxDiskReads = dict["MaxDiskReads"] as! Double
            }
            if dict.keys.contains("MaxElapsedTime") {
                self.maxElapsedTime = dict["MaxElapsedTime"] as! Double
            }
            if dict.keys.contains("MaxReturnRows") {
                self.maxReturnRows = dict["MaxReturnRows"] as! Double
            }
            if dict.keys.contains("MaxUserIoWaitTime") {
                self.maxUserIoWaitTime = dict["MaxUserIoWaitTime"] as! Double
            }
            if dict.keys.contains("MaxWaitTime") {
                self.maxWaitTime = dict["MaxWaitTime"] as! Double
            }
            if dict.keys.contains("MissPlanPercentage") {
                self.missPlanPercentage = dict["MissPlanPercentage"] as! Double
            }
            if dict.keys.contains("MissPlans") {
                self.missPlans = dict["MissPlans"] as! Double
            }
            if dict.keys.contains("RemotePlanPercentage") {
                self.remotePlanPercentage = dict["RemotePlanPercentage"] as! Double
            }
            if dict.keys.contains("RemotePlans") {
                self.remotePlans = dict["RemotePlans"] as! Double
            }
            if dict.keys.contains("RetCode4012Count") {
                self.retCode4012Count = dict["RetCode4012Count"] as! Int64
            }
            if dict.keys.contains("RetCode4013Count") {
                self.retCode4013Count = dict["RetCode4013Count"] as! Int64
            }
            if dict.keys.contains("RetCode5001Count") {
                self.retCode5001Count = dict["RetCode5001Count"] as! Double
            }
            if dict.keys.contains("RetCode5024Count") {
                self.retCode5024Count = dict["RetCode5024Count"] as! Double
            }
            if dict.keys.contains("RetCode5167Count") {
                self.retCode5167Count = dict["RetCode5167Count"] as! Double
            }
            if dict.keys.contains("RetCode5217Count") {
                self.retCode5217Count = dict["RetCode5217Count"] as! Double
            }
            if dict.keys.contains("RetCode6002Count") {
                self.retCode6002Count = dict["RetCode6002Count"] as! Double
            }
            if dict.keys.contains("RetryCount") {
                self.retryCount = dict["RetryCount"] as! Double
            }
            if dict.keys.contains("RpcCount") {
                self.rpcCount = dict["RpcCount"] as! Double
            }
            if dict.keys.contains("Server") {
                self.server = dict["Server"] as! String
            }
            if dict.keys.contains("ServerIp") {
                self.serverIp = dict["ServerIp"] as! String
            }
            if dict.keys.contains("ServerPort") {
                self.serverPort = dict["ServerPort"] as! Int64
            }
            if dict.keys.contains("SqlId") {
                self.sqlId = dict["SqlId"] as! String
            }
            if dict.keys.contains("SqlList") {
                var tmp : [DescribeOasSlowSQLListResponseBody.Data.SqlList] = []
                for v in dict["SqlList"] as! [Any] {
                    var model = DescribeOasSlowSQLListResponseBody.Data.SqlList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sqlList = tmp
            }
            if dict.keys.contains("SqlTextShort") {
                self.sqlTextShort = dict["SqlTextShort"] as! String
            }
            if dict.keys.contains("SqlType") {
                self.sqlType = dict["SqlType"] as! String
            }
            if dict.keys.contains("StrongConsistencyPercentage") {
                self.strongConsistencyPercentage = dict["StrongConsistencyPercentage"] as! Double
            }
            if dict.keys.contains("SumDbTime") {
                self.sumDbTime = dict["SumDbTime"] as! Double
            }
            if dict.keys.contains("SumElapsedTime") {
                self.sumElapsedTime = dict["SumElapsedTime"] as! Double
            }
            if dict.keys.contains("SumLogicalReads") {
                self.sumLogicalReads = dict["SumLogicalReads"] as! Double
            }
            if dict.keys.contains("SumWaitTime") {
                self.sumWaitTime = dict["SumWaitTime"] as! Double
            }
            if dict.keys.contains("TableScanPercentage") {
                self.tableScanPercentage = dict["TableScanPercentage"] as! Double
            }
            if dict.keys.contains("TotalWaitTime") {
                self.totalWaitTime = dict["TotalWaitTime"] as! Double
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
            if dict.keys.contains("WaitEvent") {
                self.waitEvent = dict["WaitEvent"] as! String
            }
            if dict.keys.contains("WeakConsistencyPercentage") {
                self.weakConsistencyPercentage = dict["WeakConsistencyPercentage"] as! Double
            }
        }
    }
    public var data: [DescribeOasSlowSQLListResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [DescribeOasSlowSQLListResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeOasSlowSQLListResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeOasSlowSQLListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOasSlowSQLListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOasSlowSQLListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOasTopSQLListRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var dbName: String?

    public var dynamicSql: Bool?

    public var endTime: String?

    public var filterCondition: String?

    public var instanceId: String?

    public var mergeDynamicSql: Bool?

    public var nodeIp: String?

    public var searchKeyWord: String?

    public var searchParam: String?

    public var searchRule: String?

    public var searchValue: String?

    public var sqlId: String?

    public var sqlTextLength: Int64?

    public var startTime: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.dynamicSql != nil {
            map["DynamicSql"] = self.dynamicSql!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.filterCondition != nil {
            map["FilterCondition"] = self.filterCondition!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mergeDynamicSql != nil {
            map["MergeDynamicSql"] = self.mergeDynamicSql!
        }
        if self.nodeIp != nil {
            map["NodeIp"] = self.nodeIp!
        }
        if self.searchKeyWord != nil {
            map["SearchKeyWord"] = self.searchKeyWord!
        }
        if self.searchParam != nil {
            map["SearchParam"] = self.searchParam!
        }
        if self.searchRule != nil {
            map["SearchRule"] = self.searchRule!
        }
        if self.searchValue != nil {
            map["SearchValue"] = self.searchValue!
        }
        if self.sqlId != nil {
            map["SqlId"] = self.sqlId!
        }
        if self.sqlTextLength != nil {
            map["SqlTextLength"] = self.sqlTextLength!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("DynamicSql") {
            self.dynamicSql = dict["DynamicSql"] as! Bool
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("FilterCondition") {
            self.filterCondition = dict["FilterCondition"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MergeDynamicSql") {
            self.mergeDynamicSql = dict["MergeDynamicSql"] as! Bool
        }
        if dict.keys.contains("NodeIp") {
            self.nodeIp = dict["NodeIp"] as! String
        }
        if dict.keys.contains("SearchKeyWord") {
            self.searchKeyWord = dict["SearchKeyWord"] as! String
        }
        if dict.keys.contains("SearchParam") {
            self.searchParam = dict["SearchParam"] as! String
        }
        if dict.keys.contains("SearchRule") {
            self.searchRule = dict["SearchRule"] as! String
        }
        if dict.keys.contains("SearchValue") {
            self.searchValue = dict["SearchValue"] as! String
        }
        if dict.keys.contains("SqlId") {
            self.sqlId = dict["SqlId"] as! String
        }
        if dict.keys.contains("SqlTextLength") {
            self.sqlTextLength = dict["SqlTextLength"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DescribeOasTopSQLListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SqlList : Tea.TeaModel {
            public var avgAffectedRows: Double?

            public var avgApplicationWaitTime: Double?

            public var avgBlockCacheHit: Double?

            public var avgBlockIndexCacheHit: Double?

            public var avgBloomFilterCacheHit: Double?

            public var avgConcurrencyWaitTime: Double?

            public var avgCpuTime: Double?

            public var avgDbTime: Double?

            public var avgDecodeTime: Double?

            public var avgDiskReads: Double?

            public var avgElapsedTime: Double?

            public var avgExecuteTime: Double?

            public var avgExecutorRpcCount: Double?

            public var avgExpectedWorkerCount: Double?

            public var avgGetPlanTime: Double?

            public var avgLogicalReads: Double?

            public var avgMemstoreReadRows: Double?

            public var avgNetTime: Double?

            public var avgNetWaitTime: Double?

            public var avgPartitionCount: Double?

            public var avgQueueTime: Double?

            public var avgReturnRows: Double?

            public var avgRowCacheHit: Double?

            public var avgRpcCount: Double?

            public var avgScheduleTime: Double?

            public var avgSsstoreReadRows: Double?

            public var avgUsedWorkerCount: Double?

            public var avgUserIoWaitTime: Double?

            public var avgWaitCount: Double?

            public var avgWaitTime: Double?

            public var clientIp: String?

            public var cpuPercentage: Double?

            public var dbName: String?

            public var distPlanPercentage: Double?

            public var execPs: Double?

            public var executions: Int64?

            public var failCount: Double?

            public var failPercentage: Double?

            public var inner: Bool?

            public var localPlanPercentage: Double?

            public var maxAffectedRows: Double?

            public var maxApplicationWaitTime: Double?

            public var maxConcurrencyWaitTime: Double?

            public var maxCpuTime: Double?

            public var maxDiskReads: Double?

            public var maxElapsedTime: Double?

            public var maxReturnRows: Double?

            public var maxUserIoWaitTime: Double?

            public var maxWaitTime: Double?

            public var missPlanPercentage: Double?

            public var missPlans: Double?

            public var remotePlanPercentage: Double?

            public var remotePlans: Double?

            public var retCode4012Count: Int64?

            public var retCode4013Count: Int64?

            public var retCode5001Count: Int64?

            public var retCode5024Count: Int64?

            public var retCode5167Count: Int64?

            public var retCode5217Count: Int64?

            public var retCode6002Count: Int64?

            public var retryCount: Double?

            public var rpcCount: Double?

            public var server: String?

            public var serverIp: String?

            public var serverPort: Int64?

            public var sqlId: String?

            public var sqlTextShort: String?

            public var sqlType: String?

            public var strongConsistencyPercentage: Double?

            public var sumDbTime: Double?

            public var sumElapsedTime: Double?

            public var sumLogicalReads: Double?

            public var sumWaitTime: Double?

            public var tableScanPercentage: Double?

            public var totalWaitTime: Double?

            public var userName: String?

            public var waitEvent: String?

            public var weakConsistencyPercentage: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avgAffectedRows != nil {
                    map["AvgAffectedRows"] = self.avgAffectedRows!
                }
                if self.avgApplicationWaitTime != nil {
                    map["AvgApplicationWaitTime"] = self.avgApplicationWaitTime!
                }
                if self.avgBlockCacheHit != nil {
                    map["AvgBlockCacheHit"] = self.avgBlockCacheHit!
                }
                if self.avgBlockIndexCacheHit != nil {
                    map["AvgBlockIndexCacheHit"] = self.avgBlockIndexCacheHit!
                }
                if self.avgBloomFilterCacheHit != nil {
                    map["AvgBloomFilterCacheHit"] = self.avgBloomFilterCacheHit!
                }
                if self.avgConcurrencyWaitTime != nil {
                    map["AvgConcurrencyWaitTime"] = self.avgConcurrencyWaitTime!
                }
                if self.avgCpuTime != nil {
                    map["AvgCpuTime"] = self.avgCpuTime!
                }
                if self.avgDbTime != nil {
                    map["AvgDbTime"] = self.avgDbTime!
                }
                if self.avgDecodeTime != nil {
                    map["AvgDecodeTime"] = self.avgDecodeTime!
                }
                if self.avgDiskReads != nil {
                    map["AvgDiskReads"] = self.avgDiskReads!
                }
                if self.avgElapsedTime != nil {
                    map["AvgElapsedTime"] = self.avgElapsedTime!
                }
                if self.avgExecuteTime != nil {
                    map["AvgExecuteTime"] = self.avgExecuteTime!
                }
                if self.avgExecutorRpcCount != nil {
                    map["AvgExecutorRpcCount"] = self.avgExecutorRpcCount!
                }
                if self.avgExpectedWorkerCount != nil {
                    map["AvgExpectedWorkerCount"] = self.avgExpectedWorkerCount!
                }
                if self.avgGetPlanTime != nil {
                    map["AvgGetPlanTime"] = self.avgGetPlanTime!
                }
                if self.avgLogicalReads != nil {
                    map["AvgLogicalReads"] = self.avgLogicalReads!
                }
                if self.avgMemstoreReadRows != nil {
                    map["AvgMemstoreReadRows"] = self.avgMemstoreReadRows!
                }
                if self.avgNetTime != nil {
                    map["AvgNetTime"] = self.avgNetTime!
                }
                if self.avgNetWaitTime != nil {
                    map["AvgNetWaitTime"] = self.avgNetWaitTime!
                }
                if self.avgPartitionCount != nil {
                    map["AvgPartitionCount"] = self.avgPartitionCount!
                }
                if self.avgQueueTime != nil {
                    map["AvgQueueTime"] = self.avgQueueTime!
                }
                if self.avgReturnRows != nil {
                    map["AvgReturnRows"] = self.avgReturnRows!
                }
                if self.avgRowCacheHit != nil {
                    map["AvgRowCacheHit"] = self.avgRowCacheHit!
                }
                if self.avgRpcCount != nil {
                    map["AvgRpcCount"] = self.avgRpcCount!
                }
                if self.avgScheduleTime != nil {
                    map["AvgScheduleTime"] = self.avgScheduleTime!
                }
                if self.avgSsstoreReadRows != nil {
                    map["AvgSsstoreReadRows"] = self.avgSsstoreReadRows!
                }
                if self.avgUsedWorkerCount != nil {
                    map["AvgUsedWorkerCount"] = self.avgUsedWorkerCount!
                }
                if self.avgUserIoWaitTime != nil {
                    map["AvgUserIoWaitTime"] = self.avgUserIoWaitTime!
                }
                if self.avgWaitCount != nil {
                    map["AvgWaitCount"] = self.avgWaitCount!
                }
                if self.avgWaitTime != nil {
                    map["AvgWaitTime"] = self.avgWaitTime!
                }
                if self.clientIp != nil {
                    map["ClientIp"] = self.clientIp!
                }
                if self.cpuPercentage != nil {
                    map["CpuPercentage"] = self.cpuPercentage!
                }
                if self.dbName != nil {
                    map["DbName"] = self.dbName!
                }
                if self.distPlanPercentage != nil {
                    map["DistPlanPercentage"] = self.distPlanPercentage!
                }
                if self.execPs != nil {
                    map["ExecPs"] = self.execPs!
                }
                if self.executions != nil {
                    map["Executions"] = self.executions!
                }
                if self.failCount != nil {
                    map["FailCount"] = self.failCount!
                }
                if self.failPercentage != nil {
                    map["FailPercentage"] = self.failPercentage!
                }
                if self.inner != nil {
                    map["Inner"] = self.inner!
                }
                if self.localPlanPercentage != nil {
                    map["LocalPlanPercentage"] = self.localPlanPercentage!
                }
                if self.maxAffectedRows != nil {
                    map["MaxAffectedRows"] = self.maxAffectedRows!
                }
                if self.maxApplicationWaitTime != nil {
                    map["MaxApplicationWaitTime"] = self.maxApplicationWaitTime!
                }
                if self.maxConcurrencyWaitTime != nil {
                    map["MaxConcurrencyWaitTime"] = self.maxConcurrencyWaitTime!
                }
                if self.maxCpuTime != nil {
                    map["MaxCpuTime"] = self.maxCpuTime!
                }
                if self.maxDiskReads != nil {
                    map["MaxDiskReads"] = self.maxDiskReads!
                }
                if self.maxElapsedTime != nil {
                    map["MaxElapsedTime"] = self.maxElapsedTime!
                }
                if self.maxReturnRows != nil {
                    map["MaxReturnRows"] = self.maxReturnRows!
                }
                if self.maxUserIoWaitTime != nil {
                    map["MaxUserIoWaitTime"] = self.maxUserIoWaitTime!
                }
                if self.maxWaitTime != nil {
                    map["MaxWaitTime"] = self.maxWaitTime!
                }
                if self.missPlanPercentage != nil {
                    map["MissPlanPercentage"] = self.missPlanPercentage!
                }
                if self.missPlans != nil {
                    map["MissPlans"] = self.missPlans!
                }
                if self.remotePlanPercentage != nil {
                    map["RemotePlanPercentage"] = self.remotePlanPercentage!
                }
                if self.remotePlans != nil {
                    map["RemotePlans"] = self.remotePlans!
                }
                if self.retCode4012Count != nil {
                    map["RetCode4012Count"] = self.retCode4012Count!
                }
                if self.retCode4013Count != nil {
                    map["RetCode4013Count"] = self.retCode4013Count!
                }
                if self.retCode5001Count != nil {
                    map["RetCode5001Count"] = self.retCode5001Count!
                }
                if self.retCode5024Count != nil {
                    map["RetCode5024Count"] = self.retCode5024Count!
                }
                if self.retCode5167Count != nil {
                    map["RetCode5167Count"] = self.retCode5167Count!
                }
                if self.retCode5217Count != nil {
                    map["RetCode5217Count"] = self.retCode5217Count!
                }
                if self.retCode6002Count != nil {
                    map["RetCode6002Count"] = self.retCode6002Count!
                }
                if self.retryCount != nil {
                    map["RetryCount"] = self.retryCount!
                }
                if self.rpcCount != nil {
                    map["RpcCount"] = self.rpcCount!
                }
                if self.server != nil {
                    map["Server"] = self.server!
                }
                if self.serverIp != nil {
                    map["ServerIp"] = self.serverIp!
                }
                if self.serverPort != nil {
                    map["ServerPort"] = self.serverPort!
                }
                if self.sqlId != nil {
                    map["SqlId"] = self.sqlId!
                }
                if self.sqlTextShort != nil {
                    map["SqlTextShort"] = self.sqlTextShort!
                }
                if self.sqlType != nil {
                    map["SqlType"] = self.sqlType!
                }
                if self.strongConsistencyPercentage != nil {
                    map["StrongConsistencyPercentage"] = self.strongConsistencyPercentage!
                }
                if self.sumDbTime != nil {
                    map["SumDbTime"] = self.sumDbTime!
                }
                if self.sumElapsedTime != nil {
                    map["SumElapsedTime"] = self.sumElapsedTime!
                }
                if self.sumLogicalReads != nil {
                    map["SumLogicalReads"] = self.sumLogicalReads!
                }
                if self.sumWaitTime != nil {
                    map["SumWaitTime"] = self.sumWaitTime!
                }
                if self.tableScanPercentage != nil {
                    map["TableScanPercentage"] = self.tableScanPercentage!
                }
                if self.totalWaitTime != nil {
                    map["TotalWaitTime"] = self.totalWaitTime!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                if self.waitEvent != nil {
                    map["WaitEvent"] = self.waitEvent!
                }
                if self.weakConsistencyPercentage != nil {
                    map["WeakConsistencyPercentage"] = self.weakConsistencyPercentage!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvgAffectedRows") {
                    self.avgAffectedRows = dict["AvgAffectedRows"] as! Double
                }
                if dict.keys.contains("AvgApplicationWaitTime") {
                    self.avgApplicationWaitTime = dict["AvgApplicationWaitTime"] as! Double
                }
                if dict.keys.contains("AvgBlockCacheHit") {
                    self.avgBlockCacheHit = dict["AvgBlockCacheHit"] as! Double
                }
                if dict.keys.contains("AvgBlockIndexCacheHit") {
                    self.avgBlockIndexCacheHit = dict["AvgBlockIndexCacheHit"] as! Double
                }
                if dict.keys.contains("AvgBloomFilterCacheHit") {
                    self.avgBloomFilterCacheHit = dict["AvgBloomFilterCacheHit"] as! Double
                }
                if dict.keys.contains("AvgConcurrencyWaitTime") {
                    self.avgConcurrencyWaitTime = dict["AvgConcurrencyWaitTime"] as! Double
                }
                if dict.keys.contains("AvgCpuTime") {
                    self.avgCpuTime = dict["AvgCpuTime"] as! Double
                }
                if dict.keys.contains("AvgDbTime") {
                    self.avgDbTime = dict["AvgDbTime"] as! Double
                }
                if dict.keys.contains("AvgDecodeTime") {
                    self.avgDecodeTime = dict["AvgDecodeTime"] as! Double
                }
                if dict.keys.contains("AvgDiskReads") {
                    self.avgDiskReads = dict["AvgDiskReads"] as! Double
                }
                if dict.keys.contains("AvgElapsedTime") {
                    self.avgElapsedTime = dict["AvgElapsedTime"] as! Double
                }
                if dict.keys.contains("AvgExecuteTime") {
                    self.avgExecuteTime = dict["AvgExecuteTime"] as! Double
                }
                if dict.keys.contains("AvgExecutorRpcCount") {
                    self.avgExecutorRpcCount = dict["AvgExecutorRpcCount"] as! Double
                }
                if dict.keys.contains("AvgExpectedWorkerCount") {
                    self.avgExpectedWorkerCount = dict["AvgExpectedWorkerCount"] as! Double
                }
                if dict.keys.contains("AvgGetPlanTime") {
                    self.avgGetPlanTime = dict["AvgGetPlanTime"] as! Double
                }
                if dict.keys.contains("AvgLogicalReads") {
                    self.avgLogicalReads = dict["AvgLogicalReads"] as! Double
                }
                if dict.keys.contains("AvgMemstoreReadRows") {
                    self.avgMemstoreReadRows = dict["AvgMemstoreReadRows"] as! Double
                }
                if dict.keys.contains("AvgNetTime") {
                    self.avgNetTime = dict["AvgNetTime"] as! Double
                }
                if dict.keys.contains("AvgNetWaitTime") {
                    self.avgNetWaitTime = dict["AvgNetWaitTime"] as! Double
                }
                if dict.keys.contains("AvgPartitionCount") {
                    self.avgPartitionCount = dict["AvgPartitionCount"] as! Double
                }
                if dict.keys.contains("AvgQueueTime") {
                    self.avgQueueTime = dict["AvgQueueTime"] as! Double
                }
                if dict.keys.contains("AvgReturnRows") {
                    self.avgReturnRows = dict["AvgReturnRows"] as! Double
                }
                if dict.keys.contains("AvgRowCacheHit") {
                    self.avgRowCacheHit = dict["AvgRowCacheHit"] as! Double
                }
                if dict.keys.contains("AvgRpcCount") {
                    self.avgRpcCount = dict["AvgRpcCount"] as! Double
                }
                if dict.keys.contains("AvgScheduleTime") {
                    self.avgScheduleTime = dict["AvgScheduleTime"] as! Double
                }
                if dict.keys.contains("AvgSsstoreReadRows") {
                    self.avgSsstoreReadRows = dict["AvgSsstoreReadRows"] as! Double
                }
                if dict.keys.contains("AvgUsedWorkerCount") {
                    self.avgUsedWorkerCount = dict["AvgUsedWorkerCount"] as! Double
                }
                if dict.keys.contains("AvgUserIoWaitTime") {
                    self.avgUserIoWaitTime = dict["AvgUserIoWaitTime"] as! Double
                }
                if dict.keys.contains("AvgWaitCount") {
                    self.avgWaitCount = dict["AvgWaitCount"] as! Double
                }
                if dict.keys.contains("AvgWaitTime") {
                    self.avgWaitTime = dict["AvgWaitTime"] as! Double
                }
                if dict.keys.contains("ClientIp") {
                    self.clientIp = dict["ClientIp"] as! String
                }
                if dict.keys.contains("CpuPercentage") {
                    self.cpuPercentage = dict["CpuPercentage"] as! Double
                }
                if dict.keys.contains("DbName") {
                    self.dbName = dict["DbName"] as! String
                }
                if dict.keys.contains("DistPlanPercentage") {
                    self.distPlanPercentage = dict["DistPlanPercentage"] as! Double
                }
                if dict.keys.contains("ExecPs") {
                    self.execPs = dict["ExecPs"] as! Double
                }
                if dict.keys.contains("Executions") {
                    self.executions = dict["Executions"] as! Int64
                }
                if dict.keys.contains("FailCount") {
                    self.failCount = dict["FailCount"] as! Double
                }
                if dict.keys.contains("FailPercentage") {
                    self.failPercentage = dict["FailPercentage"] as! Double
                }
                if dict.keys.contains("Inner") {
                    self.inner = dict["Inner"] as! Bool
                }
                if dict.keys.contains("LocalPlanPercentage") {
                    self.localPlanPercentage = dict["LocalPlanPercentage"] as! Double
                }
                if dict.keys.contains("MaxAffectedRows") {
                    self.maxAffectedRows = dict["MaxAffectedRows"] as! Double
                }
                if dict.keys.contains("MaxApplicationWaitTime") {
                    self.maxApplicationWaitTime = dict["MaxApplicationWaitTime"] as! Double
                }
                if dict.keys.contains("MaxConcurrencyWaitTime") {
                    self.maxConcurrencyWaitTime = dict["MaxConcurrencyWaitTime"] as! Double
                }
                if dict.keys.contains("MaxCpuTime") {
                    self.maxCpuTime = dict["MaxCpuTime"] as! Double
                }
                if dict.keys.contains("MaxDiskReads") {
                    self.maxDiskReads = dict["MaxDiskReads"] as! Double
                }
                if dict.keys.contains("MaxElapsedTime") {
                    self.maxElapsedTime = dict["MaxElapsedTime"] as! Double
                }
                if dict.keys.contains("MaxReturnRows") {
                    self.maxReturnRows = dict["MaxReturnRows"] as! Double
                }
                if dict.keys.contains("MaxUserIoWaitTime") {
                    self.maxUserIoWaitTime = dict["MaxUserIoWaitTime"] as! Double
                }
                if dict.keys.contains("MaxWaitTime") {
                    self.maxWaitTime = dict["MaxWaitTime"] as! Double
                }
                if dict.keys.contains("MissPlanPercentage") {
                    self.missPlanPercentage = dict["MissPlanPercentage"] as! Double
                }
                if dict.keys.contains("MissPlans") {
                    self.missPlans = dict["MissPlans"] as! Double
                }
                if dict.keys.contains("RemotePlanPercentage") {
                    self.remotePlanPercentage = dict["RemotePlanPercentage"] as! Double
                }
                if dict.keys.contains("RemotePlans") {
                    self.remotePlans = dict["RemotePlans"] as! Double
                }
                if dict.keys.contains("RetCode4012Count") {
                    self.retCode4012Count = dict["RetCode4012Count"] as! Int64
                }
                if dict.keys.contains("RetCode4013Count") {
                    self.retCode4013Count = dict["RetCode4013Count"] as! Int64
                }
                if dict.keys.contains("RetCode5001Count") {
                    self.retCode5001Count = dict["RetCode5001Count"] as! Int64
                }
                if dict.keys.contains("RetCode5024Count") {
                    self.retCode5024Count = dict["RetCode5024Count"] as! Int64
                }
                if dict.keys.contains("RetCode5167Count") {
                    self.retCode5167Count = dict["RetCode5167Count"] as! Int64
                }
                if dict.keys.contains("RetCode5217Count") {
                    self.retCode5217Count = dict["RetCode5217Count"] as! Int64
                }
                if dict.keys.contains("RetCode6002Count") {
                    self.retCode6002Count = dict["RetCode6002Count"] as! Int64
                }
                if dict.keys.contains("RetryCount") {
                    self.retryCount = dict["RetryCount"] as! Double
                }
                if dict.keys.contains("RpcCount") {
                    self.rpcCount = dict["RpcCount"] as! Double
                }
                if dict.keys.contains("Server") {
                    self.server = dict["Server"] as! String
                }
                if dict.keys.contains("ServerIp") {
                    self.serverIp = dict["ServerIp"] as! String
                }
                if dict.keys.contains("ServerPort") {
                    self.serverPort = dict["ServerPort"] as! Int64
                }
                if dict.keys.contains("SqlId") {
                    self.sqlId = dict["SqlId"] as! String
                }
                if dict.keys.contains("SqlTextShort") {
                    self.sqlTextShort = dict["SqlTextShort"] as! String
                }
                if dict.keys.contains("SqlType") {
                    self.sqlType = dict["SqlType"] as! String
                }
                if dict.keys.contains("StrongConsistencyPercentage") {
                    self.strongConsistencyPercentage = dict["StrongConsistencyPercentage"] as! Double
                }
                if dict.keys.contains("SumDbTime") {
                    self.sumDbTime = dict["SumDbTime"] as! Double
                }
                if dict.keys.contains("SumElapsedTime") {
                    self.sumElapsedTime = dict["SumElapsedTime"] as! Double
                }
                if dict.keys.contains("SumLogicalReads") {
                    self.sumLogicalReads = dict["SumLogicalReads"] as! Double
                }
                if dict.keys.contains("SumWaitTime") {
                    self.sumWaitTime = dict["SumWaitTime"] as! Double
                }
                if dict.keys.contains("TableScanPercentage") {
                    self.tableScanPercentage = dict["TableScanPercentage"] as! Double
                }
                if dict.keys.contains("TotalWaitTime") {
                    self.totalWaitTime = dict["TotalWaitTime"] as! Double
                }
                if dict.keys.contains("UserName") {
                    self.userName = dict["UserName"] as! String
                }
                if dict.keys.contains("WaitEvent") {
                    self.waitEvent = dict["WaitEvent"] as! String
                }
                if dict.keys.contains("WeakConsistencyPercentage") {
                    self.weakConsistencyPercentage = dict["WeakConsistencyPercentage"] as! Double
                }
            }
        }
        public var avgAffectedRows: Double?

        public var avgApplicationWaitTime: Double?

        public var avgBlockCacheHit: Double?

        public var avgBlockIndexCacheHit: Double?

        public var avgBloomFilterCacheHit: Double?

        public var avgConcurrencyWaitTime: Double?

        public var avgCpuTime: Double?

        public var avgDbTime: Double?

        public var avgDecodeTime: Double?

        public var avgDiskReads: Double?

        public var avgElapsedTime: Double?

        public var avgExecuteTime: Double?

        public var avgExecutorRpcCount: Double?

        public var avgExpectedWorkerCount: Double?

        public var avgGetPlanTime: Double?

        public var avgLogicalReads: Double?

        public var avgMemstoreReadRows: Double?

        public var avgNetTime: Double?

        public var avgNetWaitTime: Double?

        public var avgPartitionCount: Double?

        public var avgQueueTime: Double?

        public var avgReturnRows: Double?

        public var avgRowCacheHit: Double?

        public var avgRpcCount: Double?

        public var avgScheduleTime: Double?

        public var avgSsstoreReadRows: Double?

        public var avgUsedWorkerCount: Double?

        public var avgUserIoWaitTime: Double?

        public var avgWaitCount: Double?

        public var avgWaitTime: Double?

        public var clientIp: String?

        public var cpuPercentage: Double?

        public var dbName: String?

        public var distPlanPercentage: Double?

        public var dynamicSql: Bool?

        public var execPs: Double?

        public var executions: Int64?

        public var failCount: Double?

        public var failPercentage: Double?

        public var inner: Bool?

        public var lastFailCode: Int64?

        public var localPlanPercentage: Double?

        public var maxAffectedRows: Double?

        public var maxApplicationWaitTime: Double?

        public var maxConcurrencyWaitTime: Double?

        public var maxCpuTime: Double?

        public var maxDiskReads: Double?

        public var maxElapsedTime: Double?

        public var maxReturnRows: Double?

        public var maxUserIoWaitTime: Double?

        public var maxWaitTime: Double?

        public var missPlanPercentage: Double?

        public var missPlans: Double?

        public var remotePlanPercentage: Double?

        public var remotePlans: Double?

        public var retCode4012Count: Int64?

        public var retCode4013Count: Int64?

        public var retCode5001Count: Int64?

        public var retCode5024Count: Int64?

        public var retCode5167Count: Int64?

        public var retCode5217Count: Int64?

        public var retCode6002Count: Int64?

        public var retryCount: Double?

        public var rpcCount: Double?

        public var server: String?

        public var serverIp: String?

        public var serverPort: Int64?

        public var sqlId: String?

        public var sqlList: [DescribeOasTopSQLListResponseBody.Data.SqlList]?

        public var sqlTextShort: String?

        public var sqlType: String?

        public var strongConsistencyPercentage: Double?

        public var sumDbTime: Double?

        public var sumElapsedTime: Double?

        public var sumLogicalReads: Double?

        public var sumWaitTime: Double?

        public var tableScanPercentage: Double?

        public var totalWaitTime: Double?

        public var userName: String?

        public var waitEvent: String?

        public var weakConsistencyPercentage: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avgAffectedRows != nil {
                map["AvgAffectedRows"] = self.avgAffectedRows!
            }
            if self.avgApplicationWaitTime != nil {
                map["AvgApplicationWaitTime"] = self.avgApplicationWaitTime!
            }
            if self.avgBlockCacheHit != nil {
                map["AvgBlockCacheHit"] = self.avgBlockCacheHit!
            }
            if self.avgBlockIndexCacheHit != nil {
                map["AvgBlockIndexCacheHit"] = self.avgBlockIndexCacheHit!
            }
            if self.avgBloomFilterCacheHit != nil {
                map["AvgBloomFilterCacheHit"] = self.avgBloomFilterCacheHit!
            }
            if self.avgConcurrencyWaitTime != nil {
                map["AvgConcurrencyWaitTime"] = self.avgConcurrencyWaitTime!
            }
            if self.avgCpuTime != nil {
                map["AvgCpuTime"] = self.avgCpuTime!
            }
            if self.avgDbTime != nil {
                map["AvgDbTime"] = self.avgDbTime!
            }
            if self.avgDecodeTime != nil {
                map["AvgDecodeTime"] = self.avgDecodeTime!
            }
            if self.avgDiskReads != nil {
                map["AvgDiskReads"] = self.avgDiskReads!
            }
            if self.avgElapsedTime != nil {
                map["AvgElapsedTime"] = self.avgElapsedTime!
            }
            if self.avgExecuteTime != nil {
                map["AvgExecuteTime"] = self.avgExecuteTime!
            }
            if self.avgExecutorRpcCount != nil {
                map["AvgExecutorRpcCount"] = self.avgExecutorRpcCount!
            }
            if self.avgExpectedWorkerCount != nil {
                map["AvgExpectedWorkerCount"] = self.avgExpectedWorkerCount!
            }
            if self.avgGetPlanTime != nil {
                map["AvgGetPlanTime"] = self.avgGetPlanTime!
            }
            if self.avgLogicalReads != nil {
                map["AvgLogicalReads"] = self.avgLogicalReads!
            }
            if self.avgMemstoreReadRows != nil {
                map["AvgMemstoreReadRows"] = self.avgMemstoreReadRows!
            }
            if self.avgNetTime != nil {
                map["AvgNetTime"] = self.avgNetTime!
            }
            if self.avgNetWaitTime != nil {
                map["AvgNetWaitTime"] = self.avgNetWaitTime!
            }
            if self.avgPartitionCount != nil {
                map["AvgPartitionCount"] = self.avgPartitionCount!
            }
            if self.avgQueueTime != nil {
                map["AvgQueueTime"] = self.avgQueueTime!
            }
            if self.avgReturnRows != nil {
                map["AvgReturnRows"] = self.avgReturnRows!
            }
            if self.avgRowCacheHit != nil {
                map["AvgRowCacheHit"] = self.avgRowCacheHit!
            }
            if self.avgRpcCount != nil {
                map["AvgRpcCount"] = self.avgRpcCount!
            }
            if self.avgScheduleTime != nil {
                map["AvgScheduleTime"] = self.avgScheduleTime!
            }
            if self.avgSsstoreReadRows != nil {
                map["AvgSsstoreReadRows"] = self.avgSsstoreReadRows!
            }
            if self.avgUsedWorkerCount != nil {
                map["AvgUsedWorkerCount"] = self.avgUsedWorkerCount!
            }
            if self.avgUserIoWaitTime != nil {
                map["AvgUserIoWaitTime"] = self.avgUserIoWaitTime!
            }
            if self.avgWaitCount != nil {
                map["AvgWaitCount"] = self.avgWaitCount!
            }
            if self.avgWaitTime != nil {
                map["AvgWaitTime"] = self.avgWaitTime!
            }
            if self.clientIp != nil {
                map["ClientIp"] = self.clientIp!
            }
            if self.cpuPercentage != nil {
                map["CpuPercentage"] = self.cpuPercentage!
            }
            if self.dbName != nil {
                map["DbName"] = self.dbName!
            }
            if self.distPlanPercentage != nil {
                map["DistPlanPercentage"] = self.distPlanPercentage!
            }
            if self.dynamicSql != nil {
                map["DynamicSql"] = self.dynamicSql!
            }
            if self.execPs != nil {
                map["ExecPs"] = self.execPs!
            }
            if self.executions != nil {
                map["Executions"] = self.executions!
            }
            if self.failCount != nil {
                map["FailCount"] = self.failCount!
            }
            if self.failPercentage != nil {
                map["FailPercentage"] = self.failPercentage!
            }
            if self.inner != nil {
                map["Inner"] = self.inner!
            }
            if self.lastFailCode != nil {
                map["LastFailCode"] = self.lastFailCode!
            }
            if self.localPlanPercentage != nil {
                map["LocalPlanPercentage"] = self.localPlanPercentage!
            }
            if self.maxAffectedRows != nil {
                map["MaxAffectedRows"] = self.maxAffectedRows!
            }
            if self.maxApplicationWaitTime != nil {
                map["MaxApplicationWaitTime"] = self.maxApplicationWaitTime!
            }
            if self.maxConcurrencyWaitTime != nil {
                map["MaxConcurrencyWaitTime"] = self.maxConcurrencyWaitTime!
            }
            if self.maxCpuTime != nil {
                map["MaxCpuTime"] = self.maxCpuTime!
            }
            if self.maxDiskReads != nil {
                map["MaxDiskReads"] = self.maxDiskReads!
            }
            if self.maxElapsedTime != nil {
                map["MaxElapsedTime"] = self.maxElapsedTime!
            }
            if self.maxReturnRows != nil {
                map["MaxReturnRows"] = self.maxReturnRows!
            }
            if self.maxUserIoWaitTime != nil {
                map["MaxUserIoWaitTime"] = self.maxUserIoWaitTime!
            }
            if self.maxWaitTime != nil {
                map["MaxWaitTime"] = self.maxWaitTime!
            }
            if self.missPlanPercentage != nil {
                map["MissPlanPercentage"] = self.missPlanPercentage!
            }
            if self.missPlans != nil {
                map["MissPlans"] = self.missPlans!
            }
            if self.remotePlanPercentage != nil {
                map["RemotePlanPercentage"] = self.remotePlanPercentage!
            }
            if self.remotePlans != nil {
                map["RemotePlans"] = self.remotePlans!
            }
            if self.retCode4012Count != nil {
                map["RetCode4012Count"] = self.retCode4012Count!
            }
            if self.retCode4013Count != nil {
                map["RetCode4013Count"] = self.retCode4013Count!
            }
            if self.retCode5001Count != nil {
                map["RetCode5001Count"] = self.retCode5001Count!
            }
            if self.retCode5024Count != nil {
                map["RetCode5024Count"] = self.retCode5024Count!
            }
            if self.retCode5167Count != nil {
                map["RetCode5167Count"] = self.retCode5167Count!
            }
            if self.retCode5217Count != nil {
                map["RetCode5217Count"] = self.retCode5217Count!
            }
            if self.retCode6002Count != nil {
                map["RetCode6002Count"] = self.retCode6002Count!
            }
            if self.retryCount != nil {
                map["RetryCount"] = self.retryCount!
            }
            if self.rpcCount != nil {
                map["RpcCount"] = self.rpcCount!
            }
            if self.server != nil {
                map["Server"] = self.server!
            }
            if self.serverIp != nil {
                map["ServerIp"] = self.serverIp!
            }
            if self.serverPort != nil {
                map["ServerPort"] = self.serverPort!
            }
            if self.sqlId != nil {
                map["SqlId"] = self.sqlId!
            }
            if self.sqlList != nil {
                var tmp : [Any] = []
                for k in self.sqlList! {
                    tmp.append(k.toMap())
                }
                map["SqlList"] = tmp
            }
            if self.sqlTextShort != nil {
                map["SqlTextShort"] = self.sqlTextShort!
            }
            if self.sqlType != nil {
                map["SqlType"] = self.sqlType!
            }
            if self.strongConsistencyPercentage != nil {
                map["StrongConsistencyPercentage"] = self.strongConsistencyPercentage!
            }
            if self.sumDbTime != nil {
                map["SumDbTime"] = self.sumDbTime!
            }
            if self.sumElapsedTime != nil {
                map["SumElapsedTime"] = self.sumElapsedTime!
            }
            if self.sumLogicalReads != nil {
                map["SumLogicalReads"] = self.sumLogicalReads!
            }
            if self.sumWaitTime != nil {
                map["SumWaitTime"] = self.sumWaitTime!
            }
            if self.tableScanPercentage != nil {
                map["TableScanPercentage"] = self.tableScanPercentage!
            }
            if self.totalWaitTime != nil {
                map["TotalWaitTime"] = self.totalWaitTime!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            if self.waitEvent != nil {
                map["WaitEvent"] = self.waitEvent!
            }
            if self.weakConsistencyPercentage != nil {
                map["WeakConsistencyPercentage"] = self.weakConsistencyPercentage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvgAffectedRows") {
                self.avgAffectedRows = dict["AvgAffectedRows"] as! Double
            }
            if dict.keys.contains("AvgApplicationWaitTime") {
                self.avgApplicationWaitTime = dict["AvgApplicationWaitTime"] as! Double
            }
            if dict.keys.contains("AvgBlockCacheHit") {
                self.avgBlockCacheHit = dict["AvgBlockCacheHit"] as! Double
            }
            if dict.keys.contains("AvgBlockIndexCacheHit") {
                self.avgBlockIndexCacheHit = dict["AvgBlockIndexCacheHit"] as! Double
            }
            if dict.keys.contains("AvgBloomFilterCacheHit") {
                self.avgBloomFilterCacheHit = dict["AvgBloomFilterCacheHit"] as! Double
            }
            if dict.keys.contains("AvgConcurrencyWaitTime") {
                self.avgConcurrencyWaitTime = dict["AvgConcurrencyWaitTime"] as! Double
            }
            if dict.keys.contains("AvgCpuTime") {
                self.avgCpuTime = dict["AvgCpuTime"] as! Double
            }
            if dict.keys.contains("AvgDbTime") {
                self.avgDbTime = dict["AvgDbTime"] as! Double
            }
            if dict.keys.contains("AvgDecodeTime") {
                self.avgDecodeTime = dict["AvgDecodeTime"] as! Double
            }
            if dict.keys.contains("AvgDiskReads") {
                self.avgDiskReads = dict["AvgDiskReads"] as! Double
            }
            if dict.keys.contains("AvgElapsedTime") {
                self.avgElapsedTime = dict["AvgElapsedTime"] as! Double
            }
            if dict.keys.contains("AvgExecuteTime") {
                self.avgExecuteTime = dict["AvgExecuteTime"] as! Double
            }
            if dict.keys.contains("AvgExecutorRpcCount") {
                self.avgExecutorRpcCount = dict["AvgExecutorRpcCount"] as! Double
            }
            if dict.keys.contains("AvgExpectedWorkerCount") {
                self.avgExpectedWorkerCount = dict["AvgExpectedWorkerCount"] as! Double
            }
            if dict.keys.contains("AvgGetPlanTime") {
                self.avgGetPlanTime = dict["AvgGetPlanTime"] as! Double
            }
            if dict.keys.contains("AvgLogicalReads") {
                self.avgLogicalReads = dict["AvgLogicalReads"] as! Double
            }
            if dict.keys.contains("AvgMemstoreReadRows") {
                self.avgMemstoreReadRows = dict["AvgMemstoreReadRows"] as! Double
            }
            if dict.keys.contains("AvgNetTime") {
                self.avgNetTime = dict["AvgNetTime"] as! Double
            }
            if dict.keys.contains("AvgNetWaitTime") {
                self.avgNetWaitTime = dict["AvgNetWaitTime"] as! Double
            }
            if dict.keys.contains("AvgPartitionCount") {
                self.avgPartitionCount = dict["AvgPartitionCount"] as! Double
            }
            if dict.keys.contains("AvgQueueTime") {
                self.avgQueueTime = dict["AvgQueueTime"] as! Double
            }
            if dict.keys.contains("AvgReturnRows") {
                self.avgReturnRows = dict["AvgReturnRows"] as! Double
            }
            if dict.keys.contains("AvgRowCacheHit") {
                self.avgRowCacheHit = dict["AvgRowCacheHit"] as! Double
            }
            if dict.keys.contains("AvgRpcCount") {
                self.avgRpcCount = dict["AvgRpcCount"] as! Double
            }
            if dict.keys.contains("AvgScheduleTime") {
                self.avgScheduleTime = dict["AvgScheduleTime"] as! Double
            }
            if dict.keys.contains("AvgSsstoreReadRows") {
                self.avgSsstoreReadRows = dict["AvgSsstoreReadRows"] as! Double
            }
            if dict.keys.contains("AvgUsedWorkerCount") {
                self.avgUsedWorkerCount = dict["AvgUsedWorkerCount"] as! Double
            }
            if dict.keys.contains("AvgUserIoWaitTime") {
                self.avgUserIoWaitTime = dict["AvgUserIoWaitTime"] as! Double
            }
            if dict.keys.contains("AvgWaitCount") {
                self.avgWaitCount = dict["AvgWaitCount"] as! Double
            }
            if dict.keys.contains("AvgWaitTime") {
                self.avgWaitTime = dict["AvgWaitTime"] as! Double
            }
            if dict.keys.contains("ClientIp") {
                self.clientIp = dict["ClientIp"] as! String
            }
            if dict.keys.contains("CpuPercentage") {
                self.cpuPercentage = dict["CpuPercentage"] as! Double
            }
            if dict.keys.contains("DbName") {
                self.dbName = dict["DbName"] as! String
            }
            if dict.keys.contains("DistPlanPercentage") {
                self.distPlanPercentage = dict["DistPlanPercentage"] as! Double
            }
            if dict.keys.contains("DynamicSql") {
                self.dynamicSql = dict["DynamicSql"] as! Bool
            }
            if dict.keys.contains("ExecPs") {
                self.execPs = dict["ExecPs"] as! Double
            }
            if dict.keys.contains("Executions") {
                self.executions = dict["Executions"] as! Int64
            }
            if dict.keys.contains("FailCount") {
                self.failCount = dict["FailCount"] as! Double
            }
            if dict.keys.contains("FailPercentage") {
                self.failPercentage = dict["FailPercentage"] as! Double
            }
            if dict.keys.contains("Inner") {
                self.inner = dict["Inner"] as! Bool
            }
            if dict.keys.contains("LastFailCode") {
                self.lastFailCode = dict["LastFailCode"] as! Int64
            }
            if dict.keys.contains("LocalPlanPercentage") {
                self.localPlanPercentage = dict["LocalPlanPercentage"] as! Double
            }
            if dict.keys.contains("MaxAffectedRows") {
                self.maxAffectedRows = dict["MaxAffectedRows"] as! Double
            }
            if dict.keys.contains("MaxApplicationWaitTime") {
                self.maxApplicationWaitTime = dict["MaxApplicationWaitTime"] as! Double
            }
            if dict.keys.contains("MaxConcurrencyWaitTime") {
                self.maxConcurrencyWaitTime = dict["MaxConcurrencyWaitTime"] as! Double
            }
            if dict.keys.contains("MaxCpuTime") {
                self.maxCpuTime = dict["MaxCpuTime"] as! Double
            }
            if dict.keys.contains("MaxDiskReads") {
                self.maxDiskReads = dict["MaxDiskReads"] as! Double
            }
            if dict.keys.contains("MaxElapsedTime") {
                self.maxElapsedTime = dict["MaxElapsedTime"] as! Double
            }
            if dict.keys.contains("MaxReturnRows") {
                self.maxReturnRows = dict["MaxReturnRows"] as! Double
            }
            if dict.keys.contains("MaxUserIoWaitTime") {
                self.maxUserIoWaitTime = dict["MaxUserIoWaitTime"] as! Double
            }
            if dict.keys.contains("MaxWaitTime") {
                self.maxWaitTime = dict["MaxWaitTime"] as! Double
            }
            if dict.keys.contains("MissPlanPercentage") {
                self.missPlanPercentage = dict["MissPlanPercentage"] as! Double
            }
            if dict.keys.contains("MissPlans") {
                self.missPlans = dict["MissPlans"] as! Double
            }
            if dict.keys.contains("RemotePlanPercentage") {
                self.remotePlanPercentage = dict["RemotePlanPercentage"] as! Double
            }
            if dict.keys.contains("RemotePlans") {
                self.remotePlans = dict["RemotePlans"] as! Double
            }
            if dict.keys.contains("RetCode4012Count") {
                self.retCode4012Count = dict["RetCode4012Count"] as! Int64
            }
            if dict.keys.contains("RetCode4013Count") {
                self.retCode4013Count = dict["RetCode4013Count"] as! Int64
            }
            if dict.keys.contains("RetCode5001Count") {
                self.retCode5001Count = dict["RetCode5001Count"] as! Int64
            }
            if dict.keys.contains("RetCode5024Count") {
                self.retCode5024Count = dict["RetCode5024Count"] as! Int64
            }
            if dict.keys.contains("RetCode5167Count") {
                self.retCode5167Count = dict["RetCode5167Count"] as! Int64
            }
            if dict.keys.contains("RetCode5217Count") {
                self.retCode5217Count = dict["RetCode5217Count"] as! Int64
            }
            if dict.keys.contains("RetCode6002Count") {
                self.retCode6002Count = dict["RetCode6002Count"] as! Int64
            }
            if dict.keys.contains("RetryCount") {
                self.retryCount = dict["RetryCount"] as! Double
            }
            if dict.keys.contains("RpcCount") {
                self.rpcCount = dict["RpcCount"] as! Double
            }
            if dict.keys.contains("Server") {
                self.server = dict["Server"] as! String
            }
            if dict.keys.contains("ServerIp") {
                self.serverIp = dict["ServerIp"] as! String
            }
            if dict.keys.contains("ServerPort") {
                self.serverPort = dict["ServerPort"] as! Int64
            }
            if dict.keys.contains("SqlId") {
                self.sqlId = dict["SqlId"] as! String
            }
            if dict.keys.contains("SqlList") {
                var tmp : [DescribeOasTopSQLListResponseBody.Data.SqlList] = []
                for v in dict["SqlList"] as! [Any] {
                    var model = DescribeOasTopSQLListResponseBody.Data.SqlList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sqlList = tmp
            }
            if dict.keys.contains("SqlTextShort") {
                self.sqlTextShort = dict["SqlTextShort"] as! String
            }
            if dict.keys.contains("SqlType") {
                self.sqlType = dict["SqlType"] as! String
            }
            if dict.keys.contains("StrongConsistencyPercentage") {
                self.strongConsistencyPercentage = dict["StrongConsistencyPercentage"] as! Double
            }
            if dict.keys.contains("SumDbTime") {
                self.sumDbTime = dict["SumDbTime"] as! Double
            }
            if dict.keys.contains("SumElapsedTime") {
                self.sumElapsedTime = dict["SumElapsedTime"] as! Double
            }
            if dict.keys.contains("SumLogicalReads") {
                self.sumLogicalReads = dict["SumLogicalReads"] as! Double
            }
            if dict.keys.contains("SumWaitTime") {
                self.sumWaitTime = dict["SumWaitTime"] as! Double
            }
            if dict.keys.contains("TableScanPercentage") {
                self.tableScanPercentage = dict["TableScanPercentage"] as! Double
            }
            if dict.keys.contains("TotalWaitTime") {
                self.totalWaitTime = dict["TotalWaitTime"] as! Double
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
            if dict.keys.contains("WaitEvent") {
                self.waitEvent = dict["WaitEvent"] as! String
            }
            if dict.keys.contains("WeakConsistencyPercentage") {
                self.weakConsistencyPercentage = dict["WeakConsistencyPercentage"] as! Double
            }
        }
    }
    public var data: [DescribeOasTopSQLListResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [DescribeOasTopSQLListResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeOasTopSQLListResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeOasTopSQLListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOasTopSQLListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOasTopSQLListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOutlineBindingRequest : Tea.TeaModel {
    public var databaseName: String?

    public var instanceId: String?

    public var isConcurrentLimit: Bool?

    public var SQLId: String?

    public var tableName: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.isConcurrentLimit != nil {
            map["IsConcurrentLimit"] = self.isConcurrentLimit!
        }
        if self.SQLId != nil {
            map["SQLId"] = self.SQLId!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatabaseName") {
            self.databaseName = dict["DatabaseName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("IsConcurrentLimit") {
            self.isConcurrentLimit = dict["IsConcurrentLimit"] as! Bool
        }
        if dict.keys.contains("SQLId") {
            self.SQLId = dict["SQLId"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DescribeOutlineBindingResponseBody : Tea.TeaModel {
    public class OutlineBinding : Tea.TeaModel {
        public var bindIndex: String?

        public var bindPlan: String?

        public var maxConcurrent: Int32?

        public var outlineId: Int64?

        public var tableName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bindIndex != nil {
                map["BindIndex"] = self.bindIndex!
            }
            if self.bindPlan != nil {
                map["BindPlan"] = self.bindPlan!
            }
            if self.maxConcurrent != nil {
                map["MaxConcurrent"] = self.maxConcurrent!
            }
            if self.outlineId != nil {
                map["OutlineId"] = self.outlineId!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BindIndex") {
                self.bindIndex = dict["BindIndex"] as! String
            }
            if dict.keys.contains("BindPlan") {
                self.bindPlan = dict["BindPlan"] as! String
            }
            if dict.keys.contains("MaxConcurrent") {
                self.maxConcurrent = dict["MaxConcurrent"] as! Int32
            }
            if dict.keys.contains("OutlineId") {
                self.outlineId = dict["OutlineId"] as! Int64
            }
            if dict.keys.contains("TableName") {
                self.tableName = dict["TableName"] as! String
            }
        }
    }
    public var outlineBinding: DescribeOutlineBindingResponseBody.OutlineBinding?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.outlineBinding?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.outlineBinding != nil {
            map["OutlineBinding"] = self.outlineBinding?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OutlineBinding") {
            var model = DescribeOutlineBindingResponseBody.OutlineBinding()
            model.fromMap(dict["OutlineBinding"] as! [String: Any])
            self.outlineBinding = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeOutlineBindingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOutlineBindingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOutlineBindingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeParametersRequest : Tea.TeaModel {
    public var dimension: String?

    public var dimensionValue: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dimension != nil {
            map["Dimension"] = self.dimension!
        }
        if self.dimensionValue != nil {
            map["DimensionValue"] = self.dimensionValue!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Dimension") {
            self.dimension = dict["Dimension"] as! String
        }
        if dict.keys.contains("DimensionValue") {
            self.dimensionValue = dict["DimensionValue"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DescribeParametersResponseBody : Tea.TeaModel {
    public class Parameters : Tea.TeaModel {
        public var acceptableValue: [String]?

        public var currentValue: String?

        public var defaultValue: String?

        public var description_: String?

        public var name: String?

        public var needReboot: Bool?

        public var readonly: Bool?

        public var rejectedValue: [String]?

        public var unit: String?

        public var valueType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acceptableValue != nil {
                map["AcceptableValue"] = self.acceptableValue!
            }
            if self.currentValue != nil {
                map["CurrentValue"] = self.currentValue!
            }
            if self.defaultValue != nil {
                map["DefaultValue"] = self.defaultValue!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.needReboot != nil {
                map["NeedReboot"] = self.needReboot!
            }
            if self.readonly != nil {
                map["Readonly"] = self.readonly!
            }
            if self.rejectedValue != nil {
                map["RejectedValue"] = self.rejectedValue!
            }
            if self.unit != nil {
                map["Unit"] = self.unit!
            }
            if self.valueType != nil {
                map["ValueType"] = self.valueType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AcceptableValue") {
                self.acceptableValue = dict["AcceptableValue"] as! [String]
            }
            if dict.keys.contains("CurrentValue") {
                self.currentValue = dict["CurrentValue"] as! String
            }
            if dict.keys.contains("DefaultValue") {
                self.defaultValue = dict["DefaultValue"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NeedReboot") {
                self.needReboot = dict["NeedReboot"] as! Bool
            }
            if dict.keys.contains("Readonly") {
                self.readonly = dict["Readonly"] as! Bool
            }
            if dict.keys.contains("RejectedValue") {
                self.rejectedValue = dict["RejectedValue"] as! [String]
            }
            if dict.keys.contains("Unit") {
                self.unit = dict["Unit"] as! String
            }
            if dict.keys.contains("ValueType") {
                self.valueType = dict["ValueType"] as! String
            }
        }
    }
    public var parameters: [DescribeParametersResponseBody.Parameters]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.parameters != nil {
            var tmp : [Any] = []
            for k in self.parameters! {
                tmp.append(k.toMap())
            }
            map["Parameters"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Parameters") {
            var tmp : [DescribeParametersResponseBody.Parameters] = []
            for v in dict["Parameters"] as! [Any] {
                var model = DescribeParametersResponseBody.Parameters()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.parameters = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeParametersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeParametersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeParametersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeParametersHistoryRequest : Tea.TeaModel {
    public var dimension: String?

    public var dimensionValue: String?

    public var endTime: String?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dimension != nil {
            map["Dimension"] = self.dimension!
        }
        if self.dimensionValue != nil {
            map["DimensionValue"] = self.dimensionValue!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Dimension") {
            self.dimension = dict["Dimension"] as! String
        }
        if dict.keys.contains("DimensionValue") {
            self.dimensionValue = dict["DimensionValue"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeParametersHistoryResponseBody : Tea.TeaModel {
    public class Respond : Tea.TeaModel {
        public class Parameters : Tea.TeaModel {
            public var createTime: String?

            public var dimensionValue: String?

            public var name: String?

            public var newValue: String?

            public var oldValue: String?

            public var status: String?

            public var updateTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dimensionValue != nil {
                    map["DimensionValue"] = self.dimensionValue!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.newValue != nil {
                    map["NewValue"] = self.newValue!
                }
                if self.oldValue != nil {
                    map["OldValue"] = self.oldValue!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DimensionValue") {
                    self.dimensionValue = dict["DimensionValue"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NewValue") {
                    self.newValue = dict["NewValue"] as! String
                }
                if dict.keys.contains("OldValue") {
                    self.oldValue = dict["OldValue"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var parameters: [DescribeParametersHistoryResponseBody.Respond.Parameters]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.parameters != nil {
                var tmp : [Any] = []
                for k in self.parameters! {
                    tmp.append(k.toMap())
                }
                map["Parameters"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("Parameters") {
                var tmp : [DescribeParametersHistoryResponseBody.Respond.Parameters] = []
                for v in dict["Parameters"] as! [Any] {
                    var model = DescribeParametersHistoryResponseBody.Respond.Parameters()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.parameters = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var respond: [DescribeParametersHistoryResponseBody.Respond]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.respond != nil {
            var tmp : [Any] = []
            for k in self.respond! {
                tmp.append(k.toMap())
            }
            map["Respond"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Respond") {
            var tmp : [DescribeParametersHistoryResponseBody.Respond] = []
            for v in dict["Respond"] as! [Any] {
                var model = DescribeParametersHistoryResponseBody.Respond()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.respond = tmp
        }
    }
}

public class DescribeParametersHistoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeParametersHistoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeParametersHistoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeProcessStatsCompositionRequest : Tea.TeaModel {
    public var clientIp: String?

    public var instanceId: String?

    public var serverIp: String?

    public var sqlText: String?

    public var status: String?

    public var tenantId: String?

    public var UId: String?

    public var users: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientIp != nil {
            map["ClientIp"] = self.clientIp!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.serverIp != nil {
            map["ServerIp"] = self.serverIp!
        }
        if self.sqlText != nil {
            map["SqlText"] = self.sqlText!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.UId != nil {
            map["UId"] = self.UId!
        }
        if self.users != nil {
            map["Users"] = self.users!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientIp") {
            self.clientIp = dict["ClientIp"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ServerIp") {
            self.serverIp = dict["ServerIp"] as! String
        }
        if dict.keys.contains("SqlText") {
            self.sqlText = dict["SqlText"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("UId") {
            self.UId = dict["UId"] as! String
        }
        if dict.keys.contains("Users") {
            self.users = dict["Users"] as! String
        }
    }
}

public class DescribeProcessStatsCompositionResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AllProcessList : Tea.TeaModel {
            public var clientIp: String?

            public var command: String?

            public var cpuTime: Int64?

            public var database: String?

            public var executeTime: Int64?

            public var planId: String?

            public var proxySessId: String?

            public var serverIp: String?

            public var sessionId: Int64?

            public var sqlId: String?

            public var sqlText: String?

            public var status: String?

            public var tenantId: String?

            public var traceId: String?

            public var user: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clientIp != nil {
                    map["ClientIp"] = self.clientIp!
                }
                if self.command != nil {
                    map["Command"] = self.command!
                }
                if self.cpuTime != nil {
                    map["CpuTime"] = self.cpuTime!
                }
                if self.database != nil {
                    map["Database"] = self.database!
                }
                if self.executeTime != nil {
                    map["ExecuteTime"] = self.executeTime!
                }
                if self.planId != nil {
                    map["PlanId"] = self.planId!
                }
                if self.proxySessId != nil {
                    map["ProxySessId"] = self.proxySessId!
                }
                if self.serverIp != nil {
                    map["ServerIp"] = self.serverIp!
                }
                if self.sessionId != nil {
                    map["SessionId"] = self.sessionId!
                }
                if self.sqlId != nil {
                    map["SqlId"] = self.sqlId!
                }
                if self.sqlText != nil {
                    map["SqlText"] = self.sqlText!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                if self.traceId != nil {
                    map["TraceId"] = self.traceId!
                }
                if self.user != nil {
                    map["User"] = self.user!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClientIp") {
                    self.clientIp = dict["ClientIp"] as! String
                }
                if dict.keys.contains("Command") {
                    self.command = dict["Command"] as! String
                }
                if dict.keys.contains("CpuTime") {
                    self.cpuTime = dict["CpuTime"] as! Int64
                }
                if dict.keys.contains("Database") {
                    self.database = dict["Database"] as! String
                }
                if dict.keys.contains("ExecuteTime") {
                    self.executeTime = dict["ExecuteTime"] as! Int64
                }
                if dict.keys.contains("PlanId") {
                    self.planId = dict["PlanId"] as! String
                }
                if dict.keys.contains("ProxySessId") {
                    self.proxySessId = dict["ProxySessId"] as! String
                }
                if dict.keys.contains("ServerIp") {
                    self.serverIp = dict["ServerIp"] as! String
                }
                if dict.keys.contains("SessionId") {
                    self.sessionId = dict["SessionId"] as! Int64
                }
                if dict.keys.contains("SqlId") {
                    self.sqlId = dict["SqlId"] as! String
                }
                if dict.keys.contains("SqlText") {
                    self.sqlText = dict["SqlText"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TenantId") {
                    self.tenantId = dict["TenantId"] as! String
                }
                if dict.keys.contains("TraceId") {
                    self.traceId = dict["TraceId"] as! String
                }
                if dict.keys.contains("User") {
                    self.user = dict["User"] as! String
                }
            }
        }
        public class SessionStatistics : Tea.TeaModel {
            public class DataBaseStatistics : Tea.TeaModel {
                public var activeCount: Int64?

                public var metricValue: String?

                public var totalCount: Int64?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.activeCount != nil {
                        map["ActiveCount"] = self.activeCount!
                    }
                    if self.metricValue != nil {
                        map["MetricValue"] = self.metricValue!
                    }
                    if self.totalCount != nil {
                        map["TotalCount"] = self.totalCount!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ActiveCount") {
                        self.activeCount = dict["ActiveCount"] as! Int64
                    }
                    if dict.keys.contains("MetricValue") {
                        self.metricValue = dict["MetricValue"] as! String
                    }
                    if dict.keys.contains("TotalCount") {
                        self.totalCount = dict["TotalCount"] as! Int64
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class SourceStatistics : Tea.TeaModel {
                public var activeCount: Int64?

                public var metricValue: String?

                public var totalCount: Int64?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.activeCount != nil {
                        map["ActiveCount"] = self.activeCount!
                    }
                    if self.metricValue != nil {
                        map["MetricValue"] = self.metricValue!
                    }
                    if self.totalCount != nil {
                        map["TotalCount"] = self.totalCount!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ActiveCount") {
                        self.activeCount = dict["ActiveCount"] as! Int64
                    }
                    if dict.keys.contains("MetricValue") {
                        self.metricValue = dict["MetricValue"] as! String
                    }
                    if dict.keys.contains("TotalCount") {
                        self.totalCount = dict["TotalCount"] as! Int64
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class UserStatistics : Tea.TeaModel {
                public var activeCount: Int64?

                public var metricValue: String?

                public var totalCount: Int64?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.activeCount != nil {
                        map["ActiveCount"] = self.activeCount!
                    }
                    if self.metricValue != nil {
                        map["MetricValue"] = self.metricValue!
                    }
                    if self.totalCount != nil {
                        map["TotalCount"] = self.totalCount!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ActiveCount") {
                        self.activeCount = dict["ActiveCount"] as! Int64
                    }
                    if dict.keys.contains("MetricValue") {
                        self.metricValue = dict["MetricValue"] as! String
                    }
                    if dict.keys.contains("TotalCount") {
                        self.totalCount = dict["TotalCount"] as! Int64
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var dataBaseStatistics: [DescribeProcessStatsCompositionResponseBody.Data.SessionStatistics.DataBaseStatistics]?

            public var sourceStatistics: [DescribeProcessStatsCompositionResponseBody.Data.SessionStatistics.SourceStatistics]?

            public var userStatistics: [DescribeProcessStatsCompositionResponseBody.Data.SessionStatistics.UserStatistics]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataBaseStatistics != nil {
                    var tmp : [Any] = []
                    for k in self.dataBaseStatistics! {
                        tmp.append(k.toMap())
                    }
                    map["DataBaseStatistics"] = tmp
                }
                if self.sourceStatistics != nil {
                    var tmp : [Any] = []
                    for k in self.sourceStatistics! {
                        tmp.append(k.toMap())
                    }
                    map["SourceStatistics"] = tmp
                }
                if self.userStatistics != nil {
                    var tmp : [Any] = []
                    for k in self.userStatistics! {
                        tmp.append(k.toMap())
                    }
                    map["UserStatistics"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataBaseStatistics") {
                    var tmp : [DescribeProcessStatsCompositionResponseBody.Data.SessionStatistics.DataBaseStatistics] = []
                    for v in dict["DataBaseStatistics"] as! [Any] {
                        var model = DescribeProcessStatsCompositionResponseBody.Data.SessionStatistics.DataBaseStatistics()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.dataBaseStatistics = tmp
                }
                if dict.keys.contains("SourceStatistics") {
                    var tmp : [DescribeProcessStatsCompositionResponseBody.Data.SessionStatistics.SourceStatistics] = []
                    for v in dict["SourceStatistics"] as! [Any] {
                        var model = DescribeProcessStatsCompositionResponseBody.Data.SessionStatistics.SourceStatistics()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.sourceStatistics = tmp
                }
                if dict.keys.contains("UserStatistics") {
                    var tmp : [DescribeProcessStatsCompositionResponseBody.Data.SessionStatistics.UserStatistics] = []
                    for v in dict["UserStatistics"] as! [Any] {
                        var model = DescribeProcessStatsCompositionResponseBody.Data.SessionStatistics.UserStatistics()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.userStatistics = tmp
                }
            }
        }
        public var activeSessionCount: Int32?

        public var allProcessList: [DescribeProcessStatsCompositionResponseBody.Data.AllProcessList]?

        public var idleSessionCount: Int32?

        public var obVersion: String?

        public var sessionStatistics: DescribeProcessStatsCompositionResponseBody.Data.SessionStatistics?

        public var totalSessionCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.sessionStatistics?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activeSessionCount != nil {
                map["ActiveSessionCount"] = self.activeSessionCount!
            }
            if self.allProcessList != nil {
                var tmp : [Any] = []
                for k in self.allProcessList! {
                    tmp.append(k.toMap())
                }
                map["AllProcessList"] = tmp
            }
            if self.idleSessionCount != nil {
                map["IdleSessionCount"] = self.idleSessionCount!
            }
            if self.obVersion != nil {
                map["ObVersion"] = self.obVersion!
            }
            if self.sessionStatistics != nil {
                map["SessionStatistics"] = self.sessionStatistics?.toMap()
            }
            if self.totalSessionCount != nil {
                map["TotalSessionCount"] = self.totalSessionCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActiveSessionCount") {
                self.activeSessionCount = dict["ActiveSessionCount"] as! Int32
            }
            if dict.keys.contains("AllProcessList") {
                var tmp : [DescribeProcessStatsCompositionResponseBody.Data.AllProcessList] = []
                for v in dict["AllProcessList"] as! [Any] {
                    var model = DescribeProcessStatsCompositionResponseBody.Data.AllProcessList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.allProcessList = tmp
            }
            if dict.keys.contains("IdleSessionCount") {
                self.idleSessionCount = dict["IdleSessionCount"] as! Int32
            }
            if dict.keys.contains("ObVersion") {
                self.obVersion = dict["ObVersion"] as! String
            }
            if dict.keys.contains("SessionStatistics") {
                var model = DescribeProcessStatsCompositionResponseBody.Data.SessionStatistics()
                model.fromMap(dict["SessionStatistics"] as! [String: Any])
                self.sessionStatistics = model
            }
            if dict.keys.contains("TotalSessionCount") {
                self.totalSessionCount = dict["TotalSessionCount"] as! Int32
            }
        }
    }
    public var data: DescribeProcessStatsCompositionResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DescribeProcessStatsCompositionResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeProcessStatsCompositionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeProcessStatsCompositionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeProcessStatsCompositionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeProjectRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class DescribeProjectResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AlarmStats : Tea.TeaModel {
            public var alarmContent: String?

            public var alarming: Bool?

            public var openMonitor: Bool?

            public var recentlyTriggerCount: Int32?

            public var ruleToRecentlyTriggerCount: [String: Int32]?

            public var target: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alarmContent != nil {
                    map["AlarmContent"] = self.alarmContent!
                }
                if self.alarming != nil {
                    map["Alarming"] = self.alarming!
                }
                if self.openMonitor != nil {
                    map["OpenMonitor"] = self.openMonitor!
                }
                if self.recentlyTriggerCount != nil {
                    map["RecentlyTriggerCount"] = self.recentlyTriggerCount!
                }
                if self.ruleToRecentlyTriggerCount != nil {
                    map["RuleToRecentlyTriggerCount"] = self.ruleToRecentlyTriggerCount!
                }
                if self.target != nil {
                    map["Target"] = self.target!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlarmContent") {
                    self.alarmContent = dict["AlarmContent"] as! String
                }
                if dict.keys.contains("Alarming") {
                    self.alarming = dict["Alarming"] as! Bool
                }
                if dict.keys.contains("OpenMonitor") {
                    self.openMonitor = dict["OpenMonitor"] as! Bool
                }
                if dict.keys.contains("RecentlyTriggerCount") {
                    self.recentlyTriggerCount = dict["RecentlyTriggerCount"] as! Int32
                }
                if dict.keys.contains("RuleToRecentlyTriggerCount") {
                    self.ruleToRecentlyTriggerCount = dict["RuleToRecentlyTriggerCount"] as! [String: Int32]
                }
                if dict.keys.contains("Target") {
                    self.target = dict["Target"] as! String
                }
            }
        }
        public class CommonTransferConfig : Tea.TeaModel {
            public var activeActive: Bool?

            public var dataWorksBusinessName: String?

            public var datahubTopicType: String?

            public var mqPartition: Int32?

            public var mqPartitionMode: String?

            public var mqSerializerType: String?

            public var rocketMqEnableMsgTrace: Bool?

            public var rocketMqMsgTags: String?

            public var rocketMqProducerGroup: String?

            public var rocketMqSendMsgTimeout: Int64?

            public var sinkStoreFormat: String?

            public var sourceStoreFormat: String?

            public var tableCategory: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activeActive != nil {
                    map["ActiveActive"] = self.activeActive!
                }
                if self.dataWorksBusinessName != nil {
                    map["DataWorksBusinessName"] = self.dataWorksBusinessName!
                }
                if self.datahubTopicType != nil {
                    map["DatahubTopicType"] = self.datahubTopicType!
                }
                if self.mqPartition != nil {
                    map["MqPartition"] = self.mqPartition!
                }
                if self.mqPartitionMode != nil {
                    map["MqPartitionMode"] = self.mqPartitionMode!
                }
                if self.mqSerializerType != nil {
                    map["MqSerializerType"] = self.mqSerializerType!
                }
                if self.rocketMqEnableMsgTrace != nil {
                    map["RocketMqEnableMsgTrace"] = self.rocketMqEnableMsgTrace!
                }
                if self.rocketMqMsgTags != nil {
                    map["RocketMqMsgTags"] = self.rocketMqMsgTags!
                }
                if self.rocketMqProducerGroup != nil {
                    map["RocketMqProducerGroup"] = self.rocketMqProducerGroup!
                }
                if self.rocketMqSendMsgTimeout != nil {
                    map["RocketMqSendMsgTimeout"] = self.rocketMqSendMsgTimeout!
                }
                if self.sinkStoreFormat != nil {
                    map["SinkStoreFormat"] = self.sinkStoreFormat!
                }
                if self.sourceStoreFormat != nil {
                    map["SourceStoreFormat"] = self.sourceStoreFormat!
                }
                if self.tableCategory != nil {
                    map["TableCategory"] = self.tableCategory!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActiveActive") {
                    self.activeActive = dict["ActiveActive"] as! Bool
                }
                if dict.keys.contains("DataWorksBusinessName") {
                    self.dataWorksBusinessName = dict["DataWorksBusinessName"] as! String
                }
                if dict.keys.contains("DatahubTopicType") {
                    self.datahubTopicType = dict["DatahubTopicType"] as! String
                }
                if dict.keys.contains("MqPartition") {
                    self.mqPartition = dict["MqPartition"] as! Int32
                }
                if dict.keys.contains("MqPartitionMode") {
                    self.mqPartitionMode = dict["MqPartitionMode"] as! String
                }
                if dict.keys.contains("MqSerializerType") {
                    self.mqSerializerType = dict["MqSerializerType"] as! String
                }
                if dict.keys.contains("RocketMqEnableMsgTrace") {
                    self.rocketMqEnableMsgTrace = dict["RocketMqEnableMsgTrace"] as! Bool
                }
                if dict.keys.contains("RocketMqMsgTags") {
                    self.rocketMqMsgTags = dict["RocketMqMsgTags"] as! String
                }
                if dict.keys.contains("RocketMqProducerGroup") {
                    self.rocketMqProducerGroup = dict["RocketMqProducerGroup"] as! String
                }
                if dict.keys.contains("RocketMqSendMsgTimeout") {
                    self.rocketMqSendMsgTimeout = dict["RocketMqSendMsgTimeout"] as! Int64
                }
                if dict.keys.contains("SinkStoreFormat") {
                    self.sinkStoreFormat = dict["SinkStoreFormat"] as! String
                }
                if dict.keys.contains("SourceStoreFormat") {
                    self.sourceStoreFormat = dict["SourceStoreFormat"] as! String
                }
                if dict.keys.contains("TableCategory") {
                    self.tableCategory = dict["TableCategory"] as! String
                }
            }
        }
        public class ExtraInfo : Tea.TeaModel {
            public var accessObSource: Bool?

            public var ignoreUnsupportDdl: Bool?

            public var incrSyncTimestamp: Int64?

            public var logServiceStartCheckpoint: Int64?

            public var maxConnectorCount: Int32?

            public var monitoringIncr: Bool?

            public var overwriteConfig: Bool?

            public var reverseSubtopics: [String]?

            public var runningProgress: Int32?

            public var runningStep: String?

            public var sourceStoreKeptHour: Int32?

            public var storeIncr: Bool?

            public var subConds: [String: [DataExtraInfoSubCondsValue]]?

            public var subDbs: [String: [DataExtraInfoSubDbsValue]]?

            public var subIds: [String: String]?

            public var subtopics: [String]?

            public var syncDelay: Int64?

            public var syncDelaySampleTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessObSource != nil {
                    map["AccessObSource"] = self.accessObSource!
                }
                if self.ignoreUnsupportDdl != nil {
                    map["IgnoreUnsupportDdl"] = self.ignoreUnsupportDdl!
                }
                if self.incrSyncTimestamp != nil {
                    map["IncrSyncTimestamp"] = self.incrSyncTimestamp!
                }
                if self.logServiceStartCheckpoint != nil {
                    map["LogServiceStartCheckpoint"] = self.logServiceStartCheckpoint!
                }
                if self.maxConnectorCount != nil {
                    map["MaxConnectorCount"] = self.maxConnectorCount!
                }
                if self.monitoringIncr != nil {
                    map["MonitoringIncr"] = self.monitoringIncr!
                }
                if self.overwriteConfig != nil {
                    map["OverwriteConfig"] = self.overwriteConfig!
                }
                if self.reverseSubtopics != nil {
                    map["ReverseSubtopics"] = self.reverseSubtopics!
                }
                if self.runningProgress != nil {
                    map["RunningProgress"] = self.runningProgress!
                }
                if self.runningStep != nil {
                    map["RunningStep"] = self.runningStep!
                }
                if self.sourceStoreKeptHour != nil {
                    map["SourceStoreKeptHour"] = self.sourceStoreKeptHour!
                }
                if self.storeIncr != nil {
                    map["StoreIncr"] = self.storeIncr!
                }
                if self.subConds != nil {
                    var tmp : [String: Any] = [:]
                    for (k, v) in self.subConds! {
                        var l1 : [Any] = []
                        for k1 in v {
                            l1.append(k1.toMap())
                        }
                        tmp[k] = l1
                    }
                    map["SubConds"] = tmp
                }
                if self.subDbs != nil {
                    var tmp : [String: Any] = [:]
                    for (k, v) in self.subDbs! {
                        var l1 : [Any] = []
                        for k1 in v {
                            l1.append(k1.toMap())
                        }
                        tmp[k] = l1
                    }
                    map["SubDbs"] = tmp
                }
                if self.subIds != nil {
                    map["SubIds"] = self.subIds!
                }
                if self.subtopics != nil {
                    map["Subtopics"] = self.subtopics!
                }
                if self.syncDelay != nil {
                    map["SyncDelay"] = self.syncDelay!
                }
                if self.syncDelaySampleTimestamp != nil {
                    map["SyncDelaySampleTimestamp"] = self.syncDelaySampleTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccessObSource") {
                    self.accessObSource = dict["AccessObSource"] as! Bool
                }
                if dict.keys.contains("IgnoreUnsupportDdl") {
                    self.ignoreUnsupportDdl = dict["IgnoreUnsupportDdl"] as! Bool
                }
                if dict.keys.contains("IncrSyncTimestamp") {
                    self.incrSyncTimestamp = dict["IncrSyncTimestamp"] as! Int64
                }
                if dict.keys.contains("LogServiceStartCheckpoint") {
                    self.logServiceStartCheckpoint = dict["LogServiceStartCheckpoint"] as! Int64
                }
                if dict.keys.contains("MaxConnectorCount") {
                    self.maxConnectorCount = dict["MaxConnectorCount"] as! Int32
                }
                if dict.keys.contains("MonitoringIncr") {
                    self.monitoringIncr = dict["MonitoringIncr"] as! Bool
                }
                if dict.keys.contains("OverwriteConfig") {
                    self.overwriteConfig = dict["OverwriteConfig"] as! Bool
                }
                if dict.keys.contains("ReverseSubtopics") {
                    self.reverseSubtopics = dict["ReverseSubtopics"] as! [String]
                }
                if dict.keys.contains("RunningProgress") {
                    self.runningProgress = dict["RunningProgress"] as! Int32
                }
                if dict.keys.contains("RunningStep") {
                    self.runningStep = dict["RunningStep"] as! String
                }
                if dict.keys.contains("SourceStoreKeptHour") {
                    self.sourceStoreKeptHour = dict["SourceStoreKeptHour"] as! Int32
                }
                if dict.keys.contains("StoreIncr") {
                    self.storeIncr = dict["StoreIncr"] as! Bool
                }
                if dict.keys.contains("SubConds") {
                    var tmp : [String: [DataExtraInfoSubCondsValue]] = [:]
                    for (k, v) in dict["SubConds"] as! [String: Any] {
                        var l1 : [DataExtraInfoSubCondsValue] = []
                        for v1 in v as! [Any] {
                            var model = DataExtraInfoSubCondsValue()
                            if v1 != nil {
                                model.fromMap(v1 as! [String: Any])
                            }
                            l1.append(model)
                        }
                        tmp[k] = l1
                    }
                    self.subConds = tmp
                }
                if dict.keys.contains("SubDbs") {
                    var tmp : [String: [DataExtraInfoSubDbsValue]] = [:]
                    for (k, v) in dict["SubDbs"] as! [String: Any] {
                        var l1 : [DataExtraInfoSubDbsValue] = []
                        for v1 in v as! [Any] {
                            var model = DataExtraInfoSubDbsValue()
                            if v1 != nil {
                                model.fromMap(v1 as! [String: Any])
                            }
                            l1.append(model)
                        }
                        tmp[k] = l1
                    }
                    self.subDbs = tmp
                }
                if dict.keys.contains("SubIds") {
                    self.subIds = dict["SubIds"] as! [String: String]
                }
                if dict.keys.contains("Subtopics") {
                    self.subtopics = dict["Subtopics"] as! [String]
                }
                if dict.keys.contains("SyncDelay") {
                    self.syncDelay = dict["SyncDelay"] as! Int64
                }
                if dict.keys.contains("SyncDelaySampleTimestamp") {
                    self.syncDelaySampleTimestamp = dict["SyncDelaySampleTimestamp"] as! Int64
                }
            }
        }
        public class FullTransferConfig : Tea.TeaModel {
            public var allowDestTableNotEmpty: Bool?

            public var fullTransferSpeedMode: String?

            public var fullVerifySpeedMode: String?

            public var nonePkUkTruncateDstTable: Bool?

            public var readWorkerNum: Int32?

            public var throttleIOPS: Int32?

            public var throttleRps: Int32?

            public var writeWorkerNum: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allowDestTableNotEmpty != nil {
                    map["AllowDestTableNotEmpty"] = self.allowDestTableNotEmpty!
                }
                if self.fullTransferSpeedMode != nil {
                    map["FullTransferSpeedMode"] = self.fullTransferSpeedMode!
                }
                if self.fullVerifySpeedMode != nil {
                    map["FullVerifySpeedMode"] = self.fullVerifySpeedMode!
                }
                if self.nonePkUkTruncateDstTable != nil {
                    map["NonePkUkTruncateDstTable"] = self.nonePkUkTruncateDstTable!
                }
                if self.readWorkerNum != nil {
                    map["ReadWorkerNum"] = self.readWorkerNum!
                }
                if self.throttleIOPS != nil {
                    map["ThrottleIOPS"] = self.throttleIOPS!
                }
                if self.throttleRps != nil {
                    map["ThrottleRps"] = self.throttleRps!
                }
                if self.writeWorkerNum != nil {
                    map["WriteWorkerNum"] = self.writeWorkerNum!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AllowDestTableNotEmpty") {
                    self.allowDestTableNotEmpty = dict["AllowDestTableNotEmpty"] as! Bool
                }
                if dict.keys.contains("FullTransferSpeedMode") {
                    self.fullTransferSpeedMode = dict["FullTransferSpeedMode"] as! String
                }
                if dict.keys.contains("FullVerifySpeedMode") {
                    self.fullVerifySpeedMode = dict["FullVerifySpeedMode"] as! String
                }
                if dict.keys.contains("NonePkUkTruncateDstTable") {
                    self.nonePkUkTruncateDstTable = dict["NonePkUkTruncateDstTable"] as! Bool
                }
                if dict.keys.contains("ReadWorkerNum") {
                    self.readWorkerNum = dict["ReadWorkerNum"] as! Int32
                }
                if dict.keys.contains("ThrottleIOPS") {
                    self.throttleIOPS = dict["ThrottleIOPS"] as! Int32
                }
                if dict.keys.contains("ThrottleRps") {
                    self.throttleRps = dict["ThrottleRps"] as! Int32
                }
                if dict.keys.contains("WriteWorkerNum") {
                    self.writeWorkerNum = dict["WriteWorkerNum"] as! Int32
                }
            }
        }
        public class IncrTransferConfig : Tea.TeaModel {
            public var enableIncrSyncStatistics: Bool?

            public var enableSequencingWithinTxn: Bool?

            public var incrSyncConcurrency: Int32?

            public var recordTypeWhiteList: [String]?

            public var startTimestamp: Int64?

            public var storeLogKeptHour: Int32?

            public var supportDDLTypes: [String]?

            public var throttleIOPS: Int32?

            public var throttleRps: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.enableIncrSyncStatistics != nil {
                    map["EnableIncrSyncStatistics"] = self.enableIncrSyncStatistics!
                }
                if self.enableSequencingWithinTxn != nil {
                    map["EnableSequencingWithinTxn"] = self.enableSequencingWithinTxn!
                }
                if self.incrSyncConcurrency != nil {
                    map["IncrSyncConcurrency"] = self.incrSyncConcurrency!
                }
                if self.recordTypeWhiteList != nil {
                    map["RecordTypeWhiteList"] = self.recordTypeWhiteList!
                }
                if self.startTimestamp != nil {
                    map["StartTimestamp"] = self.startTimestamp!
                }
                if self.storeLogKeptHour != nil {
                    map["StoreLogKeptHour"] = self.storeLogKeptHour!
                }
                if self.supportDDLTypes != nil {
                    map["SupportDDLTypes"] = self.supportDDLTypes!
                }
                if self.throttleIOPS != nil {
                    map["ThrottleIOPS"] = self.throttleIOPS!
                }
                if self.throttleRps != nil {
                    map["ThrottleRps"] = self.throttleRps!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EnableIncrSyncStatistics") {
                    self.enableIncrSyncStatistics = dict["EnableIncrSyncStatistics"] as! Bool
                }
                if dict.keys.contains("EnableSequencingWithinTxn") {
                    self.enableSequencingWithinTxn = dict["EnableSequencingWithinTxn"] as! Bool
                }
                if dict.keys.contains("IncrSyncConcurrency") {
                    self.incrSyncConcurrency = dict["IncrSyncConcurrency"] as! Int32
                }
                if dict.keys.contains("RecordTypeWhiteList") {
                    self.recordTypeWhiteList = dict["RecordTypeWhiteList"] as! [String]
                }
                if dict.keys.contains("StartTimestamp") {
                    self.startTimestamp = dict["StartTimestamp"] as! Int64
                }
                if dict.keys.contains("StoreLogKeptHour") {
                    self.storeLogKeptHour = dict["StoreLogKeptHour"] as! Int32
                }
                if dict.keys.contains("SupportDDLTypes") {
                    self.supportDDLTypes = dict["SupportDDLTypes"] as! [String]
                }
                if dict.keys.contains("ThrottleIOPS") {
                    self.throttleIOPS = dict["ThrottleIOPS"] as! Int32
                }
                if dict.keys.contains("ThrottleRps") {
                    self.throttleRps = dict["ThrottleRps"] as! Int32
                }
            }
        }
        public class Labels : Tea.TeaModel {
            public var id: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public class ReverseIncrTransferConfig : Tea.TeaModel {
            public var enableIncrSyncStatistics: Bool?

            public var enableSequencingWithinTxn: Bool?

            public var incrSyncConcurrency: Int32?

            public var recordTypeWhiteList: [String]?

            public var startTimestamp: Int64?

            public var storeLogKeptHour: Int32?

            public var supportDDLTypes: [String]?

            public var throttleIOPS: Int32?

            public var throttleRps: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.enableIncrSyncStatistics != nil {
                    map["EnableIncrSyncStatistics"] = self.enableIncrSyncStatistics!
                }
                if self.enableSequencingWithinTxn != nil {
                    map["EnableSequencingWithinTxn"] = self.enableSequencingWithinTxn!
                }
                if self.incrSyncConcurrency != nil {
                    map["IncrSyncConcurrency"] = self.incrSyncConcurrency!
                }
                if self.recordTypeWhiteList != nil {
                    map["RecordTypeWhiteList"] = self.recordTypeWhiteList!
                }
                if self.startTimestamp != nil {
                    map["StartTimestamp"] = self.startTimestamp!
                }
                if self.storeLogKeptHour != nil {
                    map["StoreLogKeptHour"] = self.storeLogKeptHour!
                }
                if self.supportDDLTypes != nil {
                    map["SupportDDLTypes"] = self.supportDDLTypes!
                }
                if self.throttleIOPS != nil {
                    map["ThrottleIOPS"] = self.throttleIOPS!
                }
                if self.throttleRps != nil {
                    map["ThrottleRps"] = self.throttleRps!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EnableIncrSyncStatistics") {
                    self.enableIncrSyncStatistics = dict["EnableIncrSyncStatistics"] as! Bool
                }
                if dict.keys.contains("EnableSequencingWithinTxn") {
                    self.enableSequencingWithinTxn = dict["EnableSequencingWithinTxn"] as! Bool
                }
                if dict.keys.contains("IncrSyncConcurrency") {
                    self.incrSyncConcurrency = dict["IncrSyncConcurrency"] as! Int32
                }
                if dict.keys.contains("RecordTypeWhiteList") {
                    self.recordTypeWhiteList = dict["RecordTypeWhiteList"] as! [String]
                }
                if dict.keys.contains("StartTimestamp") {
                    self.startTimestamp = dict["StartTimestamp"] as! Int64
                }
                if dict.keys.contains("StoreLogKeptHour") {
                    self.storeLogKeptHour = dict["StoreLogKeptHour"] as! Int32
                }
                if dict.keys.contains("SupportDDLTypes") {
                    self.supportDDLTypes = dict["SupportDDLTypes"] as! [String]
                }
                if dict.keys.contains("ThrottleIOPS") {
                    self.throttleIOPS = dict["ThrottleIOPS"] as! Int32
                }
                if dict.keys.contains("ThrottleRps") {
                    self.throttleRps = dict["ThrottleRps"] as! Int32
                }
            }
        }
        public class SinkConnectInfo : Tea.TeaModel {
            public var charset: String?

            public var connExtraAttributes: Any?

            public var connectionInfo: String?

            public var dbEngine: String?

            public var endpointId: String?

            public var endpointName: String?

            public var endpointSide: String?

            public var host: String?

            public var id: String?

            public var nlsLengthSemantics: String?

            public var ocpName: String?

            public var operatingSystem: String?

            public var owner: String?

            public var port: Int32?

            public var region: String?

            public var resourceOwner: String?

            public var timezone: String?

            public var username: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.charset != nil {
                    map["Charset"] = self.charset!
                }
                if self.connExtraAttributes != nil {
                    map["ConnExtraAttributes"] = self.connExtraAttributes!
                }
                if self.connectionInfo != nil {
                    map["ConnectionInfo"] = self.connectionInfo!
                }
                if self.dbEngine != nil {
                    map["DbEngine"] = self.dbEngine!
                }
                if self.endpointId != nil {
                    map["EndpointId"] = self.endpointId!
                }
                if self.endpointName != nil {
                    map["EndpointName"] = self.endpointName!
                }
                if self.endpointSide != nil {
                    map["EndpointSide"] = self.endpointSide!
                }
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.nlsLengthSemantics != nil {
                    map["NlsLengthSemantics"] = self.nlsLengthSemantics!
                }
                if self.ocpName != nil {
                    map["OcpName"] = self.ocpName!
                }
                if self.operatingSystem != nil {
                    map["OperatingSystem"] = self.operatingSystem!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.resourceOwner != nil {
                    map["ResourceOwner"] = self.resourceOwner!
                }
                if self.timezone != nil {
                    map["Timezone"] = self.timezone!
                }
                if self.username != nil {
                    map["Username"] = self.username!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Charset") {
                    self.charset = dict["Charset"] as! String
                }
                if dict.keys.contains("ConnExtraAttributes") {
                    self.connExtraAttributes = dict["ConnExtraAttributes"] as! Any
                }
                if dict.keys.contains("ConnectionInfo") {
                    self.connectionInfo = dict["ConnectionInfo"] as! String
                }
                if dict.keys.contains("DbEngine") {
                    self.dbEngine = dict["DbEngine"] as! String
                }
                if dict.keys.contains("EndpointId") {
                    self.endpointId = dict["EndpointId"] as! String
                }
                if dict.keys.contains("EndpointName") {
                    self.endpointName = dict["EndpointName"] as! String
                }
                if dict.keys.contains("EndpointSide") {
                    self.endpointSide = dict["EndpointSide"] as! String
                }
                if dict.keys.contains("Host") {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("NlsLengthSemantics") {
                    self.nlsLengthSemantics = dict["NlsLengthSemantics"] as! String
                }
                if dict.keys.contains("OcpName") {
                    self.ocpName = dict["OcpName"] as! String
                }
                if dict.keys.contains("OperatingSystem") {
                    self.operatingSystem = dict["OperatingSystem"] as! String
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("ResourceOwner") {
                    self.resourceOwner = dict["ResourceOwner"] as! String
                }
                if dict.keys.contains("Timezone") {
                    self.timezone = dict["Timezone"] as! String
                }
                if dict.keys.contains("Username") {
                    self.username = dict["Username"] as! String
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public class SourceConnectInfo : Tea.TeaModel {
            public var charset: String?

            public var connExtraAttributes: Any?

            public var connectionInfo: String?

            public var dbEngine: String?

            public var endpointId: String?

            public var endpointName: String?

            public var endpointSide: String?

            public var host: String?

            public var id: String?

            public var nlsLengthSemantics: String?

            public var ocpName: String?

            public var operatingSystem: String?

            public var owner: String?

            public var port: Int32?

            public var region: String?

            public var resourceOwner: String?

            public var timezone: String?

            public var username: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.charset != nil {
                    map["Charset"] = self.charset!
                }
                if self.connExtraAttributes != nil {
                    map["ConnExtraAttributes"] = self.connExtraAttributes!
                }
                if self.connectionInfo != nil {
                    map["ConnectionInfo"] = self.connectionInfo!
                }
                if self.dbEngine != nil {
                    map["DbEngine"] = self.dbEngine!
                }
                if self.endpointId != nil {
                    map["EndpointId"] = self.endpointId!
                }
                if self.endpointName != nil {
                    map["EndpointName"] = self.endpointName!
                }
                if self.endpointSide != nil {
                    map["EndpointSide"] = self.endpointSide!
                }
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.nlsLengthSemantics != nil {
                    map["NlsLengthSemantics"] = self.nlsLengthSemantics!
                }
                if self.ocpName != nil {
                    map["OcpName"] = self.ocpName!
                }
                if self.operatingSystem != nil {
                    map["OperatingSystem"] = self.operatingSystem!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.resourceOwner != nil {
                    map["ResourceOwner"] = self.resourceOwner!
                }
                if self.timezone != nil {
                    map["Timezone"] = self.timezone!
                }
                if self.username != nil {
                    map["Username"] = self.username!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Charset") {
                    self.charset = dict["Charset"] as! String
                }
                if dict.keys.contains("ConnExtraAttributes") {
                    self.connExtraAttributes = dict["ConnExtraAttributes"] as! Any
                }
                if dict.keys.contains("ConnectionInfo") {
                    self.connectionInfo = dict["ConnectionInfo"] as! String
                }
                if dict.keys.contains("DbEngine") {
                    self.dbEngine = dict["DbEngine"] as! String
                }
                if dict.keys.contains("EndpointId") {
                    self.endpointId = dict["EndpointId"] as! String
                }
                if dict.keys.contains("EndpointName") {
                    self.endpointName = dict["EndpointName"] as! String
                }
                if dict.keys.contains("EndpointSide") {
                    self.endpointSide = dict["EndpointSide"] as! String
                }
                if dict.keys.contains("Host") {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("NlsLengthSemantics") {
                    self.nlsLengthSemantics = dict["NlsLengthSemantics"] as! String
                }
                if dict.keys.contains("OcpName") {
                    self.ocpName = dict["OcpName"] as! String
                }
                if dict.keys.contains("OperatingSystem") {
                    self.operatingSystem = dict["OperatingSystem"] as! String
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("ResourceOwner") {
                    self.resourceOwner = dict["ResourceOwner"] as! String
                }
                if dict.keys.contains("Timezone") {
                    self.timezone = dict["Timezone"] as! String
                }
                if dict.keys.contains("Username") {
                    self.username = dict["Username"] as! String
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public class Steps : Tea.TeaModel {
            public class ExtraInfo : Tea.TeaModel {
                public class ErrorDetails : Tea.TeaModel {
                    public var code: String?

                    public var extraContext: [String: Any]?

                    public var level: String?

                    public var message: String?

                    public var messageMcmsContext: [String: String]?

                    public var messageMcmsKey: String?

                    public var proposal: String?

                    public var proposalMcmsContext: [String: String]?

                    public var proposalMcmsKey: String?

                    public var reason: String?

                    public var reasonMcmsContext: [String: String]?

                    public var reasonMcmsKey: String?

                    public var upstreamErrorDetail: Any?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.code != nil {
                            map["Code"] = self.code!
                        }
                        if self.extraContext != nil {
                            map["ExtraContext"] = self.extraContext!
                        }
                        if self.level != nil {
                            map["Level"] = self.level!
                        }
                        if self.message != nil {
                            map["Message"] = self.message!
                        }
                        if self.messageMcmsContext != nil {
                            map["MessageMcmsContext"] = self.messageMcmsContext!
                        }
                        if self.messageMcmsKey != nil {
                            map["MessageMcmsKey"] = self.messageMcmsKey!
                        }
                        if self.proposal != nil {
                            map["Proposal"] = self.proposal!
                        }
                        if self.proposalMcmsContext != nil {
                            map["ProposalMcmsContext"] = self.proposalMcmsContext!
                        }
                        if self.proposalMcmsKey != nil {
                            map["ProposalMcmsKey"] = self.proposalMcmsKey!
                        }
                        if self.reason != nil {
                            map["Reason"] = self.reason!
                        }
                        if self.reasonMcmsContext != nil {
                            map["ReasonMcmsContext"] = self.reasonMcmsContext!
                        }
                        if self.reasonMcmsKey != nil {
                            map["ReasonMcmsKey"] = self.reasonMcmsKey!
                        }
                        if self.upstreamErrorDetail != nil {
                            map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Code") {
                            self.code = dict["Code"] as! String
                        }
                        if dict.keys.contains("ExtraContext") {
                            self.extraContext = dict["ExtraContext"] as! [String: Any]
                        }
                        if dict.keys.contains("Level") {
                            self.level = dict["Level"] as! String
                        }
                        if dict.keys.contains("Message") {
                            self.message = dict["Message"] as! String
                        }
                        if dict.keys.contains("MessageMcmsContext") {
                            self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
                        }
                        if dict.keys.contains("MessageMcmsKey") {
                            self.messageMcmsKey = dict["MessageMcmsKey"] as! String
                        }
                        if dict.keys.contains("Proposal") {
                            self.proposal = dict["Proposal"] as! String
                        }
                        if dict.keys.contains("ProposalMcmsContext") {
                            self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
                        }
                        if dict.keys.contains("ProposalMcmsKey") {
                            self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
                        }
                        if dict.keys.contains("Reason") {
                            self.reason = dict["Reason"] as! String
                        }
                        if dict.keys.contains("ReasonMcmsContext") {
                            self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
                        }
                        if dict.keys.contains("ReasonMcmsKey") {
                            self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
                        }
                        if dict.keys.contains("UpstreamErrorDetail") {
                            self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
                        }
                    }
                }
                public var errorCode: String?

                public var errorDetails: [DescribeProjectResponseBody.Data.Steps.ExtraInfo.ErrorDetails]?

                public var errorMsg: String?

                public var errorParam: [String: String]?

                public var failedTime: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorDetails != nil {
                        var tmp : [Any] = []
                        for k in self.errorDetails! {
                            tmp.append(k.toMap())
                        }
                        map["ErrorDetails"] = tmp
                    }
                    if self.errorMsg != nil {
                        map["ErrorMsg"] = self.errorMsg!
                    }
                    if self.errorParam != nil {
                        map["ErrorParam"] = self.errorParam!
                    }
                    if self.failedTime != nil {
                        map["FailedTime"] = self.failedTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorCode") {
                        self.errorCode = dict["ErrorCode"] as! String
                    }
                    if dict.keys.contains("ErrorDetails") {
                        var tmp : [DescribeProjectResponseBody.Data.Steps.ExtraInfo.ErrorDetails] = []
                        for v in dict["ErrorDetails"] as! [Any] {
                            var model = DescribeProjectResponseBody.Data.Steps.ExtraInfo.ErrorDetails()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.errorDetails = tmp
                    }
                    if dict.keys.contains("ErrorMsg") {
                        self.errorMsg = dict["ErrorMsg"] as! String
                    }
                    if dict.keys.contains("ErrorParam") {
                        self.errorParam = dict["ErrorParam"] as! [String: String]
                    }
                    if dict.keys.contains("FailedTime") {
                        self.failedTime = dict["FailedTime"] as! String
                    }
                }
            }
            public var description_: String?

            public var extraInfo: DescribeProjectResponseBody.Data.Steps.ExtraInfo?

            public var finishTime: String?

            public var name: String?

            public var order: Int32?

            public var progress: Int32?

            public var startTime: String?

            public var status: String?

            public var stepInfo: [String: Any]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.extraInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.extraInfo != nil {
                    map["ExtraInfo"] = self.extraInfo?.toMap()
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.order != nil {
                    map["Order"] = self.order!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.stepInfo != nil {
                    map["StepInfo"] = self.stepInfo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ExtraInfo") {
                    var model = DescribeProjectResponseBody.Data.Steps.ExtraInfo()
                    model.fromMap(dict["ExtraInfo"] as! [String: Any])
                    self.extraInfo = model
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Order") {
                    self.order = dict["Order"] as! Int32
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! Int32
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StepInfo") {
                    self.stepInfo = dict["StepInfo"] as! [String: Any]
                }
            }
        }
        public class StructTransferConfig : Tea.TeaModel {
            public var byteCharConvertStrategy: String?

            public var deferIndexCreation: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.byteCharConvertStrategy != nil {
                    map["ByteCharConvertStrategy"] = self.byteCharConvertStrategy!
                }
                if self.deferIndexCreation != nil {
                    map["DeferIndexCreation"] = self.deferIndexCreation!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ByteCharConvertStrategy") {
                    self.byteCharConvertStrategy = dict["ByteCharConvertStrategy"] as! String
                }
                if dict.keys.contains("DeferIndexCreation") {
                    self.deferIndexCreation = dict["DeferIndexCreation"] as! Bool
                }
            }
        }
        public class TransferMapping : Tea.TeaModel {
            public class Databases : Tea.TeaModel {
                public class SpecificTables : Tea.TeaModel {
                    public class AdbTableSchema : Tea.TeaModel {
                        public var distributedKeys: [String]?

                        public var partitionLifeCycle: String?

                        public var partitionStatement: String?

                        public var primaryKeys: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.distributedKeys != nil {
                                map["DistributedKeys"] = self.distributedKeys!
                            }
                            if self.partitionLifeCycle != nil {
                                map["PartitionLifeCycle"] = self.partitionLifeCycle!
                            }
                            if self.partitionStatement != nil {
                                map["PartitionStatement"] = self.partitionStatement!
                            }
                            if self.primaryKeys != nil {
                                map["PrimaryKeys"] = self.primaryKeys!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("DistributedKeys") {
                                self.distributedKeys = dict["DistributedKeys"] as! [String]
                            }
                            if dict.keys.contains("PartitionLifeCycle") {
                                self.partitionLifeCycle = dict["PartitionLifeCycle"] as! String
                            }
                            if dict.keys.contains("PartitionStatement") {
                                self.partitionStatement = dict["PartitionStatement"] as! String
                            }
                            if dict.keys.contains("PrimaryKeys") {
                                self.primaryKeys = dict["PrimaryKeys"] as! [String]
                            }
                        }
                    }
                    public var adbTableSchema: DescribeProjectResponseBody.Data.TransferMapping.Databases.SpecificTables.AdbTableSchema?

                    public var filterColumns: [String]?

                    public var id: String?

                    public var mappedName: String?

                    public var name: String?

                    public var shardColumns: [String]?

                    public var whereClause: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.adbTableSchema?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.adbTableSchema != nil {
                            map["AdbTableSchema"] = self.adbTableSchema?.toMap()
                        }
                        if self.filterColumns != nil {
                            map["FilterColumns"] = self.filterColumns!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.mappedName != nil {
                            map["MappedName"] = self.mappedName!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.shardColumns != nil {
                            map["ShardColumns"] = self.shardColumns!
                        }
                        if self.whereClause != nil {
                            map["WhereClause"] = self.whereClause!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AdbTableSchema") {
                            var model = DescribeProjectResponseBody.Data.TransferMapping.Databases.SpecificTables.AdbTableSchema()
                            model.fromMap(dict["AdbTableSchema"] as! [String: Any])
                            self.adbTableSchema = model
                        }
                        if dict.keys.contains("FilterColumns") {
                            self.filterColumns = dict["FilterColumns"] as! [String]
                        }
                        if dict.keys.contains("Id") {
                            self.id = dict["Id"] as! String
                        }
                        if dict.keys.contains("MappedName") {
                            self.mappedName = dict["MappedName"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("ShardColumns") {
                            self.shardColumns = dict["ShardColumns"] as! [String]
                        }
                        if dict.keys.contains("WhereClause") {
                            self.whereClause = dict["WhereClause"] as! String
                        }
                    }
                }
                public class SpecificViews : Tea.TeaModel {
                    public class AdbTableSchema : Tea.TeaModel {
                        public var distributedKeys: [String]?

                        public var partitionLifeCycle: String?

                        public var partitionStatement: String?

                        public var primaryKeys: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.distributedKeys != nil {
                                map["DistributedKeys"] = self.distributedKeys!
                            }
                            if self.partitionLifeCycle != nil {
                                map["PartitionLifeCycle"] = self.partitionLifeCycle!
                            }
                            if self.partitionStatement != nil {
                                map["PartitionStatement"] = self.partitionStatement!
                            }
                            if self.primaryKeys != nil {
                                map["PrimaryKeys"] = self.primaryKeys!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("DistributedKeys") {
                                self.distributedKeys = dict["DistributedKeys"] as! [String]
                            }
                            if dict.keys.contains("PartitionLifeCycle") {
                                self.partitionLifeCycle = dict["PartitionLifeCycle"] as! String
                            }
                            if dict.keys.contains("PartitionStatement") {
                                self.partitionStatement = dict["PartitionStatement"] as! String
                            }
                            if dict.keys.contains("PrimaryKeys") {
                                self.primaryKeys = dict["PrimaryKeys"] as! [String]
                            }
                        }
                    }
                    public var adbTableSchema: DescribeProjectResponseBody.Data.TransferMapping.Databases.SpecificViews.AdbTableSchema?

                    public var filterColumns: [String]?

                    public var id: String?

                    public var mappedName: String?

                    public var name: String?

                    public var shardColumns: [String]?

                    public var whereClause: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.adbTableSchema?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.adbTableSchema != nil {
                            map["AdbTableSchema"] = self.adbTableSchema?.toMap()
                        }
                        if self.filterColumns != nil {
                            map["FilterColumns"] = self.filterColumns!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.mappedName != nil {
                            map["MappedName"] = self.mappedName!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.shardColumns != nil {
                            map["ShardColumns"] = self.shardColumns!
                        }
                        if self.whereClause != nil {
                            map["WhereClause"] = self.whereClause!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AdbTableSchema") {
                            var model = DescribeProjectResponseBody.Data.TransferMapping.Databases.SpecificViews.AdbTableSchema()
                            model.fromMap(dict["AdbTableSchema"] as! [String: Any])
                            self.adbTableSchema = model
                        }
                        if dict.keys.contains("FilterColumns") {
                            self.filterColumns = dict["FilterColumns"] as! [String]
                        }
                        if dict.keys.contains("Id") {
                            self.id = dict["Id"] as! String
                        }
                        if dict.keys.contains("MappedName") {
                            self.mappedName = dict["MappedName"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("ShardColumns") {
                            self.shardColumns = dict["ShardColumns"] as! [String]
                        }
                        if dict.keys.contains("WhereClause") {
                            self.whereClause = dict["WhereClause"] as! String
                        }
                    }
                }
                public class Tables : Tea.TeaModel {
                    public class AdbTableSchema : Tea.TeaModel {
                        public var distributedKeys: [String]?

                        public var partitionLifeCycle: String?

                        public var partitionStatement: String?

                        public var primaryKeys: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.distributedKeys != nil {
                                map["DistributedKeys"] = self.distributedKeys!
                            }
                            if self.partitionLifeCycle != nil {
                                map["PartitionLifeCycle"] = self.partitionLifeCycle!
                            }
                            if self.partitionStatement != nil {
                                map["PartitionStatement"] = self.partitionStatement!
                            }
                            if self.primaryKeys != nil {
                                map["PrimaryKeys"] = self.primaryKeys!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("DistributedKeys") {
                                self.distributedKeys = dict["DistributedKeys"] as! [String]
                            }
                            if dict.keys.contains("PartitionLifeCycle") {
                                self.partitionLifeCycle = dict["PartitionLifeCycle"] as! String
                            }
                            if dict.keys.contains("PartitionStatement") {
                                self.partitionStatement = dict["PartitionStatement"] as! String
                            }
                            if dict.keys.contains("PrimaryKeys") {
                                self.primaryKeys = dict["PrimaryKeys"] as! [String]
                            }
                        }
                    }
                    public var adbTableSchema: DescribeProjectResponseBody.Data.TransferMapping.Databases.Tables.AdbTableSchema?

                    public var filterColumns: [String]?

                    public var id: String?

                    public var mappedName: String?

                    public var name: String?

                    public var shardColumns: [String]?

                    public var whereClause: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.adbTableSchema?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.adbTableSchema != nil {
                            map["AdbTableSchema"] = self.adbTableSchema?.toMap()
                        }
                        if self.filterColumns != nil {
                            map["FilterColumns"] = self.filterColumns!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.mappedName != nil {
                            map["MappedName"] = self.mappedName!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.shardColumns != nil {
                            map["ShardColumns"] = self.shardColumns!
                        }
                        if self.whereClause != nil {
                            map["WhereClause"] = self.whereClause!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AdbTableSchema") {
                            var model = DescribeProjectResponseBody.Data.TransferMapping.Databases.Tables.AdbTableSchema()
                            model.fromMap(dict["AdbTableSchema"] as! [String: Any])
                            self.adbTableSchema = model
                        }
                        if dict.keys.contains("FilterColumns") {
                            self.filterColumns = dict["FilterColumns"] as! [String]
                        }
                        if dict.keys.contains("Id") {
                            self.id = dict["Id"] as! String
                        }
                        if dict.keys.contains("MappedName") {
                            self.mappedName = dict["MappedName"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("ShardColumns") {
                            self.shardColumns = dict["ShardColumns"] as! [String]
                        }
                        if dict.keys.contains("WhereClause") {
                            self.whereClause = dict["WhereClause"] as! String
                        }
                    }
                }
                public class Views : Tea.TeaModel {
                    public class AdbTableSchema : Tea.TeaModel {
                        public var distributedKeys: [String]?

                        public var partitionLifeCycle: String?

                        public var partitionStatement: String?

                        public var primaryKeys: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.distributedKeys != nil {
                                map["DistributedKeys"] = self.distributedKeys!
                            }
                            if self.partitionLifeCycle != nil {
                                map["PartitionLifeCycle"] = self.partitionLifeCycle!
                            }
                            if self.partitionStatement != nil {
                                map["PartitionStatement"] = self.partitionStatement!
                            }
                            if self.primaryKeys != nil {
                                map["PrimaryKeys"] = self.primaryKeys!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("DistributedKeys") {
                                self.distributedKeys = dict["DistributedKeys"] as! [String]
                            }
                            if dict.keys.contains("PartitionLifeCycle") {
                                self.partitionLifeCycle = dict["PartitionLifeCycle"] as! String
                            }
                            if dict.keys.contains("PartitionStatement") {
                                self.partitionStatement = dict["PartitionStatement"] as! String
                            }
                            if dict.keys.contains("PrimaryKeys") {
                                self.primaryKeys = dict["PrimaryKeys"] as! [String]
                            }
                        }
                    }
                    public var adbTableSchema: DescribeProjectResponseBody.Data.TransferMapping.Databases.Views.AdbTableSchema?

                    public var filterColumns: [String]?

                    public var id: String?

                    public var mappedName: String?

                    public var name: String?

                    public var shardColumns: [String]?

                    public var whereClause: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.adbTableSchema?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.adbTableSchema != nil {
                            map["AdbTableSchema"] = self.adbTableSchema?.toMap()
                        }
                        if self.filterColumns != nil {
                            map["FilterColumns"] = self.filterColumns!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.mappedName != nil {
                            map["MappedName"] = self.mappedName!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.shardColumns != nil {
                            map["ShardColumns"] = self.shardColumns!
                        }
                        if self.whereClause != nil {
                            map["WhereClause"] = self.whereClause!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AdbTableSchema") {
                            var model = DescribeProjectResponseBody.Data.TransferMapping.Databases.Views.AdbTableSchema()
                            model.fromMap(dict["AdbTableSchema"] as! [String: Any])
                            self.adbTableSchema = model
                        }
                        if dict.keys.contains("FilterColumns") {
                            self.filterColumns = dict["FilterColumns"] as! [String]
                        }
                        if dict.keys.contains("Id") {
                            self.id = dict["Id"] as! String
                        }
                        if dict.keys.contains("MappedName") {
                            self.mappedName = dict["MappedName"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("ShardColumns") {
                            self.shardColumns = dict["ShardColumns"] as! [String]
                        }
                        if dict.keys.contains("WhereClause") {
                            self.whereClause = dict["WhereClause"] as! String
                        }
                    }
                }
                public var id: String?

                public var mappedName: String?

                public var name: String?

                public var specificTables: [DescribeProjectResponseBody.Data.TransferMapping.Databases.SpecificTables]?

                public var specificViews: [DescribeProjectResponseBody.Data.TransferMapping.Databases.SpecificViews]?

                public var tables: [DescribeProjectResponseBody.Data.TransferMapping.Databases.Tables]?

                public var tenantName: String?

                public var type: String?

                public var views: [DescribeProjectResponseBody.Data.TransferMapping.Databases.Views]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.mappedName != nil {
                        map["MappedName"] = self.mappedName!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.specificTables != nil {
                        var tmp : [Any] = []
                        for k in self.specificTables! {
                            tmp.append(k.toMap())
                        }
                        map["SpecificTables"] = tmp
                    }
                    if self.specificViews != nil {
                        var tmp : [Any] = []
                        for k in self.specificViews! {
                            tmp.append(k.toMap())
                        }
                        map["SpecificViews"] = tmp
                    }
                    if self.tables != nil {
                        var tmp : [Any] = []
                        for k in self.tables! {
                            tmp.append(k.toMap())
                        }
                        map["Tables"] = tmp
                    }
                    if self.tenantName != nil {
                        map["TenantName"] = self.tenantName!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.views != nil {
                        var tmp : [Any] = []
                        for k in self.views! {
                            tmp.append(k.toMap())
                        }
                        map["Views"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("MappedName") {
                        self.mappedName = dict["MappedName"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("SpecificTables") {
                        var tmp : [DescribeProjectResponseBody.Data.TransferMapping.Databases.SpecificTables] = []
                        for v in dict["SpecificTables"] as! [Any] {
                            var model = DescribeProjectResponseBody.Data.TransferMapping.Databases.SpecificTables()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.specificTables = tmp
                    }
                    if dict.keys.contains("SpecificViews") {
                        var tmp : [DescribeProjectResponseBody.Data.TransferMapping.Databases.SpecificViews] = []
                        for v in dict["SpecificViews"] as! [Any] {
                            var model = DescribeProjectResponseBody.Data.TransferMapping.Databases.SpecificViews()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.specificViews = tmp
                    }
                    if dict.keys.contains("Tables") {
                        var tmp : [DescribeProjectResponseBody.Data.TransferMapping.Databases.Tables] = []
                        for v in dict["Tables"] as! [Any] {
                            var model = DescribeProjectResponseBody.Data.TransferMapping.Databases.Tables()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tables = tmp
                    }
                    if dict.keys.contains("TenantName") {
                        self.tenantName = dict["TenantName"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Views") {
                        var tmp : [DescribeProjectResponseBody.Data.TransferMapping.Databases.Views] = []
                        for v in dict["Views"] as! [Any] {
                            var model = DescribeProjectResponseBody.Data.TransferMapping.Databases.Views()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.views = tmp
                    }
                }
            }
            public class DatabasesBlack : Tea.TeaModel {
                public class SpecificTables : Tea.TeaModel {
                    public class AdbTableSchema : Tea.TeaModel {
                        public var distributedKeys: [String]?

                        public var partitionLifeCycle: String?

                        public var partitionStatement: String?

                        public var primaryKeys: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.distributedKeys != nil {
                                map["DistributedKeys"] = self.distributedKeys!
                            }
                            if self.partitionLifeCycle != nil {
                                map["PartitionLifeCycle"] = self.partitionLifeCycle!
                            }
                            if self.partitionStatement != nil {
                                map["PartitionStatement"] = self.partitionStatement!
                            }
                            if self.primaryKeys != nil {
                                map["PrimaryKeys"] = self.primaryKeys!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("DistributedKeys") {
                                self.distributedKeys = dict["DistributedKeys"] as! [String]
                            }
                            if dict.keys.contains("PartitionLifeCycle") {
                                self.partitionLifeCycle = dict["PartitionLifeCycle"] as! String
                            }
                            if dict.keys.contains("PartitionStatement") {
                                self.partitionStatement = dict["PartitionStatement"] as! String
                            }
                            if dict.keys.contains("PrimaryKeys") {
                                self.primaryKeys = dict["PrimaryKeys"] as! [String]
                            }
                        }
                    }
                    public var adbTableSchema: DescribeProjectResponseBody.Data.TransferMapping.DatabasesBlack.SpecificTables.AdbTableSchema?

                    public var filterColumns: [String]?

                    public var id: String?

                    public var mappedName: String?

                    public var name: String?

                    public var shardColumns: [String]?

                    public var whereClause: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.adbTableSchema?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.adbTableSchema != nil {
                            map["AdbTableSchema"] = self.adbTableSchema?.toMap()
                        }
                        if self.filterColumns != nil {
                            map["FilterColumns"] = self.filterColumns!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.mappedName != nil {
                            map["MappedName"] = self.mappedName!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.shardColumns != nil {
                            map["ShardColumns"] = self.shardColumns!
                        }
                        if self.whereClause != nil {
                            map["WhereClause"] = self.whereClause!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AdbTableSchema") {
                            var model = DescribeProjectResponseBody.Data.TransferMapping.DatabasesBlack.SpecificTables.AdbTableSchema()
                            model.fromMap(dict["AdbTableSchema"] as! [String: Any])
                            self.adbTableSchema = model
                        }
                        if dict.keys.contains("FilterColumns") {
                            self.filterColumns = dict["FilterColumns"] as! [String]
                        }
                        if dict.keys.contains("Id") {
                            self.id = dict["Id"] as! String
                        }
                        if dict.keys.contains("MappedName") {
                            self.mappedName = dict["MappedName"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("ShardColumns") {
                            self.shardColumns = dict["ShardColumns"] as! [String]
                        }
                        if dict.keys.contains("WhereClause") {
                            self.whereClause = dict["WhereClause"] as! String
                        }
                    }
                }
                public class SpecificViews : Tea.TeaModel {
                    public class AdbTableSchema : Tea.TeaModel {
                        public var distributedKeys: [String]?

                        public var partitionLifeCycle: String?

                        public var partitionStatement: String?

                        public var primaryKeys: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.distributedKeys != nil {
                                map["DistributedKeys"] = self.distributedKeys!
                            }
                            if self.partitionLifeCycle != nil {
                                map["PartitionLifeCycle"] = self.partitionLifeCycle!
                            }
                            if self.partitionStatement != nil {
                                map["PartitionStatement"] = self.partitionStatement!
                            }
                            if self.primaryKeys != nil {
                                map["PrimaryKeys"] = self.primaryKeys!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("DistributedKeys") {
                                self.distributedKeys = dict["DistributedKeys"] as! [String]
                            }
                            if dict.keys.contains("PartitionLifeCycle") {
                                self.partitionLifeCycle = dict["PartitionLifeCycle"] as! String
                            }
                            if dict.keys.contains("PartitionStatement") {
                                self.partitionStatement = dict["PartitionStatement"] as! String
                            }
                            if dict.keys.contains("PrimaryKeys") {
                                self.primaryKeys = dict["PrimaryKeys"] as! [String]
                            }
                        }
                    }
                    public var adbTableSchema: DescribeProjectResponseBody.Data.TransferMapping.DatabasesBlack.SpecificViews.AdbTableSchema?

                    public var filterColumns: [String]?

                    public var id: String?

                    public var mappedName: String?

                    public var name: String?

                    public var shardColumns: [String]?

                    public var whereClause: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.adbTableSchema?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.adbTableSchema != nil {
                            map["AdbTableSchema"] = self.adbTableSchema?.toMap()
                        }
                        if self.filterColumns != nil {
                            map["FilterColumns"] = self.filterColumns!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.mappedName != nil {
                            map["MappedName"] = self.mappedName!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.shardColumns != nil {
                            map["ShardColumns"] = self.shardColumns!
                        }
                        if self.whereClause != nil {
                            map["WhereClause"] = self.whereClause!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AdbTableSchema") {
                            var model = DescribeProjectResponseBody.Data.TransferMapping.DatabasesBlack.SpecificViews.AdbTableSchema()
                            model.fromMap(dict["AdbTableSchema"] as! [String: Any])
                            self.adbTableSchema = model
                        }
                        if dict.keys.contains("FilterColumns") {
                            self.filterColumns = dict["FilterColumns"] as! [String]
                        }
                        if dict.keys.contains("Id") {
                            self.id = dict["Id"] as! String
                        }
                        if dict.keys.contains("MappedName") {
                            self.mappedName = dict["MappedName"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("ShardColumns") {
                            self.shardColumns = dict["ShardColumns"] as! [String]
                        }
                        if dict.keys.contains("WhereClause") {
                            self.whereClause = dict["WhereClause"] as! String
                        }
                    }
                }
                public class Tables : Tea.TeaModel {
                    public class AdbTableSchema : Tea.TeaModel {
                        public var distributedKeys: [String]?

                        public var partitionLifeCycle: String?

                        public var partitionStatement: String?

                        public var primaryKeys: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.distributedKeys != nil {
                                map["DistributedKeys"] = self.distributedKeys!
                            }
                            if self.partitionLifeCycle != nil {
                                map["PartitionLifeCycle"] = self.partitionLifeCycle!
                            }
                            if self.partitionStatement != nil {
                                map["PartitionStatement"] = self.partitionStatement!
                            }
                            if self.primaryKeys != nil {
                                map["PrimaryKeys"] = self.primaryKeys!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("DistributedKeys") {
                                self.distributedKeys = dict["DistributedKeys"] as! [String]
                            }
                            if dict.keys.contains("PartitionLifeCycle") {
                                self.partitionLifeCycle = dict["PartitionLifeCycle"] as! String
                            }
                            if dict.keys.contains("PartitionStatement") {
                                self.partitionStatement = dict["PartitionStatement"] as! String
                            }
                            if dict.keys.contains("PrimaryKeys") {
                                self.primaryKeys = dict["PrimaryKeys"] as! [String]
                            }
                        }
                    }
                    public var adbTableSchema: DescribeProjectResponseBody.Data.TransferMapping.DatabasesBlack.Tables.AdbTableSchema?

                    public var filterColumns: [String]?

                    public var id: String?

                    public var mappedName: String?

                    public var name: String?

                    public var shardColumns: [String]?

                    public var whereClause: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.adbTableSchema?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.adbTableSchema != nil {
                            map["AdbTableSchema"] = self.adbTableSchema?.toMap()
                        }
                        if self.filterColumns != nil {
                            map["FilterColumns"] = self.filterColumns!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.mappedName != nil {
                            map["MappedName"] = self.mappedName!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.shardColumns != nil {
                            map["ShardColumns"] = self.shardColumns!
                        }
                        if self.whereClause != nil {
                            map["WhereClause"] = self.whereClause!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AdbTableSchema") {
                            var model = DescribeProjectResponseBody.Data.TransferMapping.DatabasesBlack.Tables.AdbTableSchema()
                            model.fromMap(dict["AdbTableSchema"] as! [String: Any])
                            self.adbTableSchema = model
                        }
                        if dict.keys.contains("FilterColumns") {
                            self.filterColumns = dict["FilterColumns"] as! [String]
                        }
                        if dict.keys.contains("Id") {
                            self.id = dict["Id"] as! String
                        }
                        if dict.keys.contains("MappedName") {
                            self.mappedName = dict["MappedName"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("ShardColumns") {
                            self.shardColumns = dict["ShardColumns"] as! [String]
                        }
                        if dict.keys.contains("WhereClause") {
                            self.whereClause = dict["WhereClause"] as! String
                        }
                    }
                }
                public class Views : Tea.TeaModel {
                    public class AdbTableSchema : Tea.TeaModel {
                        public var distributedKeys: [String]?

                        public var partitionLifeCycle: String?

                        public var partitionStatement: String?

                        public var primaryKeys: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.distributedKeys != nil {
                                map["DistributedKeys"] = self.distributedKeys!
                            }
                            if self.partitionLifeCycle != nil {
                                map["PartitionLifeCycle"] = self.partitionLifeCycle!
                            }
                            if self.partitionStatement != nil {
                                map["PartitionStatement"] = self.partitionStatement!
                            }
                            if self.primaryKeys != nil {
                                map["PrimaryKeys"] = self.primaryKeys!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("DistributedKeys") {
                                self.distributedKeys = dict["DistributedKeys"] as! [String]
                            }
                            if dict.keys.contains("PartitionLifeCycle") {
                                self.partitionLifeCycle = dict["PartitionLifeCycle"] as! String
                            }
                            if dict.keys.contains("PartitionStatement") {
                                self.partitionStatement = dict["PartitionStatement"] as! String
                            }
                            if dict.keys.contains("PrimaryKeys") {
                                self.primaryKeys = dict["PrimaryKeys"] as! [String]
                            }
                        }
                    }
                    public var adbTableSchema: DescribeProjectResponseBody.Data.TransferMapping.DatabasesBlack.Views.AdbTableSchema?

                    public var filterColumns: [String]?

                    public var id: String?

                    public var mappedName: String?

                    public var name: String?

                    public var shardColumns: [String]?

                    public var whereClause: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.adbTableSchema?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.adbTableSchema != nil {
                            map["AdbTableSchema"] = self.adbTableSchema?.toMap()
                        }
                        if self.filterColumns != nil {
                            map["FilterColumns"] = self.filterColumns!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.mappedName != nil {
                            map["MappedName"] = self.mappedName!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.shardColumns != nil {
                            map["ShardColumns"] = self.shardColumns!
                        }
                        if self.whereClause != nil {
                            map["WhereClause"] = self.whereClause!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AdbTableSchema") {
                            var model = DescribeProjectResponseBody.Data.TransferMapping.DatabasesBlack.Views.AdbTableSchema()
                            model.fromMap(dict["AdbTableSchema"] as! [String: Any])
                            self.adbTableSchema = model
                        }
                        if dict.keys.contains("FilterColumns") {
                            self.filterColumns = dict["FilterColumns"] as! [String]
                        }
                        if dict.keys.contains("Id") {
                            self.id = dict["Id"] as! String
                        }
                        if dict.keys.contains("MappedName") {
                            self.mappedName = dict["MappedName"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("ShardColumns") {
                            self.shardColumns = dict["ShardColumns"] as! [String]
                        }
                        if dict.keys.contains("WhereClause") {
                            self.whereClause = dict["WhereClause"] as! String
                        }
                    }
                }
                public var id: String?

                public var mappedName: String?

                public var name: String?

                public var specificTables: [DescribeProjectResponseBody.Data.TransferMapping.DatabasesBlack.SpecificTables]?

                public var specificViews: [DescribeProjectResponseBody.Data.TransferMapping.DatabasesBlack.SpecificViews]?

                public var tables: [DescribeProjectResponseBody.Data.TransferMapping.DatabasesBlack.Tables]?

                public var tenantName: String?

                public var type: String?

                public var views: [DescribeProjectResponseBody.Data.TransferMapping.DatabasesBlack.Views]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.mappedName != nil {
                        map["MappedName"] = self.mappedName!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.specificTables != nil {
                        var tmp : [Any] = []
                        for k in self.specificTables! {
                            tmp.append(k.toMap())
                        }
                        map["SpecificTables"] = tmp
                    }
                    if self.specificViews != nil {
                        var tmp : [Any] = []
                        for k in self.specificViews! {
                            tmp.append(k.toMap())
                        }
                        map["SpecificViews"] = tmp
                    }
                    if self.tables != nil {
                        var tmp : [Any] = []
                        for k in self.tables! {
                            tmp.append(k.toMap())
                        }
                        map["Tables"] = tmp
                    }
                    if self.tenantName != nil {
                        map["TenantName"] = self.tenantName!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.views != nil {
                        var tmp : [Any] = []
                        for k in self.views! {
                            tmp.append(k.toMap())
                        }
                        map["Views"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("MappedName") {
                        self.mappedName = dict["MappedName"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("SpecificTables") {
                        var tmp : [DescribeProjectResponseBody.Data.TransferMapping.DatabasesBlack.SpecificTables] = []
                        for v in dict["SpecificTables"] as! [Any] {
                            var model = DescribeProjectResponseBody.Data.TransferMapping.DatabasesBlack.SpecificTables()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.specificTables = tmp
                    }
                    if dict.keys.contains("SpecificViews") {
                        var tmp : [DescribeProjectResponseBody.Data.TransferMapping.DatabasesBlack.SpecificViews] = []
                        for v in dict["SpecificViews"] as! [Any] {
                            var model = DescribeProjectResponseBody.Data.TransferMapping.DatabasesBlack.SpecificViews()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.specificViews = tmp
                    }
                    if dict.keys.contains("Tables") {
                        var tmp : [DescribeProjectResponseBody.Data.TransferMapping.DatabasesBlack.Tables] = []
                        for v in dict["Tables"] as! [Any] {
                            var model = DescribeProjectResponseBody.Data.TransferMapping.DatabasesBlack.Tables()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tables = tmp
                    }
                    if dict.keys.contains("TenantName") {
                        self.tenantName = dict["TenantName"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Views") {
                        var tmp : [DescribeProjectResponseBody.Data.TransferMapping.DatabasesBlack.Views] = []
                        for v in dict["Views"] as! [Any] {
                            var model = DescribeProjectResponseBody.Data.TransferMapping.DatabasesBlack.Views()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.views = tmp
                    }
                }
            }
            public var databases: [DescribeProjectResponseBody.Data.TransferMapping.Databases]?

            public var databasesBlack: [DescribeProjectResponseBody.Data.TransferMapping.DatabasesBlack]?

            public var mode: String?

            public var tableAndViewBlackList: [String]?

            public var tableAndViewWhiteList: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.databases != nil {
                    var tmp : [Any] = []
                    for k in self.databases! {
                        tmp.append(k.toMap())
                    }
                    map["Databases"] = tmp
                }
                if self.databasesBlack != nil {
                    var tmp : [Any] = []
                    for k in self.databasesBlack! {
                        tmp.append(k.toMap())
                    }
                    map["DatabasesBlack"] = tmp
                }
                if self.mode != nil {
                    map["Mode"] = self.mode!
                }
                if self.tableAndViewBlackList != nil {
                    map["TableAndViewBlackList"] = self.tableAndViewBlackList!
                }
                if self.tableAndViewWhiteList != nil {
                    map["TableAndViewWhiteList"] = self.tableAndViewWhiteList!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Databases") {
                    var tmp : [DescribeProjectResponseBody.Data.TransferMapping.Databases] = []
                    for v in dict["Databases"] as! [Any] {
                        var model = DescribeProjectResponseBody.Data.TransferMapping.Databases()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.databases = tmp
                }
                if dict.keys.contains("DatabasesBlack") {
                    var tmp : [DescribeProjectResponseBody.Data.TransferMapping.DatabasesBlack] = []
                    for v in dict["DatabasesBlack"] as! [Any] {
                        var model = DescribeProjectResponseBody.Data.TransferMapping.DatabasesBlack()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.databasesBlack = tmp
                }
                if dict.keys.contains("Mode") {
                    self.mode = dict["Mode"] as! String
                }
                if dict.keys.contains("TableAndViewBlackList") {
                    self.tableAndViewBlackList = dict["TableAndViewBlackList"] as! [String]
                }
                if dict.keys.contains("TableAndViewWhiteList") {
                    self.tableAndViewWhiteList = dict["TableAndViewWhiteList"] as! [String]
                }
            }
        }
        public class WorkerGradeInfo : Tea.TeaModel {
            public var autoRenewal: Bool?

            public var chargeType: String?

            public var destRegion: String?

            public var destType: String?

            public var endTime: String?

            public var expired: Bool?

            public var gmtCreate: String?

            public var grade: String?

            public var id: String?

            public var name: String?

            public var sourceRegion: String?

            public var sourceType: String?

            public var spec: String?

            public var specName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoRenewal != nil {
                    map["AutoRenewal"] = self.autoRenewal!
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.destRegion != nil {
                    map["DestRegion"] = self.destRegion!
                }
                if self.destType != nil {
                    map["DestType"] = self.destType!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.expired != nil {
                    map["Expired"] = self.expired!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.grade != nil {
                    map["Grade"] = self.grade!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.sourceRegion != nil {
                    map["SourceRegion"] = self.sourceRegion!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.spec != nil {
                    map["Spec"] = self.spec!
                }
                if self.specName != nil {
                    map["SpecName"] = self.specName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutoRenewal") {
                    self.autoRenewal = dict["AutoRenewal"] as! Bool
                }
                if dict.keys.contains("ChargeType") {
                    self.chargeType = dict["ChargeType"] as! String
                }
                if dict.keys.contains("DestRegion") {
                    self.destRegion = dict["DestRegion"] as! String
                }
                if dict.keys.contains("DestType") {
                    self.destType = dict["DestType"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("Expired") {
                    self.expired = dict["Expired"] as! Bool
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("Grade") {
                    self.grade = dict["Grade"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("SourceRegion") {
                    self.sourceRegion = dict["SourceRegion"] as! String
                }
                if dict.keys.contains("SourceType") {
                    self.sourceType = dict["SourceType"] as! String
                }
                if dict.keys.contains("Spec") {
                    self.spec = dict["Spec"] as! String
                }
                if dict.keys.contains("SpecName") {
                    self.specName = dict["SpecName"] as! String
                }
            }
        }
        public var alarmStats: DescribeProjectResponseBody.Data.AlarmStats?

        public var commonTransferConfig: DescribeProjectResponseBody.Data.CommonTransferConfig?

        public var destConnId: String?

        public var enableFullTransfer: Bool?

        public var enableFullVerify: Bool?

        public var enableIncrTransfer: Bool?

        public var enableIncrVerify: Bool?

        public var enableReverseIncrTransfer: Bool?

        public var enableStructTransfer: Bool?

        public var extraInfo: DescribeProjectResponseBody.Data.ExtraInfo?

        public var fullTransferConfig: DescribeProjectResponseBody.Data.FullTransferConfig?

        public var gmtCreate: String?

        public var gmtFinish: String?

        public var gmtModified: String?

        public var gmtStart: String?

        public var id: String?

        public var importance: String?

        public var incrTransferConfig: DescribeProjectResponseBody.Data.IncrTransferConfig?

        public var isMerging: Bool?

        public var isModifying: Bool?

        public var isSubProject: Bool?

        public var labels: [DescribeProjectResponseBody.Data.Labels]?

        public var name: String?

        public var owner: String?

        public var reverseIncrTransferConfig: DescribeProjectResponseBody.Data.ReverseIncrTransferConfig?

        public var sinkConnectInfo: DescribeProjectResponseBody.Data.SinkConnectInfo?

        public var sinkEndpointType: String?

        public var sourceConnectInfo: DescribeProjectResponseBody.Data.SourceConnectInfo?

        public var sourceEndpointType: String?

        public var status: String?

        public var steps: [DescribeProjectResponseBody.Data.Steps]?

        public var structTransferConfig: DescribeProjectResponseBody.Data.StructTransferConfig?

        public var transferMapping: DescribeProjectResponseBody.Data.TransferMapping?

        public var type: String?

        public var workerGradeId: String?

        public var workerGradeInfo: DescribeProjectResponseBody.Data.WorkerGradeInfo?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.alarmStats?.validate()
            try self.commonTransferConfig?.validate()
            try self.extraInfo?.validate()
            try self.fullTransferConfig?.validate()
            try self.incrTransferConfig?.validate()
            try self.reverseIncrTransferConfig?.validate()
            try self.sinkConnectInfo?.validate()
            try self.sourceConnectInfo?.validate()
            try self.structTransferConfig?.validate()
            try self.transferMapping?.validate()
            try self.workerGradeInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarmStats != nil {
                map["AlarmStats"] = self.alarmStats?.toMap()
            }
            if self.commonTransferConfig != nil {
                map["CommonTransferConfig"] = self.commonTransferConfig?.toMap()
            }
            if self.destConnId != nil {
                map["DestConnId"] = self.destConnId!
            }
            if self.enableFullTransfer != nil {
                map["EnableFullTransfer"] = self.enableFullTransfer!
            }
            if self.enableFullVerify != nil {
                map["EnableFullVerify"] = self.enableFullVerify!
            }
            if self.enableIncrTransfer != nil {
                map["EnableIncrTransfer"] = self.enableIncrTransfer!
            }
            if self.enableIncrVerify != nil {
                map["EnableIncrVerify"] = self.enableIncrVerify!
            }
            if self.enableReverseIncrTransfer != nil {
                map["EnableReverseIncrTransfer"] = self.enableReverseIncrTransfer!
            }
            if self.enableStructTransfer != nil {
                map["EnableStructTransfer"] = self.enableStructTransfer!
            }
            if self.extraInfo != nil {
                map["ExtraInfo"] = self.extraInfo?.toMap()
            }
            if self.fullTransferConfig != nil {
                map["FullTransferConfig"] = self.fullTransferConfig?.toMap()
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtFinish != nil {
                map["GmtFinish"] = self.gmtFinish!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.gmtStart != nil {
                map["GmtStart"] = self.gmtStart!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.importance != nil {
                map["Importance"] = self.importance!
            }
            if self.incrTransferConfig != nil {
                map["IncrTransferConfig"] = self.incrTransferConfig?.toMap()
            }
            if self.isMerging != nil {
                map["IsMerging"] = self.isMerging!
            }
            if self.isModifying != nil {
                map["IsModifying"] = self.isModifying!
            }
            if self.isSubProject != nil {
                map["IsSubProject"] = self.isSubProject!
            }
            if self.labels != nil {
                var tmp : [Any] = []
                for k in self.labels! {
                    tmp.append(k.toMap())
                }
                map["Labels"] = tmp
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.reverseIncrTransferConfig != nil {
                map["ReverseIncrTransferConfig"] = self.reverseIncrTransferConfig?.toMap()
            }
            if self.sinkConnectInfo != nil {
                map["SinkConnectInfo"] = self.sinkConnectInfo?.toMap()
            }
            if self.sinkEndpointType != nil {
                map["SinkEndpointType"] = self.sinkEndpointType!
            }
            if self.sourceConnectInfo != nil {
                map["SourceConnectInfo"] = self.sourceConnectInfo?.toMap()
            }
            if self.sourceEndpointType != nil {
                map["SourceEndpointType"] = self.sourceEndpointType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.steps != nil {
                var tmp : [Any] = []
                for k in self.steps! {
                    tmp.append(k.toMap())
                }
                map["Steps"] = tmp
            }
            if self.structTransferConfig != nil {
                map["StructTransferConfig"] = self.structTransferConfig?.toMap()
            }
            if self.transferMapping != nil {
                map["TransferMapping"] = self.transferMapping?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.workerGradeId != nil {
                map["WorkerGradeId"] = self.workerGradeId!
            }
            if self.workerGradeInfo != nil {
                map["WorkerGradeInfo"] = self.workerGradeInfo?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlarmStats") {
                var model = DescribeProjectResponseBody.Data.AlarmStats()
                model.fromMap(dict["AlarmStats"] as! [String: Any])
                self.alarmStats = model
            }
            if dict.keys.contains("CommonTransferConfig") {
                var model = DescribeProjectResponseBody.Data.CommonTransferConfig()
                model.fromMap(dict["CommonTransferConfig"] as! [String: Any])
                self.commonTransferConfig = model
            }
            if dict.keys.contains("DestConnId") {
                self.destConnId = dict["DestConnId"] as! String
            }
            if dict.keys.contains("EnableFullTransfer") {
                self.enableFullTransfer = dict["EnableFullTransfer"] as! Bool
            }
            if dict.keys.contains("EnableFullVerify") {
                self.enableFullVerify = dict["EnableFullVerify"] as! Bool
            }
            if dict.keys.contains("EnableIncrTransfer") {
                self.enableIncrTransfer = dict["EnableIncrTransfer"] as! Bool
            }
            if dict.keys.contains("EnableIncrVerify") {
                self.enableIncrVerify = dict["EnableIncrVerify"] as! Bool
            }
            if dict.keys.contains("EnableReverseIncrTransfer") {
                self.enableReverseIncrTransfer = dict["EnableReverseIncrTransfer"] as! Bool
            }
            if dict.keys.contains("EnableStructTransfer") {
                self.enableStructTransfer = dict["EnableStructTransfer"] as! Bool
            }
            if dict.keys.contains("ExtraInfo") {
                var model = DescribeProjectResponseBody.Data.ExtraInfo()
                model.fromMap(dict["ExtraInfo"] as! [String: Any])
                self.extraInfo = model
            }
            if dict.keys.contains("FullTransferConfig") {
                var model = DescribeProjectResponseBody.Data.FullTransferConfig()
                model.fromMap(dict["FullTransferConfig"] as! [String: Any])
                self.fullTransferConfig = model
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtFinish") {
                self.gmtFinish = dict["GmtFinish"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("GmtStart") {
                self.gmtStart = dict["GmtStart"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Importance") {
                self.importance = dict["Importance"] as! String
            }
            if dict.keys.contains("IncrTransferConfig") {
                var model = DescribeProjectResponseBody.Data.IncrTransferConfig()
                model.fromMap(dict["IncrTransferConfig"] as! [String: Any])
                self.incrTransferConfig = model
            }
            if dict.keys.contains("IsMerging") {
                self.isMerging = dict["IsMerging"] as! Bool
            }
            if dict.keys.contains("IsModifying") {
                self.isModifying = dict["IsModifying"] as! Bool
            }
            if dict.keys.contains("IsSubProject") {
                self.isSubProject = dict["IsSubProject"] as! Bool
            }
            if dict.keys.contains("Labels") {
                var tmp : [DescribeProjectResponseBody.Data.Labels] = []
                for v in dict["Labels"] as! [Any] {
                    var model = DescribeProjectResponseBody.Data.Labels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.labels = tmp
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Owner") {
                self.owner = dict["Owner"] as! String
            }
            if dict.keys.contains("ReverseIncrTransferConfig") {
                var model = DescribeProjectResponseBody.Data.ReverseIncrTransferConfig()
                model.fromMap(dict["ReverseIncrTransferConfig"] as! [String: Any])
                self.reverseIncrTransferConfig = model
            }
            if dict.keys.contains("SinkConnectInfo") {
                var model = DescribeProjectResponseBody.Data.SinkConnectInfo()
                model.fromMap(dict["SinkConnectInfo"] as! [String: Any])
                self.sinkConnectInfo = model
            }
            if dict.keys.contains("SinkEndpointType") {
                self.sinkEndpointType = dict["SinkEndpointType"] as! String
            }
            if dict.keys.contains("SourceConnectInfo") {
                var model = DescribeProjectResponseBody.Data.SourceConnectInfo()
                model.fromMap(dict["SourceConnectInfo"] as! [String: Any])
                self.sourceConnectInfo = model
            }
            if dict.keys.contains("SourceEndpointType") {
                self.sourceEndpointType = dict["SourceEndpointType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Steps") {
                var tmp : [DescribeProjectResponseBody.Data.Steps] = []
                for v in dict["Steps"] as! [Any] {
                    var model = DescribeProjectResponseBody.Data.Steps()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.steps = tmp
            }
            if dict.keys.contains("StructTransferConfig") {
                var model = DescribeProjectResponseBody.Data.StructTransferConfig()
                model.fromMap(dict["StructTransferConfig"] as! [String: Any])
                self.structTransferConfig = model
            }
            if dict.keys.contains("TransferMapping") {
                var model = DescribeProjectResponseBody.Data.TransferMapping()
                model.fromMap(dict["TransferMapping"] as! [String: Any])
                self.transferMapping = model
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("WorkerGradeId") {
                self.workerGradeId = dict["WorkerGradeId"] as! String
            }
            if dict.keys.contains("WorkerGradeInfo") {
                var model = DescribeProjectResponseBody.Data.WorkerGradeInfo()
                model.fromMap(dict["WorkerGradeInfo"] as! [String: Any])
                self.workerGradeInfo = model
            }
        }
    }
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: DescribeProjectResponseBody.Data?

    public var errorDetail: DescribeProjectResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeProjectResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorDetail") {
            var model = DescribeProjectResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeProjectComponentsRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class DescribeProjectComponentsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class FullImportComponents : Tea.TeaModel {
            public class ErrorDetails : Tea.TeaModel {
                public var code: String?

                public var extraContext: [String: Any]?

                public var level: String?

                public var message: String?

                public var messageMcmsContext: [String: String]?

                public var messageMcmsKey: String?

                public var proposal: String?

                public var proposalMcmsContext: [String: String]?

                public var proposalMcmsKey: String?

                public var reason: String?

                public var reasonMcmsContext: [String: String]?

                public var reasonMcmsKey: String?

                public var upstreamErrorDetail: Any?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.extraContext != nil {
                        map["ExtraContext"] = self.extraContext!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.message != nil {
                        map["Message"] = self.message!
                    }
                    if self.messageMcmsContext != nil {
                        map["MessageMcmsContext"] = self.messageMcmsContext!
                    }
                    if self.messageMcmsKey != nil {
                        map["MessageMcmsKey"] = self.messageMcmsKey!
                    }
                    if self.proposal != nil {
                        map["Proposal"] = self.proposal!
                    }
                    if self.proposalMcmsContext != nil {
                        map["ProposalMcmsContext"] = self.proposalMcmsContext!
                    }
                    if self.proposalMcmsKey != nil {
                        map["ProposalMcmsKey"] = self.proposalMcmsKey!
                    }
                    if self.reason != nil {
                        map["Reason"] = self.reason!
                    }
                    if self.reasonMcmsContext != nil {
                        map["ReasonMcmsContext"] = self.reasonMcmsContext!
                    }
                    if self.reasonMcmsKey != nil {
                        map["ReasonMcmsKey"] = self.reasonMcmsKey!
                    }
                    if self.upstreamErrorDetail != nil {
                        map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Code") {
                        self.code = dict["Code"] as! String
                    }
                    if dict.keys.contains("ExtraContext") {
                        self.extraContext = dict["ExtraContext"] as! [String: Any]
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("Message") {
                        self.message = dict["Message"] as! String
                    }
                    if dict.keys.contains("MessageMcmsContext") {
                        self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
                    }
                    if dict.keys.contains("MessageMcmsKey") {
                        self.messageMcmsKey = dict["MessageMcmsKey"] as! String
                    }
                    if dict.keys.contains("Proposal") {
                        self.proposal = dict["Proposal"] as! String
                    }
                    if dict.keys.contains("ProposalMcmsContext") {
                        self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
                    }
                    if dict.keys.contains("ProposalMcmsKey") {
                        self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
                    }
                    if dict.keys.contains("Reason") {
                        self.reason = dict["Reason"] as! String
                    }
                    if dict.keys.contains("ReasonMcmsContext") {
                        self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
                    }
                    if dict.keys.contains("ReasonMcmsKey") {
                        self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
                    }
                    if dict.keys.contains("UpstreamErrorDetail") {
                        self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
                    }
                }
            }
            public var errorDetails: [DescribeProjectComponentsResponseBody.Data.FullImportComponents.ErrorDetails]?

            public var gmtCreate: String?

            public var gmtModify: String?

            public var identity: String?

            public var ip: String?

            public var name: String?

            public var progress: Int32?

            public var region: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorDetails != nil {
                    var tmp : [Any] = []
                    for k in self.errorDetails! {
                        tmp.append(k.toMap())
                    }
                    map["ErrorDetails"] = tmp
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModify != nil {
                    map["GmtModify"] = self.gmtModify!
                }
                if self.identity != nil {
                    map["Identity"] = self.identity!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorDetails") {
                    var tmp : [DescribeProjectComponentsResponseBody.Data.FullImportComponents.ErrorDetails] = []
                    for v in dict["ErrorDetails"] as! [Any] {
                        var model = DescribeProjectComponentsResponseBody.Data.FullImportComponents.ErrorDetails()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.errorDetails = tmp
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModify") {
                    self.gmtModify = dict["GmtModify"] as! String
                }
                if dict.keys.contains("Identity") {
                    self.identity = dict["Identity"] as! String
                }
                if dict.keys.contains("Ip") {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! Int32
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class FullVerifyComponents : Tea.TeaModel {
            public class ErrorDetails : Tea.TeaModel {
                public var code: String?

                public var extraContext: [String: Any]?

                public var level: String?

                public var message: String?

                public var messageMcmsContext: [String: String]?

                public var messageMcmsKey: String?

                public var proposal: String?

                public var proposalMcmsContext: [String: String]?

                public var proposalMcmsKey: String?

                public var reason: String?

                public var reasonMcmsContext: [String: String]?

                public var reasonMcmsKey: String?

                public var upstreamErrorDetail: Any?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.extraContext != nil {
                        map["ExtraContext"] = self.extraContext!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.message != nil {
                        map["Message"] = self.message!
                    }
                    if self.messageMcmsContext != nil {
                        map["MessageMcmsContext"] = self.messageMcmsContext!
                    }
                    if self.messageMcmsKey != nil {
                        map["MessageMcmsKey"] = self.messageMcmsKey!
                    }
                    if self.proposal != nil {
                        map["Proposal"] = self.proposal!
                    }
                    if self.proposalMcmsContext != nil {
                        map["ProposalMcmsContext"] = self.proposalMcmsContext!
                    }
                    if self.proposalMcmsKey != nil {
                        map["ProposalMcmsKey"] = self.proposalMcmsKey!
                    }
                    if self.reason != nil {
                        map["Reason"] = self.reason!
                    }
                    if self.reasonMcmsContext != nil {
                        map["ReasonMcmsContext"] = self.reasonMcmsContext!
                    }
                    if self.reasonMcmsKey != nil {
                        map["ReasonMcmsKey"] = self.reasonMcmsKey!
                    }
                    if self.upstreamErrorDetail != nil {
                        map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Code") {
                        self.code = dict["Code"] as! String
                    }
                    if dict.keys.contains("ExtraContext") {
                        self.extraContext = dict["ExtraContext"] as! [String: Any]
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("Message") {
                        self.message = dict["Message"] as! String
                    }
                    if dict.keys.contains("MessageMcmsContext") {
                        self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
                    }
                    if dict.keys.contains("MessageMcmsKey") {
                        self.messageMcmsKey = dict["MessageMcmsKey"] as! String
                    }
                    if dict.keys.contains("Proposal") {
                        self.proposal = dict["Proposal"] as! String
                    }
                    if dict.keys.contains("ProposalMcmsContext") {
                        self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
                    }
                    if dict.keys.contains("ProposalMcmsKey") {
                        self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
                    }
                    if dict.keys.contains("Reason") {
                        self.reason = dict["Reason"] as! String
                    }
                    if dict.keys.contains("ReasonMcmsContext") {
                        self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
                    }
                    if dict.keys.contains("ReasonMcmsKey") {
                        self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
                    }
                    if dict.keys.contains("UpstreamErrorDetail") {
                        self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
                    }
                }
            }
            public var consistentQuantity: Int64?

            public var errorDetails: [DescribeProjectComponentsResponseBody.Data.FullVerifyComponents.ErrorDetails]?

            public var inconsistentQuantity: Int64?

            public var ip: String?

            public var name: String?

            public var progress: String?

            public var recordProgress: Int32?

            public var region: String?

            public var status: String?

            public var taskId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.consistentQuantity != nil {
                    map["ConsistentQuantity"] = self.consistentQuantity!
                }
                if self.errorDetails != nil {
                    var tmp : [Any] = []
                    for k in self.errorDetails! {
                        tmp.append(k.toMap())
                    }
                    map["ErrorDetails"] = tmp
                }
                if self.inconsistentQuantity != nil {
                    map["InconsistentQuantity"] = self.inconsistentQuantity!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.recordProgress != nil {
                    map["RecordProgress"] = self.recordProgress!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConsistentQuantity") {
                    self.consistentQuantity = dict["ConsistentQuantity"] as! Int64
                }
                if dict.keys.contains("ErrorDetails") {
                    var tmp : [DescribeProjectComponentsResponseBody.Data.FullVerifyComponents.ErrorDetails] = []
                    for v in dict["ErrorDetails"] as! [Any] {
                        var model = DescribeProjectComponentsResponseBody.Data.FullVerifyComponents.ErrorDetails()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.errorDetails = tmp
                }
                if dict.keys.contains("InconsistentQuantity") {
                    self.inconsistentQuantity = dict["InconsistentQuantity"] as! Int64
                }
                if dict.keys.contains("Ip") {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("RecordProgress") {
                    self.recordProgress = dict["RecordProgress"] as! Int32
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TaskId") {
                    self.taskId = dict["TaskId"] as! Int64
                }
            }
        }
        public class IncrSyncComponents : Tea.TeaModel {
            public class ErrorDetails : Tea.TeaModel {
                public var code: String?

                public var extraContext: [String: Any]?

                public var level: String?

                public var message: String?

                public var messageMcmsContext: [String: String]?

                public var messageMcmsKey: String?

                public var proposal: String?

                public var proposalMcmsContext: [String: String]?

                public var proposalMcmsKey: String?

                public var reason: String?

                public var reasonMcmsContext: [String: String]?

                public var reasonMcmsKey: String?

                public var upstreamErrorDetail: Any?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.extraContext != nil {
                        map["ExtraContext"] = self.extraContext!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.message != nil {
                        map["Message"] = self.message!
                    }
                    if self.messageMcmsContext != nil {
                        map["MessageMcmsContext"] = self.messageMcmsContext!
                    }
                    if self.messageMcmsKey != nil {
                        map["MessageMcmsKey"] = self.messageMcmsKey!
                    }
                    if self.proposal != nil {
                        map["Proposal"] = self.proposal!
                    }
                    if self.proposalMcmsContext != nil {
                        map["ProposalMcmsContext"] = self.proposalMcmsContext!
                    }
                    if self.proposalMcmsKey != nil {
                        map["ProposalMcmsKey"] = self.proposalMcmsKey!
                    }
                    if self.reason != nil {
                        map["Reason"] = self.reason!
                    }
                    if self.reasonMcmsContext != nil {
                        map["ReasonMcmsContext"] = self.reasonMcmsContext!
                    }
                    if self.reasonMcmsKey != nil {
                        map["ReasonMcmsKey"] = self.reasonMcmsKey!
                    }
                    if self.upstreamErrorDetail != nil {
                        map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Code") {
                        self.code = dict["Code"] as! String
                    }
                    if dict.keys.contains("ExtraContext") {
                        self.extraContext = dict["ExtraContext"] as! [String: Any]
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("Message") {
                        self.message = dict["Message"] as! String
                    }
                    if dict.keys.contains("MessageMcmsContext") {
                        self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
                    }
                    if dict.keys.contains("MessageMcmsKey") {
                        self.messageMcmsKey = dict["MessageMcmsKey"] as! String
                    }
                    if dict.keys.contains("Proposal") {
                        self.proposal = dict["Proposal"] as! String
                    }
                    if dict.keys.contains("ProposalMcmsContext") {
                        self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
                    }
                    if dict.keys.contains("ProposalMcmsKey") {
                        self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
                    }
                    if dict.keys.contains("Reason") {
                        self.reason = dict["Reason"] as! String
                    }
                    if dict.keys.contains("ReasonMcmsContext") {
                        self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
                    }
                    if dict.keys.contains("ReasonMcmsKey") {
                        self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
                    }
                    if dict.keys.contains("UpstreamErrorDetail") {
                        self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
                    }
                }
            }
            public var checkpoint: String?

            public var checkpointSampleTimestamp: Int64?

            public var delay: Int64?

            public var errorDetails: [DescribeProjectComponentsResponseBody.Data.IncrSyncComponents.ErrorDetails]?

            public var gmtCreate: String?

            public var gmtModify: String?

            public var identity: String?

            public var ip: String?

            public var name: String?

            public var region: String?

            public var status: String?

            public var subtopics: [String]?

            public var tps: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkpoint != nil {
                    map["Checkpoint"] = self.checkpoint!
                }
                if self.checkpointSampleTimestamp != nil {
                    map["CheckpointSampleTimestamp"] = self.checkpointSampleTimestamp!
                }
                if self.delay != nil {
                    map["Delay"] = self.delay!
                }
                if self.errorDetails != nil {
                    var tmp : [Any] = []
                    for k in self.errorDetails! {
                        tmp.append(k.toMap())
                    }
                    map["ErrorDetails"] = tmp
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModify != nil {
                    map["GmtModify"] = self.gmtModify!
                }
                if self.identity != nil {
                    map["Identity"] = self.identity!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.subtopics != nil {
                    map["Subtopics"] = self.subtopics!
                }
                if self.tps != nil {
                    map["Tps"] = self.tps!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Checkpoint") {
                    self.checkpoint = dict["Checkpoint"] as! String
                }
                if dict.keys.contains("CheckpointSampleTimestamp") {
                    self.checkpointSampleTimestamp = dict["CheckpointSampleTimestamp"] as! Int64
                }
                if dict.keys.contains("Delay") {
                    self.delay = dict["Delay"] as! Int64
                }
                if dict.keys.contains("ErrorDetails") {
                    var tmp : [DescribeProjectComponentsResponseBody.Data.IncrSyncComponents.ErrorDetails] = []
                    for v in dict["ErrorDetails"] as! [Any] {
                        var model = DescribeProjectComponentsResponseBody.Data.IncrSyncComponents.ErrorDetails()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.errorDetails = tmp
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModify") {
                    self.gmtModify = dict["GmtModify"] as! String
                }
                if dict.keys.contains("Identity") {
                    self.identity = dict["Identity"] as! String
                }
                if dict.keys.contains("Ip") {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Subtopics") {
                    self.subtopics = dict["Subtopics"] as! [String]
                }
                if dict.keys.contains("Tps") {
                    self.tps = dict["Tps"] as! Int64
                }
            }
        }
        public class ReverseIncrSyncComponents : Tea.TeaModel {
            public class ErrorDetails : Tea.TeaModel {
                public var code: String?

                public var extraContext: [String: Any]?

                public var level: String?

                public var message: String?

                public var messageMcmsContext: [String: String]?

                public var messageMcmsKey: String?

                public var proposal: String?

                public var proposalMcmsContext: [String: String]?

                public var proposalMcmsKey: String?

                public var reason: String?

                public var reasonMcmsContext: [String: String]?

                public var reasonMcmsKey: String?

                public var upstreamErrorDetail: Any?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.extraContext != nil {
                        map["ExtraContext"] = self.extraContext!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.message != nil {
                        map["Message"] = self.message!
                    }
                    if self.messageMcmsContext != nil {
                        map["MessageMcmsContext"] = self.messageMcmsContext!
                    }
                    if self.messageMcmsKey != nil {
                        map["MessageMcmsKey"] = self.messageMcmsKey!
                    }
                    if self.proposal != nil {
                        map["Proposal"] = self.proposal!
                    }
                    if self.proposalMcmsContext != nil {
                        map["ProposalMcmsContext"] = self.proposalMcmsContext!
                    }
                    if self.proposalMcmsKey != nil {
                        map["ProposalMcmsKey"] = self.proposalMcmsKey!
                    }
                    if self.reason != nil {
                        map["Reason"] = self.reason!
                    }
                    if self.reasonMcmsContext != nil {
                        map["ReasonMcmsContext"] = self.reasonMcmsContext!
                    }
                    if self.reasonMcmsKey != nil {
                        map["ReasonMcmsKey"] = self.reasonMcmsKey!
                    }
                    if self.upstreamErrorDetail != nil {
                        map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Code") {
                        self.code = dict["Code"] as! String
                    }
                    if dict.keys.contains("ExtraContext") {
                        self.extraContext = dict["ExtraContext"] as! [String: Any]
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("Message") {
                        self.message = dict["Message"] as! String
                    }
                    if dict.keys.contains("MessageMcmsContext") {
                        self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
                    }
                    if dict.keys.contains("MessageMcmsKey") {
                        self.messageMcmsKey = dict["MessageMcmsKey"] as! String
                    }
                    if dict.keys.contains("Proposal") {
                        self.proposal = dict["Proposal"] as! String
                    }
                    if dict.keys.contains("ProposalMcmsContext") {
                        self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
                    }
                    if dict.keys.contains("ProposalMcmsKey") {
                        self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
                    }
                    if dict.keys.contains("Reason") {
                        self.reason = dict["Reason"] as! String
                    }
                    if dict.keys.contains("ReasonMcmsContext") {
                        self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
                    }
                    if dict.keys.contains("ReasonMcmsKey") {
                        self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
                    }
                    if dict.keys.contains("UpstreamErrorDetail") {
                        self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
                    }
                }
            }
            public var checkpoint: String?

            public var checkpointSampleTimestamp: Int64?

            public var delay: Int64?

            public var errorDetails: [DescribeProjectComponentsResponseBody.Data.ReverseIncrSyncComponents.ErrorDetails]?

            public var gmtCreate: String?

            public var gmtModify: String?

            public var identity: String?

            public var ip: String?

            public var name: String?

            public var region: String?

            public var status: String?

            public var subtopics: [String]?

            public var tps: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkpoint != nil {
                    map["Checkpoint"] = self.checkpoint!
                }
                if self.checkpointSampleTimestamp != nil {
                    map["CheckpointSampleTimestamp"] = self.checkpointSampleTimestamp!
                }
                if self.delay != nil {
                    map["Delay"] = self.delay!
                }
                if self.errorDetails != nil {
                    var tmp : [Any] = []
                    for k in self.errorDetails! {
                        tmp.append(k.toMap())
                    }
                    map["ErrorDetails"] = tmp
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModify != nil {
                    map["GmtModify"] = self.gmtModify!
                }
                if self.identity != nil {
                    map["Identity"] = self.identity!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.subtopics != nil {
                    map["Subtopics"] = self.subtopics!
                }
                if self.tps != nil {
                    map["Tps"] = self.tps!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Checkpoint") {
                    self.checkpoint = dict["Checkpoint"] as! String
                }
                if dict.keys.contains("CheckpointSampleTimestamp") {
                    self.checkpointSampleTimestamp = dict["CheckpointSampleTimestamp"] as! Int64
                }
                if dict.keys.contains("Delay") {
                    self.delay = dict["Delay"] as! Int64
                }
                if dict.keys.contains("ErrorDetails") {
                    var tmp : [DescribeProjectComponentsResponseBody.Data.ReverseIncrSyncComponents.ErrorDetails] = []
                    for v in dict["ErrorDetails"] as! [Any] {
                        var model = DescribeProjectComponentsResponseBody.Data.ReverseIncrSyncComponents.ErrorDetails()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.errorDetails = tmp
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModify") {
                    self.gmtModify = dict["GmtModify"] as! String
                }
                if dict.keys.contains("Identity") {
                    self.identity = dict["Identity"] as! String
                }
                if dict.keys.contains("Ip") {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Subtopics") {
                    self.subtopics = dict["Subtopics"] as! [String]
                }
                if dict.keys.contains("Tps") {
                    self.tps = dict["Tps"] as! Int64
                }
            }
        }
        public class ReverseStoreList : Tea.TeaModel {
            public class ErrorDetails : Tea.TeaModel {
                public var code: String?

                public var extraContext: [String: Any]?

                public var level: String?

                public var message: String?

                public var messageMcmsContext: [String: String]?

                public var messageMcmsKey: String?

                public var proposal: String?

                public var proposalMcmsContext: [String: String]?

                public var proposalMcmsKey: String?

                public var reason: String?

                public var reasonMcmsContext: [String: String]?

                public var reasonMcmsKey: String?

                public var upstreamErrorDetail: Any?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.extraContext != nil {
                        map["ExtraContext"] = self.extraContext!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.message != nil {
                        map["Message"] = self.message!
                    }
                    if self.messageMcmsContext != nil {
                        map["MessageMcmsContext"] = self.messageMcmsContext!
                    }
                    if self.messageMcmsKey != nil {
                        map["MessageMcmsKey"] = self.messageMcmsKey!
                    }
                    if self.proposal != nil {
                        map["Proposal"] = self.proposal!
                    }
                    if self.proposalMcmsContext != nil {
                        map["ProposalMcmsContext"] = self.proposalMcmsContext!
                    }
                    if self.proposalMcmsKey != nil {
                        map["ProposalMcmsKey"] = self.proposalMcmsKey!
                    }
                    if self.reason != nil {
                        map["Reason"] = self.reason!
                    }
                    if self.reasonMcmsContext != nil {
                        map["ReasonMcmsContext"] = self.reasonMcmsContext!
                    }
                    if self.reasonMcmsKey != nil {
                        map["ReasonMcmsKey"] = self.reasonMcmsKey!
                    }
                    if self.upstreamErrorDetail != nil {
                        map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Code") {
                        self.code = dict["Code"] as! String
                    }
                    if dict.keys.contains("ExtraContext") {
                        self.extraContext = dict["ExtraContext"] as! [String: Any]
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("Message") {
                        self.message = dict["Message"] as! String
                    }
                    if dict.keys.contains("MessageMcmsContext") {
                        self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
                    }
                    if dict.keys.contains("MessageMcmsKey") {
                        self.messageMcmsKey = dict["MessageMcmsKey"] as! String
                    }
                    if dict.keys.contains("Proposal") {
                        self.proposal = dict["Proposal"] as! String
                    }
                    if dict.keys.contains("ProposalMcmsContext") {
                        self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
                    }
                    if dict.keys.contains("ProposalMcmsKey") {
                        self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
                    }
                    if dict.keys.contains("Reason") {
                        self.reason = dict["Reason"] as! String
                    }
                    if dict.keys.contains("ReasonMcmsContext") {
                        self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
                    }
                    if dict.keys.contains("ReasonMcmsKey") {
                        self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
                    }
                    if dict.keys.contains("UpstreamErrorDetail") {
                        self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
                    }
                }
            }
            public var beginCheckpoint: String?

            public var conn: Int64?

            public var delay: Int64?

            public var endCheckpoint: String?

            public var errMsg: String?

            public var errorDetails: [DescribeProjectComponentsResponseBody.Data.ReverseStoreList.ErrorDetails]?

            public var gmt: Int64?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var ip: String?

            public var latelyHeartbeatTimeSec: Int64?

            public var name: String?

            public var port: Int32?

            public var region: String?

            public var status: String?

            public var storePort: Int32?

            public var subtopic: String?

            public var toSwitch: Bool?

            public var topic: String?

            public var tps: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.beginCheckpoint != nil {
                    map["BeginCheckpoint"] = self.beginCheckpoint!
                }
                if self.conn != nil {
                    map["Conn"] = self.conn!
                }
                if self.delay != nil {
                    map["Delay"] = self.delay!
                }
                if self.endCheckpoint != nil {
                    map["EndCheckpoint"] = self.endCheckpoint!
                }
                if self.errMsg != nil {
                    map["ErrMsg"] = self.errMsg!
                }
                if self.errorDetails != nil {
                    var tmp : [Any] = []
                    for k in self.errorDetails! {
                        tmp.append(k.toMap())
                    }
                    map["ErrorDetails"] = tmp
                }
                if self.gmt != nil {
                    map["Gmt"] = self.gmt!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.latelyHeartbeatTimeSec != nil {
                    map["LatelyHeartbeatTimeSec"] = self.latelyHeartbeatTimeSec!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.storePort != nil {
                    map["StorePort"] = self.storePort!
                }
                if self.subtopic != nil {
                    map["Subtopic"] = self.subtopic!
                }
                if self.toSwitch != nil {
                    map["ToSwitch"] = self.toSwitch!
                }
                if self.topic != nil {
                    map["Topic"] = self.topic!
                }
                if self.tps != nil {
                    map["Tps"] = self.tps!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BeginCheckpoint") {
                    self.beginCheckpoint = dict["BeginCheckpoint"] as! String
                }
                if dict.keys.contains("Conn") {
                    self.conn = dict["Conn"] as! Int64
                }
                if dict.keys.contains("Delay") {
                    self.delay = dict["Delay"] as! Int64
                }
                if dict.keys.contains("EndCheckpoint") {
                    self.endCheckpoint = dict["EndCheckpoint"] as! String
                }
                if dict.keys.contains("ErrMsg") {
                    self.errMsg = dict["ErrMsg"] as! String
                }
                if dict.keys.contains("ErrorDetails") {
                    var tmp : [DescribeProjectComponentsResponseBody.Data.ReverseStoreList.ErrorDetails] = []
                    for v in dict["ErrorDetails"] as! [Any] {
                        var model = DescribeProjectComponentsResponseBody.Data.ReverseStoreList.ErrorDetails()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.errorDetails = tmp
                }
                if dict.keys.contains("Gmt") {
                    self.gmt = dict["Gmt"] as! Int64
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Ip") {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("LatelyHeartbeatTimeSec") {
                    self.latelyHeartbeatTimeSec = dict["LatelyHeartbeatTimeSec"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StorePort") {
                    self.storePort = dict["StorePort"] as! Int32
                }
                if dict.keys.contains("Subtopic") {
                    self.subtopic = dict["Subtopic"] as! String
                }
                if dict.keys.contains("ToSwitch") {
                    self.toSwitch = dict["ToSwitch"] as! Bool
                }
                if dict.keys.contains("Topic") {
                    self.topic = dict["Topic"] as! String
                }
                if dict.keys.contains("Tps") {
                    self.tps = dict["Tps"] as! Int64
                }
            }
        }
        public class StoreList : Tea.TeaModel {
            public class ErrorDetails : Tea.TeaModel {
                public var code: String?

                public var extraContext: [String: Any]?

                public var level: String?

                public var message: String?

                public var messageMcmsContext: [String: String]?

                public var messageMcmsKey: String?

                public var proposal: String?

                public var proposalMcmsContext: [String: String]?

                public var proposalMcmsKey: String?

                public var reason: String?

                public var reasonMcmsContext: [String: String]?

                public var reasonMcmsKey: String?

                public var upstreamErrorDetail: Any?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.extraContext != nil {
                        map["ExtraContext"] = self.extraContext!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.message != nil {
                        map["Message"] = self.message!
                    }
                    if self.messageMcmsContext != nil {
                        map["MessageMcmsContext"] = self.messageMcmsContext!
                    }
                    if self.messageMcmsKey != nil {
                        map["MessageMcmsKey"] = self.messageMcmsKey!
                    }
                    if self.proposal != nil {
                        map["Proposal"] = self.proposal!
                    }
                    if self.proposalMcmsContext != nil {
                        map["ProposalMcmsContext"] = self.proposalMcmsContext!
                    }
                    if self.proposalMcmsKey != nil {
                        map["ProposalMcmsKey"] = self.proposalMcmsKey!
                    }
                    if self.reason != nil {
                        map["Reason"] = self.reason!
                    }
                    if self.reasonMcmsContext != nil {
                        map["ReasonMcmsContext"] = self.reasonMcmsContext!
                    }
                    if self.reasonMcmsKey != nil {
                        map["ReasonMcmsKey"] = self.reasonMcmsKey!
                    }
                    if self.upstreamErrorDetail != nil {
                        map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Code") {
                        self.code = dict["Code"] as! String
                    }
                    if dict.keys.contains("ExtraContext") {
                        self.extraContext = dict["ExtraContext"] as! [String: Any]
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("Message") {
                        self.message = dict["Message"] as! String
                    }
                    if dict.keys.contains("MessageMcmsContext") {
                        self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
                    }
                    if dict.keys.contains("MessageMcmsKey") {
                        self.messageMcmsKey = dict["MessageMcmsKey"] as! String
                    }
                    if dict.keys.contains("Proposal") {
                        self.proposal = dict["Proposal"] as! String
                    }
                    if dict.keys.contains("ProposalMcmsContext") {
                        self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
                    }
                    if dict.keys.contains("ProposalMcmsKey") {
                        self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
                    }
                    if dict.keys.contains("Reason") {
                        self.reason = dict["Reason"] as! String
                    }
                    if dict.keys.contains("ReasonMcmsContext") {
                        self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
                    }
                    if dict.keys.contains("ReasonMcmsKey") {
                        self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
                    }
                    if dict.keys.contains("UpstreamErrorDetail") {
                        self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
                    }
                }
            }
            public var beginCheckpoint: String?

            public var conn: Int64?

            public var delay: Int64?

            public var endCheckpoint: String?

            public var errMsg: String?

            public var errorDetails: [DescribeProjectComponentsResponseBody.Data.StoreList.ErrorDetails]?

            public var gmt: Int64?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var ip: String?

            public var latelyHeartbeatTimeSec: Int64?

            public var name: String?

            public var port: Int32?

            public var region: String?

            public var status: String?

            public var storePort: Int32?

            public var subtopic: String?

            public var toSwitch: Bool?

            public var topic: String?

            public var tps: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.beginCheckpoint != nil {
                    map["BeginCheckpoint"] = self.beginCheckpoint!
                }
                if self.conn != nil {
                    map["Conn"] = self.conn!
                }
                if self.delay != nil {
                    map["Delay"] = self.delay!
                }
                if self.endCheckpoint != nil {
                    map["EndCheckpoint"] = self.endCheckpoint!
                }
                if self.errMsg != nil {
                    map["ErrMsg"] = self.errMsg!
                }
                if self.errorDetails != nil {
                    var tmp : [Any] = []
                    for k in self.errorDetails! {
                        tmp.append(k.toMap())
                    }
                    map["ErrorDetails"] = tmp
                }
                if self.gmt != nil {
                    map["Gmt"] = self.gmt!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.latelyHeartbeatTimeSec != nil {
                    map["LatelyHeartbeatTimeSec"] = self.latelyHeartbeatTimeSec!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.storePort != nil {
                    map["StorePort"] = self.storePort!
                }
                if self.subtopic != nil {
                    map["Subtopic"] = self.subtopic!
                }
                if self.toSwitch != nil {
                    map["ToSwitch"] = self.toSwitch!
                }
                if self.topic != nil {
                    map["Topic"] = self.topic!
                }
                if self.tps != nil {
                    map["Tps"] = self.tps!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BeginCheckpoint") {
                    self.beginCheckpoint = dict["BeginCheckpoint"] as! String
                }
                if dict.keys.contains("Conn") {
                    self.conn = dict["Conn"] as! Int64
                }
                if dict.keys.contains("Delay") {
                    self.delay = dict["Delay"] as! Int64
                }
                if dict.keys.contains("EndCheckpoint") {
                    self.endCheckpoint = dict["EndCheckpoint"] as! String
                }
                if dict.keys.contains("ErrMsg") {
                    self.errMsg = dict["ErrMsg"] as! String
                }
                if dict.keys.contains("ErrorDetails") {
                    var tmp : [DescribeProjectComponentsResponseBody.Data.StoreList.ErrorDetails] = []
                    for v in dict["ErrorDetails"] as! [Any] {
                        var model = DescribeProjectComponentsResponseBody.Data.StoreList.ErrorDetails()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.errorDetails = tmp
                }
                if dict.keys.contains("Gmt") {
                    self.gmt = dict["Gmt"] as! Int64
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Ip") {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("LatelyHeartbeatTimeSec") {
                    self.latelyHeartbeatTimeSec = dict["LatelyHeartbeatTimeSec"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StorePort") {
                    self.storePort = dict["StorePort"] as! Int32
                }
                if dict.keys.contains("Subtopic") {
                    self.subtopic = dict["Subtopic"] as! String
                }
                if dict.keys.contains("ToSwitch") {
                    self.toSwitch = dict["ToSwitch"] as! Bool
                }
                if dict.keys.contains("Topic") {
                    self.topic = dict["Topic"] as! String
                }
                if dict.keys.contains("Tps") {
                    self.tps = dict["Tps"] as! Int64
                }
            }
        }
        public var fullImportComponents: [DescribeProjectComponentsResponseBody.Data.FullImportComponents]?

        public var fullVerifyComponents: [DescribeProjectComponentsResponseBody.Data.FullVerifyComponents]?

        public var incrSyncComponents: [DescribeProjectComponentsResponseBody.Data.IncrSyncComponents]?

        public var reverseIncrSyncComponents: [DescribeProjectComponentsResponseBody.Data.ReverseIncrSyncComponents]?

        public var reverseStoreList: [DescribeProjectComponentsResponseBody.Data.ReverseStoreList]?

        public var storeList: [DescribeProjectComponentsResponseBody.Data.StoreList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fullImportComponents != nil {
                var tmp : [Any] = []
                for k in self.fullImportComponents! {
                    tmp.append(k.toMap())
                }
                map["FullImportComponents"] = tmp
            }
            if self.fullVerifyComponents != nil {
                var tmp : [Any] = []
                for k in self.fullVerifyComponents! {
                    tmp.append(k.toMap())
                }
                map["FullVerifyComponents"] = tmp
            }
            if self.incrSyncComponents != nil {
                var tmp : [Any] = []
                for k in self.incrSyncComponents! {
                    tmp.append(k.toMap())
                }
                map["IncrSyncComponents"] = tmp
            }
            if self.reverseIncrSyncComponents != nil {
                var tmp : [Any] = []
                for k in self.reverseIncrSyncComponents! {
                    tmp.append(k.toMap())
                }
                map["ReverseIncrSyncComponents"] = tmp
            }
            if self.reverseStoreList != nil {
                var tmp : [Any] = []
                for k in self.reverseStoreList! {
                    tmp.append(k.toMap())
                }
                map["ReverseStoreList"] = tmp
            }
            if self.storeList != nil {
                var tmp : [Any] = []
                for k in self.storeList! {
                    tmp.append(k.toMap())
                }
                map["StoreList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FullImportComponents") {
                var tmp : [DescribeProjectComponentsResponseBody.Data.FullImportComponents] = []
                for v in dict["FullImportComponents"] as! [Any] {
                    var model = DescribeProjectComponentsResponseBody.Data.FullImportComponents()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fullImportComponents = tmp
            }
            if dict.keys.contains("FullVerifyComponents") {
                var tmp : [DescribeProjectComponentsResponseBody.Data.FullVerifyComponents] = []
                for v in dict["FullVerifyComponents"] as! [Any] {
                    var model = DescribeProjectComponentsResponseBody.Data.FullVerifyComponents()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fullVerifyComponents = tmp
            }
            if dict.keys.contains("IncrSyncComponents") {
                var tmp : [DescribeProjectComponentsResponseBody.Data.IncrSyncComponents] = []
                for v in dict["IncrSyncComponents"] as! [Any] {
                    var model = DescribeProjectComponentsResponseBody.Data.IncrSyncComponents()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.incrSyncComponents = tmp
            }
            if dict.keys.contains("ReverseIncrSyncComponents") {
                var tmp : [DescribeProjectComponentsResponseBody.Data.ReverseIncrSyncComponents] = []
                for v in dict["ReverseIncrSyncComponents"] as! [Any] {
                    var model = DescribeProjectComponentsResponseBody.Data.ReverseIncrSyncComponents()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.reverseIncrSyncComponents = tmp
            }
            if dict.keys.contains("ReverseStoreList") {
                var tmp : [DescribeProjectComponentsResponseBody.Data.ReverseStoreList] = []
                for v in dict["ReverseStoreList"] as! [Any] {
                    var model = DescribeProjectComponentsResponseBody.Data.ReverseStoreList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.reverseStoreList = tmp
            }
            if dict.keys.contains("StoreList") {
                var tmp : [DescribeProjectComponentsResponseBody.Data.StoreList] = []
                for v in dict["StoreList"] as! [Any] {
                    var model = DescribeProjectComponentsResponseBody.Data.StoreList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.storeList = tmp
            }
        }
    }
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: DescribeProjectComponentsResponseBody.Data?

    public var errorDetail: DescribeProjectComponentsResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeProjectComponentsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorDetail") {
            var model = DescribeProjectComponentsResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeProjectComponentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeProjectComponentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeProjectComponentsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeProjectProgressRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class DescribeProjectProgressResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var alarmLevel: String?

        public var currentStep: String?

        public var enableFullTransfer: Bool?

        public var enableIncrSync: Bool?

        public var enableReverseIncrTransfer: Bool?

        public var enableStructTransfer: Bool?

        public var fullTransferProgress: Int32?

        public var incrSyncCheckpoint: Int64?

        public var projectId: String?

        public var reverseIncrTransferCheckpoint: Int64?

        public var status: String?

        public var structTransferProgress: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarmLevel != nil {
                map["AlarmLevel"] = self.alarmLevel!
            }
            if self.currentStep != nil {
                map["CurrentStep"] = self.currentStep!
            }
            if self.enableFullTransfer != nil {
                map["EnableFullTransfer"] = self.enableFullTransfer!
            }
            if self.enableIncrSync != nil {
                map["EnableIncrSync"] = self.enableIncrSync!
            }
            if self.enableReverseIncrTransfer != nil {
                map["EnableReverseIncrTransfer"] = self.enableReverseIncrTransfer!
            }
            if self.enableStructTransfer != nil {
                map["EnableStructTransfer"] = self.enableStructTransfer!
            }
            if self.fullTransferProgress != nil {
                map["FullTransferProgress"] = self.fullTransferProgress!
            }
            if self.incrSyncCheckpoint != nil {
                map["IncrSyncCheckpoint"] = self.incrSyncCheckpoint!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.reverseIncrTransferCheckpoint != nil {
                map["ReverseIncrTransferCheckpoint"] = self.reverseIncrTransferCheckpoint!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.structTransferProgress != nil {
                map["StructTransferProgress"] = self.structTransferProgress!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlarmLevel") {
                self.alarmLevel = dict["AlarmLevel"] as! String
            }
            if dict.keys.contains("CurrentStep") {
                self.currentStep = dict["CurrentStep"] as! String
            }
            if dict.keys.contains("EnableFullTransfer") {
                self.enableFullTransfer = dict["EnableFullTransfer"] as! Bool
            }
            if dict.keys.contains("EnableIncrSync") {
                self.enableIncrSync = dict["EnableIncrSync"] as! Bool
            }
            if dict.keys.contains("EnableReverseIncrTransfer") {
                self.enableReverseIncrTransfer = dict["EnableReverseIncrTransfer"] as! Bool
            }
            if dict.keys.contains("EnableStructTransfer") {
                self.enableStructTransfer = dict["EnableStructTransfer"] as! Bool
            }
            if dict.keys.contains("FullTransferProgress") {
                self.fullTransferProgress = dict["FullTransferProgress"] as! Int32
            }
            if dict.keys.contains("IncrSyncCheckpoint") {
                self.incrSyncCheckpoint = dict["IncrSyncCheckpoint"] as! Int64
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("ReverseIncrTransferCheckpoint") {
                self.reverseIncrTransferCheckpoint = dict["ReverseIncrTransferCheckpoint"] as! Int64
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StructTransferProgress") {
                self.structTransferProgress = dict["StructTransferProgress"] as! Int32
            }
        }
    }
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: DescribeProjectProgressResponseBody.Data?

    public var errorDetail: DescribeProjectProgressResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeProjectProgressResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorDetail") {
            var model = DescribeProjectProgressResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeProjectProgressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeProjectProgressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeProjectProgressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeProjectStepMetricRequest : Tea.TeaModel {
    public var aggregator: String?

    public var beginTimestamp: Int64?

    public var endTimestamp: Int64?

    public var maxPointNum: Int32?

    public var metricType: String?

    public var projectId: String?

    public var stepName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregator != nil {
            map["Aggregator"] = self.aggregator!
        }
        if self.beginTimestamp != nil {
            map["BeginTimestamp"] = self.beginTimestamp!
        }
        if self.endTimestamp != nil {
            map["EndTimestamp"] = self.endTimestamp!
        }
        if self.maxPointNum != nil {
            map["MaxPointNum"] = self.maxPointNum!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.stepName != nil {
            map["StepName"] = self.stepName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Aggregator") {
            self.aggregator = dict["Aggregator"] as! String
        }
        if dict.keys.contains("BeginTimestamp") {
            self.beginTimestamp = dict["BeginTimestamp"] as! Int64
        }
        if dict.keys.contains("EndTimestamp") {
            self.endTimestamp = dict["EndTimestamp"] as! Int64
        }
        if dict.keys.contains("MaxPointNum") {
            self.maxPointNum = dict["MaxPointNum"] as! Int32
        }
        if dict.keys.contains("MetricType") {
            self.metricType = dict["MetricType"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("StepName") {
            self.stepName = dict["StepName"] as! String
        }
    }
}

public class DescribeProjectStepMetricResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Metrics : Tea.TeaModel {
            public class DataPoints : Tea.TeaModel {
                public var timestamp: Int64?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public var dataPoints: [DescribeProjectStepMetricResponseBody.Data.Metrics.DataPoints]?

            public var name: String?

            public var tags: [String: String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataPoints != nil {
                    var tmp : [Any] = []
                    for k in self.dataPoints! {
                        tmp.append(k.toMap())
                    }
                    map["DataPoints"] = tmp
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataPoints") {
                    var tmp : [DescribeProjectStepMetricResponseBody.Data.Metrics.DataPoints] = []
                    for v in dict["DataPoints"] as! [Any] {
                        var model = DescribeProjectStepMetricResponseBody.Data.Metrics.DataPoints()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.dataPoints = tmp
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Tags") {
                    self.tags = dict["Tags"] as! [String: String]
                }
            }
        }
        public var aggregator: String?

        public var metrics: [DescribeProjectStepMetricResponseBody.Data.Metrics]?

        public var referenceValue: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aggregator != nil {
                map["Aggregator"] = self.aggregator!
            }
            if self.metrics != nil {
                var tmp : [Any] = []
                for k in self.metrics! {
                    tmp.append(k.toMap())
                }
                map["Metrics"] = tmp
            }
            if self.referenceValue != nil {
                map["ReferenceValue"] = self.referenceValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Aggregator") {
                self.aggregator = dict["Aggregator"] as! String
            }
            if dict.keys.contains("Metrics") {
                var tmp : [DescribeProjectStepMetricResponseBody.Data.Metrics] = []
                for v in dict["Metrics"] as! [Any] {
                    var model = DescribeProjectStepMetricResponseBody.Data.Metrics()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.metrics = tmp
            }
            if dict.keys.contains("ReferenceValue") {
                self.referenceValue = dict["ReferenceValue"] as! Int64
            }
        }
    }
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: DescribeProjectStepMetricResponseBody.Data?

    public var errorDetail: DescribeProjectStepMetricResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeProjectStepMetricResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorDetail") {
            var model = DescribeProjectStepMetricResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeProjectStepMetricResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeProjectStepMetricResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeProjectStepMetricResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeProjectStepsRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class DescribeProjectStepsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ExtraInfo : Tea.TeaModel {
            public class ErrorDetails : Tea.TeaModel {
                public var code: String?

                public var extraContext: [String: Any]?

                public var level: String?

                public var message: String?

                public var messageMcmsContext: [String: String]?

                public var messageMcmsKey: String?

                public var proposal: String?

                public var proposalMcmsContext: [String: String]?

                public var proposalMcmsKey: String?

                public var reason: String?

                public var reasonMcmsContext: [String: String]?

                public var reasonMcmsKey: String?

                public var upstreamErrorDetail: Any?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.extraContext != nil {
                        map["ExtraContext"] = self.extraContext!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.message != nil {
                        map["Message"] = self.message!
                    }
                    if self.messageMcmsContext != nil {
                        map["MessageMcmsContext"] = self.messageMcmsContext!
                    }
                    if self.messageMcmsKey != nil {
                        map["MessageMcmsKey"] = self.messageMcmsKey!
                    }
                    if self.proposal != nil {
                        map["Proposal"] = self.proposal!
                    }
                    if self.proposalMcmsContext != nil {
                        map["ProposalMcmsContext"] = self.proposalMcmsContext!
                    }
                    if self.proposalMcmsKey != nil {
                        map["ProposalMcmsKey"] = self.proposalMcmsKey!
                    }
                    if self.reason != nil {
                        map["Reason"] = self.reason!
                    }
                    if self.reasonMcmsContext != nil {
                        map["ReasonMcmsContext"] = self.reasonMcmsContext!
                    }
                    if self.reasonMcmsKey != nil {
                        map["ReasonMcmsKey"] = self.reasonMcmsKey!
                    }
                    if self.upstreamErrorDetail != nil {
                        map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Code") {
                        self.code = dict["Code"] as! String
                    }
                    if dict.keys.contains("ExtraContext") {
                        self.extraContext = dict["ExtraContext"] as! [String: Any]
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("Message") {
                        self.message = dict["Message"] as! String
                    }
                    if dict.keys.contains("MessageMcmsContext") {
                        self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
                    }
                    if dict.keys.contains("MessageMcmsKey") {
                        self.messageMcmsKey = dict["MessageMcmsKey"] as! String
                    }
                    if dict.keys.contains("Proposal") {
                        self.proposal = dict["Proposal"] as! String
                    }
                    if dict.keys.contains("ProposalMcmsContext") {
                        self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
                    }
                    if dict.keys.contains("ProposalMcmsKey") {
                        self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
                    }
                    if dict.keys.contains("Reason") {
                        self.reason = dict["Reason"] as! String
                    }
                    if dict.keys.contains("ReasonMcmsContext") {
                        self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
                    }
                    if dict.keys.contains("ReasonMcmsKey") {
                        self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
                    }
                    if dict.keys.contains("UpstreamErrorDetail") {
                        self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
                    }
                }
            }
            public var errorCode: String?

            public var errorDetails: [DescribeProjectStepsResponseBody.Data.ExtraInfo.ErrorDetails]?

            public var errorMsg: String?

            public var errorParam: [String: String]?

            public var failedTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorDetails != nil {
                    var tmp : [Any] = []
                    for k in self.errorDetails! {
                        tmp.append(k.toMap())
                    }
                    map["ErrorDetails"] = tmp
                }
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.errorParam != nil {
                    map["ErrorParam"] = self.errorParam!
                }
                if self.failedTime != nil {
                    map["FailedTime"] = self.failedTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorCode") {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ErrorDetails") {
                    var tmp : [DescribeProjectStepsResponseBody.Data.ExtraInfo.ErrorDetails] = []
                    for v in dict["ErrorDetails"] as! [Any] {
                        var model = DescribeProjectStepsResponseBody.Data.ExtraInfo.ErrorDetails()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.errorDetails = tmp
                }
                if dict.keys.contains("ErrorMsg") {
                    self.errorMsg = dict["ErrorMsg"] as! String
                }
                if dict.keys.contains("ErrorParam") {
                    self.errorParam = dict["ErrorParam"] as! [String: String]
                }
                if dict.keys.contains("FailedTime") {
                    self.failedTime = dict["FailedTime"] as! String
                }
            }
        }
        public var description_: String?

        public var extraInfo: DescribeProjectStepsResponseBody.Data.ExtraInfo?

        public var finishTime: String?

        public var name: String?

        public var order: Int32?

        public var progress: Int32?

        public var startTime: String?

        public var status: String?

        public var stepInfo: [String: Any]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.extraInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.extraInfo != nil {
                map["ExtraInfo"] = self.extraInfo?.toMap()
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.order != nil {
                map["Order"] = self.order!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.stepInfo != nil {
                map["StepInfo"] = self.stepInfo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ExtraInfo") {
                var model = DescribeProjectStepsResponseBody.Data.ExtraInfo()
                model.fromMap(dict["ExtraInfo"] as! [String: Any])
                self.extraInfo = model
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Order") {
                self.order = dict["Order"] as! Int32
            }
            if dict.keys.contains("Progress") {
                self.progress = dict["Progress"] as! Int32
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StepInfo") {
                self.stepInfo = dict["StepInfo"] as! [String: Any]
            }
        }
    }
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: [DescribeProjectStepsResponseBody.Data]?

    public var errorDetail: DescribeProjectStepsResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [DescribeProjectStepsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeProjectStepsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorDetail") {
            var model = DescribeProjectStepsResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeProjectStepsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeProjectStepsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeProjectStepsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRecommendIndexRequest : Tea.TeaModel {
    public var instanceId: String?

    public var SQLId: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.SQLId != nil {
            map["SQLId"] = self.SQLId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SQLId") {
            self.SQLId = dict["SQLId"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DescribeRecommendIndexResponseBody : Tea.TeaModel {
    public class RecommendIndex : Tea.TeaModel {
        public var suggestIndex: String?

        public var tableList: String?

        public var tenantMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.suggestIndex != nil {
                map["SuggestIndex"] = self.suggestIndex!
            }
            if self.tableList != nil {
                map["TableList"] = self.tableList!
            }
            if self.tenantMode != nil {
                map["TenantMode"] = self.tenantMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SuggestIndex") {
                self.suggestIndex = dict["SuggestIndex"] as! String
            }
            if dict.keys.contains("TableList") {
                self.tableList = dict["TableList"] as! String
            }
            if dict.keys.contains("TenantMode") {
                self.tenantMode = dict["TenantMode"] as! String
            }
        }
    }
    public var recommendIndex: DescribeRecommendIndexResponseBody.RecommendIndex?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recommendIndex?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recommendIndex != nil {
            map["RecommendIndex"] = self.recommendIndex?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecommendIndex") {
            var model = DescribeRecommendIndexResponseBody.RecommendIndex()
            model.fromMap(dict["RecommendIndex"] as! [String: Any])
            self.recommendIndex = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeRecommendIndexResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRecommendIndexResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRecommendIndexResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSQLDetailsRequest : Tea.TeaModel {
    public var SQLId: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.SQLId != nil {
            map["SQLId"] = self.SQLId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SQLId") {
            self.SQLId = dict["SQLId"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DescribeSQLDetailsResponseBody : Tea.TeaModel {
    public class SQLDetails : Tea.TeaModel {
        public var dbName: String?

        public var SQLText: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dbName != nil {
                map["DbName"] = self.dbName!
            }
            if self.SQLText != nil {
                map["SQLText"] = self.SQLText!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DbName") {
                self.dbName = dict["DbName"] as! String
            }
            if dict.keys.contains("SQLText") {
                self.SQLText = dict["SQLText"] as! String
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public var requestId: String?

    public var SQLDetails: [DescribeSQLDetailsResponseBody.SQLDetails]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.SQLDetails != nil {
            var tmp : [Any] = []
            for k in self.SQLDetails! {
                tmp.append(k.toMap())
            }
            map["SQLDetails"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SQLDetails") {
            var tmp : [DescribeSQLDetailsResponseBody.SQLDetails] = []
            for v in dict["SQLDetails"] as! [Any] {
                var model = DescribeSQLDetailsResponseBody.SQLDetails()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.SQLDetails = tmp
        }
    }
}

public class DescribeSQLDetailsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSQLDetailsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSQLDetailsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSQLHistoryListRequest : Tea.TeaModel {
    public var endTime: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var SQLId: String?

    public var startTime: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.SQLId != nil {
            map["SQLId"] = self.SQLId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SQLId") {
            self.SQLId = dict["SQLId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DescribeSQLHistoryListResponseBody : Tea.TeaModel {
    public class SQLHistoryList : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var affectedRows: Int64?

            public var appWaitTime: Double?

            public var blockCacheHit: Int64?

            public var blockIndexCacheHit: Int64?

            public var bloomFilterCacheHit: Int64?

            public var clientIp: String?

            public var concurrencyWaitTime: Double?

            public var cpuTime: Double?

            public var dbName: String?

            public var decodeTime: Double?

            public var diskRead: Int64?

            public var elapsedTime: Double?

            public var endTime: Int64?

            public var endTimeUTCString: String?

            public var event: String?

            public var execPerSecond: Int64?

            public var executeTime: Double?

            public var executions: Int64?

            public var failTimes: Int64?

            public var getPlanTime: Double?

            public var IOWaitTime: Double?

            public var logicalRead: Int64?

            public var maxCpuTime: Double?

            public var maxElapsedTime: Double?

            public var memstoreReadRowCount: Int64?

            public var missPlans: Int64?

            public var netWaitTime: Double?

            public var nodeIp: String?

            public var queueTime: Double?

            public var RPCCount: Int64?

            public var remotePlans: Int64?

            public var retryCount: Int64?

            public var returnRows: Int64?

            public var rowCacheHit: Int64?

            public var scheduleTime: Double?

            public var ssstoreReadRowCount: Int64?

            public var totalWaitTime: Double?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.affectedRows != nil {
                    map["AffectedRows"] = self.affectedRows!
                }
                if self.appWaitTime != nil {
                    map["AppWaitTime"] = self.appWaitTime!
                }
                if self.blockCacheHit != nil {
                    map["BlockCacheHit"] = self.blockCacheHit!
                }
                if self.blockIndexCacheHit != nil {
                    map["BlockIndexCacheHit"] = self.blockIndexCacheHit!
                }
                if self.bloomFilterCacheHit != nil {
                    map["BloomFilterCacheHit"] = self.bloomFilterCacheHit!
                }
                if self.clientIp != nil {
                    map["ClientIp"] = self.clientIp!
                }
                if self.concurrencyWaitTime != nil {
                    map["ConcurrencyWaitTime"] = self.concurrencyWaitTime!
                }
                if self.cpuTime != nil {
                    map["CpuTime"] = self.cpuTime!
                }
                if self.dbName != nil {
                    map["DbName"] = self.dbName!
                }
                if self.decodeTime != nil {
                    map["DecodeTime"] = self.decodeTime!
                }
                if self.diskRead != nil {
                    map["DiskRead"] = self.diskRead!
                }
                if self.elapsedTime != nil {
                    map["ElapsedTime"] = self.elapsedTime!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.endTimeUTCString != nil {
                    map["EndTimeUTCString"] = self.endTimeUTCString!
                }
                if self.event != nil {
                    map["Event"] = self.event!
                }
                if self.execPerSecond != nil {
                    map["ExecPerSecond"] = self.execPerSecond!
                }
                if self.executeTime != nil {
                    map["ExecuteTime"] = self.executeTime!
                }
                if self.executions != nil {
                    map["Executions"] = self.executions!
                }
                if self.failTimes != nil {
                    map["FailTimes"] = self.failTimes!
                }
                if self.getPlanTime != nil {
                    map["GetPlanTime"] = self.getPlanTime!
                }
                if self.IOWaitTime != nil {
                    map["IOWaitTime"] = self.IOWaitTime!
                }
                if self.logicalRead != nil {
                    map["LogicalRead"] = self.logicalRead!
                }
                if self.maxCpuTime != nil {
                    map["MaxCpuTime"] = self.maxCpuTime!
                }
                if self.maxElapsedTime != nil {
                    map["MaxElapsedTime"] = self.maxElapsedTime!
                }
                if self.memstoreReadRowCount != nil {
                    map["MemstoreReadRowCount"] = self.memstoreReadRowCount!
                }
                if self.missPlans != nil {
                    map["MissPlans"] = self.missPlans!
                }
                if self.netWaitTime != nil {
                    map["NetWaitTime"] = self.netWaitTime!
                }
                if self.nodeIp != nil {
                    map["NodeIp"] = self.nodeIp!
                }
                if self.queueTime != nil {
                    map["QueueTime"] = self.queueTime!
                }
                if self.RPCCount != nil {
                    map["RPCCount"] = self.RPCCount!
                }
                if self.remotePlans != nil {
                    map["RemotePlans"] = self.remotePlans!
                }
                if self.retryCount != nil {
                    map["RetryCount"] = self.retryCount!
                }
                if self.returnRows != nil {
                    map["ReturnRows"] = self.returnRows!
                }
                if self.rowCacheHit != nil {
                    map["RowCacheHit"] = self.rowCacheHit!
                }
                if self.scheduleTime != nil {
                    map["ScheduleTime"] = self.scheduleTime!
                }
                if self.ssstoreReadRowCount != nil {
                    map["SsstoreReadRowCount"] = self.ssstoreReadRowCount!
                }
                if self.totalWaitTime != nil {
                    map["TotalWaitTime"] = self.totalWaitTime!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AffectedRows") {
                    self.affectedRows = dict["AffectedRows"] as! Int64
                }
                if dict.keys.contains("AppWaitTime") {
                    self.appWaitTime = dict["AppWaitTime"] as! Double
                }
                if dict.keys.contains("BlockCacheHit") {
                    self.blockCacheHit = dict["BlockCacheHit"] as! Int64
                }
                if dict.keys.contains("BlockIndexCacheHit") {
                    self.blockIndexCacheHit = dict["BlockIndexCacheHit"] as! Int64
                }
                if dict.keys.contains("BloomFilterCacheHit") {
                    self.bloomFilterCacheHit = dict["BloomFilterCacheHit"] as! Int64
                }
                if dict.keys.contains("ClientIp") {
                    self.clientIp = dict["ClientIp"] as! String
                }
                if dict.keys.contains("ConcurrencyWaitTime") {
                    self.concurrencyWaitTime = dict["ConcurrencyWaitTime"] as! Double
                }
                if dict.keys.contains("CpuTime") {
                    self.cpuTime = dict["CpuTime"] as! Double
                }
                if dict.keys.contains("DbName") {
                    self.dbName = dict["DbName"] as! String
                }
                if dict.keys.contains("DecodeTime") {
                    self.decodeTime = dict["DecodeTime"] as! Double
                }
                if dict.keys.contains("DiskRead") {
                    self.diskRead = dict["DiskRead"] as! Int64
                }
                if dict.keys.contains("ElapsedTime") {
                    self.elapsedTime = dict["ElapsedTime"] as! Double
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("EndTimeUTCString") {
                    self.endTimeUTCString = dict["EndTimeUTCString"] as! String
                }
                if dict.keys.contains("Event") {
                    self.event = dict["Event"] as! String
                }
                if dict.keys.contains("ExecPerSecond") {
                    self.execPerSecond = dict["ExecPerSecond"] as! Int64
                }
                if dict.keys.contains("ExecuteTime") {
                    self.executeTime = dict["ExecuteTime"] as! Double
                }
                if dict.keys.contains("Executions") {
                    self.executions = dict["Executions"] as! Int64
                }
                if dict.keys.contains("FailTimes") {
                    self.failTimes = dict["FailTimes"] as! Int64
                }
                if dict.keys.contains("GetPlanTime") {
                    self.getPlanTime = dict["GetPlanTime"] as! Double
                }
                if dict.keys.contains("IOWaitTime") {
                    self.IOWaitTime = dict["IOWaitTime"] as! Double
                }
                if dict.keys.contains("LogicalRead") {
                    self.logicalRead = dict["LogicalRead"] as! Int64
                }
                if dict.keys.contains("MaxCpuTime") {
                    self.maxCpuTime = dict["MaxCpuTime"] as! Double
                }
                if dict.keys.contains("MaxElapsedTime") {
                    self.maxElapsedTime = dict["MaxElapsedTime"] as! Double
                }
                if dict.keys.contains("MemstoreReadRowCount") {
                    self.memstoreReadRowCount = dict["MemstoreReadRowCount"] as! Int64
                }
                if dict.keys.contains("MissPlans") {
                    self.missPlans = dict["MissPlans"] as! Int64
                }
                if dict.keys.contains("NetWaitTime") {
                    self.netWaitTime = dict["NetWaitTime"] as! Double
                }
                if dict.keys.contains("NodeIp") {
                    self.nodeIp = dict["NodeIp"] as! String
                }
                if dict.keys.contains("QueueTime") {
                    self.queueTime = dict["QueueTime"] as! Double
                }
                if dict.keys.contains("RPCCount") {
                    self.RPCCount = dict["RPCCount"] as! Int64
                }
                if dict.keys.contains("RemotePlans") {
                    self.remotePlans = dict["RemotePlans"] as! Int64
                }
                if dict.keys.contains("RetryCount") {
                    self.retryCount = dict["RetryCount"] as! Int64
                }
                if dict.keys.contains("ReturnRows") {
                    self.returnRows = dict["ReturnRows"] as! Int64
                }
                if dict.keys.contains("RowCacheHit") {
                    self.rowCacheHit = dict["RowCacheHit"] as! Int64
                }
                if dict.keys.contains("ScheduleTime") {
                    self.scheduleTime = dict["ScheduleTime"] as! Double
                }
                if dict.keys.contains("SsstoreReadRowCount") {
                    self.ssstoreReadRowCount = dict["SsstoreReadRowCount"] as! Int64
                }
                if dict.keys.contains("TotalWaitTime") {
                    self.totalWaitTime = dict["TotalWaitTime"] as! Double
                }
                if dict.keys.contains("UserName") {
                    self.userName = dict["UserName"] as! String
                }
            }
        }
        public var count: Int64?

        public var list: [DescribeSQLHistoryListResponseBody.SQLHistoryList.List]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") {
                self.count = dict["Count"] as! Int64
            }
            if dict.keys.contains("List") {
                var tmp : [DescribeSQLHistoryListResponseBody.SQLHistoryList.List] = []
                for v in dict["List"] as! [Any] {
                    var model = DescribeSQLHistoryListResponseBody.SQLHistoryList.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
        }
    }
    public var requestId: String?

    public var SQLHistoryList: DescribeSQLHistoryListResponseBody.SQLHistoryList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.SQLHistoryList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.SQLHistoryList != nil {
            map["SQLHistoryList"] = self.SQLHistoryList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SQLHistoryList") {
            var model = DescribeSQLHistoryListResponseBody.SQLHistoryList()
            model.fromMap(dict["SQLHistoryList"] as! [String: Any])
            self.SQLHistoryList = model
        }
    }
}

public class DescribeSQLHistoryListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSQLHistoryListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSQLHistoryListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSQLPlansRequest : Tea.TeaModel {
    public var SQLId: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.SQLId != nil {
            map["SQLId"] = self.SQLId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SQLId") {
            self.SQLId = dict["SQLId"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DescribeSQLPlansResponseBody : Tea.TeaModel {
    public class SQLPlans : Tea.TeaModel {
        public var avgExecutionMS: Double?

        public var avgExecutionTimeMS: Int64?

        public var firstLoadTime: Int64?

        public var firstLoadTimeUTCString: String?

        public var hitCount: Int32?

        public var mergedVersion: Int32?

        public var nodeIp: String?

        public var outlineData: String?

        public var outlineId: Int64?

        public var outlineTime: Int64?

        public var outlineTimeUTCString: String?

        public var planFull: String?

        public var planId: Int32?

        public var planInfo: String?

        public var planUnionHash: String?

        public var querySQL: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avgExecutionMS != nil {
                map["AvgExecutionMS"] = self.avgExecutionMS!
            }
            if self.avgExecutionTimeMS != nil {
                map["AvgExecutionTimeMS"] = self.avgExecutionTimeMS!
            }
            if self.firstLoadTime != nil {
                map["FirstLoadTime"] = self.firstLoadTime!
            }
            if self.firstLoadTimeUTCString != nil {
                map["FirstLoadTimeUTCString"] = self.firstLoadTimeUTCString!
            }
            if self.hitCount != nil {
                map["HitCount"] = self.hitCount!
            }
            if self.mergedVersion != nil {
                map["MergedVersion"] = self.mergedVersion!
            }
            if self.nodeIp != nil {
                map["NodeIp"] = self.nodeIp!
            }
            if self.outlineData != nil {
                map["OutlineData"] = self.outlineData!
            }
            if self.outlineId != nil {
                map["OutlineId"] = self.outlineId!
            }
            if self.outlineTime != nil {
                map["OutlineTime"] = self.outlineTime!
            }
            if self.outlineTimeUTCString != nil {
                map["OutlineTimeUTCString"] = self.outlineTimeUTCString!
            }
            if self.planFull != nil {
                map["PlanFull"] = self.planFull!
            }
            if self.planId != nil {
                map["PlanId"] = self.planId!
            }
            if self.planInfo != nil {
                map["PlanInfo"] = self.planInfo!
            }
            if self.planUnionHash != nil {
                map["PlanUnionHash"] = self.planUnionHash!
            }
            if self.querySQL != nil {
                map["QuerySQL"] = self.querySQL!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvgExecutionMS") {
                self.avgExecutionMS = dict["AvgExecutionMS"] as! Double
            }
            if dict.keys.contains("AvgExecutionTimeMS") {
                self.avgExecutionTimeMS = dict["AvgExecutionTimeMS"] as! Int64
            }
            if dict.keys.contains("FirstLoadTime") {
                self.firstLoadTime = dict["FirstLoadTime"] as! Int64
            }
            if dict.keys.contains("FirstLoadTimeUTCString") {
                self.firstLoadTimeUTCString = dict["FirstLoadTimeUTCString"] as! String
            }
            if dict.keys.contains("HitCount") {
                self.hitCount = dict["HitCount"] as! Int32
            }
            if dict.keys.contains("MergedVersion") {
                self.mergedVersion = dict["MergedVersion"] as! Int32
            }
            if dict.keys.contains("NodeIp") {
                self.nodeIp = dict["NodeIp"] as! String
            }
            if dict.keys.contains("OutlineData") {
                self.outlineData = dict["OutlineData"] as! String
            }
            if dict.keys.contains("OutlineId") {
                self.outlineId = dict["OutlineId"] as! Int64
            }
            if dict.keys.contains("OutlineTime") {
                self.outlineTime = dict["OutlineTime"] as! Int64
            }
            if dict.keys.contains("OutlineTimeUTCString") {
                self.outlineTimeUTCString = dict["OutlineTimeUTCString"] as! String
            }
            if dict.keys.contains("PlanFull") {
                self.planFull = dict["PlanFull"] as! String
            }
            if dict.keys.contains("PlanId") {
                self.planId = dict["PlanId"] as! Int32
            }
            if dict.keys.contains("PlanInfo") {
                self.planInfo = dict["PlanInfo"] as! String
            }
            if dict.keys.contains("PlanUnionHash") {
                self.planUnionHash = dict["PlanUnionHash"] as! String
            }
            if dict.keys.contains("QuerySQL") {
                self.querySQL = dict["QuerySQL"] as! String
            }
        }
    }
    public var requestId: String?

    public var SQLPlans: [DescribeSQLPlansResponseBody.SQLPlans]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.SQLPlans != nil {
            var tmp : [Any] = []
            for k in self.SQLPlans! {
                tmp.append(k.toMap())
            }
            map["SQLPlans"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SQLPlans") {
            var tmp : [DescribeSQLPlansResponseBody.SQLPlans] = []
            for v in dict["SQLPlans"] as! [Any] {
                var model = DescribeSQLPlansResponseBody.SQLPlans()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.SQLPlans = tmp
        }
    }
}

public class DescribeSQLPlansResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSQLPlansResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSQLPlansResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSQLSamplesRequest : Tea.TeaModel {
    public var dbName: String?

    public var endTime: String?

    public var instanceId: String?

    public var returnSqlText: Bool?

    public var sqlId: String?

    public var startTime: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.returnSqlText != nil {
            map["ReturnSqlText"] = self.returnSqlText!
        }
        if self.sqlId != nil {
            map["SqlId"] = self.sqlId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ReturnSqlText") {
            self.returnSqlText = dict["ReturnSqlText"] as! Bool
        }
        if dict.keys.contains("SqlId") {
            self.sqlId = dict["SqlId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DescribeSQLSamplesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var affectedRows: Double?

        public var applicationWaitTime: Double?

        public var blockCacheHit: Double?

        public var blockIndexCacheHit: Double?

        public var bloomFilterCacheHit: Double?

        public var clientIp: String?

        public var clientPort: String?

        public var concurrencyWaitTime: Double?

        public var consistencyLevel: String?

        public var cpuTime: Double?

        public var dbName: String?

        public var decodeTime: Double?

        public var diskReads: Double?

        public var elapsedTime: Double?

        public var executeTime: Double?

        public var executorRpc: Bool?

        public var expectedWorkerCount: Double?

        public var fullSqlText: String?

        public var getPlanTime: Double?

        public var hitPlan: Bool?

        public var inner: Bool?

        public var memstoreReadRows: Double?

        public var netTime: Double?

        public var netWaitTime: Double?

        public var obDbId: Double?

        public var obServerId: Double?

        public var obUserId: Double?

        public var partitionCount: Double?

        public var planId: Double?

        public var planType: String?

        public var queueTime: Double?

        public var requestId: String?

        public var requestTime: String?

        public var retCode: Double?

        public var retryCount: Double?

        public var returnRows: Double?

        public var rowCacheHit: Double?

        public var rpcCount: Double?

        public var scheduleTime: Double?

        public var server: String?

        public var sqlText: String?

        public var sqlType: String?

        public var ssstoreReadRows: Double?

        public var statement: String?

        public var tableScan: Bool?

        public var traceId: String?

        public var transHash: String?

        public var usedWorkerCount: Double?

        public var userIoWaitTime: Double?

        public var userName: String?

        public var waitCount: Double?

        public var waitEvent: String?

        public var waitTime: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.affectedRows != nil {
                map["AffectedRows"] = self.affectedRows!
            }
            if self.applicationWaitTime != nil {
                map["ApplicationWaitTime"] = self.applicationWaitTime!
            }
            if self.blockCacheHit != nil {
                map["BlockCacheHit"] = self.blockCacheHit!
            }
            if self.blockIndexCacheHit != nil {
                map["BlockIndexCacheHit"] = self.blockIndexCacheHit!
            }
            if self.bloomFilterCacheHit != nil {
                map["BloomFilterCacheHit"] = self.bloomFilterCacheHit!
            }
            if self.clientIp != nil {
                map["ClientIp"] = self.clientIp!
            }
            if self.clientPort != nil {
                map["ClientPort"] = self.clientPort!
            }
            if self.concurrencyWaitTime != nil {
                map["ConcurrencyWaitTime"] = self.concurrencyWaitTime!
            }
            if self.consistencyLevel != nil {
                map["ConsistencyLevel"] = self.consistencyLevel!
            }
            if self.cpuTime != nil {
                map["CpuTime"] = self.cpuTime!
            }
            if self.dbName != nil {
                map["DbName"] = self.dbName!
            }
            if self.decodeTime != nil {
                map["DecodeTime"] = self.decodeTime!
            }
            if self.diskReads != nil {
                map["DiskReads"] = self.diskReads!
            }
            if self.elapsedTime != nil {
                map["ElapsedTime"] = self.elapsedTime!
            }
            if self.executeTime != nil {
                map["ExecuteTime"] = self.executeTime!
            }
            if self.executorRpc != nil {
                map["ExecutorRpc"] = self.executorRpc!
            }
            if self.expectedWorkerCount != nil {
                map["ExpectedWorkerCount"] = self.expectedWorkerCount!
            }
            if self.fullSqlText != nil {
                map["FullSqlText"] = self.fullSqlText!
            }
            if self.getPlanTime != nil {
                map["GetPlanTime"] = self.getPlanTime!
            }
            if self.hitPlan != nil {
                map["HitPlan"] = self.hitPlan!
            }
            if self.inner != nil {
                map["Inner"] = self.inner!
            }
            if self.memstoreReadRows != nil {
                map["MemstoreReadRows"] = self.memstoreReadRows!
            }
            if self.netTime != nil {
                map["NetTime"] = self.netTime!
            }
            if self.netWaitTime != nil {
                map["NetWaitTime"] = self.netWaitTime!
            }
            if self.obDbId != nil {
                map["ObDbId"] = self.obDbId!
            }
            if self.obServerId != nil {
                map["ObServerId"] = self.obServerId!
            }
            if self.obUserId != nil {
                map["ObUserId"] = self.obUserId!
            }
            if self.partitionCount != nil {
                map["PartitionCount"] = self.partitionCount!
            }
            if self.planId != nil {
                map["PlanId"] = self.planId!
            }
            if self.planType != nil {
                map["PlanType"] = self.planType!
            }
            if self.queueTime != nil {
                map["QueueTime"] = self.queueTime!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.requestTime != nil {
                map["RequestTime"] = self.requestTime!
            }
            if self.retCode != nil {
                map["RetCode"] = self.retCode!
            }
            if self.retryCount != nil {
                map["RetryCount"] = self.retryCount!
            }
            if self.returnRows != nil {
                map["ReturnRows"] = self.returnRows!
            }
            if self.rowCacheHit != nil {
                map["RowCacheHit"] = self.rowCacheHit!
            }
            if self.rpcCount != nil {
                map["RpcCount"] = self.rpcCount!
            }
            if self.scheduleTime != nil {
                map["ScheduleTime"] = self.scheduleTime!
            }
            if self.server != nil {
                map["Server"] = self.server!
            }
            if self.sqlText != nil {
                map["SqlText"] = self.sqlText!
            }
            if self.sqlType != nil {
                map["SqlType"] = self.sqlType!
            }
            if self.ssstoreReadRows != nil {
                map["SsstoreReadRows"] = self.ssstoreReadRows!
            }
            if self.statement != nil {
                map["Statement"] = self.statement!
            }
            if self.tableScan != nil {
                map["TableScan"] = self.tableScan!
            }
            if self.traceId != nil {
                map["TraceId"] = self.traceId!
            }
            if self.transHash != nil {
                map["TransHash"] = self.transHash!
            }
            if self.usedWorkerCount != nil {
                map["UsedWorkerCount"] = self.usedWorkerCount!
            }
            if self.userIoWaitTime != nil {
                map["UserIoWaitTime"] = self.userIoWaitTime!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            if self.waitCount != nil {
                map["WaitCount"] = self.waitCount!
            }
            if self.waitEvent != nil {
                map["WaitEvent"] = self.waitEvent!
            }
            if self.waitTime != nil {
                map["WaitTime"] = self.waitTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AffectedRows") {
                self.affectedRows = dict["AffectedRows"] as! Double
            }
            if dict.keys.contains("ApplicationWaitTime") {
                self.applicationWaitTime = dict["ApplicationWaitTime"] as! Double
            }
            if dict.keys.contains("BlockCacheHit") {
                self.blockCacheHit = dict["BlockCacheHit"] as! Double
            }
            if dict.keys.contains("BlockIndexCacheHit") {
                self.blockIndexCacheHit = dict["BlockIndexCacheHit"] as! Double
            }
            if dict.keys.contains("BloomFilterCacheHit") {
                self.bloomFilterCacheHit = dict["BloomFilterCacheHit"] as! Double
            }
            if dict.keys.contains("ClientIp") {
                self.clientIp = dict["ClientIp"] as! String
            }
            if dict.keys.contains("ClientPort") {
                self.clientPort = dict["ClientPort"] as! String
            }
            if dict.keys.contains("ConcurrencyWaitTime") {
                self.concurrencyWaitTime = dict["ConcurrencyWaitTime"] as! Double
            }
            if dict.keys.contains("ConsistencyLevel") {
                self.consistencyLevel = dict["ConsistencyLevel"] as! String
            }
            if dict.keys.contains("CpuTime") {
                self.cpuTime = dict["CpuTime"] as! Double
            }
            if dict.keys.contains("DbName") {
                self.dbName = dict["DbName"] as! String
            }
            if dict.keys.contains("DecodeTime") {
                self.decodeTime = dict["DecodeTime"] as! Double
            }
            if dict.keys.contains("DiskReads") {
                self.diskReads = dict["DiskReads"] as! Double
            }
            if dict.keys.contains("ElapsedTime") {
                self.elapsedTime = dict["ElapsedTime"] as! Double
            }
            if dict.keys.contains("ExecuteTime") {
                self.executeTime = dict["ExecuteTime"] as! Double
            }
            if dict.keys.contains("ExecutorRpc") {
                self.executorRpc = dict["ExecutorRpc"] as! Bool
            }
            if dict.keys.contains("ExpectedWorkerCount") {
                self.expectedWorkerCount = dict["ExpectedWorkerCount"] as! Double
            }
            if dict.keys.contains("FullSqlText") {
                self.fullSqlText = dict["FullSqlText"] as! String
            }
            if dict.keys.contains("GetPlanTime") {
                self.getPlanTime = dict["GetPlanTime"] as! Double
            }
            if dict.keys.contains("HitPlan") {
                self.hitPlan = dict["HitPlan"] as! Bool
            }
            if dict.keys.contains("Inner") {
                self.inner = dict["Inner"] as! Bool
            }
            if dict.keys.contains("MemstoreReadRows") {
                self.memstoreReadRows = dict["MemstoreReadRows"] as! Double
            }
            if dict.keys.contains("NetTime") {
                self.netTime = dict["NetTime"] as! Double
            }
            if dict.keys.contains("NetWaitTime") {
                self.netWaitTime = dict["NetWaitTime"] as! Double
            }
            if dict.keys.contains("ObDbId") {
                self.obDbId = dict["ObDbId"] as! Double
            }
            if dict.keys.contains("ObServerId") {
                self.obServerId = dict["ObServerId"] as! Double
            }
            if dict.keys.contains("ObUserId") {
                self.obUserId = dict["ObUserId"] as! Double
            }
            if dict.keys.contains("PartitionCount") {
                self.partitionCount = dict["PartitionCount"] as! Double
            }
            if dict.keys.contains("PlanId") {
                self.planId = dict["PlanId"] as! Double
            }
            if dict.keys.contains("PlanType") {
                self.planType = dict["PlanType"] as! String
            }
            if dict.keys.contains("QueueTime") {
                self.queueTime = dict["QueueTime"] as! Double
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("RequestTime") {
                self.requestTime = dict["RequestTime"] as! String
            }
            if dict.keys.contains("RetCode") {
                self.retCode = dict["RetCode"] as! Double
            }
            if dict.keys.contains("RetryCount") {
                self.retryCount = dict["RetryCount"] as! Double
            }
            if dict.keys.contains("ReturnRows") {
                self.returnRows = dict["ReturnRows"] as! Double
            }
            if dict.keys.contains("RowCacheHit") {
                self.rowCacheHit = dict["RowCacheHit"] as! Double
            }
            if dict.keys.contains("RpcCount") {
                self.rpcCount = dict["RpcCount"] as! Double
            }
            if dict.keys.contains("ScheduleTime") {
                self.scheduleTime = dict["ScheduleTime"] as! Double
            }
            if dict.keys.contains("Server") {
                self.server = dict["Server"] as! String
            }
            if dict.keys.contains("SqlText") {
                self.sqlText = dict["SqlText"] as! String
            }
            if dict.keys.contains("SqlType") {
                self.sqlType = dict["SqlType"] as! String
            }
            if dict.keys.contains("SsstoreReadRows") {
                self.ssstoreReadRows = dict["SsstoreReadRows"] as! Double
            }
            if dict.keys.contains("Statement") {
                self.statement = dict["Statement"] as! String
            }
            if dict.keys.contains("TableScan") {
                self.tableScan = dict["TableScan"] as! Bool
            }
            if dict.keys.contains("TraceId") {
                self.traceId = dict["TraceId"] as! String
            }
            if dict.keys.contains("TransHash") {
                self.transHash = dict["TransHash"] as! String
            }
            if dict.keys.contains("UsedWorkerCount") {
                self.usedWorkerCount = dict["UsedWorkerCount"] as! Double
            }
            if dict.keys.contains("UserIoWaitTime") {
                self.userIoWaitTime = dict["UserIoWaitTime"] as! Double
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
            if dict.keys.contains("WaitCount") {
                self.waitCount = dict["WaitCount"] as! Double
            }
            if dict.keys.contains("WaitEvent") {
                self.waitEvent = dict["WaitEvent"] as! String
            }
            if dict.keys.contains("WaitTime") {
                self.waitTime = dict["WaitTime"] as! Double
            }
        }
    }
    public var data: [DescribeSQLSamplesResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [DescribeSQLSamplesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeSQLSamplesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeSQLSamplesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSQLSamplesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSQLSamplesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSampleSqlRawTextsRequest : Tea.TeaModel {
    public var dbName: String?

    public var endTime: String?

    public var instanceId: String?

    public var limit: String?

    public var sqlId: String?

    public var startTime: String?

    public var tenantId: String?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.sqlId != nil {
            map["SqlId"] = self.sqlId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Limit") {
            self.limit = dict["Limit"] as! String
        }
        if dict.keys.contains("SqlId") {
            self.sqlId = dict["SqlId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribeSampleSqlRawTextsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var sqlText: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sqlText != nil {
                map["SqlText"] = self.sqlText!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SqlText") {
                self.sqlText = dict["SqlText"] as! [String]
            }
        }
    }
    public var data: DescribeSampleSqlRawTextsResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DescribeSampleSqlRawTextsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeSampleSqlRawTextsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSampleSqlRawTextsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSampleSqlRawTextsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSecurityIpGroupsRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DescribeSecurityIpGroupsResponseBody : Tea.TeaModel {
    public class SecurityIpGroups : Tea.TeaModel {
        public var securityIpGroupName: String?

        public var securityIps: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.securityIpGroupName != nil {
                map["SecurityIpGroupName"] = self.securityIpGroupName!
            }
            if self.securityIps != nil {
                map["SecurityIps"] = self.securityIps!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SecurityIpGroupName") {
                self.securityIpGroupName = dict["SecurityIpGroupName"] as! String
            }
            if dict.keys.contains("SecurityIps") {
                self.securityIps = dict["SecurityIps"] as! String
            }
        }
    }
    public var requestId: String?

    public var securityIpGroups: [DescribeSecurityIpGroupsResponseBody.SecurityIpGroups]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityIpGroups != nil {
            var tmp : [Any] = []
            for k in self.securityIpGroups! {
                tmp.append(k.toMap())
            }
            map["SecurityIpGroups"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityIpGroups") {
            var tmp : [DescribeSecurityIpGroupsResponseBody.SecurityIpGroups] = []
            for v in dict["SecurityIpGroups"] as! [Any] {
                var model = DescribeSecurityIpGroupsResponseBody.SecurityIpGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.securityIpGroups = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeSecurityIpGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSecurityIpGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSecurityIpGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSlowSQLHistoryListRequest : Tea.TeaModel {
    public var endTime: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var SQLId: String?

    public var startTime: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.SQLId != nil {
            map["SQLId"] = self.SQLId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SQLId") {
            self.SQLId = dict["SQLId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DescribeSlowSQLHistoryListResponseBody : Tea.TeaModel {
    public class SlowSQLHistoryList : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var affectedRows: Double?

            public var appWaitTime: Double?

            public var blockCacheHit: Double?

            public var blockIndexCacheHit: Double?

            public var bloomFilterCacheHit: Double?

            public var clientIp: String?

            public var concurrencyWaitTime: Double?

            public var cpuTime: Double?

            public var dbName: String?

            public var decodeTime: Double?

            public var diskRead: Double?

            public var elapsedTime: Double?

            public var endTimeUTCString: String?

            public var event: String?

            public var execPerSecond: Double?

            public var executeTime: Double?

            public var executions: Double?

            public var failTimes: Double?

            public var getPlanTime: Double?

            public var IOWaitTime: Double?

            public var logicalRead: Double?

            public var maxCpuTime: Double?

            public var maxElapsedTime: Double?

            public var memstoreReadRowCount: Double?

            public var missPlans: Double?

            public var netWaitTime: Double?

            public var nodeIp: String?

            public var queueTime: Double?

            public var RPCCount: Double?

            public var remotePlans: Double?

            public var retryCount: Double?

            public var returnRows: Double?

            public var rowCacheHit: Double?

            public var scheduleTime: Double?

            public var sqlId: String?

            public var sqlType: String?

            public var ssstoreReadRowCount: Double?

            public var tenantName: String?

            public var totalWaitTime: Double?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.affectedRows != nil {
                    map["AffectedRows"] = self.affectedRows!
                }
                if self.appWaitTime != nil {
                    map["AppWaitTime"] = self.appWaitTime!
                }
                if self.blockCacheHit != nil {
                    map["BlockCacheHit"] = self.blockCacheHit!
                }
                if self.blockIndexCacheHit != nil {
                    map["BlockIndexCacheHit"] = self.blockIndexCacheHit!
                }
                if self.bloomFilterCacheHit != nil {
                    map["BloomFilterCacheHit"] = self.bloomFilterCacheHit!
                }
                if self.clientIp != nil {
                    map["ClientIp"] = self.clientIp!
                }
                if self.concurrencyWaitTime != nil {
                    map["ConcurrencyWaitTime"] = self.concurrencyWaitTime!
                }
                if self.cpuTime != nil {
                    map["CpuTime"] = self.cpuTime!
                }
                if self.dbName != nil {
                    map["DbName"] = self.dbName!
                }
                if self.decodeTime != nil {
                    map["DecodeTime"] = self.decodeTime!
                }
                if self.diskRead != nil {
                    map["DiskRead"] = self.diskRead!
                }
                if self.elapsedTime != nil {
                    map["ElapsedTime"] = self.elapsedTime!
                }
                if self.endTimeUTCString != nil {
                    map["EndTimeUTCString"] = self.endTimeUTCString!
                }
                if self.event != nil {
                    map["Event"] = self.event!
                }
                if self.execPerSecond != nil {
                    map["ExecPerSecond"] = self.execPerSecond!
                }
                if self.executeTime != nil {
                    map["ExecuteTime"] = self.executeTime!
                }
                if self.executions != nil {
                    map["Executions"] = self.executions!
                }
                if self.failTimes != nil {
                    map["FailTimes"] = self.failTimes!
                }
                if self.getPlanTime != nil {
                    map["GetPlanTime"] = self.getPlanTime!
                }
                if self.IOWaitTime != nil {
                    map["IOWaitTime"] = self.IOWaitTime!
                }
                if self.logicalRead != nil {
                    map["LogicalRead"] = self.logicalRead!
                }
                if self.maxCpuTime != nil {
                    map["MaxCpuTime"] = self.maxCpuTime!
                }
                if self.maxElapsedTime != nil {
                    map["MaxElapsedTime"] = self.maxElapsedTime!
                }
                if self.memstoreReadRowCount != nil {
                    map["MemstoreReadRowCount"] = self.memstoreReadRowCount!
                }
                if self.missPlans != nil {
                    map["MissPlans"] = self.missPlans!
                }
                if self.netWaitTime != nil {
                    map["NetWaitTime"] = self.netWaitTime!
                }
                if self.nodeIp != nil {
                    map["NodeIp"] = self.nodeIp!
                }
                if self.queueTime != nil {
                    map["QueueTime"] = self.queueTime!
                }
                if self.RPCCount != nil {
                    map["RPCCount"] = self.RPCCount!
                }
                if self.remotePlans != nil {
                    map["RemotePlans"] = self.remotePlans!
                }
                if self.retryCount != nil {
                    map["RetryCount"] = self.retryCount!
                }
                if self.returnRows != nil {
                    map["ReturnRows"] = self.returnRows!
                }
                if self.rowCacheHit != nil {
                    map["RowCacheHit"] = self.rowCacheHit!
                }
                if self.scheduleTime != nil {
                    map["ScheduleTime"] = self.scheduleTime!
                }
                if self.sqlId != nil {
                    map["SqlId"] = self.sqlId!
                }
                if self.sqlType != nil {
                    map["SqlType"] = self.sqlType!
                }
                if self.ssstoreReadRowCount != nil {
                    map["SsstoreReadRowCount"] = self.ssstoreReadRowCount!
                }
                if self.tenantName != nil {
                    map["TenantName"] = self.tenantName!
                }
                if self.totalWaitTime != nil {
                    map["TotalWaitTime"] = self.totalWaitTime!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AffectedRows") {
                    self.affectedRows = dict["AffectedRows"] as! Double
                }
                if dict.keys.contains("AppWaitTime") {
                    self.appWaitTime = dict["AppWaitTime"] as! Double
                }
                if dict.keys.contains("BlockCacheHit") {
                    self.blockCacheHit = dict["BlockCacheHit"] as! Double
                }
                if dict.keys.contains("BlockIndexCacheHit") {
                    self.blockIndexCacheHit = dict["BlockIndexCacheHit"] as! Double
                }
                if dict.keys.contains("BloomFilterCacheHit") {
                    self.bloomFilterCacheHit = dict["BloomFilterCacheHit"] as! Double
                }
                if dict.keys.contains("ClientIp") {
                    self.clientIp = dict["ClientIp"] as! String
                }
                if dict.keys.contains("ConcurrencyWaitTime") {
                    self.concurrencyWaitTime = dict["ConcurrencyWaitTime"] as! Double
                }
                if dict.keys.contains("CpuTime") {
                    self.cpuTime = dict["CpuTime"] as! Double
                }
                if dict.keys.contains("DbName") {
                    self.dbName = dict["DbName"] as! String
                }
                if dict.keys.contains("DecodeTime") {
                    self.decodeTime = dict["DecodeTime"] as! Double
                }
                if dict.keys.contains("DiskRead") {
                    self.diskRead = dict["DiskRead"] as! Double
                }
                if dict.keys.contains("ElapsedTime") {
                    self.elapsedTime = dict["ElapsedTime"] as! Double
                }
                if dict.keys.contains("EndTimeUTCString") {
                    self.endTimeUTCString = dict["EndTimeUTCString"] as! String
                }
                if dict.keys.contains("Event") {
                    self.event = dict["Event"] as! String
                }
                if dict.keys.contains("ExecPerSecond") {
                    self.execPerSecond = dict["ExecPerSecond"] as! Double
                }
                if dict.keys.contains("ExecuteTime") {
                    self.executeTime = dict["ExecuteTime"] as! Double
                }
                if dict.keys.contains("Executions") {
                    self.executions = dict["Executions"] as! Double
                }
                if dict.keys.contains("FailTimes") {
                    self.failTimes = dict["FailTimes"] as! Double
                }
                if dict.keys.contains("GetPlanTime") {
                    self.getPlanTime = dict["GetPlanTime"] as! Double
                }
                if dict.keys.contains("IOWaitTime") {
                    self.IOWaitTime = dict["IOWaitTime"] as! Double
                }
                if dict.keys.contains("LogicalRead") {
                    self.logicalRead = dict["LogicalRead"] as! Double
                }
                if dict.keys.contains("MaxCpuTime") {
                    self.maxCpuTime = dict["MaxCpuTime"] as! Double
                }
                if dict.keys.contains("MaxElapsedTime") {
                    self.maxElapsedTime = dict["MaxElapsedTime"] as! Double
                }
                if dict.keys.contains("MemstoreReadRowCount") {
                    self.memstoreReadRowCount = dict["MemstoreReadRowCount"] as! Double
                }
                if dict.keys.contains("MissPlans") {
                    self.missPlans = dict["MissPlans"] as! Double
                }
                if dict.keys.contains("NetWaitTime") {
                    self.netWaitTime = dict["NetWaitTime"] as! Double
                }
                if dict.keys.contains("NodeIp") {
                    self.nodeIp = dict["NodeIp"] as! String
                }
                if dict.keys.contains("QueueTime") {
                    self.queueTime = dict["QueueTime"] as! Double
                }
                if dict.keys.contains("RPCCount") {
                    self.RPCCount = dict["RPCCount"] as! Double
                }
                if dict.keys.contains("RemotePlans") {
                    self.remotePlans = dict["RemotePlans"] as! Double
                }
                if dict.keys.contains("RetryCount") {
                    self.retryCount = dict["RetryCount"] as! Double
                }
                if dict.keys.contains("ReturnRows") {
                    self.returnRows = dict["ReturnRows"] as! Double
                }
                if dict.keys.contains("RowCacheHit") {
                    self.rowCacheHit = dict["RowCacheHit"] as! Double
                }
                if dict.keys.contains("ScheduleTime") {
                    self.scheduleTime = dict["ScheduleTime"] as! Double
                }
                if dict.keys.contains("SqlId") {
                    self.sqlId = dict["SqlId"] as! String
                }
                if dict.keys.contains("SqlType") {
                    self.sqlType = dict["SqlType"] as! String
                }
                if dict.keys.contains("SsstoreReadRowCount") {
                    self.ssstoreReadRowCount = dict["SsstoreReadRowCount"] as! Double
                }
                if dict.keys.contains("TenantName") {
                    self.tenantName = dict["TenantName"] as! String
                }
                if dict.keys.contains("TotalWaitTime") {
                    self.totalWaitTime = dict["TotalWaitTime"] as! Double
                }
                if dict.keys.contains("UserName") {
                    self.userName = dict["UserName"] as! String
                }
            }
        }
        public var count: Int64?

        public var list: [DescribeSlowSQLHistoryListResponseBody.SlowSQLHistoryList.List]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") {
                self.count = dict["Count"] as! Int64
            }
            if dict.keys.contains("List") {
                var tmp : [DescribeSlowSQLHistoryListResponseBody.SlowSQLHistoryList.List] = []
                for v in dict["List"] as! [Any] {
                    var model = DescribeSlowSQLHistoryListResponseBody.SlowSQLHistoryList.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
        }
    }
    public var requestId: String?

    public var slowSQLHistoryList: DescribeSlowSQLHistoryListResponseBody.SlowSQLHistoryList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.slowSQLHistoryList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.slowSQLHistoryList != nil {
            map["SlowSQLHistoryList"] = self.slowSQLHistoryList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SlowSQLHistoryList") {
            var model = DescribeSlowSQLHistoryListResponseBody.SlowSQLHistoryList()
            model.fromMap(dict["SlowSQLHistoryList"] as! [String: Any])
            self.slowSQLHistoryList = model
        }
    }
}

public class DescribeSlowSQLHistoryListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSlowSQLHistoryListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSlowSQLHistoryListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSlowSQLListRequest : Tea.TeaModel {
    public var dbName: String?

    public var endTime: String?

    public var filterCondition: [String: Any]?

    public var nodeIp: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var SQLId: String?

    public var searchKeyWord: String?

    public var searchParameter: String?

    public var searchRule: String?

    public var searchValue: String?

    public var sortColumn: String?

    public var sortOrder: String?

    public var startTime: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.filterCondition != nil {
            map["FilterCondition"] = self.filterCondition!
        }
        if self.nodeIp != nil {
            map["NodeIp"] = self.nodeIp!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.SQLId != nil {
            map["SQLId"] = self.SQLId!
        }
        if self.searchKeyWord != nil {
            map["SearchKeyWord"] = self.searchKeyWord!
        }
        if self.searchParameter != nil {
            map["SearchParameter"] = self.searchParameter!
        }
        if self.searchRule != nil {
            map["SearchRule"] = self.searchRule!
        }
        if self.searchValue != nil {
            map["SearchValue"] = self.searchValue!
        }
        if self.sortColumn != nil {
            map["SortColumn"] = self.sortColumn!
        }
        if self.sortOrder != nil {
            map["SortOrder"] = self.sortOrder!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("FilterCondition") {
            self.filterCondition = dict["FilterCondition"] as! [String: Any]
        }
        if dict.keys.contains("NodeIp") {
            self.nodeIp = dict["NodeIp"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SQLId") {
            self.SQLId = dict["SQLId"] as! String
        }
        if dict.keys.contains("SearchKeyWord") {
            self.searchKeyWord = dict["SearchKeyWord"] as! String
        }
        if dict.keys.contains("SearchParameter") {
            self.searchParameter = dict["SearchParameter"] as! String
        }
        if dict.keys.contains("SearchRule") {
            self.searchRule = dict["SearchRule"] as! String
        }
        if dict.keys.contains("SearchValue") {
            self.searchValue = dict["SearchValue"] as! String
        }
        if dict.keys.contains("SortColumn") {
            self.sortColumn = dict["SortColumn"] as! String
        }
        if dict.keys.contains("SortOrder") {
            self.sortOrder = dict["SortOrder"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DescribeSlowSQLListShrinkRequest : Tea.TeaModel {
    public var dbName: String?

    public var endTime: String?

    public var filterConditionShrink: String?

    public var nodeIp: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var SQLId: String?

    public var searchKeyWord: String?

    public var searchParameter: String?

    public var searchRule: String?

    public var searchValue: String?

    public var sortColumn: String?

    public var sortOrder: String?

    public var startTime: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.filterConditionShrink != nil {
            map["FilterCondition"] = self.filterConditionShrink!
        }
        if self.nodeIp != nil {
            map["NodeIp"] = self.nodeIp!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.SQLId != nil {
            map["SQLId"] = self.SQLId!
        }
        if self.searchKeyWord != nil {
            map["SearchKeyWord"] = self.searchKeyWord!
        }
        if self.searchParameter != nil {
            map["SearchParameter"] = self.searchParameter!
        }
        if self.searchRule != nil {
            map["SearchRule"] = self.searchRule!
        }
        if self.searchValue != nil {
            map["SearchValue"] = self.searchValue!
        }
        if self.sortColumn != nil {
            map["SortColumn"] = self.sortColumn!
        }
        if self.sortOrder != nil {
            map["SortOrder"] = self.sortOrder!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("FilterCondition") {
            self.filterConditionShrink = dict["FilterCondition"] as! String
        }
        if dict.keys.contains("NodeIp") {
            self.nodeIp = dict["NodeIp"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SQLId") {
            self.SQLId = dict["SQLId"] as! String
        }
        if dict.keys.contains("SearchKeyWord") {
            self.searchKeyWord = dict["SearchKeyWord"] as! String
        }
        if dict.keys.contains("SearchParameter") {
            self.searchParameter = dict["SearchParameter"] as! String
        }
        if dict.keys.contains("SearchRule") {
            self.searchRule = dict["SearchRule"] as! String
        }
        if dict.keys.contains("SearchValue") {
            self.searchValue = dict["SearchValue"] as! String
        }
        if dict.keys.contains("SortColumn") {
            self.sortColumn = dict["SortColumn"] as! String
        }
        if dict.keys.contains("SortOrder") {
            self.sortOrder = dict["SortOrder"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DescribeSlowSQLListResponseBody : Tea.TeaModel {
    public class SlowSQLList : Tea.TeaModel {
        public var affectedRows: Int64?

        public var appWaitTime: Double?

        public var blockCacheHit: Int64?

        public var blockIndexCacheHit: Int64?

        public var bloomFilterCacheHit: Int64?

        public var clientIp: String?

        public var concurrencyWaitTime: Double?

        public var cpuTime: Double?

        public var dbName: String?

        public var decodeTime: Double?

        public var diskRead: Int64?

        public var elapsedTime: Double?

        public var event: String?

        public var execPerSecond: Double?

        public var executeTime: Double?

        public var executions: Int64?

        public var failTimes: Int64?

        public var getPlanTime: Double?

        public var IOWaitTime: Double?

        public var key: Int64?

        public var logicalRead: Int64?

        public var maxCpuTime: Double?

        public var maxElapsedTime: Double?

        public var memstoreReadRowCount: Int64?

        public var missPlans: Int64?

        public var netWaitTime: Double?

        public var nodeIp: String?

        public var queueTime: Double?

        public var RPCCount: Int64?

        public var remotePlans: Int64?

        public var retryCount: Int64?

        public var returnRows: Int64?

        public var rowCacheHit: Int64?

        public var SQLId: String?

        public var SQLText: String?

        public var SQLType: Int64?

        public var scheduleTime: Double?

        public var ssstoreReadRowCount: Int64?

        public var totalWaitTime: Double?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.affectedRows != nil {
                map["AffectedRows"] = self.affectedRows!
            }
            if self.appWaitTime != nil {
                map["AppWaitTime"] = self.appWaitTime!
            }
            if self.blockCacheHit != nil {
                map["BlockCacheHit"] = self.blockCacheHit!
            }
            if self.blockIndexCacheHit != nil {
                map["BlockIndexCacheHit"] = self.blockIndexCacheHit!
            }
            if self.bloomFilterCacheHit != nil {
                map["BloomFilterCacheHit"] = self.bloomFilterCacheHit!
            }
            if self.clientIp != nil {
                map["ClientIp"] = self.clientIp!
            }
            if self.concurrencyWaitTime != nil {
                map["ConcurrencyWaitTime"] = self.concurrencyWaitTime!
            }
            if self.cpuTime != nil {
                map["CpuTime"] = self.cpuTime!
            }
            if self.dbName != nil {
                map["DbName"] = self.dbName!
            }
            if self.decodeTime != nil {
                map["DecodeTime"] = self.decodeTime!
            }
            if self.diskRead != nil {
                map["DiskRead"] = self.diskRead!
            }
            if self.elapsedTime != nil {
                map["ElapsedTime"] = self.elapsedTime!
            }
            if self.event != nil {
                map["Event"] = self.event!
            }
            if self.execPerSecond != nil {
                map["ExecPerSecond"] = self.execPerSecond!
            }
            if self.executeTime != nil {
                map["ExecuteTime"] = self.executeTime!
            }
            if self.executions != nil {
                map["Executions"] = self.executions!
            }
            if self.failTimes != nil {
                map["FailTimes"] = self.failTimes!
            }
            if self.getPlanTime != nil {
                map["GetPlanTime"] = self.getPlanTime!
            }
            if self.IOWaitTime != nil {
                map["IOWaitTime"] = self.IOWaitTime!
            }
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.logicalRead != nil {
                map["LogicalRead"] = self.logicalRead!
            }
            if self.maxCpuTime != nil {
                map["MaxCpuTime"] = self.maxCpuTime!
            }
            if self.maxElapsedTime != nil {
                map["MaxElapsedTime"] = self.maxElapsedTime!
            }
            if self.memstoreReadRowCount != nil {
                map["MemstoreReadRowCount"] = self.memstoreReadRowCount!
            }
            if self.missPlans != nil {
                map["MissPlans"] = self.missPlans!
            }
            if self.netWaitTime != nil {
                map["NetWaitTime"] = self.netWaitTime!
            }
            if self.nodeIp != nil {
                map["NodeIp"] = self.nodeIp!
            }
            if self.queueTime != nil {
                map["QueueTime"] = self.queueTime!
            }
            if self.RPCCount != nil {
                map["RPCCount"] = self.RPCCount!
            }
            if self.remotePlans != nil {
                map["RemotePlans"] = self.remotePlans!
            }
            if self.retryCount != nil {
                map["RetryCount"] = self.retryCount!
            }
            if self.returnRows != nil {
                map["ReturnRows"] = self.returnRows!
            }
            if self.rowCacheHit != nil {
                map["RowCacheHit"] = self.rowCacheHit!
            }
            if self.SQLId != nil {
                map["SQLId"] = self.SQLId!
            }
            if self.SQLText != nil {
                map["SQLText"] = self.SQLText!
            }
            if self.SQLType != nil {
                map["SQLType"] = self.SQLType!
            }
            if self.scheduleTime != nil {
                map["ScheduleTime"] = self.scheduleTime!
            }
            if self.ssstoreReadRowCount != nil {
                map["SsstoreReadRowCount"] = self.ssstoreReadRowCount!
            }
            if self.totalWaitTime != nil {
                map["TotalWaitTime"] = self.totalWaitTime!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AffectedRows") {
                self.affectedRows = dict["AffectedRows"] as! Int64
            }
            if dict.keys.contains("AppWaitTime") {
                self.appWaitTime = dict["AppWaitTime"] as! Double
            }
            if dict.keys.contains("BlockCacheHit") {
                self.blockCacheHit = dict["BlockCacheHit"] as! Int64
            }
            if dict.keys.contains("BlockIndexCacheHit") {
                self.blockIndexCacheHit = dict["BlockIndexCacheHit"] as! Int64
            }
            if dict.keys.contains("BloomFilterCacheHit") {
                self.bloomFilterCacheHit = dict["BloomFilterCacheHit"] as! Int64
            }
            if dict.keys.contains("ClientIp") {
                self.clientIp = dict["ClientIp"] as! String
            }
            if dict.keys.contains("ConcurrencyWaitTime") {
                self.concurrencyWaitTime = dict["ConcurrencyWaitTime"] as! Double
            }
            if dict.keys.contains("CpuTime") {
                self.cpuTime = dict["CpuTime"] as! Double
            }
            if dict.keys.contains("DbName") {
                self.dbName = dict["DbName"] as! String
            }
            if dict.keys.contains("DecodeTime") {
                self.decodeTime = dict["DecodeTime"] as! Double
            }
            if dict.keys.contains("DiskRead") {
                self.diskRead = dict["DiskRead"] as! Int64
            }
            if dict.keys.contains("ElapsedTime") {
                self.elapsedTime = dict["ElapsedTime"] as! Double
            }
            if dict.keys.contains("Event") {
                self.event = dict["Event"] as! String
            }
            if dict.keys.contains("ExecPerSecond") {
                self.execPerSecond = dict["ExecPerSecond"] as! Double
            }
            if dict.keys.contains("ExecuteTime") {
                self.executeTime = dict["ExecuteTime"] as! Double
            }
            if dict.keys.contains("Executions") {
                self.executions = dict["Executions"] as! Int64
            }
            if dict.keys.contains("FailTimes") {
                self.failTimes = dict["FailTimes"] as! Int64
            }
            if dict.keys.contains("GetPlanTime") {
                self.getPlanTime = dict["GetPlanTime"] as! Double
            }
            if dict.keys.contains("IOWaitTime") {
                self.IOWaitTime = dict["IOWaitTime"] as! Double
            }
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! Int64
            }
            if dict.keys.contains("LogicalRead") {
                self.logicalRead = dict["LogicalRead"] as! Int64
            }
            if dict.keys.contains("MaxCpuTime") {
                self.maxCpuTime = dict["MaxCpuTime"] as! Double
            }
            if dict.keys.contains("MaxElapsedTime") {
                self.maxElapsedTime = dict["MaxElapsedTime"] as! Double
            }
            if dict.keys.contains("MemstoreReadRowCount") {
                self.memstoreReadRowCount = dict["MemstoreReadRowCount"] as! Int64
            }
            if dict.keys.contains("MissPlans") {
                self.missPlans = dict["MissPlans"] as! Int64
            }
            if dict.keys.contains("NetWaitTime") {
                self.netWaitTime = dict["NetWaitTime"] as! Double
            }
            if dict.keys.contains("NodeIp") {
                self.nodeIp = dict["NodeIp"] as! String
            }
            if dict.keys.contains("QueueTime") {
                self.queueTime = dict["QueueTime"] as! Double
            }
            if dict.keys.contains("RPCCount") {
                self.RPCCount = dict["RPCCount"] as! Int64
            }
            if dict.keys.contains("RemotePlans") {
                self.remotePlans = dict["RemotePlans"] as! Int64
            }
            if dict.keys.contains("RetryCount") {
                self.retryCount = dict["RetryCount"] as! Int64
            }
            if dict.keys.contains("ReturnRows") {
                self.returnRows = dict["ReturnRows"] as! Int64
            }
            if dict.keys.contains("RowCacheHit") {
                self.rowCacheHit = dict["RowCacheHit"] as! Int64
            }
            if dict.keys.contains("SQLId") {
                self.SQLId = dict["SQLId"] as! String
            }
            if dict.keys.contains("SQLText") {
                self.SQLText = dict["SQLText"] as! String
            }
            if dict.keys.contains("SQLType") {
                self.SQLType = dict["SQLType"] as! Int64
            }
            if dict.keys.contains("ScheduleTime") {
                self.scheduleTime = dict["ScheduleTime"] as! Double
            }
            if dict.keys.contains("SsstoreReadRowCount") {
                self.ssstoreReadRowCount = dict["SsstoreReadRowCount"] as! Int64
            }
            if dict.keys.contains("TotalWaitTime") {
                self.totalWaitTime = dict["TotalWaitTime"] as! Double
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public var requestId: String?

    public var slowSQLList: [DescribeSlowSQLListResponseBody.SlowSQLList]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.slowSQLList != nil {
            var tmp : [Any] = []
            for k in self.slowSQLList! {
                tmp.append(k.toMap())
            }
            map["SlowSQLList"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SlowSQLList") {
            var tmp : [DescribeSlowSQLListResponseBody.SlowSQLList] = []
            for v in dict["SlowSQLList"] as! [Any] {
                var model = DescribeSlowSQLListResponseBody.SlowSQLList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.slowSQLList = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeSlowSQLListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSlowSQLListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSlowSQLListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTagValuesRequest : Tea.TeaModel {
    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class DescribeTagValuesResponseBody : Tea.TeaModel {
    public var map: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.map != nil {
            map["Map"] = self.map!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Map") {
            self.map = dict["Map"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeTagValuesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTagValuesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTagValuesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTenantRequest : Tea.TeaModel {
    public var instanceId: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DescribeTenantResponseBody : Tea.TeaModel {
    public class Tenant : Tea.TeaModel {
        public class ReadOnlyResource : Tea.TeaModel {
            public class CapacityUnit : Tea.TeaModel {
                public var maxCapacityUnit: Int32?

                public var minCapacityUnit: Int32?

                public var usedCapacit: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxCapacityUnit != nil {
                        map["MaxCapacityUnit"] = self.maxCapacityUnit!
                    }
                    if self.minCapacityUnit != nil {
                        map["MinCapacityUnit"] = self.minCapacityUnit!
                    }
                    if self.usedCapacit != nil {
                        map["UsedCapacit"] = self.usedCapacit!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MaxCapacityUnit") {
                        self.maxCapacityUnit = dict["MaxCapacityUnit"] as! Int32
                    }
                    if dict.keys.contains("MinCapacityUnit") {
                        self.minCapacityUnit = dict["MinCapacityUnit"] as! Int32
                    }
                    if dict.keys.contains("UsedCapacit") {
                        self.usedCapacit = dict["UsedCapacit"] as! Int32
                    }
                }
            }
            public class Cpu : Tea.TeaModel {
                public var totalCpu: Double?

                public var unitCpu: Double?

                public var usedCpu: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.totalCpu != nil {
                        map["TotalCpu"] = self.totalCpu!
                    }
                    if self.unitCpu != nil {
                        map["UnitCpu"] = self.unitCpu!
                    }
                    if self.usedCpu != nil {
                        map["UsedCpu"] = self.usedCpu!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TotalCpu") {
                        self.totalCpu = dict["TotalCpu"] as! Double
                    }
                    if dict.keys.contains("UnitCpu") {
                        self.unitCpu = dict["UnitCpu"] as! Double
                    }
                    if dict.keys.contains("UsedCpu") {
                        self.usedCpu = dict["UsedCpu"] as! Double
                    }
                }
            }
            public class DiskSize : Tea.TeaModel {
                public var usedDiskSize: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.usedDiskSize != nil {
                        map["UsedDiskSize"] = self.usedDiskSize!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("UsedDiskSize") {
                        self.usedDiskSize = dict["UsedDiskSize"] as! Double
                    }
                }
            }
            public class LogDiskSize : Tea.TeaModel {
                public var totalLogDisk: Int32?

                public var unitLogDisk: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.totalLogDisk != nil {
                        map["TotalLogDisk"] = self.totalLogDisk!
                    }
                    if self.unitLogDisk != nil {
                        map["UnitLogDisk"] = self.unitLogDisk!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TotalLogDisk") {
                        self.totalLogDisk = dict["TotalLogDisk"] as! Int32
                    }
                    if dict.keys.contains("UnitLogDisk") {
                        self.unitLogDisk = dict["UnitLogDisk"] as! Int32
                    }
                }
            }
            public class Memory : Tea.TeaModel {
                public var totalMemory: Double?

                public var unitMemory: Double?

                public var usedMemory: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.totalMemory != nil {
                        map["TotalMemory"] = self.totalMemory!
                    }
                    if self.unitMemory != nil {
                        map["UnitMemory"] = self.unitMemory!
                    }
                    if self.usedMemory != nil {
                        map["UsedMemory"] = self.usedMemory!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TotalMemory") {
                        self.totalMemory = dict["TotalMemory"] as! Double
                    }
                    if dict.keys.contains("UnitMemory") {
                        self.unitMemory = dict["UnitMemory"] as! Double
                    }
                    if dict.keys.contains("UsedMemory") {
                        self.usedMemory = dict["UsedMemory"] as! Double
                    }
                }
            }
            public var capacityUnit: DescribeTenantResponseBody.Tenant.ReadOnlyResource.CapacityUnit?

            public var cpu: DescribeTenantResponseBody.Tenant.ReadOnlyResource.Cpu?

            public var diskSize: DescribeTenantResponseBody.Tenant.ReadOnlyResource.DiskSize?

            public var logDiskSize: DescribeTenantResponseBody.Tenant.ReadOnlyResource.LogDiskSize?

            public var memory: DescribeTenantResponseBody.Tenant.ReadOnlyResource.Memory?

            public var unitNum: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.capacityUnit?.validate()
                try self.cpu?.validate()
                try self.diskSize?.validate()
                try self.logDiskSize?.validate()
                try self.memory?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.capacityUnit != nil {
                    map["CapacityUnit"] = self.capacityUnit?.toMap()
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu?.toMap()
                }
                if self.diskSize != nil {
                    map["DiskSize"] = self.diskSize?.toMap()
                }
                if self.logDiskSize != nil {
                    map["LogDiskSize"] = self.logDiskSize?.toMap()
                }
                if self.memory != nil {
                    map["Memory"] = self.memory?.toMap()
                }
                if self.unitNum != nil {
                    map["UnitNum"] = self.unitNum!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CapacityUnit") {
                    var model = DescribeTenantResponseBody.Tenant.ReadOnlyResource.CapacityUnit()
                    model.fromMap(dict["CapacityUnit"] as! [String: Any])
                    self.capacityUnit = model
                }
                if dict.keys.contains("Cpu") {
                    var model = DescribeTenantResponseBody.Tenant.ReadOnlyResource.Cpu()
                    model.fromMap(dict["Cpu"] as! [String: Any])
                    self.cpu = model
                }
                if dict.keys.contains("DiskSize") {
                    var model = DescribeTenantResponseBody.Tenant.ReadOnlyResource.DiskSize()
                    model.fromMap(dict["DiskSize"] as! [String: Any])
                    self.diskSize = model
                }
                if dict.keys.contains("LogDiskSize") {
                    var model = DescribeTenantResponseBody.Tenant.ReadOnlyResource.LogDiskSize()
                    model.fromMap(dict["LogDiskSize"] as! [String: Any])
                    self.logDiskSize = model
                }
                if dict.keys.contains("Memory") {
                    var model = DescribeTenantResponseBody.Tenant.ReadOnlyResource.Memory()
                    model.fromMap(dict["Memory"] as! [String: Any])
                    self.memory = model
                }
                if dict.keys.contains("UnitNum") {
                    self.unitNum = dict["UnitNum"] as! Int32
                }
            }
        }
        public class TenantConnections : Tea.TeaModel {
            public var addressType: String?

            public var connectionLogicalZones: [String]?

            public var connectionReplicaType: String?

            public var connectionZones: [String]?

            public var enableTransactionSplit: Bool?

            public var internetAddress: String?

            public var internetAddressStatus: String?

            public var internetMaxConnectionLimit: Int64?

            public var internetMaxConnectionNum: Int64?

            public var internetPort: Int32?

            public var internetRpcPort: Int32?

            public var intranetAddress: String?

            public var intranetAddressMasterZoneId: String?

            public var intranetAddressSlaveZoneId: String?

            public var intranetAddressStatus: String?

            public var intranetPort: Int32?

            public var intranetRpcPort: Int32?

            public var maxConnectionLimit: Int64?

            public var maxConnectionNum: Int64?

            public var parallelQueryDegree: Int64?

            public var proxyClusterId: String?

            public var tenantEndpointId: String?

            public var transactionSplit: Bool?

            public var vSwitchId: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addressType != nil {
                    map["AddressType"] = self.addressType!
                }
                if self.connectionLogicalZones != nil {
                    map["ConnectionLogicalZones"] = self.connectionLogicalZones!
                }
                if self.connectionReplicaType != nil {
                    map["ConnectionReplicaType"] = self.connectionReplicaType!
                }
                if self.connectionZones != nil {
                    map["ConnectionZones"] = self.connectionZones!
                }
                if self.enableTransactionSplit != nil {
                    map["EnableTransactionSplit"] = self.enableTransactionSplit!
                }
                if self.internetAddress != nil {
                    map["InternetAddress"] = self.internetAddress!
                }
                if self.internetAddressStatus != nil {
                    map["InternetAddressStatus"] = self.internetAddressStatus!
                }
                if self.internetMaxConnectionLimit != nil {
                    map["InternetMaxConnectionLimit"] = self.internetMaxConnectionLimit!
                }
                if self.internetMaxConnectionNum != nil {
                    map["InternetMaxConnectionNum"] = self.internetMaxConnectionNum!
                }
                if self.internetPort != nil {
                    map["InternetPort"] = self.internetPort!
                }
                if self.internetRpcPort != nil {
                    map["InternetRpcPort"] = self.internetRpcPort!
                }
                if self.intranetAddress != nil {
                    map["IntranetAddress"] = self.intranetAddress!
                }
                if self.intranetAddressMasterZoneId != nil {
                    map["IntranetAddressMasterZoneId"] = self.intranetAddressMasterZoneId!
                }
                if self.intranetAddressSlaveZoneId != nil {
                    map["IntranetAddressSlaveZoneId"] = self.intranetAddressSlaveZoneId!
                }
                if self.intranetAddressStatus != nil {
                    map["IntranetAddressStatus"] = self.intranetAddressStatus!
                }
                if self.intranetPort != nil {
                    map["IntranetPort"] = self.intranetPort!
                }
                if self.intranetRpcPort != nil {
                    map["IntranetRpcPort"] = self.intranetRpcPort!
                }
                if self.maxConnectionLimit != nil {
                    map["MaxConnectionLimit"] = self.maxConnectionLimit!
                }
                if self.maxConnectionNum != nil {
                    map["MaxConnectionNum"] = self.maxConnectionNum!
                }
                if self.parallelQueryDegree != nil {
                    map["ParallelQueryDegree"] = self.parallelQueryDegree!
                }
                if self.proxyClusterId != nil {
                    map["ProxyClusterId"] = self.proxyClusterId!
                }
                if self.tenantEndpointId != nil {
                    map["TenantEndpointId"] = self.tenantEndpointId!
                }
                if self.transactionSplit != nil {
                    map["TransactionSplit"] = self.transactionSplit!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddressType") {
                    self.addressType = dict["AddressType"] as! String
                }
                if dict.keys.contains("ConnectionLogicalZones") {
                    self.connectionLogicalZones = dict["ConnectionLogicalZones"] as! [String]
                }
                if dict.keys.contains("ConnectionReplicaType") {
                    self.connectionReplicaType = dict["ConnectionReplicaType"] as! String
                }
                if dict.keys.contains("ConnectionZones") {
                    self.connectionZones = dict["ConnectionZones"] as! [String]
                }
                if dict.keys.contains("EnableTransactionSplit") {
                    self.enableTransactionSplit = dict["EnableTransactionSplit"] as! Bool
                }
                if dict.keys.contains("InternetAddress") {
                    self.internetAddress = dict["InternetAddress"] as! String
                }
                if dict.keys.contains("InternetAddressStatus") {
                    self.internetAddressStatus = dict["InternetAddressStatus"] as! String
                }
                if dict.keys.contains("InternetMaxConnectionLimit") {
                    self.internetMaxConnectionLimit = dict["InternetMaxConnectionLimit"] as! Int64
                }
                if dict.keys.contains("InternetMaxConnectionNum") {
                    self.internetMaxConnectionNum = dict["InternetMaxConnectionNum"] as! Int64
                }
                if dict.keys.contains("InternetPort") {
                    self.internetPort = dict["InternetPort"] as! Int32
                }
                if dict.keys.contains("InternetRpcPort") {
                    self.internetRpcPort = dict["InternetRpcPort"] as! Int32
                }
                if dict.keys.contains("IntranetAddress") {
                    self.intranetAddress = dict["IntranetAddress"] as! String
                }
                if dict.keys.contains("IntranetAddressMasterZoneId") {
                    self.intranetAddressMasterZoneId = dict["IntranetAddressMasterZoneId"] as! String
                }
                if dict.keys.contains("IntranetAddressSlaveZoneId") {
                    self.intranetAddressSlaveZoneId = dict["IntranetAddressSlaveZoneId"] as! String
                }
                if dict.keys.contains("IntranetAddressStatus") {
                    self.intranetAddressStatus = dict["IntranetAddressStatus"] as! String
                }
                if dict.keys.contains("IntranetPort") {
                    self.intranetPort = dict["IntranetPort"] as! Int32
                }
                if dict.keys.contains("IntranetRpcPort") {
                    self.intranetRpcPort = dict["IntranetRpcPort"] as! Int32
                }
                if dict.keys.contains("MaxConnectionLimit") {
                    self.maxConnectionLimit = dict["MaxConnectionLimit"] as! Int64
                }
                if dict.keys.contains("MaxConnectionNum") {
                    self.maxConnectionNum = dict["MaxConnectionNum"] as! Int64
                }
                if dict.keys.contains("ParallelQueryDegree") {
                    self.parallelQueryDegree = dict["ParallelQueryDegree"] as! Int64
                }
                if dict.keys.contains("ProxyClusterId") {
                    self.proxyClusterId = dict["ProxyClusterId"] as! String
                }
                if dict.keys.contains("TenantEndpointId") {
                    self.tenantEndpointId = dict["TenantEndpointId"] as! String
                }
                if dict.keys.contains("TransactionSplit") {
                    self.transactionSplit = dict["TransactionSplit"] as! Bool
                }
                if dict.keys.contains("VSwitchId") {
                    self.vSwitchId = dict["VSwitchId"] as! String
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public class TenantResource : Tea.TeaModel {
            public class CapacityUnit : Tea.TeaModel {
                public var maxCapacityUnit: Int32?

                public var minCapacityUnit: Int32?

                public var usedCapacit: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxCapacityUnit != nil {
                        map["MaxCapacityUnit"] = self.maxCapacityUnit!
                    }
                    if self.minCapacityUnit != nil {
                        map["MinCapacityUnit"] = self.minCapacityUnit!
                    }
                    if self.usedCapacit != nil {
                        map["UsedCapacit"] = self.usedCapacit!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MaxCapacityUnit") {
                        self.maxCapacityUnit = dict["MaxCapacityUnit"] as! Int32
                    }
                    if dict.keys.contains("MinCapacityUnit") {
                        self.minCapacityUnit = dict["MinCapacityUnit"] as! Int32
                    }
                    if dict.keys.contains("UsedCapacit") {
                        self.usedCapacit = dict["UsedCapacit"] as! Int32
                    }
                }
            }
            public class Cpu : Tea.TeaModel {
                public var totalCpu: Double?

                public var unitCpu: Double?

                public var usedCpu: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.totalCpu != nil {
                        map["TotalCpu"] = self.totalCpu!
                    }
                    if self.unitCpu != nil {
                        map["UnitCpu"] = self.unitCpu!
                    }
                    if self.usedCpu != nil {
                        map["UsedCpu"] = self.usedCpu!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TotalCpu") {
                        self.totalCpu = dict["TotalCpu"] as! Double
                    }
                    if dict.keys.contains("UnitCpu") {
                        self.unitCpu = dict["UnitCpu"] as! Double
                    }
                    if dict.keys.contains("UsedCpu") {
                        self.usedCpu = dict["UsedCpu"] as! Double
                    }
                }
            }
            public class DiskSize : Tea.TeaModel {
                public var usedDiskSize: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.usedDiskSize != nil {
                        map["UsedDiskSize"] = self.usedDiskSize!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("UsedDiskSize") {
                        self.usedDiskSize = dict["UsedDiskSize"] as! Double
                    }
                }
            }
            public class LogDiskSize : Tea.TeaModel {
                public var totalLogDisk: Int32?

                public var unitLogDisk: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.totalLogDisk != nil {
                        map["TotalLogDisk"] = self.totalLogDisk!
                    }
                    if self.unitLogDisk != nil {
                        map["UnitLogDisk"] = self.unitLogDisk!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TotalLogDisk") {
                        self.totalLogDisk = dict["TotalLogDisk"] as! Int32
                    }
                    if dict.keys.contains("UnitLogDisk") {
                        self.unitLogDisk = dict["UnitLogDisk"] as! Int32
                    }
                }
            }
            public class Memory : Tea.TeaModel {
                public var totalMemory: Double?

                public var unitMemory: Double?

                public var usedMemory: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.totalMemory != nil {
                        map["TotalMemory"] = self.totalMemory!
                    }
                    if self.unitMemory != nil {
                        map["UnitMemory"] = self.unitMemory!
                    }
                    if self.usedMemory != nil {
                        map["UsedMemory"] = self.usedMemory!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TotalMemory") {
                        self.totalMemory = dict["TotalMemory"] as! Double
                    }
                    if dict.keys.contains("UnitMemory") {
                        self.unitMemory = dict["UnitMemory"] as! Double
                    }
                    if dict.keys.contains("UsedMemory") {
                        self.usedMemory = dict["UsedMemory"] as! Double
                    }
                }
            }
            public var capacityUnit: DescribeTenantResponseBody.Tenant.TenantResource.CapacityUnit?

            public var cpu: DescribeTenantResponseBody.Tenant.TenantResource.Cpu?

            public var diskSize: DescribeTenantResponseBody.Tenant.TenantResource.DiskSize?

            public var logDiskSize: DescribeTenantResponseBody.Tenant.TenantResource.LogDiskSize?

            public var memory: DescribeTenantResponseBody.Tenant.TenantResource.Memory?

            public var unitNum: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.capacityUnit?.validate()
                try self.cpu?.validate()
                try self.diskSize?.validate()
                try self.logDiskSize?.validate()
                try self.memory?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.capacityUnit != nil {
                    map["CapacityUnit"] = self.capacityUnit?.toMap()
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu?.toMap()
                }
                if self.diskSize != nil {
                    map["DiskSize"] = self.diskSize?.toMap()
                }
                if self.logDiskSize != nil {
                    map["LogDiskSize"] = self.logDiskSize?.toMap()
                }
                if self.memory != nil {
                    map["Memory"] = self.memory?.toMap()
                }
                if self.unitNum != nil {
                    map["UnitNum"] = self.unitNum!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CapacityUnit") {
                    var model = DescribeTenantResponseBody.Tenant.TenantResource.CapacityUnit()
                    model.fromMap(dict["CapacityUnit"] as! [String: Any])
                    self.capacityUnit = model
                }
                if dict.keys.contains("Cpu") {
                    var model = DescribeTenantResponseBody.Tenant.TenantResource.Cpu()
                    model.fromMap(dict["Cpu"] as! [String: Any])
                    self.cpu = model
                }
                if dict.keys.contains("DiskSize") {
                    var model = DescribeTenantResponseBody.Tenant.TenantResource.DiskSize()
                    model.fromMap(dict["DiskSize"] as! [String: Any])
                    self.diskSize = model
                }
                if dict.keys.contains("LogDiskSize") {
                    var model = DescribeTenantResponseBody.Tenant.TenantResource.LogDiskSize()
                    model.fromMap(dict["LogDiskSize"] as! [String: Any])
                    self.logDiskSize = model
                }
                if dict.keys.contains("Memory") {
                    var model = DescribeTenantResponseBody.Tenant.TenantResource.Memory()
                    model.fromMap(dict["Memory"] as! [String: Any])
                    self.memory = model
                }
                if dict.keys.contains("UnitNum") {
                    self.unitNum = dict["UnitNum"] as! Int32
                }
            }
        }
        public class TenantZones : Tea.TeaModel {
            public class TenantZoneReplicas : Tea.TeaModel {
                public var fullCopyId: Int32?

                public var logicZoneName: String?

                public var readOnlyCopyId: String?

                public var zoneCopyId: Int32?

                public var zoneNodes: String?

                public var zoneReplicaType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fullCopyId != nil {
                        map["FullCopyId"] = self.fullCopyId!
                    }
                    if self.logicZoneName != nil {
                        map["LogicZoneName"] = self.logicZoneName!
                    }
                    if self.readOnlyCopyId != nil {
                        map["ReadOnlyCopyId"] = self.readOnlyCopyId!
                    }
                    if self.zoneCopyId != nil {
                        map["ZoneCopyId"] = self.zoneCopyId!
                    }
                    if self.zoneNodes != nil {
                        map["ZoneNodes"] = self.zoneNodes!
                    }
                    if self.zoneReplicaType != nil {
                        map["ZoneReplicaType"] = self.zoneReplicaType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FullCopyId") {
                        self.fullCopyId = dict["FullCopyId"] as! Int32
                    }
                    if dict.keys.contains("LogicZoneName") {
                        self.logicZoneName = dict["LogicZoneName"] as! String
                    }
                    if dict.keys.contains("ReadOnlyCopyId") {
                        self.readOnlyCopyId = dict["ReadOnlyCopyId"] as! String
                    }
                    if dict.keys.contains("ZoneCopyId") {
                        self.zoneCopyId = dict["ZoneCopyId"] as! Int32
                    }
                    if dict.keys.contains("ZoneNodes") {
                        self.zoneNodes = dict["ZoneNodes"] as! String
                    }
                    if dict.keys.contains("ZoneReplicaType") {
                        self.zoneReplicaType = dict["ZoneReplicaType"] as! String
                    }
                }
            }
            public var region: String?

            public var tenantZoneId: String?

            public var tenantZoneReplicas: [DescribeTenantResponseBody.Tenant.TenantZones.TenantZoneReplicas]?

            public var tenantZoneRole: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.tenantZoneId != nil {
                    map["TenantZoneId"] = self.tenantZoneId!
                }
                if self.tenantZoneReplicas != nil {
                    var tmp : [Any] = []
                    for k in self.tenantZoneReplicas! {
                        tmp.append(k.toMap())
                    }
                    map["TenantZoneReplicas"] = tmp
                }
                if self.tenantZoneRole != nil {
                    map["TenantZoneRole"] = self.tenantZoneRole!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("TenantZoneId") {
                    self.tenantZoneId = dict["TenantZoneId"] as! String
                }
                if dict.keys.contains("TenantZoneReplicas") {
                    var tmp : [DescribeTenantResponseBody.Tenant.TenantZones.TenantZoneReplicas] = []
                    for v in dict["TenantZoneReplicas"] as! [Any] {
                        var model = DescribeTenantResponseBody.Tenant.TenantZones.TenantZoneReplicas()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tenantZoneReplicas = tmp
                }
                if dict.keys.contains("TenantZoneRole") {
                    self.tenantZoneRole = dict["TenantZoneRole"] as! String
                }
            }
        }
        public var availableZones: [String]?

        public var charset: String?

        public var clogServiceStatus: String?

        public var collation: String?

        public var createTime: String?

        public var dataMergeTime: String?

        public var deployMode: String?

        public var deployType: String?

        public var description_: String?

        public var diskType: String?

        public var enableBinlogService: Bool?

        public var enableClogService: Bool?

        public var enableInternetAddressService: Bool?

        public var enableParallelQuery: Bool?

        public var enableReadOnlyReplica: Bool?

        public var enableReadWriteSplit: Bool?

        public var instanceType: String?

        public var lowerCaseTableNames: [UInt8]?

        public var masterIntranetAddressZone: String?

        public var maxParallelQueryDegree: Int64?

        public var payType: String?

        public var primaryZone: String?

        public var primaryZoneDeployType: String?

        public var readOnlyResource: DescribeTenantResponseBody.Tenant.ReadOnlyResource?

        public var recycleBinStatus: String?

        public var series: String?

        public var status: String?

        public var tenantConnections: [DescribeTenantResponseBody.Tenant.TenantConnections]?

        public var tenantId: String?

        public var tenantMode: String?

        public var tenantName: String?

        public var tenantResource: DescribeTenantResponseBody.Tenant.TenantResource?

        public var tenantZones: [DescribeTenantResponseBody.Tenant.TenantZones]?

        public var timeZone: String?

        public var version: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.readOnlyResource?.validate()
            try self.tenantResource?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.availableZones != nil {
                map["AvailableZones"] = self.availableZones!
            }
            if self.charset != nil {
                map["Charset"] = self.charset!
            }
            if self.clogServiceStatus != nil {
                map["ClogServiceStatus"] = self.clogServiceStatus!
            }
            if self.collation != nil {
                map["Collation"] = self.collation!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.dataMergeTime != nil {
                map["DataMergeTime"] = self.dataMergeTime!
            }
            if self.deployMode != nil {
                map["DeployMode"] = self.deployMode!
            }
            if self.deployType != nil {
                map["DeployType"] = self.deployType!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.diskType != nil {
                map["DiskType"] = self.diskType!
            }
            if self.enableBinlogService != nil {
                map["EnableBinlogService"] = self.enableBinlogService!
            }
            if self.enableClogService != nil {
                map["EnableClogService"] = self.enableClogService!
            }
            if self.enableInternetAddressService != nil {
                map["EnableInternetAddressService"] = self.enableInternetAddressService!
            }
            if self.enableParallelQuery != nil {
                map["EnableParallelQuery"] = self.enableParallelQuery!
            }
            if self.enableReadOnlyReplica != nil {
                map["EnableReadOnlyReplica"] = self.enableReadOnlyReplica!
            }
            if self.enableReadWriteSplit != nil {
                map["EnableReadWriteSplit"] = self.enableReadWriteSplit!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.lowerCaseTableNames != nil {
                map["LowerCaseTableNames"] = self.lowerCaseTableNames!
            }
            if self.masterIntranetAddressZone != nil {
                map["MasterIntranetAddressZone"] = self.masterIntranetAddressZone!
            }
            if self.maxParallelQueryDegree != nil {
                map["MaxParallelQueryDegree"] = self.maxParallelQueryDegree!
            }
            if self.payType != nil {
                map["PayType"] = self.payType!
            }
            if self.primaryZone != nil {
                map["PrimaryZone"] = self.primaryZone!
            }
            if self.primaryZoneDeployType != nil {
                map["PrimaryZoneDeployType"] = self.primaryZoneDeployType!
            }
            if self.readOnlyResource != nil {
                map["ReadOnlyResource"] = self.readOnlyResource?.toMap()
            }
            if self.recycleBinStatus != nil {
                map["RecycleBinStatus"] = self.recycleBinStatus!
            }
            if self.series != nil {
                map["Series"] = self.series!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tenantConnections != nil {
                var tmp : [Any] = []
                for k in self.tenantConnections! {
                    tmp.append(k.toMap())
                }
                map["TenantConnections"] = tmp
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.tenantMode != nil {
                map["TenantMode"] = self.tenantMode!
            }
            if self.tenantName != nil {
                map["TenantName"] = self.tenantName!
            }
            if self.tenantResource != nil {
                map["TenantResource"] = self.tenantResource?.toMap()
            }
            if self.tenantZones != nil {
                var tmp : [Any] = []
                for k in self.tenantZones! {
                    tmp.append(k.toMap())
                }
                map["TenantZones"] = tmp
            }
            if self.timeZone != nil {
                map["TimeZone"] = self.timeZone!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvailableZones") {
                self.availableZones = dict["AvailableZones"] as! [String]
            }
            if dict.keys.contains("Charset") {
                self.charset = dict["Charset"] as! String
            }
            if dict.keys.contains("ClogServiceStatus") {
                self.clogServiceStatus = dict["ClogServiceStatus"] as! String
            }
            if dict.keys.contains("Collation") {
                self.collation = dict["Collation"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DataMergeTime") {
                self.dataMergeTime = dict["DataMergeTime"] as! String
            }
            if dict.keys.contains("DeployMode") {
                self.deployMode = dict["DeployMode"] as! String
            }
            if dict.keys.contains("DeployType") {
                self.deployType = dict["DeployType"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DiskType") {
                self.diskType = dict["DiskType"] as! String
            }
            if dict.keys.contains("EnableBinlogService") {
                self.enableBinlogService = dict["EnableBinlogService"] as! Bool
            }
            if dict.keys.contains("EnableClogService") {
                self.enableClogService = dict["EnableClogService"] as! Bool
            }
            if dict.keys.contains("EnableInternetAddressService") {
                self.enableInternetAddressService = dict["EnableInternetAddressService"] as! Bool
            }
            if dict.keys.contains("EnableParallelQuery") {
                self.enableParallelQuery = dict["EnableParallelQuery"] as! Bool
            }
            if dict.keys.contains("EnableReadOnlyReplica") {
                self.enableReadOnlyReplica = dict["EnableReadOnlyReplica"] as! Bool
            }
            if dict.keys.contains("EnableReadWriteSplit") {
                self.enableReadWriteSplit = dict["EnableReadWriteSplit"] as! Bool
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("LowerCaseTableNames") {
                self.lowerCaseTableNames = dict["LowerCaseTableNames"] as! [UInt8]
            }
            if dict.keys.contains("MasterIntranetAddressZone") {
                self.masterIntranetAddressZone = dict["MasterIntranetAddressZone"] as! String
            }
            if dict.keys.contains("MaxParallelQueryDegree") {
                self.maxParallelQueryDegree = dict["MaxParallelQueryDegree"] as! Int64
            }
            if dict.keys.contains("PayType") {
                self.payType = dict["PayType"] as! String
            }
            if dict.keys.contains("PrimaryZone") {
                self.primaryZone = dict["PrimaryZone"] as! String
            }
            if dict.keys.contains("PrimaryZoneDeployType") {
                self.primaryZoneDeployType = dict["PrimaryZoneDeployType"] as! String
            }
            if dict.keys.contains("ReadOnlyResource") {
                var model = DescribeTenantResponseBody.Tenant.ReadOnlyResource()
                model.fromMap(dict["ReadOnlyResource"] as! [String: Any])
                self.readOnlyResource = model
            }
            if dict.keys.contains("RecycleBinStatus") {
                self.recycleBinStatus = dict["RecycleBinStatus"] as! String
            }
            if dict.keys.contains("Series") {
                self.series = dict["Series"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TenantConnections") {
                var tmp : [DescribeTenantResponseBody.Tenant.TenantConnections] = []
                for v in dict["TenantConnections"] as! [Any] {
                    var model = DescribeTenantResponseBody.Tenant.TenantConnections()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tenantConnections = tmp
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! String
            }
            if dict.keys.contains("TenantMode") {
                self.tenantMode = dict["TenantMode"] as! String
            }
            if dict.keys.contains("TenantName") {
                self.tenantName = dict["TenantName"] as! String
            }
            if dict.keys.contains("TenantResource") {
                var model = DescribeTenantResponseBody.Tenant.TenantResource()
                model.fromMap(dict["TenantResource"] as! [String: Any])
                self.tenantResource = model
            }
            if dict.keys.contains("TenantZones") {
                var tmp : [DescribeTenantResponseBody.Tenant.TenantZones] = []
                for v in dict["TenantZones"] as! [Any] {
                    var model = DescribeTenantResponseBody.Tenant.TenantZones()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tenantZones = tmp
            }
            if dict.keys.contains("TimeZone") {
                self.timeZone = dict["TimeZone"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var requestId: String?

    public var tenant: DescribeTenantResponseBody.Tenant?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenant?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tenant != nil {
            map["Tenant"] = self.tenant?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Tenant") {
            var model = DescribeTenantResponseBody.Tenant()
            model.fromMap(dict["Tenant"] as! [String: Any])
            self.tenant = model
        }
    }
}

public class DescribeTenantResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTenantResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTenantResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTenantEncryptionRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var tenantId: String?

    public var tenantName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.tenantName != nil {
            map["TenantName"] = self.tenantName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("TenantName") {
            self.tenantName = dict["TenantName"] as! String
        }
    }
}

public class DescribeTenantEncryptionResponseBody : Tea.TeaModel {
    public class TenantEncryptions : Tea.TeaModel {
        public var enableEncryption: Bool?

        public var encryptionKeyId: String?

        public var encryptionType: String?

        public var status: String?

        public var tenantId: String?

        public var tenantMode: String?

        public var tenantName: String?

        public var tenantStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableEncryption != nil {
                map["EnableEncryption"] = self.enableEncryption!
            }
            if self.encryptionKeyId != nil {
                map["EncryptionKeyId"] = self.encryptionKeyId!
            }
            if self.encryptionType != nil {
                map["EncryptionType"] = self.encryptionType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.tenantMode != nil {
                map["TenantMode"] = self.tenantMode!
            }
            if self.tenantName != nil {
                map["TenantName"] = self.tenantName!
            }
            if self.tenantStatus != nil {
                map["TenantStatus"] = self.tenantStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableEncryption") {
                self.enableEncryption = dict["EnableEncryption"] as! Bool
            }
            if dict.keys.contains("EncryptionKeyId") {
                self.encryptionKeyId = dict["EncryptionKeyId"] as! String
            }
            if dict.keys.contains("EncryptionType") {
                self.encryptionType = dict["EncryptionType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! String
            }
            if dict.keys.contains("TenantMode") {
                self.tenantMode = dict["TenantMode"] as! String
            }
            if dict.keys.contains("TenantName") {
                self.tenantName = dict["TenantName"] as! String
            }
            if dict.keys.contains("TenantStatus") {
                self.tenantStatus = dict["TenantStatus"] as! String
            }
        }
    }
    public var requestId: String?

    public var tenantEncryptions: [DescribeTenantEncryptionResponseBody.TenantEncryptions]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tenantEncryptions != nil {
            var tmp : [Any] = []
            for k in self.tenantEncryptions! {
                tmp.append(k.toMap())
            }
            map["TenantEncryptions"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TenantEncryptions") {
            var tmp : [DescribeTenantEncryptionResponseBody.TenantEncryptions] = []
            for v in dict["TenantEncryptions"] as! [Any] {
                var model = DescribeTenantEncryptionResponseBody.TenantEncryptions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tenantEncryptions = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeTenantEncryptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTenantEncryptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTenantEncryptionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTenantMetricsRequest : Tea.TeaModel {
    public var endTime: String?

    public var instanceId: String?

    public var metrics: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTime: String?

    public var tenantId: String?

    public var tenantIdList: String?

    public var tenantName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.metrics != nil {
            map["Metrics"] = self.metrics!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.tenantIdList != nil {
            map["TenantIdList"] = self.tenantIdList!
        }
        if self.tenantName != nil {
            map["TenantName"] = self.tenantName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Metrics") {
            self.metrics = dict["Metrics"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("TenantIdList") {
            self.tenantIdList = dict["TenantIdList"] as! String
        }
        if dict.keys.contains("TenantName") {
            self.tenantName = dict["TenantName"] as! String
        }
    }
}

public class DescribeTenantMetricsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var tenantMetrics: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tenantMetrics != nil {
            map["TenantMetrics"] = self.tenantMetrics!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TenantMetrics") {
            self.tenantMetrics = dict["TenantMetrics"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeTenantMetricsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTenantMetricsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTenantMetricsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTenantReadableScnRequest : Tea.TeaModel {
    public var instanceId: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DescribeTenantReadableScnResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var readableScn: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.readableScn != nil {
                map["ReadableScn"] = self.readableScn!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ReadableScn") {
                self.readableScn = dict["ReadableScn"] as! Int64
            }
        }
    }
    public var data: DescribeTenantReadableScnResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DescribeTenantReadableScnResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeTenantReadableScnResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTenantReadableScnResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTenantReadableScnResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTenantSecurityConfigsRequest : Tea.TeaModel {
    public var checkId: String?

    public var instanceId: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkId != nil {
            map["CheckId"] = self.checkId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckId") {
            self.checkId = dict["CheckId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DescribeTenantSecurityConfigsResponseBody : Tea.TeaModel {
    public class Configs : Tea.TeaModel {
        public class TenantSecurityConfigs : Tea.TeaModel {
            public class SecurityConfigs : Tea.TeaModel {
                public var configDescription: String?

                public var configGroup: String?

                public var configName: String?

                public var risk: Bool?

                public var riskDescription: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.configDescription != nil {
                        map["ConfigDescription"] = self.configDescription!
                    }
                    if self.configGroup != nil {
                        map["ConfigGroup"] = self.configGroup!
                    }
                    if self.configName != nil {
                        map["ConfigName"] = self.configName!
                    }
                    if self.risk != nil {
                        map["Risk"] = self.risk!
                    }
                    if self.riskDescription != nil {
                        map["RiskDescription"] = self.riskDescription!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ConfigDescription") {
                        self.configDescription = dict["ConfigDescription"] as! String
                    }
                    if dict.keys.contains("ConfigGroup") {
                        self.configGroup = dict["ConfigGroup"] as! String
                    }
                    if dict.keys.contains("ConfigName") {
                        self.configName = dict["ConfigName"] as! String
                    }
                    if dict.keys.contains("Risk") {
                        self.risk = dict["Risk"] as! Bool
                    }
                    if dict.keys.contains("RiskDescription") {
                        self.riskDescription = dict["RiskDescription"] as! String
                    }
                }
            }
            public var riskCount: Int32?

            public var securityConfigs: [DescribeTenantSecurityConfigsResponseBody.Configs.TenantSecurityConfigs.SecurityConfigs]?

            public var tenantId: String?

            public var tenantName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.riskCount != nil {
                    map["RiskCount"] = self.riskCount!
                }
                if self.securityConfigs != nil {
                    var tmp : [Any] = []
                    for k in self.securityConfigs! {
                        tmp.append(k.toMap())
                    }
                    map["SecurityConfigs"] = tmp
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                if self.tenantName != nil {
                    map["TenantName"] = self.tenantName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RiskCount") {
                    self.riskCount = dict["RiskCount"] as! Int32
                }
                if dict.keys.contains("SecurityConfigs") {
                    var tmp : [DescribeTenantSecurityConfigsResponseBody.Configs.TenantSecurityConfigs.SecurityConfigs] = []
                    for v in dict["SecurityConfigs"] as! [Any] {
                        var model = DescribeTenantSecurityConfigsResponseBody.Configs.TenantSecurityConfigs.SecurityConfigs()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.securityConfigs = tmp
                }
                if dict.keys.contains("TenantId") {
                    self.tenantId = dict["TenantId"] as! String
                }
                if dict.keys.contains("TenantName") {
                    self.tenantName = dict["TenantName"] as! String
                }
            }
        }
        public var checkId: String?

        public var checkTime: String?

        public var instanceId: String?

        public var tenantSecurityConfigs: [DescribeTenantSecurityConfigsResponseBody.Configs.TenantSecurityConfigs]?

        public var totalCheckCount: Int32?

        public var totalRiskCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkId != nil {
                map["CheckId"] = self.checkId!
            }
            if self.checkTime != nil {
                map["CheckTime"] = self.checkTime!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.tenantSecurityConfigs != nil {
                var tmp : [Any] = []
                for k in self.tenantSecurityConfigs! {
                    tmp.append(k.toMap())
                }
                map["TenantSecurityConfigs"] = tmp
            }
            if self.totalCheckCount != nil {
                map["TotalCheckCount"] = self.totalCheckCount!
            }
            if self.totalRiskCount != nil {
                map["TotalRiskCount"] = self.totalRiskCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CheckId") {
                self.checkId = dict["CheckId"] as! String
            }
            if dict.keys.contains("CheckTime") {
                self.checkTime = dict["CheckTime"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("TenantSecurityConfigs") {
                var tmp : [DescribeTenantSecurityConfigsResponseBody.Configs.TenantSecurityConfigs] = []
                for v in dict["TenantSecurityConfigs"] as! [Any] {
                    var model = DescribeTenantSecurityConfigsResponseBody.Configs.TenantSecurityConfigs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tenantSecurityConfigs = tmp
            }
            if dict.keys.contains("TotalCheckCount") {
                self.totalCheckCount = dict["TotalCheckCount"] as! Int32
            }
            if dict.keys.contains("TotalRiskCount") {
                self.totalRiskCount = dict["TotalRiskCount"] as! Int32
            }
        }
    }
    public var configs: DescribeTenantSecurityConfigsResponseBody.Configs?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.configs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configs != nil {
            map["Configs"] = self.configs?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Configs") {
            var model = DescribeTenantSecurityConfigsResponseBody.Configs()
            model.fromMap(dict["Configs"] as! [String: Any])
            self.configs = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeTenantSecurityConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTenantSecurityConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTenantSecurityConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTenantSecurityIpGroupsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DescribeTenantSecurityIpGroupsResponseBody : Tea.TeaModel {
    public class SecurityIpGroups : Tea.TeaModel {
        public var securityIpGroupName: String?

        public var securityIpGroupType: String?

        public var securityIps: String?

        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.securityIpGroupName != nil {
                map["SecurityIpGroupName"] = self.securityIpGroupName!
            }
            if self.securityIpGroupType != nil {
                map["SecurityIpGroupType"] = self.securityIpGroupType!
            }
            if self.securityIps != nil {
                map["SecurityIps"] = self.securityIps!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SecurityIpGroupName") {
                self.securityIpGroupName = dict["SecurityIpGroupName"] as! String
            }
            if dict.keys.contains("SecurityIpGroupType") {
                self.securityIpGroupType = dict["SecurityIpGroupType"] as! String
            }
            if dict.keys.contains("SecurityIps") {
                self.securityIps = dict["SecurityIps"] as! String
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! String
            }
        }
    }
    public var requestId: String?

    public var securityIpGroups: [DescribeTenantSecurityIpGroupsResponseBody.SecurityIpGroups]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityIpGroups != nil {
            var tmp : [Any] = []
            for k in self.securityIpGroups! {
                tmp.append(k.toMap())
            }
            map["SecurityIpGroups"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityIpGroups") {
            var tmp : [DescribeTenantSecurityIpGroupsResponseBody.SecurityIpGroups] = []
            for v in dict["SecurityIpGroups"] as! [Any] {
                var model = DescribeTenantSecurityIpGroupsResponseBody.SecurityIpGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.securityIpGroups = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeTenantSecurityIpGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTenantSecurityIpGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTenantSecurityIpGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTenantTagsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var tags: String?

    public var tenantIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.tenantIds != nil {
            map["TenantIds"] = self.tenantIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("TenantIds") {
            self.tenantIds = dict["TenantIds"] as! String
        }
    }
}

public class DescribeTenantTagsResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public var resourceId: String?

        public var resourceType: String?

        public var tag: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! String
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
            if dict.keys.contains("Tag") {
                self.tag = dict["Tag"] as! String
            }
        }
    }
    public var requestId: String?

    public var tagResources: [DescribeTenantTagsResponseBody.TagResources]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            var tmp : [Any] = []
            for k in self.tagResources! {
                tmp.append(k.toMap())
            }
            map["TagResources"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagResources") {
            var tmp : [DescribeTenantTagsResponseBody.TagResources] = []
            for v in dict["TagResources"] as! [Any] {
                var model = DescribeTenantTagsResponseBody.TagResources()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tagResources = tmp
        }
    }
}

public class DescribeTenantTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTenantTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTenantTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTenantUserRolesRequest : Tea.TeaModel {
    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DescribeTenantUserRolesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var role: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Role") {
            self.role = dict["Role"] as! [String]
        }
    }
}

public class DescribeTenantUserRolesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTenantUserRolesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTenantUserRolesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTenantUsersRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchKey: String?

    public var tenantId: String?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchKey") {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
    }
}

public class DescribeTenantUsersResponseBody : Tea.TeaModel {
    public class TenantUsers : Tea.TeaModel {
        public class Databases : Tea.TeaModel {
            public var database: String?

            public var privileges: String?

            public var role: String?

            public var table: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.database != nil {
                    map["Database"] = self.database!
                }
                if self.privileges != nil {
                    map["Privileges"] = self.privileges!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.table != nil {
                    map["Table"] = self.table!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Database") {
                    self.database = dict["Database"] as! String
                }
                if dict.keys.contains("Privileges") {
                    self.privileges = dict["Privileges"] as! String
                }
                if dict.keys.contains("Role") {
                    self.role = dict["Role"] as! String
                }
                if dict.keys.contains("Table") {
                    self.table = dict["Table"] as! String
                }
            }
        }
        public var databases: [DescribeTenantUsersResponseBody.TenantUsers.Databases]?

        public var description_: String?

        public var instanceId: String?

        public var tenantId: String?

        public var userName: String?

        public var userStatus: String?

        public var userType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.databases != nil {
                var tmp : [Any] = []
                for k in self.databases! {
                    tmp.append(k.toMap())
                }
                map["Databases"] = tmp
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            if self.userStatus != nil {
                map["UserStatus"] = self.userStatus!
            }
            if self.userType != nil {
                map["UserType"] = self.userType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Databases") {
                var tmp : [DescribeTenantUsersResponseBody.TenantUsers.Databases] = []
                for v in dict["Databases"] as! [Any] {
                    var model = DescribeTenantUsersResponseBody.TenantUsers.Databases()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.databases = tmp
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! String
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
            if dict.keys.contains("UserStatus") {
                self.userStatus = dict["UserStatus"] as! String
            }
            if dict.keys.contains("UserType") {
                self.userType = dict["UserType"] as! String
            }
        }
    }
    public var requestId: String?

    public var tenantUsers: [DescribeTenantUsersResponseBody.TenantUsers]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tenantUsers != nil {
            var tmp : [Any] = []
            for k in self.tenantUsers! {
                tmp.append(k.toMap())
            }
            map["TenantUsers"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TenantUsers") {
            var tmp : [DescribeTenantUsersResponseBody.TenantUsers] = []
            for v in dict["TenantUsers"] as! [Any] {
                var model = DescribeTenantUsersResponseBody.TenantUsers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tenantUsers = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeTenantUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTenantUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTenantUsersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTenantZonesReadRequest : Tea.TeaModel {
    public var instanceId: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DescribeTenantZonesReadResponseBody : Tea.TeaModel {
    public class TenantZones : Tea.TeaModel {
        public var isElectable: Bool?

        public var isPrimary: Bool?

        public var isReadable: String?

        public var zone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.isElectable != nil {
                map["IsElectable"] = self.isElectable!
            }
            if self.isPrimary != nil {
                map["IsPrimary"] = self.isPrimary!
            }
            if self.isReadable != nil {
                map["IsReadable"] = self.isReadable!
            }
            if self.zone != nil {
                map["Zone"] = self.zone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IsElectable") {
                self.isElectable = dict["IsElectable"] as! Bool
            }
            if dict.keys.contains("IsPrimary") {
                self.isPrimary = dict["IsPrimary"] as! Bool
            }
            if dict.keys.contains("IsReadable") {
                self.isReadable = dict["IsReadable"] as! String
            }
            if dict.keys.contains("Zone") {
                self.zone = dict["Zone"] as! String
            }
        }
    }
    public var requestId: String?

    public var tenantZones: [DescribeTenantZonesReadResponseBody.TenantZones]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tenantZones != nil {
            var tmp : [Any] = []
            for k in self.tenantZones! {
                tmp.append(k.toMap())
            }
            map["TenantZones"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TenantZones") {
            var tmp : [DescribeTenantZonesReadResponseBody.TenantZones] = []
            for v in dict["TenantZones"] as! [Any] {
                var model = DescribeTenantZonesReadResponseBody.TenantZones()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tenantZones = tmp
        }
    }
}

public class DescribeTenantZonesReadResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTenantZonesReadResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTenantZonesReadResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTenantsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchKey: String?

    public var tenantId: String?

    public var tenantName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.tenantName != nil {
            map["TenantName"] = self.tenantName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchKey") {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("TenantName") {
            self.tenantName = dict["TenantName"] as! String
        }
    }
}

public class DescribeTenantsResponseBody : Tea.TeaModel {
    public class Tenants : Tea.TeaModel {
        public var charset: String?

        public var collation: String?

        public var cpu: Int32?

        public var createTime: String?

        public var deployMode: String?

        public var deployType: String?

        public var description_: String?

        public var enableReadOnlyReplica: Bool?

        public var mem: Int32?

        public var primaryZone: String?

        public var status: String?

        public var tenantId: String?

        public var tenantMode: String?

        public var tenantName: String?

        public var unitCpu: Int32?

        public var unitMem: Int32?

        public var unitNum: Int32?

        public var usedDiskSize: Double?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.charset != nil {
                map["Charset"] = self.charset!
            }
            if self.collation != nil {
                map["Collation"] = self.collation!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.deployMode != nil {
                map["DeployMode"] = self.deployMode!
            }
            if self.deployType != nil {
                map["DeployType"] = self.deployType!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.enableReadOnlyReplica != nil {
                map["EnableReadOnlyReplica"] = self.enableReadOnlyReplica!
            }
            if self.mem != nil {
                map["Mem"] = self.mem!
            }
            if self.primaryZone != nil {
                map["PrimaryZone"] = self.primaryZone!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.tenantMode != nil {
                map["TenantMode"] = self.tenantMode!
            }
            if self.tenantName != nil {
                map["TenantName"] = self.tenantName!
            }
            if self.unitCpu != nil {
                map["UnitCpu"] = self.unitCpu!
            }
            if self.unitMem != nil {
                map["UnitMem"] = self.unitMem!
            }
            if self.unitNum != nil {
                map["UnitNum"] = self.unitNum!
            }
            if self.usedDiskSize != nil {
                map["UsedDiskSize"] = self.usedDiskSize!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Charset") {
                self.charset = dict["Charset"] as! String
            }
            if dict.keys.contains("Collation") {
                self.collation = dict["Collation"] as! String
            }
            if dict.keys.contains("Cpu") {
                self.cpu = dict["Cpu"] as! Int32
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DeployMode") {
                self.deployMode = dict["DeployMode"] as! String
            }
            if dict.keys.contains("DeployType") {
                self.deployType = dict["DeployType"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EnableReadOnlyReplica") {
                self.enableReadOnlyReplica = dict["EnableReadOnlyReplica"] as! Bool
            }
            if dict.keys.contains("Mem") {
                self.mem = dict["Mem"] as! Int32
            }
            if dict.keys.contains("PrimaryZone") {
                self.primaryZone = dict["PrimaryZone"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! String
            }
            if dict.keys.contains("TenantMode") {
                self.tenantMode = dict["TenantMode"] as! String
            }
            if dict.keys.contains("TenantName") {
                self.tenantName = dict["TenantName"] as! String
            }
            if dict.keys.contains("UnitCpu") {
                self.unitCpu = dict["UnitCpu"] as! Int32
            }
            if dict.keys.contains("UnitMem") {
                self.unitMem = dict["UnitMem"] as! Int32
            }
            if dict.keys.contains("UnitNum") {
                self.unitNum = dict["UnitNum"] as! Int32
            }
            if dict.keys.contains("UsedDiskSize") {
                self.usedDiskSize = dict["UsedDiskSize"] as! Double
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var requestId: String?

    public var tenants: [DescribeTenantsResponseBody.Tenants]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tenants != nil {
            var tmp : [Any] = []
            for k in self.tenants! {
                tmp.append(k.toMap())
            }
            map["Tenants"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Tenants") {
            var tmp : [DescribeTenantsResponseBody.Tenants] = []
            for v in dict["Tenants"] as! [Any] {
                var model = DescribeTenantsResponseBody.Tenants()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tenants = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeTenantsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTenantsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTenantsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTimeZonesResponseBody : Tea.TeaModel {
    public class TimeZones : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var description_: String?

            public var timeZone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.timeZone != nil {
                    map["TimeZone"] = self.timeZone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("TimeZone") {
                    self.timeZone = dict["TimeZone"] as! String
                }
            }
        }
        public var default_: String?

        public var list: [DescribeTimeZonesResponseBody.TimeZones.List]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.default_ != nil {
                map["Default"] = self.default_!
            }
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Default") {
                self.default_ = dict["Default"] as! String
            }
            if dict.keys.contains("List") {
                var tmp : [DescribeTimeZonesResponseBody.TimeZones.List] = []
                for v in dict["List"] as! [Any] {
                    var model = DescribeTimeZonesResponseBody.TimeZones.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
        }
    }
    public var requestId: String?

    public var timeZones: DescribeTimeZonesResponseBody.TimeZones?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.timeZones?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.timeZones != nil {
            map["TimeZones"] = self.timeZones?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TimeZones") {
            var model = DescribeTimeZonesResponseBody.TimeZones()
            model.fromMap(dict["TimeZones"] as! [String: Any])
            self.timeZones = model
        }
    }
}

public class DescribeTimeZonesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTimeZonesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTimeZonesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTopSQLListRequest : Tea.TeaModel {
    public var dbName: String?

    public var endTime: String?

    public var filterCondition: [String: Any]?

    public var nodeIp: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var SQLId: String?

    public var searchKeyWord: String?

    public var searchParameter: String?

    public var searchRule: String?

    public var searchValue: String?

    public var sortColumn: String?

    public var sortOrder: String?

    public var startTime: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.filterCondition != nil {
            map["FilterCondition"] = self.filterCondition!
        }
        if self.nodeIp != nil {
            map["NodeIp"] = self.nodeIp!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.SQLId != nil {
            map["SQLId"] = self.SQLId!
        }
        if self.searchKeyWord != nil {
            map["SearchKeyWord"] = self.searchKeyWord!
        }
        if self.searchParameter != nil {
            map["SearchParameter"] = self.searchParameter!
        }
        if self.searchRule != nil {
            map["SearchRule"] = self.searchRule!
        }
        if self.searchValue != nil {
            map["SearchValue"] = self.searchValue!
        }
        if self.sortColumn != nil {
            map["SortColumn"] = self.sortColumn!
        }
        if self.sortOrder != nil {
            map["SortOrder"] = self.sortOrder!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("FilterCondition") {
            self.filterCondition = dict["FilterCondition"] as! [String: Any]
        }
        if dict.keys.contains("NodeIp") {
            self.nodeIp = dict["NodeIp"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SQLId") {
            self.SQLId = dict["SQLId"] as! String
        }
        if dict.keys.contains("SearchKeyWord") {
            self.searchKeyWord = dict["SearchKeyWord"] as! String
        }
        if dict.keys.contains("SearchParameter") {
            self.searchParameter = dict["SearchParameter"] as! String
        }
        if dict.keys.contains("SearchRule") {
            self.searchRule = dict["SearchRule"] as! String
        }
        if dict.keys.contains("SearchValue") {
            self.searchValue = dict["SearchValue"] as! String
        }
        if dict.keys.contains("SortColumn") {
            self.sortColumn = dict["SortColumn"] as! String
        }
        if dict.keys.contains("SortOrder") {
            self.sortOrder = dict["SortOrder"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DescribeTopSQLListShrinkRequest : Tea.TeaModel {
    public var dbName: String?

    public var endTime: String?

    public var filterConditionShrink: String?

    public var nodeIp: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var SQLId: String?

    public var searchKeyWord: String?

    public var searchParameter: String?

    public var searchRule: String?

    public var searchValue: String?

    public var sortColumn: String?

    public var sortOrder: String?

    public var startTime: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.filterConditionShrink != nil {
            map["FilterCondition"] = self.filterConditionShrink!
        }
        if self.nodeIp != nil {
            map["NodeIp"] = self.nodeIp!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.SQLId != nil {
            map["SQLId"] = self.SQLId!
        }
        if self.searchKeyWord != nil {
            map["SearchKeyWord"] = self.searchKeyWord!
        }
        if self.searchParameter != nil {
            map["SearchParameter"] = self.searchParameter!
        }
        if self.searchRule != nil {
            map["SearchRule"] = self.searchRule!
        }
        if self.searchValue != nil {
            map["SearchValue"] = self.searchValue!
        }
        if self.sortColumn != nil {
            map["SortColumn"] = self.sortColumn!
        }
        if self.sortOrder != nil {
            map["SortOrder"] = self.sortOrder!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("FilterCondition") {
            self.filterConditionShrink = dict["FilterCondition"] as! String
        }
        if dict.keys.contains("NodeIp") {
            self.nodeIp = dict["NodeIp"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SQLId") {
            self.SQLId = dict["SQLId"] as! String
        }
        if dict.keys.contains("SearchKeyWord") {
            self.searchKeyWord = dict["SearchKeyWord"] as! String
        }
        if dict.keys.contains("SearchParameter") {
            self.searchParameter = dict["SearchParameter"] as! String
        }
        if dict.keys.contains("SearchRule") {
            self.searchRule = dict["SearchRule"] as! String
        }
        if dict.keys.contains("SearchValue") {
            self.searchValue = dict["SearchValue"] as! String
        }
        if dict.keys.contains("SortColumn") {
            self.sortColumn = dict["SortColumn"] as! String
        }
        if dict.keys.contains("SortOrder") {
            self.sortOrder = dict["SortOrder"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class DescribeTopSQLListResponseBody : Tea.TeaModel {
    public class TopSQLList : Tea.TeaModel {
        public var affectedRows: Int64?

        public var appWaitTime: Double?

        public var blockCacheHit: Int64?

        public var blockIndexCacheHit: Int64?

        public var bloomFilterCacheHit: Int64?

        public var clientIp: String?

        public var concurrencyWaitTime: Double?

        public var cpuTime: Double?

        public var dbName: String?

        public var decodeTime: Double?

        public var diskRead: Int64?

        public var elapsedTime: Double?

        public var event: String?

        public var execPerSecond: Double?

        public var executeTime: Double?

        public var executions: Int64?

        public var failTimes: Int64?

        public var getPlanTime: Double?

        public var IOWaitTime: Double?

        public var key: Int64?

        public var logicalRead: Int64?

        public var maxCpuTime: Double?

        public var maxElapsedTime: Double?

        public var memstoreReadRowCount: Int64?

        public var missPlans: Int64?

        public var netWaitTime: Double?

        public var nodeIp: String?

        public var queueTime: Double?

        public var RPCCount: Int64?

        public var remotePlans: Int64?

        public var retryCount: Int64?

        public var returnRows: Int64?

        public var rowCacheHit: Int64?

        public var SQLId: String?

        public var SQLText: String?

        public var SQLType: Int64?

        public var scheduleTime: Double?

        public var ssstoreReadRowCount: Int64?

        public var totalWaitTime: Double?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.affectedRows != nil {
                map["AffectedRows"] = self.affectedRows!
            }
            if self.appWaitTime != nil {
                map["AppWaitTime"] = self.appWaitTime!
            }
            if self.blockCacheHit != nil {
                map["BlockCacheHit"] = self.blockCacheHit!
            }
            if self.blockIndexCacheHit != nil {
                map["BlockIndexCacheHit"] = self.blockIndexCacheHit!
            }
            if self.bloomFilterCacheHit != nil {
                map["BloomFilterCacheHit"] = self.bloomFilterCacheHit!
            }
            if self.clientIp != nil {
                map["ClientIp"] = self.clientIp!
            }
            if self.concurrencyWaitTime != nil {
                map["ConcurrencyWaitTime"] = self.concurrencyWaitTime!
            }
            if self.cpuTime != nil {
                map["CpuTime"] = self.cpuTime!
            }
            if self.dbName != nil {
                map["DbName"] = self.dbName!
            }
            if self.decodeTime != nil {
                map["DecodeTime"] = self.decodeTime!
            }
            if self.diskRead != nil {
                map["DiskRead"] = self.diskRead!
            }
            if self.elapsedTime != nil {
                map["ElapsedTime"] = self.elapsedTime!
            }
            if self.event != nil {
                map["Event"] = self.event!
            }
            if self.execPerSecond != nil {
                map["ExecPerSecond"] = self.execPerSecond!
            }
            if self.executeTime != nil {
                map["ExecuteTime"] = self.executeTime!
            }
            if self.executions != nil {
                map["Executions"] = self.executions!
            }
            if self.failTimes != nil {
                map["FailTimes"] = self.failTimes!
            }
            if self.getPlanTime != nil {
                map["GetPlanTime"] = self.getPlanTime!
            }
            if self.IOWaitTime != nil {
                map["IOWaitTime"] = self.IOWaitTime!
            }
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.logicalRead != nil {
                map["LogicalRead"] = self.logicalRead!
            }
            if self.maxCpuTime != nil {
                map["MaxCpuTime"] = self.maxCpuTime!
            }
            if self.maxElapsedTime != nil {
                map["MaxElapsedTime"] = self.maxElapsedTime!
            }
            if self.memstoreReadRowCount != nil {
                map["MemstoreReadRowCount"] = self.memstoreReadRowCount!
            }
            if self.missPlans != nil {
                map["MissPlans"] = self.missPlans!
            }
            if self.netWaitTime != nil {
                map["NetWaitTime"] = self.netWaitTime!
            }
            if self.nodeIp != nil {
                map["NodeIp"] = self.nodeIp!
            }
            if self.queueTime != nil {
                map["QueueTime"] = self.queueTime!
            }
            if self.RPCCount != nil {
                map["RPCCount"] = self.RPCCount!
            }
            if self.remotePlans != nil {
                map["RemotePlans"] = self.remotePlans!
            }
            if self.retryCount != nil {
                map["RetryCount"] = self.retryCount!
            }
            if self.returnRows != nil {
                map["ReturnRows"] = self.returnRows!
            }
            if self.rowCacheHit != nil {
                map["RowCacheHit"] = self.rowCacheHit!
            }
            if self.SQLId != nil {
                map["SQLId"] = self.SQLId!
            }
            if self.SQLText != nil {
                map["SQLText"] = self.SQLText!
            }
            if self.SQLType != nil {
                map["SQLType"] = self.SQLType!
            }
            if self.scheduleTime != nil {
                map["ScheduleTime"] = self.scheduleTime!
            }
            if self.ssstoreReadRowCount != nil {
                map["SsstoreReadRowCount"] = self.ssstoreReadRowCount!
            }
            if self.totalWaitTime != nil {
                map["TotalWaitTime"] = self.totalWaitTime!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AffectedRows") {
                self.affectedRows = dict["AffectedRows"] as! Int64
            }
            if dict.keys.contains("AppWaitTime") {
                self.appWaitTime = dict["AppWaitTime"] as! Double
            }
            if dict.keys.contains("BlockCacheHit") {
                self.blockCacheHit = dict["BlockCacheHit"] as! Int64
            }
            if dict.keys.contains("BlockIndexCacheHit") {
                self.blockIndexCacheHit = dict["BlockIndexCacheHit"] as! Int64
            }
            if dict.keys.contains("BloomFilterCacheHit") {
                self.bloomFilterCacheHit = dict["BloomFilterCacheHit"] as! Int64
            }
            if dict.keys.contains("ClientIp") {
                self.clientIp = dict["ClientIp"] as! String
            }
            if dict.keys.contains("ConcurrencyWaitTime") {
                self.concurrencyWaitTime = dict["ConcurrencyWaitTime"] as! Double
            }
            if dict.keys.contains("CpuTime") {
                self.cpuTime = dict["CpuTime"] as! Double
            }
            if dict.keys.contains("DbName") {
                self.dbName = dict["DbName"] as! String
            }
            if dict.keys.contains("DecodeTime") {
                self.decodeTime = dict["DecodeTime"] as! Double
            }
            if dict.keys.contains("DiskRead") {
                self.diskRead = dict["DiskRead"] as! Int64
            }
            if dict.keys.contains("ElapsedTime") {
                self.elapsedTime = dict["ElapsedTime"] as! Double
            }
            if dict.keys.contains("Event") {
                self.event = dict["Event"] as! String
            }
            if dict.keys.contains("ExecPerSecond") {
                self.execPerSecond = dict["ExecPerSecond"] as! Double
            }
            if dict.keys.contains("ExecuteTime") {
                self.executeTime = dict["ExecuteTime"] as! Double
            }
            if dict.keys.contains("Executions") {
                self.executions = dict["Executions"] as! Int64
            }
            if dict.keys.contains("FailTimes") {
                self.failTimes = dict["FailTimes"] as! Int64
            }
            if dict.keys.contains("GetPlanTime") {
                self.getPlanTime = dict["GetPlanTime"] as! Double
            }
            if dict.keys.contains("IOWaitTime") {
                self.IOWaitTime = dict["IOWaitTime"] as! Double
            }
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! Int64
            }
            if dict.keys.contains("LogicalRead") {
                self.logicalRead = dict["LogicalRead"] as! Int64
            }
            if dict.keys.contains("MaxCpuTime") {
                self.maxCpuTime = dict["MaxCpuTime"] as! Double
            }
            if dict.keys.contains("MaxElapsedTime") {
                self.maxElapsedTime = dict["MaxElapsedTime"] as! Double
            }
            if dict.keys.contains("MemstoreReadRowCount") {
                self.memstoreReadRowCount = dict["MemstoreReadRowCount"] as! Int64
            }
            if dict.keys.contains("MissPlans") {
                self.missPlans = dict["MissPlans"] as! Int64
            }
            if dict.keys.contains("NetWaitTime") {
                self.netWaitTime = dict["NetWaitTime"] as! Double
            }
            if dict.keys.contains("NodeIp") {
                self.nodeIp = dict["NodeIp"] as! String
            }
            if dict.keys.contains("QueueTime") {
                self.queueTime = dict["QueueTime"] as! Double
            }
            if dict.keys.contains("RPCCount") {
                self.RPCCount = dict["RPCCount"] as! Int64
            }
            if dict.keys.contains("RemotePlans") {
                self.remotePlans = dict["RemotePlans"] as! Int64
            }
            if dict.keys.contains("RetryCount") {
                self.retryCount = dict["RetryCount"] as! Int64
            }
            if dict.keys.contains("ReturnRows") {
                self.returnRows = dict["ReturnRows"] as! Int64
            }
            if dict.keys.contains("RowCacheHit") {
                self.rowCacheHit = dict["RowCacheHit"] as! Int64
            }
            if dict.keys.contains("SQLId") {
                self.SQLId = dict["SQLId"] as! String
            }
            if dict.keys.contains("SQLText") {
                self.SQLText = dict["SQLText"] as! String
            }
            if dict.keys.contains("SQLType") {
                self.SQLType = dict["SQLType"] as! Int64
            }
            if dict.keys.contains("ScheduleTime") {
                self.scheduleTime = dict["ScheduleTime"] as! Double
            }
            if dict.keys.contains("SsstoreReadRowCount") {
                self.ssstoreReadRowCount = dict["SsstoreReadRowCount"] as! Int64
            }
            if dict.keys.contains("TotalWaitTime") {
                self.totalWaitTime = dict["TotalWaitTime"] as! Double
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public var requestId: String?

    public var topSQLList: [DescribeTopSQLListResponseBody.TopSQLList]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.topSQLList != nil {
            var tmp : [Any] = []
            for k in self.topSQLList! {
                tmp.append(k.toMap())
            }
            map["TopSQLList"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TopSQLList") {
            var tmp : [DescribeTopSQLListResponseBody.TopSQLList] = []
            for v in dict["TopSQLList"] as! [Any] {
                var model = DescribeTopSQLListResponseBody.TopSQLList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.topSQLList = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeTopSQLListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTopSQLListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTopSQLListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeZonesRequest : Tea.TeaModel {
    public var cpuArch: String?

    public var deployType: String?

    public var series: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cpuArch != nil {
            map["CpuArch"] = self.cpuArch!
        }
        if self.deployType != nil {
            map["DeployType"] = self.deployType!
        }
        if self.series != nil {
            map["Series"] = self.series!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CpuArch") {
            self.cpuArch = dict["CpuArch"] as! String
        }
        if dict.keys.contains("DeployType") {
            self.deployType = dict["DeployType"] as! String
        }
        if dict.keys.contains("Series") {
            self.series = dict["Series"] as! String
        }
    }
}

public class DescribeZonesResponseBody : Tea.TeaModel {
    public class Zones : Tea.TeaModel {
        public var deployType: String?

        public var series: String?

        public var zoneId: String?

        public var zoneName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deployType != nil {
                map["DeployType"] = self.deployType!
            }
            if self.series != nil {
                map["Series"] = self.series!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            if self.zoneName != nil {
                map["ZoneName"] = self.zoneName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeployType") {
                self.deployType = dict["DeployType"] as! String
            }
            if dict.keys.contains("Series") {
                self.series = dict["Series"] as! String
            }
            if dict.keys.contains("ZoneId") {
                self.zoneId = dict["ZoneId"] as! String
            }
            if dict.keys.contains("ZoneName") {
                self.zoneName = dict["ZoneName"] as! String
            }
        }
    }
    public var requestId: String?

    public var zones: [DescribeZonesResponseBody.Zones]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.zones != nil {
            var tmp : [Any] = []
            for k in self.zones! {
                tmp.append(k.toMap())
            }
            map["Zones"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Zones") {
            var tmp : [DescribeZonesResponseBody.Zones] = []
            for v in dict["Zones"] as! [Any] {
                var model = DescribeZonesResponseBody.Zones()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.zones = tmp
        }
    }
}

public class DescribeZonesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeZonesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeZonesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUploadOssUrlRequest : Tea.TeaModel {
    public var effectiveTimeMinutes: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.effectiveTimeMinutes != nil {
            map["EffectiveTimeMinutes"] = self.effectiveTimeMinutes!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EffectiveTimeMinutes") {
            self.effectiveTimeMinutes = dict["EffectiveTimeMinutes"] as! Int32
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetUploadOssUrlResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var expectedExpirationTime: String?

        public var ossKey: String?

        public var ossUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.expectedExpirationTime != nil {
                map["ExpectedExpirationTime"] = self.expectedExpirationTime!
            }
            if self.ossKey != nil {
                map["OssKey"] = self.ossKey!
            }
            if self.ossUrl != nil {
                map["OssUrl"] = self.ossUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ExpectedExpirationTime") {
                self.expectedExpirationTime = dict["ExpectedExpirationTime"] as! String
            }
            if dict.keys.contains("OssKey") {
                self.ossKey = dict["OssKey"] as! String
            }
            if dict.keys.contains("OssUrl") {
                self.ossUrl = dict["OssUrl"] as! String
            }
        }
    }
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: GetUploadOssUrlResponseBody.Data?

    public var errorDetail: GetUploadOssUrlResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetUploadOssUrlResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorDetail") {
            var model = GetUploadOssUrlResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class GetUploadOssUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUploadOssUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetUploadOssUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class KillProcessListRequest : Tea.TeaModel {
    public var instanceId: String?

    public var sessionList: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.sessionList != nil {
            map["SessionList"] = self.sessionList!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SessionList") {
            self.sessionList = dict["SessionList"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class KillProcessListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clientIp: String?

        public var command: String?

        public var database: String?

        public var errorMessage: String?

        public var executeTime: String?

        public var serverIp: String?

        public var sessionId: Int64?

        public var sqlText: String?

        public var status: String?

        public var tenantId: String?

        public var user: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientIp != nil {
                map["ClientIp"] = self.clientIp!
            }
            if self.command != nil {
                map["Command"] = self.command!
            }
            if self.database != nil {
                map["Database"] = self.database!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.executeTime != nil {
                map["ExecuteTime"] = self.executeTime!
            }
            if self.serverIp != nil {
                map["ServerIp"] = self.serverIp!
            }
            if self.sessionId != nil {
                map["SessionId"] = self.sessionId!
            }
            if self.sqlText != nil {
                map["SqlText"] = self.sqlText!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.user != nil {
                map["User"] = self.user!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClientIp") {
                self.clientIp = dict["ClientIp"] as! String
            }
            if dict.keys.contains("Command") {
                self.command = dict["Command"] as! String
            }
            if dict.keys.contains("Database") {
                self.database = dict["Database"] as! String
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("ExecuteTime") {
                self.executeTime = dict["ExecuteTime"] as! String
            }
            if dict.keys.contains("ServerIp") {
                self.serverIp = dict["ServerIp"] as! String
            }
            if dict.keys.contains("SessionId") {
                self.sessionId = dict["SessionId"] as! Int64
            }
            if dict.keys.contains("SqlText") {
                self.sqlText = dict["SqlText"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! String
            }
            if dict.keys.contains("User") {
                self.user = dict["User"] as! String
            }
        }
    }
    public var data: [KillProcessListResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [KillProcessListResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = KillProcessListResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class KillProcessListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: KillProcessListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = KillProcessListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAllLabelsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var id: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
        }
    }
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: [ListAllLabelsResponseBody.Data]?

    public var errorDetail: ListAllLabelsResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [ListAllLabelsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListAllLabelsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorDetail") {
            var model = ListAllLabelsResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListAllLabelsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAllLabelsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAllLabelsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataSourceRequest : Tea.TeaModel {
    public var order: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var searchKey: String?

    public var sortField: String?

    public var types: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.sortField != nil {
            map["SortField"] = self.sortField!
        }
        if self.types != nil {
            map["Types"] = self.types!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Order") {
            self.order = dict["Order"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("SearchKey") {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("SortField") {
            self.sortField = dict["SortField"] as! String
        }
        if dict.keys.contains("Types") {
            self.types = dict["Types"] as! [String]
        }
    }
}

public class ListDataSourceShrinkRequest : Tea.TeaModel {
    public var order: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var searchKey: String?

    public var sortField: String?

    public var typesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.sortField != nil {
            map["SortField"] = self.sortField!
        }
        if self.typesShrink != nil {
            map["Types"] = self.typesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Order") {
            self.order = dict["Order"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("SearchKey") {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("SortField") {
            self.sortField = dict["SortField"] as! String
        }
        if dict.keys.contains("Types") {
            self.typesShrink = dict["Types"] as! String
        }
    }
}

public class ListDataSourceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var charset: String?

        public var cluster: String?

        public var connExtraAttributes: Any?

        public var description_: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: String?

        public var ip: String?

        public var name: String?

        public var operatingSystem: String?

        public var oracleNlsLengthSemantics: String?

        public var oracleSid: String?

        public var owner: String?

        public var partnerId: String?

        public var port: Int32?

        public var region: String?

        public var resourceOwner: String?

        public var role: String?

        public var schema: String?

        public var tenant: String?

        public var timezone: String?

        public var type: String?

        public var userName: String?

        public var version: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.charset != nil {
                map["Charset"] = self.charset!
            }
            if self.cluster != nil {
                map["Cluster"] = self.cluster!
            }
            if self.connExtraAttributes != nil {
                map["ConnExtraAttributes"] = self.connExtraAttributes!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.operatingSystem != nil {
                map["OperatingSystem"] = self.operatingSystem!
            }
            if self.oracleNlsLengthSemantics != nil {
                map["OracleNlsLengthSemantics"] = self.oracleNlsLengthSemantics!
            }
            if self.oracleSid != nil {
                map["OracleSid"] = self.oracleSid!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.partnerId != nil {
                map["PartnerId"] = self.partnerId!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.resourceOwner != nil {
                map["ResourceOwner"] = self.resourceOwner!
            }
            if self.role != nil {
                map["Role"] = self.role!
            }
            if self.schema != nil {
                map["Schema"] = self.schema!
            }
            if self.tenant != nil {
                map["Tenant"] = self.tenant!
            }
            if self.timezone != nil {
                map["Timezone"] = self.timezone!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Charset") {
                self.charset = dict["Charset"] as! String
            }
            if dict.keys.contains("Cluster") {
                self.cluster = dict["Cluster"] as! String
            }
            if dict.keys.contains("ConnExtraAttributes") {
                self.connExtraAttributes = dict["ConnExtraAttributes"] as! Any
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Ip") {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OperatingSystem") {
                self.operatingSystem = dict["OperatingSystem"] as! String
            }
            if dict.keys.contains("OracleNlsLengthSemantics") {
                self.oracleNlsLengthSemantics = dict["OracleNlsLengthSemantics"] as! String
            }
            if dict.keys.contains("OracleSid") {
                self.oracleSid = dict["OracleSid"] as! String
            }
            if dict.keys.contains("Owner") {
                self.owner = dict["Owner"] as! String
            }
            if dict.keys.contains("PartnerId") {
                self.partnerId = dict["PartnerId"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("ResourceOwner") {
                self.resourceOwner = dict["ResourceOwner"] as! String
            }
            if dict.keys.contains("Role") {
                self.role = dict["Role"] as! String
            }
            if dict.keys.contains("Schema") {
                self.schema = dict["Schema"] as! String
            }
            if dict.keys.contains("Tenant") {
                self.tenant = dict["Tenant"] as! String
            }
            if dict.keys.contains("Timezone") {
                self.timezone = dict["Timezone"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: [ListDataSourceResponseBody.Data]?

    public var errorDetail: ListDataSourceResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [ListDataSourceResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListDataSourceResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorDetail") {
            var model = ListDataSourceResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProjectFullVerifyResultRequest : Tea.TeaModel {
    public var destSchemas: [String]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: String?

    public var sourceSchemas: [String]?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destSchemas != nil {
            map["DestSchemas"] = self.destSchemas!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.sourceSchemas != nil {
            map["SourceSchemas"] = self.sourceSchemas!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestSchemas") {
            self.destSchemas = dict["DestSchemas"] as! [String]
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("SourceSchemas") {
            self.sourceSchemas = dict["SourceSchemas"] as! [String]
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListProjectFullVerifyResultShrinkRequest : Tea.TeaModel {
    public var destSchemasShrink: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: String?

    public var sourceSchemasShrink: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destSchemasShrink != nil {
            map["DestSchemas"] = self.destSchemasShrink!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.sourceSchemasShrink != nil {
            map["SourceSchemas"] = self.sourceSchemasShrink!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestSchemas") {
            self.destSchemasShrink = dict["DestSchemas"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("SourceSchemas") {
            self.sourceSchemasShrink = dict["SourceSchemas"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListProjectFullVerifyResultResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class FullVerifyTableStatistics : Tea.TeaModel {
            public class ErrorDetails : Tea.TeaModel {
                public var code: String?

                public var extraContext: [String: Any]?

                public var level: String?

                public var message: String?

                public var messageMcmsContext: [String: String]?

                public var messageMcmsKey: String?

                public var proposal: String?

                public var proposalMcmsContext: [String: String]?

                public var proposalMcmsKey: String?

                public var reason: String?

                public var reasonMcmsContext: [String: String]?

                public var reasonMcmsKey: String?

                public var upstreamErrorDetail: Any?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.extraContext != nil {
                        map["ExtraContext"] = self.extraContext!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.message != nil {
                        map["Message"] = self.message!
                    }
                    if self.messageMcmsContext != nil {
                        map["MessageMcmsContext"] = self.messageMcmsContext!
                    }
                    if self.messageMcmsKey != nil {
                        map["MessageMcmsKey"] = self.messageMcmsKey!
                    }
                    if self.proposal != nil {
                        map["Proposal"] = self.proposal!
                    }
                    if self.proposalMcmsContext != nil {
                        map["ProposalMcmsContext"] = self.proposalMcmsContext!
                    }
                    if self.proposalMcmsKey != nil {
                        map["ProposalMcmsKey"] = self.proposalMcmsKey!
                    }
                    if self.reason != nil {
                        map["Reason"] = self.reason!
                    }
                    if self.reasonMcmsContext != nil {
                        map["ReasonMcmsContext"] = self.reasonMcmsContext!
                    }
                    if self.reasonMcmsKey != nil {
                        map["ReasonMcmsKey"] = self.reasonMcmsKey!
                    }
                    if self.upstreamErrorDetail != nil {
                        map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Code") {
                        self.code = dict["Code"] as! String
                    }
                    if dict.keys.contains("ExtraContext") {
                        self.extraContext = dict["ExtraContext"] as! [String: Any]
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("Message") {
                        self.message = dict["Message"] as! String
                    }
                    if dict.keys.contains("MessageMcmsContext") {
                        self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
                    }
                    if dict.keys.contains("MessageMcmsKey") {
                        self.messageMcmsKey = dict["MessageMcmsKey"] as! String
                    }
                    if dict.keys.contains("Proposal") {
                        self.proposal = dict["Proposal"] as! String
                    }
                    if dict.keys.contains("ProposalMcmsContext") {
                        self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
                    }
                    if dict.keys.contains("ProposalMcmsKey") {
                        self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
                    }
                    if dict.keys.contains("Reason") {
                        self.reason = dict["Reason"] as! String
                    }
                    if dict.keys.contains("ReasonMcmsContext") {
                        self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
                    }
                    if dict.keys.contains("ReasonMcmsKey") {
                        self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
                    }
                    if dict.keys.contains("UpstreamErrorDetail") {
                        self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
                    }
                }
            }
            public var consistentCount: Int64?

            public var destOnlyCount: Int64?

            public var destSchemaName: String?

            public var errorDetails: [ListProjectFullVerifyResultResponseBody.Data.FullVerifyTableStatistics.ErrorDetails]?

            public var message: String?

            public var mismatchedCount: Int64?

            public var progress: String?

            public var resultDesc: String?

            public var resultType: String?

            public var sourceOnlyCount: Int64?

            public var sourceSchemaName: String?

            public var sourceTableName: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.consistentCount != nil {
                    map["ConsistentCount"] = self.consistentCount!
                }
                if self.destOnlyCount != nil {
                    map["DestOnlyCount"] = self.destOnlyCount!
                }
                if self.destSchemaName != nil {
                    map["DestSchemaName"] = self.destSchemaName!
                }
                if self.errorDetails != nil {
                    var tmp : [Any] = []
                    for k in self.errorDetails! {
                        tmp.append(k.toMap())
                    }
                    map["ErrorDetails"] = tmp
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.mismatchedCount != nil {
                    map["MismatchedCount"] = self.mismatchedCount!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.resultDesc != nil {
                    map["ResultDesc"] = self.resultDesc!
                }
                if self.resultType != nil {
                    map["ResultType"] = self.resultType!
                }
                if self.sourceOnlyCount != nil {
                    map["SourceOnlyCount"] = self.sourceOnlyCount!
                }
                if self.sourceSchemaName != nil {
                    map["SourceSchemaName"] = self.sourceSchemaName!
                }
                if self.sourceTableName != nil {
                    map["SourceTableName"] = self.sourceTableName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConsistentCount") {
                    self.consistentCount = dict["ConsistentCount"] as! Int64
                }
                if dict.keys.contains("DestOnlyCount") {
                    self.destOnlyCount = dict["DestOnlyCount"] as! Int64
                }
                if dict.keys.contains("DestSchemaName") {
                    self.destSchemaName = dict["DestSchemaName"] as! String
                }
                if dict.keys.contains("ErrorDetails") {
                    var tmp : [ListProjectFullVerifyResultResponseBody.Data.FullVerifyTableStatistics.ErrorDetails] = []
                    for v in dict["ErrorDetails"] as! [Any] {
                        var model = ListProjectFullVerifyResultResponseBody.Data.FullVerifyTableStatistics.ErrorDetails()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.errorDetails = tmp
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("MismatchedCount") {
                    self.mismatchedCount = dict["MismatchedCount"] as! Int64
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("ResultDesc") {
                    self.resultDesc = dict["ResultDesc"] as! String
                }
                if dict.keys.contains("ResultType") {
                    self.resultType = dict["ResultType"] as! String
                }
                if dict.keys.contains("SourceOnlyCount") {
                    self.sourceOnlyCount = dict["SourceOnlyCount"] as! Int64
                }
                if dict.keys.contains("SourceSchemaName") {
                    self.sourceSchemaName = dict["SourceSchemaName"] as! String
                }
                if dict.keys.contains("SourceTableName") {
                    self.sourceTableName = dict["SourceTableName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var differentNumber: Int64?

        public var fullVerifyTableStatistics: [ListProjectFullVerifyResultResponseBody.Data.FullVerifyTableStatistics]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.differentNumber != nil {
                map["DifferentNumber"] = self.differentNumber!
            }
            if self.fullVerifyTableStatistics != nil {
                var tmp : [Any] = []
                for k in self.fullVerifyTableStatistics! {
                    tmp.append(k.toMap())
                }
                map["FullVerifyTableStatistics"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DifferentNumber") {
                self.differentNumber = dict["DifferentNumber"] as! Int64
            }
            if dict.keys.contains("FullVerifyTableStatistics") {
                var tmp : [ListProjectFullVerifyResultResponseBody.Data.FullVerifyTableStatistics] = []
                for v in dict["FullVerifyTableStatistics"] as! [Any] {
                    var model = ListProjectFullVerifyResultResponseBody.Data.FullVerifyTableStatistics()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fullVerifyTableStatistics = tmp
            }
        }
    }
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: ListProjectFullVerifyResultResponseBody.Data?

    public var errorDetail: ListProjectFullVerifyResultResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListProjectFullVerifyResultResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorDetail") {
            var model = ListProjectFullVerifyResultResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListProjectFullVerifyResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProjectFullVerifyResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListProjectFullVerifyResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProjectModifyRecordsRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class ListProjectModifyRecordsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Databases : Tea.TeaModel {
            public class SpecificTables : Tea.TeaModel {
                public class AdbTableSchema : Tea.TeaModel {
                    public var distributedKeys: [String]?

                    public var partitionLifeCycle: Int32?

                    public var partitionStatement: String?

                    public var primaryKeys: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.distributedKeys != nil {
                            map["DistributedKeys"] = self.distributedKeys!
                        }
                        if self.partitionLifeCycle != nil {
                            map["PartitionLifeCycle"] = self.partitionLifeCycle!
                        }
                        if self.partitionStatement != nil {
                            map["PartitionStatement"] = self.partitionStatement!
                        }
                        if self.primaryKeys != nil {
                            map["PrimaryKeys"] = self.primaryKeys!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DistributedKeys") {
                            self.distributedKeys = dict["DistributedKeys"] as! [String]
                        }
                        if dict.keys.contains("PartitionLifeCycle") {
                            self.partitionLifeCycle = dict["PartitionLifeCycle"] as! Int32
                        }
                        if dict.keys.contains("PartitionStatement") {
                            self.partitionStatement = dict["PartitionStatement"] as! String
                        }
                        if dict.keys.contains("PrimaryKeys") {
                            self.primaryKeys = dict["PrimaryKeys"] as! [String]
                        }
                    }
                }
                public class Columns : Tea.TeaModel {
                    public var columnComment: String?

                    public var columnKey: String?

                    public var columnName: String?

                    public var columnType: String?

                    public var dataLength: Int64?

                    public var dataPrecision: Int32?

                    public var dataScale: Int32?

                    public var defaultValue: String?

                    public var encoding: String?

                    public var isGenerateField: Bool?

                    public var mappedName: String?

                    public var nullable: Bool?

                    public var position: Int32?

                    public var rawColumnType: String?

                    public var recordFieldType: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.columnComment != nil {
                            map["ColumnComment"] = self.columnComment!
                        }
                        if self.columnKey != nil {
                            map["ColumnKey"] = self.columnKey!
                        }
                        if self.columnName != nil {
                            map["ColumnName"] = self.columnName!
                        }
                        if self.columnType != nil {
                            map["ColumnType"] = self.columnType!
                        }
                        if self.dataLength != nil {
                            map["DataLength"] = self.dataLength!
                        }
                        if self.dataPrecision != nil {
                            map["DataPrecision"] = self.dataPrecision!
                        }
                        if self.dataScale != nil {
                            map["DataScale"] = self.dataScale!
                        }
                        if self.defaultValue != nil {
                            map["DefaultValue"] = self.defaultValue!
                        }
                        if self.encoding != nil {
                            map["Encoding"] = self.encoding!
                        }
                        if self.isGenerateField != nil {
                            map["IsGenerateField"] = self.isGenerateField!
                        }
                        if self.mappedName != nil {
                            map["MappedName"] = self.mappedName!
                        }
                        if self.nullable != nil {
                            map["Nullable"] = self.nullable!
                        }
                        if self.position != nil {
                            map["Position"] = self.position!
                        }
                        if self.rawColumnType != nil {
                            map["RawColumnType"] = self.rawColumnType!
                        }
                        if self.recordFieldType != nil {
                            map["RecordFieldType"] = self.recordFieldType!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ColumnComment") {
                            self.columnComment = dict["ColumnComment"] as! String
                        }
                        if dict.keys.contains("ColumnKey") {
                            self.columnKey = dict["ColumnKey"] as! String
                        }
                        if dict.keys.contains("ColumnName") {
                            self.columnName = dict["ColumnName"] as! String
                        }
                        if dict.keys.contains("ColumnType") {
                            self.columnType = dict["ColumnType"] as! String
                        }
                        if dict.keys.contains("DataLength") {
                            self.dataLength = dict["DataLength"] as! Int64
                        }
                        if dict.keys.contains("DataPrecision") {
                            self.dataPrecision = dict["DataPrecision"] as! Int32
                        }
                        if dict.keys.contains("DataScale") {
                            self.dataScale = dict["DataScale"] as! Int32
                        }
                        if dict.keys.contains("DefaultValue") {
                            self.defaultValue = dict["DefaultValue"] as! String
                        }
                        if dict.keys.contains("Encoding") {
                            self.encoding = dict["Encoding"] as! String
                        }
                        if dict.keys.contains("IsGenerateField") {
                            self.isGenerateField = dict["IsGenerateField"] as! Bool
                        }
                        if dict.keys.contains("MappedName") {
                            self.mappedName = dict["MappedName"] as! String
                        }
                        if dict.keys.contains("Nullable") {
                            self.nullable = dict["Nullable"] as! Bool
                        }
                        if dict.keys.contains("Position") {
                            self.position = dict["Position"] as! Int32
                        }
                        if dict.keys.contains("RawColumnType") {
                            self.rawColumnType = dict["RawColumnType"] as! String
                        }
                        if dict.keys.contains("RecordFieldType") {
                            self.recordFieldType = dict["RecordFieldType"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var adbTableSchema: ListProjectModifyRecordsResponseBody.Data.Databases.SpecificTables.AdbTableSchema?

                public var columns: [ListProjectModifyRecordsResponseBody.Data.Databases.SpecificTables.Columns]?

                public var filterColumns: [String]?

                public var id: String?

                public var mappedName: String?

                public var name: String?

                public var shardColumns: [String]?

                public var whereClause: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.adbTableSchema?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adbTableSchema != nil {
                        map["AdbTableSchema"] = self.adbTableSchema?.toMap()
                    }
                    if self.columns != nil {
                        var tmp : [Any] = []
                        for k in self.columns! {
                            tmp.append(k.toMap())
                        }
                        map["Columns"] = tmp
                    }
                    if self.filterColumns != nil {
                        map["FilterColumns"] = self.filterColumns!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.mappedName != nil {
                        map["MappedName"] = self.mappedName!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.shardColumns != nil {
                        map["ShardColumns"] = self.shardColumns!
                    }
                    if self.whereClause != nil {
                        map["WhereClause"] = self.whereClause!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AdbTableSchema") {
                        var model = ListProjectModifyRecordsResponseBody.Data.Databases.SpecificTables.AdbTableSchema()
                        model.fromMap(dict["AdbTableSchema"] as! [String: Any])
                        self.adbTableSchema = model
                    }
                    if dict.keys.contains("Columns") {
                        var tmp : [ListProjectModifyRecordsResponseBody.Data.Databases.SpecificTables.Columns] = []
                        for v in dict["Columns"] as! [Any] {
                            var model = ListProjectModifyRecordsResponseBody.Data.Databases.SpecificTables.Columns()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.columns = tmp
                    }
                    if dict.keys.contains("FilterColumns") {
                        self.filterColumns = dict["FilterColumns"] as! [String]
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("MappedName") {
                        self.mappedName = dict["MappedName"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("ShardColumns") {
                        self.shardColumns = dict["ShardColumns"] as! [String]
                    }
                    if dict.keys.contains("WhereClause") {
                        self.whereClause = dict["WhereClause"] as! String
                    }
                }
            }
            public class SpecificViews : Tea.TeaModel {
                public class AdbTableSchema : Tea.TeaModel {
                    public var distributedKeys: [String]?

                    public var partitionLifeCycle: Int32?

                    public var partitionStatement: String?

                    public var primaryKeys: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.distributedKeys != nil {
                            map["DistributedKeys"] = self.distributedKeys!
                        }
                        if self.partitionLifeCycle != nil {
                            map["PartitionLifeCycle"] = self.partitionLifeCycle!
                        }
                        if self.partitionStatement != nil {
                            map["PartitionStatement"] = self.partitionStatement!
                        }
                        if self.primaryKeys != nil {
                            map["PrimaryKeys"] = self.primaryKeys!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DistributedKeys") {
                            self.distributedKeys = dict["DistributedKeys"] as! [String]
                        }
                        if dict.keys.contains("PartitionLifeCycle") {
                            self.partitionLifeCycle = dict["PartitionLifeCycle"] as! Int32
                        }
                        if dict.keys.contains("PartitionStatement") {
                            self.partitionStatement = dict["PartitionStatement"] as! String
                        }
                        if dict.keys.contains("PrimaryKeys") {
                            self.primaryKeys = dict["PrimaryKeys"] as! [String]
                        }
                    }
                }
                public class Columns : Tea.TeaModel {
                    public var columnComment: String?

                    public var columnKey: String?

                    public var columnName: String?

                    public var columnType: String?

                    public var dataLength: Int64?

                    public var dataPrecision: Int32?

                    public var dataScale: Int32?

                    public var defaultValue: String?

                    public var encoding: String?

                    public var isGenerateField: Bool?

                    public var mappedName: String?

                    public var nullable: Bool?

                    public var position: Int32?

                    public var rawColumnType: String?

                    public var recordFieldType: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.columnComment != nil {
                            map["ColumnComment"] = self.columnComment!
                        }
                        if self.columnKey != nil {
                            map["ColumnKey"] = self.columnKey!
                        }
                        if self.columnName != nil {
                            map["ColumnName"] = self.columnName!
                        }
                        if self.columnType != nil {
                            map["ColumnType"] = self.columnType!
                        }
                        if self.dataLength != nil {
                            map["DataLength"] = self.dataLength!
                        }
                        if self.dataPrecision != nil {
                            map["DataPrecision"] = self.dataPrecision!
                        }
                        if self.dataScale != nil {
                            map["DataScale"] = self.dataScale!
                        }
                        if self.defaultValue != nil {
                            map["DefaultValue"] = self.defaultValue!
                        }
                        if self.encoding != nil {
                            map["Encoding"] = self.encoding!
                        }
                        if self.isGenerateField != nil {
                            map["IsGenerateField"] = self.isGenerateField!
                        }
                        if self.mappedName != nil {
                            map["MappedName"] = self.mappedName!
                        }
                        if self.nullable != nil {
                            map["Nullable"] = self.nullable!
                        }
                        if self.position != nil {
                            map["Position"] = self.position!
                        }
                        if self.rawColumnType != nil {
                            map["RawColumnType"] = self.rawColumnType!
                        }
                        if self.recordFieldType != nil {
                            map["RecordFieldType"] = self.recordFieldType!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ColumnComment") {
                            self.columnComment = dict["ColumnComment"] as! String
                        }
                        if dict.keys.contains("ColumnKey") {
                            self.columnKey = dict["ColumnKey"] as! String
                        }
                        if dict.keys.contains("ColumnName") {
                            self.columnName = dict["ColumnName"] as! String
                        }
                        if dict.keys.contains("ColumnType") {
                            self.columnType = dict["ColumnType"] as! String
                        }
                        if dict.keys.contains("DataLength") {
                            self.dataLength = dict["DataLength"] as! Int64
                        }
                        if dict.keys.contains("DataPrecision") {
                            self.dataPrecision = dict["DataPrecision"] as! Int32
                        }
                        if dict.keys.contains("DataScale") {
                            self.dataScale = dict["DataScale"] as! Int32
                        }
                        if dict.keys.contains("DefaultValue") {
                            self.defaultValue = dict["DefaultValue"] as! String
                        }
                        if dict.keys.contains("Encoding") {
                            self.encoding = dict["Encoding"] as! String
                        }
                        if dict.keys.contains("IsGenerateField") {
                            self.isGenerateField = dict["IsGenerateField"] as! Bool
                        }
                        if dict.keys.contains("MappedName") {
                            self.mappedName = dict["MappedName"] as! String
                        }
                        if dict.keys.contains("Nullable") {
                            self.nullable = dict["Nullable"] as! Bool
                        }
                        if dict.keys.contains("Position") {
                            self.position = dict["Position"] as! Int32
                        }
                        if dict.keys.contains("RawColumnType") {
                            self.rawColumnType = dict["RawColumnType"] as! String
                        }
                        if dict.keys.contains("RecordFieldType") {
                            self.recordFieldType = dict["RecordFieldType"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var adbTableSchema: ListProjectModifyRecordsResponseBody.Data.Databases.SpecificViews.AdbTableSchema?

                public var columns: [ListProjectModifyRecordsResponseBody.Data.Databases.SpecificViews.Columns]?

                public var filterColumns: [String]?

                public var id: String?

                public var mappedName: String?

                public var name: String?

                public var shardColumns: [String]?

                public var whereClause: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.adbTableSchema?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adbTableSchema != nil {
                        map["AdbTableSchema"] = self.adbTableSchema?.toMap()
                    }
                    if self.columns != nil {
                        var tmp : [Any] = []
                        for k in self.columns! {
                            tmp.append(k.toMap())
                        }
                        map["Columns"] = tmp
                    }
                    if self.filterColumns != nil {
                        map["FilterColumns"] = self.filterColumns!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.mappedName != nil {
                        map["MappedName"] = self.mappedName!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.shardColumns != nil {
                        map["ShardColumns"] = self.shardColumns!
                    }
                    if self.whereClause != nil {
                        map["WhereClause"] = self.whereClause!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AdbTableSchema") {
                        var model = ListProjectModifyRecordsResponseBody.Data.Databases.SpecificViews.AdbTableSchema()
                        model.fromMap(dict["AdbTableSchema"] as! [String: Any])
                        self.adbTableSchema = model
                    }
                    if dict.keys.contains("Columns") {
                        var tmp : [ListProjectModifyRecordsResponseBody.Data.Databases.SpecificViews.Columns] = []
                        for v in dict["Columns"] as! [Any] {
                            var model = ListProjectModifyRecordsResponseBody.Data.Databases.SpecificViews.Columns()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.columns = tmp
                    }
                    if dict.keys.contains("FilterColumns") {
                        self.filterColumns = dict["FilterColumns"] as! [String]
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("MappedName") {
                        self.mappedName = dict["MappedName"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("ShardColumns") {
                        self.shardColumns = dict["ShardColumns"] as! [String]
                    }
                    if dict.keys.contains("WhereClause") {
                        self.whereClause = dict["WhereClause"] as! String
                    }
                }
            }
            public class Tables : Tea.TeaModel {
                public class AdbTableSchema : Tea.TeaModel {
                    public var distributedKeys: [String]?

                    public var partitionLifeCycle: Int32?

                    public var partitionStatement: String?

                    public var primaryKeys: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.distributedKeys != nil {
                            map["DistributedKeys"] = self.distributedKeys!
                        }
                        if self.partitionLifeCycle != nil {
                            map["PartitionLifeCycle"] = self.partitionLifeCycle!
                        }
                        if self.partitionStatement != nil {
                            map["PartitionStatement"] = self.partitionStatement!
                        }
                        if self.primaryKeys != nil {
                            map["PrimaryKeys"] = self.primaryKeys!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DistributedKeys") {
                            self.distributedKeys = dict["DistributedKeys"] as! [String]
                        }
                        if dict.keys.contains("PartitionLifeCycle") {
                            self.partitionLifeCycle = dict["PartitionLifeCycle"] as! Int32
                        }
                        if dict.keys.contains("PartitionStatement") {
                            self.partitionStatement = dict["PartitionStatement"] as! String
                        }
                        if dict.keys.contains("PrimaryKeys") {
                            self.primaryKeys = dict["PrimaryKeys"] as! [String]
                        }
                    }
                }
                public class Columns : Tea.TeaModel {
                    public var columnComment: String?

                    public var columnKey: String?

                    public var columnName: String?

                    public var columnType: String?

                    public var dataLength: Int64?

                    public var dataPrecision: Int32?

                    public var dataScale: Int32?

                    public var defaultValue: String?

                    public var encoding: String?

                    public var isGenerateField: Bool?

                    public var mappedName: String?

                    public var nullable: Bool?

                    public var position: Int32?

                    public var rawColumnType: String?

                    public var recordFieldType: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.columnComment != nil {
                            map["ColumnComment"] = self.columnComment!
                        }
                        if self.columnKey != nil {
                            map["ColumnKey"] = self.columnKey!
                        }
                        if self.columnName != nil {
                            map["ColumnName"] = self.columnName!
                        }
                        if self.columnType != nil {
                            map["ColumnType"] = self.columnType!
                        }
                        if self.dataLength != nil {
                            map["DataLength"] = self.dataLength!
                        }
                        if self.dataPrecision != nil {
                            map["DataPrecision"] = self.dataPrecision!
                        }
                        if self.dataScale != nil {
                            map["DataScale"] = self.dataScale!
                        }
                        if self.defaultValue != nil {
                            map["DefaultValue"] = self.defaultValue!
                        }
                        if self.encoding != nil {
                            map["Encoding"] = self.encoding!
                        }
                        if self.isGenerateField != nil {
                            map["IsGenerateField"] = self.isGenerateField!
                        }
                        if self.mappedName != nil {
                            map["MappedName"] = self.mappedName!
                        }
                        if self.nullable != nil {
                            map["Nullable"] = self.nullable!
                        }
                        if self.position != nil {
                            map["Position"] = self.position!
                        }
                        if self.rawColumnType != nil {
                            map["RawColumnType"] = self.rawColumnType!
                        }
                        if self.recordFieldType != nil {
                            map["RecordFieldType"] = self.recordFieldType!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ColumnComment") {
                            self.columnComment = dict["ColumnComment"] as! String
                        }
                        if dict.keys.contains("ColumnKey") {
                            self.columnKey = dict["ColumnKey"] as! String
                        }
                        if dict.keys.contains("ColumnName") {
                            self.columnName = dict["ColumnName"] as! String
                        }
                        if dict.keys.contains("ColumnType") {
                            self.columnType = dict["ColumnType"] as! String
                        }
                        if dict.keys.contains("DataLength") {
                            self.dataLength = dict["DataLength"] as! Int64
                        }
                        if dict.keys.contains("DataPrecision") {
                            self.dataPrecision = dict["DataPrecision"] as! Int32
                        }
                        if dict.keys.contains("DataScale") {
                            self.dataScale = dict["DataScale"] as! Int32
                        }
                        if dict.keys.contains("DefaultValue") {
                            self.defaultValue = dict["DefaultValue"] as! String
                        }
                        if dict.keys.contains("Encoding") {
                            self.encoding = dict["Encoding"] as! String
                        }
                        if dict.keys.contains("IsGenerateField") {
                            self.isGenerateField = dict["IsGenerateField"] as! Bool
                        }
                        if dict.keys.contains("MappedName") {
                            self.mappedName = dict["MappedName"] as! String
                        }
                        if dict.keys.contains("Nullable") {
                            self.nullable = dict["Nullable"] as! Bool
                        }
                        if dict.keys.contains("Position") {
                            self.position = dict["Position"] as! Int32
                        }
                        if dict.keys.contains("RawColumnType") {
                            self.rawColumnType = dict["RawColumnType"] as! String
                        }
                        if dict.keys.contains("RecordFieldType") {
                            self.recordFieldType = dict["RecordFieldType"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var adbTableSchema: ListProjectModifyRecordsResponseBody.Data.Databases.Tables.AdbTableSchema?

                public var columns: [ListProjectModifyRecordsResponseBody.Data.Databases.Tables.Columns]?

                public var filterColumns: [String]?

                public var id: String?

                public var mappedName: String?

                public var name: String?

                public var shardColumns: [String]?

                public var whereClause: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.adbTableSchema?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adbTableSchema != nil {
                        map["AdbTableSchema"] = self.adbTableSchema?.toMap()
                    }
                    if self.columns != nil {
                        var tmp : [Any] = []
                        for k in self.columns! {
                            tmp.append(k.toMap())
                        }
                        map["Columns"] = tmp
                    }
                    if self.filterColumns != nil {
                        map["FilterColumns"] = self.filterColumns!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.mappedName != nil {
                        map["MappedName"] = self.mappedName!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.shardColumns != nil {
                        map["ShardColumns"] = self.shardColumns!
                    }
                    if self.whereClause != nil {
                        map["WhereClause"] = self.whereClause!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AdbTableSchema") {
                        var model = ListProjectModifyRecordsResponseBody.Data.Databases.Tables.AdbTableSchema()
                        model.fromMap(dict["AdbTableSchema"] as! [String: Any])
                        self.adbTableSchema = model
                    }
                    if dict.keys.contains("Columns") {
                        var tmp : [ListProjectModifyRecordsResponseBody.Data.Databases.Tables.Columns] = []
                        for v in dict["Columns"] as! [Any] {
                            var model = ListProjectModifyRecordsResponseBody.Data.Databases.Tables.Columns()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.columns = tmp
                    }
                    if dict.keys.contains("FilterColumns") {
                        self.filterColumns = dict["FilterColumns"] as! [String]
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("MappedName") {
                        self.mappedName = dict["MappedName"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("ShardColumns") {
                        self.shardColumns = dict["ShardColumns"] as! [String]
                    }
                    if dict.keys.contains("WhereClause") {
                        self.whereClause = dict["WhereClause"] as! String
                    }
                }
            }
            public class Views : Tea.TeaModel {
                public class AdbTableSchema : Tea.TeaModel {
                    public var distributedKeys: [String]?

                    public var partitionLifeCycle: Int32?

                    public var partitionStatement: String?

                    public var primaryKeys: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.distributedKeys != nil {
                            map["DistributedKeys"] = self.distributedKeys!
                        }
                        if self.partitionLifeCycle != nil {
                            map["PartitionLifeCycle"] = self.partitionLifeCycle!
                        }
                        if self.partitionStatement != nil {
                            map["PartitionStatement"] = self.partitionStatement!
                        }
                        if self.primaryKeys != nil {
                            map["PrimaryKeys"] = self.primaryKeys!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DistributedKeys") {
                            self.distributedKeys = dict["DistributedKeys"] as! [String]
                        }
                        if dict.keys.contains("PartitionLifeCycle") {
                            self.partitionLifeCycle = dict["PartitionLifeCycle"] as! Int32
                        }
                        if dict.keys.contains("PartitionStatement") {
                            self.partitionStatement = dict["PartitionStatement"] as! String
                        }
                        if dict.keys.contains("PrimaryKeys") {
                            self.primaryKeys = dict["PrimaryKeys"] as! [String]
                        }
                    }
                }
                public class Columns : Tea.TeaModel {
                    public var columnComment: String?

                    public var columnKey: String?

                    public var columnName: String?

                    public var columnType: String?

                    public var dataLength: Int64?

                    public var dataPrecision: Int32?

                    public var dataScale: Int32?

                    public var defaultValue: String?

                    public var encoding: String?

                    public var isGenerateField: Bool?

                    public var mappedName: String?

                    public var nullable: Bool?

                    public var position: Int32?

                    public var rawColumnType: String?

                    public var recordFieldType: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.columnComment != nil {
                            map["ColumnComment"] = self.columnComment!
                        }
                        if self.columnKey != nil {
                            map["ColumnKey"] = self.columnKey!
                        }
                        if self.columnName != nil {
                            map["ColumnName"] = self.columnName!
                        }
                        if self.columnType != nil {
                            map["ColumnType"] = self.columnType!
                        }
                        if self.dataLength != nil {
                            map["DataLength"] = self.dataLength!
                        }
                        if self.dataPrecision != nil {
                            map["DataPrecision"] = self.dataPrecision!
                        }
                        if self.dataScale != nil {
                            map["DataScale"] = self.dataScale!
                        }
                        if self.defaultValue != nil {
                            map["DefaultValue"] = self.defaultValue!
                        }
                        if self.encoding != nil {
                            map["Encoding"] = self.encoding!
                        }
                        if self.isGenerateField != nil {
                            map["IsGenerateField"] = self.isGenerateField!
                        }
                        if self.mappedName != nil {
                            map["MappedName"] = self.mappedName!
                        }
                        if self.nullable != nil {
                            map["Nullable"] = self.nullable!
                        }
                        if self.position != nil {
                            map["Position"] = self.position!
                        }
                        if self.rawColumnType != nil {
                            map["RawColumnType"] = self.rawColumnType!
                        }
                        if self.recordFieldType != nil {
                            map["RecordFieldType"] = self.recordFieldType!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ColumnComment") {
                            self.columnComment = dict["ColumnComment"] as! String
                        }
                        if dict.keys.contains("ColumnKey") {
                            self.columnKey = dict["ColumnKey"] as! String
                        }
                        if dict.keys.contains("ColumnName") {
                            self.columnName = dict["ColumnName"] as! String
                        }
                        if dict.keys.contains("ColumnType") {
                            self.columnType = dict["ColumnType"] as! String
                        }
                        if dict.keys.contains("DataLength") {
                            self.dataLength = dict["DataLength"] as! Int64
                        }
                        if dict.keys.contains("DataPrecision") {
                            self.dataPrecision = dict["DataPrecision"] as! Int32
                        }
                        if dict.keys.contains("DataScale") {
                            self.dataScale = dict["DataScale"] as! Int32
                        }
                        if dict.keys.contains("DefaultValue") {
                            self.defaultValue = dict["DefaultValue"] as! String
                        }
                        if dict.keys.contains("Encoding") {
                            self.encoding = dict["Encoding"] as! String
                        }
                        if dict.keys.contains("IsGenerateField") {
                            self.isGenerateField = dict["IsGenerateField"] as! Bool
                        }
                        if dict.keys.contains("MappedName") {
                            self.mappedName = dict["MappedName"] as! String
                        }
                        if dict.keys.contains("Nullable") {
                            self.nullable = dict["Nullable"] as! Bool
                        }
                        if dict.keys.contains("Position") {
                            self.position = dict["Position"] as! Int32
                        }
                        if dict.keys.contains("RawColumnType") {
                            self.rawColumnType = dict["RawColumnType"] as! String
                        }
                        if dict.keys.contains("RecordFieldType") {
                            self.recordFieldType = dict["RecordFieldType"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var adbTableSchema: ListProjectModifyRecordsResponseBody.Data.Databases.Views.AdbTableSchema?

                public var columns: [ListProjectModifyRecordsResponseBody.Data.Databases.Views.Columns]?

                public var filterColumns: [String]?

                public var id: String?

                public var mappedName: String?

                public var name: String?

                public var shardColumns: [String]?

                public var whereClause: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.adbTableSchema?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adbTableSchema != nil {
                        map["AdbTableSchema"] = self.adbTableSchema?.toMap()
                    }
                    if self.columns != nil {
                        var tmp : [Any] = []
                        for k in self.columns! {
                            tmp.append(k.toMap())
                        }
                        map["Columns"] = tmp
                    }
                    if self.filterColumns != nil {
                        map["FilterColumns"] = self.filterColumns!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.mappedName != nil {
                        map["MappedName"] = self.mappedName!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.shardColumns != nil {
                        map["ShardColumns"] = self.shardColumns!
                    }
                    if self.whereClause != nil {
                        map["WhereClause"] = self.whereClause!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AdbTableSchema") {
                        var model = ListProjectModifyRecordsResponseBody.Data.Databases.Views.AdbTableSchema()
                        model.fromMap(dict["AdbTableSchema"] as! [String: Any])
                        self.adbTableSchema = model
                    }
                    if dict.keys.contains("Columns") {
                        var tmp : [ListProjectModifyRecordsResponseBody.Data.Databases.Views.Columns] = []
                        for v in dict["Columns"] as! [Any] {
                            var model = ListProjectModifyRecordsResponseBody.Data.Databases.Views.Columns()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.columns = tmp
                    }
                    if dict.keys.contains("FilterColumns") {
                        self.filterColumns = dict["FilterColumns"] as! [String]
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("MappedName") {
                        self.mappedName = dict["MappedName"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("ShardColumns") {
                        self.shardColumns = dict["ShardColumns"] as! [String]
                    }
                    if dict.keys.contains("WhereClause") {
                        self.whereClause = dict["WhereClause"] as! String
                    }
                }
            }
            public var id: String?

            public var mappedName: String?

            public var name: String?

            public var specificTables: [ListProjectModifyRecordsResponseBody.Data.Databases.SpecificTables]?

            public var specificViews: [ListProjectModifyRecordsResponseBody.Data.Databases.SpecificViews]?

            public var tables: [ListProjectModifyRecordsResponseBody.Data.Databases.Tables]?

            public var views: [ListProjectModifyRecordsResponseBody.Data.Databases.Views]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.mappedName != nil {
                    map["MappedName"] = self.mappedName!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.specificTables != nil {
                    var tmp : [Any] = []
                    for k in self.specificTables! {
                        tmp.append(k.toMap())
                    }
                    map["SpecificTables"] = tmp
                }
                if self.specificViews != nil {
                    var tmp : [Any] = []
                    for k in self.specificViews! {
                        tmp.append(k.toMap())
                    }
                    map["SpecificViews"] = tmp
                }
                if self.tables != nil {
                    var tmp : [Any] = []
                    for k in self.tables! {
                        tmp.append(k.toMap())
                    }
                    map["Tables"] = tmp
                }
                if self.views != nil {
                    var tmp : [Any] = []
                    for k in self.views! {
                        tmp.append(k.toMap())
                    }
                    map["Views"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("MappedName") {
                    self.mappedName = dict["MappedName"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("SpecificTables") {
                    var tmp : [ListProjectModifyRecordsResponseBody.Data.Databases.SpecificTables] = []
                    for v in dict["SpecificTables"] as! [Any] {
                        var model = ListProjectModifyRecordsResponseBody.Data.Databases.SpecificTables()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.specificTables = tmp
                }
                if dict.keys.contains("SpecificViews") {
                    var tmp : [ListProjectModifyRecordsResponseBody.Data.Databases.SpecificViews] = []
                    for v in dict["SpecificViews"] as! [Any] {
                        var model = ListProjectModifyRecordsResponseBody.Data.Databases.SpecificViews()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.specificViews = tmp
                }
                if dict.keys.contains("Tables") {
                    var tmp : [ListProjectModifyRecordsResponseBody.Data.Databases.Tables] = []
                    for v in dict["Tables"] as! [Any] {
                        var model = ListProjectModifyRecordsResponseBody.Data.Databases.Tables()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tables = tmp
                }
                if dict.keys.contains("Views") {
                    var tmp : [ListProjectModifyRecordsResponseBody.Data.Databases.Views] = []
                    for v in dict["Views"] as! [Any] {
                        var model = ListProjectModifyRecordsResponseBody.Data.Databases.Views()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.views = tmp
                }
            }
        }
        public class ErrorDetail : Tea.TeaModel {
            public var code: String?

            public var extraContext: [String: Any]?

            public var level: String?

            public var message: String?

            public var messageMcmsContext: [String: String]?

            public var messageMcmsKey: String?

            public var proposal: String?

            public var proposalMcmsContext: [String: String]?

            public var proposalMcmsKey: String?

            public var reason: String?

            public var reasonMcmsContext: [String: String]?

            public var reasonMcmsKey: String?

            public var upstreamErrorDetail: Any?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.extraContext != nil {
                    map["ExtraContext"] = self.extraContext!
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.messageMcmsContext != nil {
                    map["MessageMcmsContext"] = self.messageMcmsContext!
                }
                if self.messageMcmsKey != nil {
                    map["MessageMcmsKey"] = self.messageMcmsKey!
                }
                if self.proposal != nil {
                    map["Proposal"] = self.proposal!
                }
                if self.proposalMcmsContext != nil {
                    map["ProposalMcmsContext"] = self.proposalMcmsContext!
                }
                if self.proposalMcmsKey != nil {
                    map["ProposalMcmsKey"] = self.proposalMcmsKey!
                }
                if self.reason != nil {
                    map["Reason"] = self.reason!
                }
                if self.reasonMcmsContext != nil {
                    map["ReasonMcmsContext"] = self.reasonMcmsContext!
                }
                if self.reasonMcmsKey != nil {
                    map["ReasonMcmsKey"] = self.reasonMcmsKey!
                }
                if self.upstreamErrorDetail != nil {
                    map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("ExtraContext") {
                    self.extraContext = dict["ExtraContext"] as! [String: Any]
                }
                if dict.keys.contains("Level") {
                    self.level = dict["Level"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("MessageMcmsContext") {
                    self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
                }
                if dict.keys.contains("MessageMcmsKey") {
                    self.messageMcmsKey = dict["MessageMcmsKey"] as! String
                }
                if dict.keys.contains("Proposal") {
                    self.proposal = dict["Proposal"] as! String
                }
                if dict.keys.contains("ProposalMcmsContext") {
                    self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
                }
                if dict.keys.contains("ProposalMcmsKey") {
                    self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
                }
                if dict.keys.contains("Reason") {
                    self.reason = dict["Reason"] as! String
                }
                if dict.keys.contains("ReasonMcmsContext") {
                    self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
                }
                if dict.keys.contains("ReasonMcmsKey") {
                    self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
                }
                if dict.keys.contains("UpstreamErrorDetail") {
                    self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
                }
            }
        }
        public class MigrationObjectsInfo : Tea.TeaModel {
            public class Tables : Tea.TeaModel {
                public var name: String?

                public var schema: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.schema != nil {
                        map["Schema"] = self.schema!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Schema") {
                        self.schema = dict["Schema"] as! String
                    }
                }
            }
            public class TablesBlack : Tea.TeaModel {
                public var name: String?

                public var schema: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.schema != nil {
                        map["Schema"] = self.schema!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Schema") {
                        self.schema = dict["Schema"] as! String
                    }
                }
            }
            public class Views : Tea.TeaModel {
                public var name: String?

                public var schema: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.schema != nil {
                        map["Schema"] = self.schema!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Schema") {
                        self.schema = dict["Schema"] as! String
                    }
                }
            }
            public class ViewsBlack : Tea.TeaModel {
                public var name: String?

                public var schema: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.schema != nil {
                        map["Schema"] = self.schema!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Schema") {
                        self.schema = dict["Schema"] as! String
                    }
                }
            }
            public var tables: [ListProjectModifyRecordsResponseBody.Data.MigrationObjectsInfo.Tables]?

            public var tablesBlack: [ListProjectModifyRecordsResponseBody.Data.MigrationObjectsInfo.TablesBlack]?

            public var views: [ListProjectModifyRecordsResponseBody.Data.MigrationObjectsInfo.Views]?

            public var viewsBlack: [ListProjectModifyRecordsResponseBody.Data.MigrationObjectsInfo.ViewsBlack]?

            public var wildcardMode: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tables != nil {
                    var tmp : [Any] = []
                    for k in self.tables! {
                        tmp.append(k.toMap())
                    }
                    map["Tables"] = tmp
                }
                if self.tablesBlack != nil {
                    var tmp : [Any] = []
                    for k in self.tablesBlack! {
                        tmp.append(k.toMap())
                    }
                    map["TablesBlack"] = tmp
                }
                if self.views != nil {
                    var tmp : [Any] = []
                    for k in self.views! {
                        tmp.append(k.toMap())
                    }
                    map["Views"] = tmp
                }
                if self.viewsBlack != nil {
                    var tmp : [Any] = []
                    for k in self.viewsBlack! {
                        tmp.append(k.toMap())
                    }
                    map["ViewsBlack"] = tmp
                }
                if self.wildcardMode != nil {
                    map["WildcardMode"] = self.wildcardMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Tables") {
                    var tmp : [ListProjectModifyRecordsResponseBody.Data.MigrationObjectsInfo.Tables] = []
                    for v in dict["Tables"] as! [Any] {
                        var model = ListProjectModifyRecordsResponseBody.Data.MigrationObjectsInfo.Tables()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tables = tmp
                }
                if dict.keys.contains("TablesBlack") {
                    var tmp : [ListProjectModifyRecordsResponseBody.Data.MigrationObjectsInfo.TablesBlack] = []
                    for v in dict["TablesBlack"] as! [Any] {
                        var model = ListProjectModifyRecordsResponseBody.Data.MigrationObjectsInfo.TablesBlack()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tablesBlack = tmp
                }
                if dict.keys.contains("Views") {
                    var tmp : [ListProjectModifyRecordsResponseBody.Data.MigrationObjectsInfo.Views] = []
                    for v in dict["Views"] as! [Any] {
                        var model = ListProjectModifyRecordsResponseBody.Data.MigrationObjectsInfo.Views()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.views = tmp
                }
                if dict.keys.contains("ViewsBlack") {
                    var tmp : [ListProjectModifyRecordsResponseBody.Data.MigrationObjectsInfo.ViewsBlack] = []
                    for v in dict["ViewsBlack"] as! [Any] {
                        var model = ListProjectModifyRecordsResponseBody.Data.MigrationObjectsInfo.ViewsBlack()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.viewsBlack = tmp
                }
                if dict.keys.contains("WildcardMode") {
                    self.wildcardMode = dict["WildcardMode"] as! Bool
                }
            }
        }
        public class OmsProjectMappingInfo : Tea.TeaModel {
            public class ColumnMappings : Tea.TeaModel {
                public var destName: String?

                public var sourceName: String?

                public var sourceSchema: String?

                public var sourceTable: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.destName != nil {
                        map["DestName"] = self.destName!
                    }
                    if self.sourceName != nil {
                        map["SourceName"] = self.sourceName!
                    }
                    if self.sourceSchema != nil {
                        map["SourceSchema"] = self.sourceSchema!
                    }
                    if self.sourceTable != nil {
                        map["SourceTable"] = self.sourceTable!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DestName") {
                        self.destName = dict["DestName"] as! String
                    }
                    if dict.keys.contains("SourceName") {
                        self.sourceName = dict["SourceName"] as! String
                    }
                    if dict.keys.contains("SourceSchema") {
                        self.sourceSchema = dict["SourceSchema"] as! String
                    }
                    if dict.keys.contains("SourceTable") {
                        self.sourceTable = dict["SourceTable"] as! String
                    }
                }
            }
            public class SchemaMappings : Tea.TeaModel {
                public var destName: String?

                public var sourceName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.destName != nil {
                        map["DestName"] = self.destName!
                    }
                    if self.sourceName != nil {
                        map["SourceName"] = self.sourceName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DestName") {
                        self.destName = dict["DestName"] as! String
                    }
                    if dict.keys.contains("SourceName") {
                        self.sourceName = dict["SourceName"] as! String
                    }
                }
            }
            public class TableMappings : Tea.TeaModel {
                public var destName: String?

                public var sourceName: String?

                public var sourceSchema: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.destName != nil {
                        map["DestName"] = self.destName!
                    }
                    if self.sourceName != nil {
                        map["SourceName"] = self.sourceName!
                    }
                    if self.sourceSchema != nil {
                        map["SourceSchema"] = self.sourceSchema!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DestName") {
                        self.destName = dict["DestName"] as! String
                    }
                    if dict.keys.contains("SourceName") {
                        self.sourceName = dict["SourceName"] as! String
                    }
                    if dict.keys.contains("SourceSchema") {
                        self.sourceSchema = dict["SourceSchema"] as! String
                    }
                }
            }
            public class ViewMappings : Tea.TeaModel {
                public var destName: String?

                public var sourceName: String?

                public var sourceSchema: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.destName != nil {
                        map["DestName"] = self.destName!
                    }
                    if self.sourceName != nil {
                        map["SourceName"] = self.sourceName!
                    }
                    if self.sourceSchema != nil {
                        map["SourceSchema"] = self.sourceSchema!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DestName") {
                        self.destName = dict["DestName"] as! String
                    }
                    if dict.keys.contains("SourceName") {
                        self.sourceName = dict["SourceName"] as! String
                    }
                    if dict.keys.contains("SourceSchema") {
                        self.sourceSchema = dict["SourceSchema"] as! String
                    }
                }
            }
            public var columnMappings: [ListProjectModifyRecordsResponseBody.Data.OmsProjectMappingInfo.ColumnMappings]?

            public var schemaMappings: [ListProjectModifyRecordsResponseBody.Data.OmsProjectMappingInfo.SchemaMappings]?

            public var tableMappings: [ListProjectModifyRecordsResponseBody.Data.OmsProjectMappingInfo.TableMappings]?

            public var viewMappings: [ListProjectModifyRecordsResponseBody.Data.OmsProjectMappingInfo.ViewMappings]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.columnMappings != nil {
                    var tmp : [Any] = []
                    for k in self.columnMappings! {
                        tmp.append(k.toMap())
                    }
                    map["ColumnMappings"] = tmp
                }
                if self.schemaMappings != nil {
                    var tmp : [Any] = []
                    for k in self.schemaMappings! {
                        tmp.append(k.toMap())
                    }
                    map["SchemaMappings"] = tmp
                }
                if self.tableMappings != nil {
                    var tmp : [Any] = []
                    for k in self.tableMappings! {
                        tmp.append(k.toMap())
                    }
                    map["TableMappings"] = tmp
                }
                if self.viewMappings != nil {
                    var tmp : [Any] = []
                    for k in self.viewMappings! {
                        tmp.append(k.toMap())
                    }
                    map["ViewMappings"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ColumnMappings") {
                    var tmp : [ListProjectModifyRecordsResponseBody.Data.OmsProjectMappingInfo.ColumnMappings] = []
                    for v in dict["ColumnMappings"] as! [Any] {
                        var model = ListProjectModifyRecordsResponseBody.Data.OmsProjectMappingInfo.ColumnMappings()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.columnMappings = tmp
                }
                if dict.keys.contains("SchemaMappings") {
                    var tmp : [ListProjectModifyRecordsResponseBody.Data.OmsProjectMappingInfo.SchemaMappings] = []
                    for v in dict["SchemaMappings"] as! [Any] {
                        var model = ListProjectModifyRecordsResponseBody.Data.OmsProjectMappingInfo.SchemaMappings()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.schemaMappings = tmp
                }
                if dict.keys.contains("TableMappings") {
                    var tmp : [ListProjectModifyRecordsResponseBody.Data.OmsProjectMappingInfo.TableMappings] = []
                    for v in dict["TableMappings"] as! [Any] {
                        var model = ListProjectModifyRecordsResponseBody.Data.OmsProjectMappingInfo.TableMappings()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tableMappings = tmp
                }
                if dict.keys.contains("ViewMappings") {
                    var tmp : [ListProjectModifyRecordsResponseBody.Data.OmsProjectMappingInfo.ViewMappings] = []
                    for v in dict["ViewMappings"] as! [Any] {
                        var model = ListProjectModifyRecordsResponseBody.Data.OmsProjectMappingInfo.ViewMappings()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.viewMappings = tmp
                }
            }
        }
        public class TableEtlList : Tea.TeaModel {
            public var database: String?

            public var destDatabase: String?

            public var destName: String?

            public var filterColumns: [String]?

            public var logicTableId: String?

            public var shardColumns: [String]?

            public var sourceEndpointId: String?

            public var tableName: String?

            public var tenantName: String?

            public var whereClause: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.database != nil {
                    map["Database"] = self.database!
                }
                if self.destDatabase != nil {
                    map["DestDatabase"] = self.destDatabase!
                }
                if self.destName != nil {
                    map["DestName"] = self.destName!
                }
                if self.filterColumns != nil {
                    map["FilterColumns"] = self.filterColumns!
                }
                if self.logicTableId != nil {
                    map["LogicTableId"] = self.logicTableId!
                }
                if self.shardColumns != nil {
                    map["ShardColumns"] = self.shardColumns!
                }
                if self.sourceEndpointId != nil {
                    map["SourceEndpointId"] = self.sourceEndpointId!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                if self.tenantName != nil {
                    map["TenantName"] = self.tenantName!
                }
                if self.whereClause != nil {
                    map["WhereClause"] = self.whereClause!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Database") {
                    self.database = dict["Database"] as! String
                }
                if dict.keys.contains("DestDatabase") {
                    self.destDatabase = dict["DestDatabase"] as! String
                }
                if dict.keys.contains("DestName") {
                    self.destName = dict["DestName"] as! String
                }
                if dict.keys.contains("FilterColumns") {
                    self.filterColumns = dict["FilterColumns"] as! [String]
                }
                if dict.keys.contains("LogicTableId") {
                    self.logicTableId = dict["LogicTableId"] as! String
                }
                if dict.keys.contains("ShardColumns") {
                    self.shardColumns = dict["ShardColumns"] as! [String]
                }
                if dict.keys.contains("SourceEndpointId") {
                    self.sourceEndpointId = dict["SourceEndpointId"] as! String
                }
                if dict.keys.contains("TableName") {
                    self.tableName = dict["TableName"] as! String
                }
                if dict.keys.contains("TenantName") {
                    self.tenantName = dict["TenantName"] as! String
                }
                if dict.keys.contains("WhereClause") {
                    self.whereClause = dict["WhereClause"] as! String
                }
            }
        }
        public var databases: [ListProjectModifyRecordsResponseBody.Data.Databases]?

        public var errorDetail: ListProjectModifyRecordsResponseBody.Data.ErrorDetail?

        public var gmtModified: String?

        public var id: Int64?

        public var mergeRequestId: Int64?

        public var migrationObjectsInfo: ListProjectModifyRecordsResponseBody.Data.MigrationObjectsInfo?

        public var omsProjectMappingInfo: ListProjectModifyRecordsResponseBody.Data.OmsProjectMappingInfo?

        public var status: String?

        public var subProjectId: String?

        public var tableEtlList: [ListProjectModifyRecordsResponseBody.Data.TableEtlList]?

        public var type: String?

        public var updateRequestId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.errorDetail?.validate()
            try self.migrationObjectsInfo?.validate()
            try self.omsProjectMappingInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.databases != nil {
                var tmp : [Any] = []
                for k in self.databases! {
                    tmp.append(k.toMap())
                }
                map["Databases"] = tmp
            }
            if self.errorDetail != nil {
                map["ErrorDetail"] = self.errorDetail?.toMap()
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.mergeRequestId != nil {
                map["MergeRequestId"] = self.mergeRequestId!
            }
            if self.migrationObjectsInfo != nil {
                map["MigrationObjectsInfo"] = self.migrationObjectsInfo?.toMap()
            }
            if self.omsProjectMappingInfo != nil {
                map["OmsProjectMappingInfo"] = self.omsProjectMappingInfo?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subProjectId != nil {
                map["SubProjectId"] = self.subProjectId!
            }
            if self.tableEtlList != nil {
                var tmp : [Any] = []
                for k in self.tableEtlList! {
                    tmp.append(k.toMap())
                }
                map["TableEtlList"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.updateRequestId != nil {
                map["UpdateRequestId"] = self.updateRequestId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Databases") {
                var tmp : [ListProjectModifyRecordsResponseBody.Data.Databases] = []
                for v in dict["Databases"] as! [Any] {
                    var model = ListProjectModifyRecordsResponseBody.Data.Databases()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.databases = tmp
            }
            if dict.keys.contains("ErrorDetail") {
                var model = ListProjectModifyRecordsResponseBody.Data.ErrorDetail()
                model.fromMap(dict["ErrorDetail"] as! [String: Any])
                self.errorDetail = model
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MergeRequestId") {
                self.mergeRequestId = dict["MergeRequestId"] as! Int64
            }
            if dict.keys.contains("MigrationObjectsInfo") {
                var model = ListProjectModifyRecordsResponseBody.Data.MigrationObjectsInfo()
                model.fromMap(dict["MigrationObjectsInfo"] as! [String: Any])
                self.migrationObjectsInfo = model
            }
            if dict.keys.contains("OmsProjectMappingInfo") {
                var model = ListProjectModifyRecordsResponseBody.Data.OmsProjectMappingInfo()
                model.fromMap(dict["OmsProjectMappingInfo"] as! [String: Any])
                self.omsProjectMappingInfo = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SubProjectId") {
                self.subProjectId = dict["SubProjectId"] as! String
            }
            if dict.keys.contains("TableEtlList") {
                var tmp : [ListProjectModifyRecordsResponseBody.Data.TableEtlList] = []
                for v in dict["TableEtlList"] as! [Any] {
                    var model = ListProjectModifyRecordsResponseBody.Data.TableEtlList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tableEtlList = tmp
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("UpdateRequestId") {
                self.updateRequestId = dict["UpdateRequestId"] as! Int64
            }
        }
    }
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: [ListProjectModifyRecordsResponseBody.Data]?

    public var errorDetail: ListProjectModifyRecordsResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [ListProjectModifyRecordsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListProjectModifyRecordsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorDetail") {
            var model = ListProjectModifyRecordsResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListProjectModifyRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProjectModifyRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListProjectModifyRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProjectsRequest : Tea.TeaModel {
    public var labelIds: [String]?

    public var needRelatedInfo: Bool?

    public var order: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchKey: String?

    public var sinkEndpointTypes: [String]?

    public var sortField: String?

    public var sourceEndpointTypes: [String]?

    public var status: [String]?

    public var type: String?

    public var visibleSubProject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.labelIds != nil {
            map["LabelIds"] = self.labelIds!
        }
        if self.needRelatedInfo != nil {
            map["NeedRelatedInfo"] = self.needRelatedInfo!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.sinkEndpointTypes != nil {
            map["SinkEndpointTypes"] = self.sinkEndpointTypes!
        }
        if self.sortField != nil {
            map["SortField"] = self.sortField!
        }
        if self.sourceEndpointTypes != nil {
            map["SourceEndpointTypes"] = self.sourceEndpointTypes!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.visibleSubProject != nil {
            map["VisibleSubProject"] = self.visibleSubProject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LabelIds") {
            self.labelIds = dict["LabelIds"] as! [String]
        }
        if dict.keys.contains("NeedRelatedInfo") {
            self.needRelatedInfo = dict["NeedRelatedInfo"] as! Bool
        }
        if dict.keys.contains("Order") {
            self.order = dict["Order"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchKey") {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("SinkEndpointTypes") {
            self.sinkEndpointTypes = dict["SinkEndpointTypes"] as! [String]
        }
        if dict.keys.contains("SortField") {
            self.sortField = dict["SortField"] as! String
        }
        if dict.keys.contains("SourceEndpointTypes") {
            self.sourceEndpointTypes = dict["SourceEndpointTypes"] as! [String]
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! [String]
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("VisibleSubProject") {
            self.visibleSubProject = dict["VisibleSubProject"] as! Bool
        }
    }
}

public class ListProjectsShrinkRequest : Tea.TeaModel {
    public var labelIdsShrink: String?

    public var needRelatedInfo: Bool?

    public var order: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchKey: String?

    public var sinkEndpointTypesShrink: String?

    public var sortField: String?

    public var sourceEndpointTypesShrink: String?

    public var statusShrink: String?

    public var type: String?

    public var visibleSubProject: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.labelIdsShrink != nil {
            map["LabelIds"] = self.labelIdsShrink!
        }
        if self.needRelatedInfo != nil {
            map["NeedRelatedInfo"] = self.needRelatedInfo!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.sinkEndpointTypesShrink != nil {
            map["SinkEndpointTypes"] = self.sinkEndpointTypesShrink!
        }
        if self.sortField != nil {
            map["SortField"] = self.sortField!
        }
        if self.sourceEndpointTypesShrink != nil {
            map["SourceEndpointTypes"] = self.sourceEndpointTypesShrink!
        }
        if self.statusShrink != nil {
            map["Status"] = self.statusShrink!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.visibleSubProject != nil {
            map["VisibleSubProject"] = self.visibleSubProject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LabelIds") {
            self.labelIdsShrink = dict["LabelIds"] as! String
        }
        if dict.keys.contains("NeedRelatedInfo") {
            self.needRelatedInfo = dict["NeedRelatedInfo"] as! Bool
        }
        if dict.keys.contains("Order") {
            self.order = dict["Order"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchKey") {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("SinkEndpointTypes") {
            self.sinkEndpointTypesShrink = dict["SinkEndpointTypes"] as! String
        }
        if dict.keys.contains("SortField") {
            self.sortField = dict["SortField"] as! String
        }
        if dict.keys.contains("SourceEndpointTypes") {
            self.sourceEndpointTypesShrink = dict["SourceEndpointTypes"] as! String
        }
        if dict.keys.contains("Status") {
            self.statusShrink = dict["Status"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("VisibleSubProject") {
            self.visibleSubProject = dict["VisibleSubProject"] as! Bool
        }
    }
}

public class ListProjectsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AlarmStats : Tea.TeaModel {
            public var alarmContent: String?

            public var alarming: Bool?

            public var openMonitor: Bool?

            public var recentlyTriggerCount: Int32?

            public var ruleToRecentlyTriggerCount: [String: Int32]?

            public var target: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alarmContent != nil {
                    map["AlarmContent"] = self.alarmContent!
                }
                if self.alarming != nil {
                    map["Alarming"] = self.alarming!
                }
                if self.openMonitor != nil {
                    map["OpenMonitor"] = self.openMonitor!
                }
                if self.recentlyTriggerCount != nil {
                    map["RecentlyTriggerCount"] = self.recentlyTriggerCount!
                }
                if self.ruleToRecentlyTriggerCount != nil {
                    map["RuleToRecentlyTriggerCount"] = self.ruleToRecentlyTriggerCount!
                }
                if self.target != nil {
                    map["Target"] = self.target!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlarmContent") {
                    self.alarmContent = dict["AlarmContent"] as! String
                }
                if dict.keys.contains("Alarming") {
                    self.alarming = dict["Alarming"] as! Bool
                }
                if dict.keys.contains("OpenMonitor") {
                    self.openMonitor = dict["OpenMonitor"] as! Bool
                }
                if dict.keys.contains("RecentlyTriggerCount") {
                    self.recentlyTriggerCount = dict["RecentlyTriggerCount"] as! Int32
                }
                if dict.keys.contains("RuleToRecentlyTriggerCount") {
                    self.ruleToRecentlyTriggerCount = dict["RuleToRecentlyTriggerCount"] as! [String: Int32]
                }
                if dict.keys.contains("Target") {
                    self.target = dict["Target"] as! String
                }
            }
        }
        public class CommonTransferConfig : Tea.TeaModel {
            public var activeActive: Bool?

            public var dataWorksBusinessName: String?

            public var datahubTopicType: String?

            public var mqPartition: Int32?

            public var mqPartitionMode: String?

            public var mqSerializerType: String?

            public var rocketMqEnableMsgTrace: Bool?

            public var rocketMqMsgTags: String?

            public var rocketMqProducerGroup: String?

            public var rocketMqSendMsgTimeout: Int64?

            public var tableCategory: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activeActive != nil {
                    map["ActiveActive"] = self.activeActive!
                }
                if self.dataWorksBusinessName != nil {
                    map["DataWorksBusinessName"] = self.dataWorksBusinessName!
                }
                if self.datahubTopicType != nil {
                    map["DatahubTopicType"] = self.datahubTopicType!
                }
                if self.mqPartition != nil {
                    map["MqPartition"] = self.mqPartition!
                }
                if self.mqPartitionMode != nil {
                    map["MqPartitionMode"] = self.mqPartitionMode!
                }
                if self.mqSerializerType != nil {
                    map["MqSerializerType"] = self.mqSerializerType!
                }
                if self.rocketMqEnableMsgTrace != nil {
                    map["RocketMqEnableMsgTrace"] = self.rocketMqEnableMsgTrace!
                }
                if self.rocketMqMsgTags != nil {
                    map["RocketMqMsgTags"] = self.rocketMqMsgTags!
                }
                if self.rocketMqProducerGroup != nil {
                    map["RocketMqProducerGroup"] = self.rocketMqProducerGroup!
                }
                if self.rocketMqSendMsgTimeout != nil {
                    map["RocketMqSendMsgTimeout"] = self.rocketMqSendMsgTimeout!
                }
                if self.tableCategory != nil {
                    map["TableCategory"] = self.tableCategory!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActiveActive") {
                    self.activeActive = dict["ActiveActive"] as! Bool
                }
                if dict.keys.contains("DataWorksBusinessName") {
                    self.dataWorksBusinessName = dict["DataWorksBusinessName"] as! String
                }
                if dict.keys.contains("DatahubTopicType") {
                    self.datahubTopicType = dict["DatahubTopicType"] as! String
                }
                if dict.keys.contains("MqPartition") {
                    self.mqPartition = dict["MqPartition"] as! Int32
                }
                if dict.keys.contains("MqPartitionMode") {
                    self.mqPartitionMode = dict["MqPartitionMode"] as! String
                }
                if dict.keys.contains("MqSerializerType") {
                    self.mqSerializerType = dict["MqSerializerType"] as! String
                }
                if dict.keys.contains("RocketMqEnableMsgTrace") {
                    self.rocketMqEnableMsgTrace = dict["RocketMqEnableMsgTrace"] as! Bool
                }
                if dict.keys.contains("RocketMqMsgTags") {
                    self.rocketMqMsgTags = dict["RocketMqMsgTags"] as! String
                }
                if dict.keys.contains("RocketMqProducerGroup") {
                    self.rocketMqProducerGroup = dict["RocketMqProducerGroup"] as! String
                }
                if dict.keys.contains("RocketMqSendMsgTimeout") {
                    self.rocketMqSendMsgTimeout = dict["RocketMqSendMsgTimeout"] as! Int64
                }
                if dict.keys.contains("TableCategory") {
                    self.tableCategory = dict["TableCategory"] as! String
                }
            }
        }
        public class ExtraInfo : Tea.TeaModel {
            public var accessObSource: Bool?

            public var ignoreUnsupportDdl: Bool?

            public var incrSyncTimestamp: Int64?

            public var logServiceStartCheckpoint: Int64?

            public var maxConnectorCount: Int32?

            public var monitoringIncr: Bool?

            public var overwriteConfig: Bool?

            public var reverseSubtopics: [String]?

            public var runningProgress: Int32?

            public var runningStep: String?

            public var sourceStoreKeptHour: Int32?

            public var storeIncr: Bool?

            public var subConds: [String: [DataExtraInfoSubCondsValue]]?

            public var subDbs: [String: [DataExtraInfoSubDbsValue]]?

            public var subIds: [String: String]?

            public var subtopics: [String]?

            public var syncDelay: Int64?

            public var syncDelaySampleTimestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessObSource != nil {
                    map["AccessObSource"] = self.accessObSource!
                }
                if self.ignoreUnsupportDdl != nil {
                    map["IgnoreUnsupportDdl"] = self.ignoreUnsupportDdl!
                }
                if self.incrSyncTimestamp != nil {
                    map["IncrSyncTimestamp"] = self.incrSyncTimestamp!
                }
                if self.logServiceStartCheckpoint != nil {
                    map["LogServiceStartCheckpoint"] = self.logServiceStartCheckpoint!
                }
                if self.maxConnectorCount != nil {
                    map["MaxConnectorCount"] = self.maxConnectorCount!
                }
                if self.monitoringIncr != nil {
                    map["MonitoringIncr"] = self.monitoringIncr!
                }
                if self.overwriteConfig != nil {
                    map["OverwriteConfig"] = self.overwriteConfig!
                }
                if self.reverseSubtopics != nil {
                    map["ReverseSubtopics"] = self.reverseSubtopics!
                }
                if self.runningProgress != nil {
                    map["RunningProgress"] = self.runningProgress!
                }
                if self.runningStep != nil {
                    map["RunningStep"] = self.runningStep!
                }
                if self.sourceStoreKeptHour != nil {
                    map["SourceStoreKeptHour"] = self.sourceStoreKeptHour!
                }
                if self.storeIncr != nil {
                    map["StoreIncr"] = self.storeIncr!
                }
                if self.subConds != nil {
                    var tmp : [String: Any] = [:]
                    for (k, v) in self.subConds! {
                        var l1 : [Any] = []
                        for k1 in v {
                            l1.append(k1.toMap())
                        }
                        tmp[k] = l1
                    }
                    map["SubConds"] = tmp
                }
                if self.subDbs != nil {
                    var tmp : [String: Any] = [:]
                    for (k, v) in self.subDbs! {
                        var l1 : [Any] = []
                        for k1 in v {
                            l1.append(k1.toMap())
                        }
                        tmp[k] = l1
                    }
                    map["SubDbs"] = tmp
                }
                if self.subIds != nil {
                    map["SubIds"] = self.subIds!
                }
                if self.subtopics != nil {
                    map["Subtopics"] = self.subtopics!
                }
                if self.syncDelay != nil {
                    map["SyncDelay"] = self.syncDelay!
                }
                if self.syncDelaySampleTimestamp != nil {
                    map["SyncDelaySampleTimestamp"] = self.syncDelaySampleTimestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccessObSource") {
                    self.accessObSource = dict["AccessObSource"] as! Bool
                }
                if dict.keys.contains("IgnoreUnsupportDdl") {
                    self.ignoreUnsupportDdl = dict["IgnoreUnsupportDdl"] as! Bool
                }
                if dict.keys.contains("IncrSyncTimestamp") {
                    self.incrSyncTimestamp = dict["IncrSyncTimestamp"] as! Int64
                }
                if dict.keys.contains("LogServiceStartCheckpoint") {
                    self.logServiceStartCheckpoint = dict["LogServiceStartCheckpoint"] as! Int64
                }
                if dict.keys.contains("MaxConnectorCount") {
                    self.maxConnectorCount = dict["MaxConnectorCount"] as! Int32
                }
                if dict.keys.contains("MonitoringIncr") {
                    self.monitoringIncr = dict["MonitoringIncr"] as! Bool
                }
                if dict.keys.contains("OverwriteConfig") {
                    self.overwriteConfig = dict["OverwriteConfig"] as! Bool
                }
                if dict.keys.contains("ReverseSubtopics") {
                    self.reverseSubtopics = dict["ReverseSubtopics"] as! [String]
                }
                if dict.keys.contains("RunningProgress") {
                    self.runningProgress = dict["RunningProgress"] as! Int32
                }
                if dict.keys.contains("RunningStep") {
                    self.runningStep = dict["RunningStep"] as! String
                }
                if dict.keys.contains("SourceStoreKeptHour") {
                    self.sourceStoreKeptHour = dict["SourceStoreKeptHour"] as! Int32
                }
                if dict.keys.contains("StoreIncr") {
                    self.storeIncr = dict["StoreIncr"] as! Bool
                }
                if dict.keys.contains("SubConds") {
                    var tmp : [String: [DataExtraInfoSubCondsValue]] = [:]
                    for (k, v) in dict["SubConds"] as! [String: Any] {
                        var l1 : [DataExtraInfoSubCondsValue] = []
                        for v1 in v as! [Any] {
                            var model = DataExtraInfoSubCondsValue()
                            if v1 != nil {
                                model.fromMap(v1 as! [String: Any])
                            }
                            l1.append(model)
                        }
                        tmp[k] = l1
                    }
                    self.subConds = tmp
                }
                if dict.keys.contains("SubDbs") {
                    var tmp : [String: [DataExtraInfoSubDbsValue]] = [:]
                    for (k, v) in dict["SubDbs"] as! [String: Any] {
                        var l1 : [DataExtraInfoSubDbsValue] = []
                        for v1 in v as! [Any] {
                            var model = DataExtraInfoSubDbsValue()
                            if v1 != nil {
                                model.fromMap(v1 as! [String: Any])
                            }
                            l1.append(model)
                        }
                        tmp[k] = l1
                    }
                    self.subDbs = tmp
                }
                if dict.keys.contains("SubIds") {
                    self.subIds = dict["SubIds"] as! [String: String]
                }
                if dict.keys.contains("Subtopics") {
                    self.subtopics = dict["Subtopics"] as! [String]
                }
                if dict.keys.contains("SyncDelay") {
                    self.syncDelay = dict["SyncDelay"] as! Int64
                }
                if dict.keys.contains("SyncDelaySampleTimestamp") {
                    self.syncDelaySampleTimestamp = dict["SyncDelaySampleTimestamp"] as! Int64
                }
            }
        }
        public class FullTransferConfig : Tea.TeaModel {
            public var allowDestTableNotEmpty: Bool?

            public var fullTransferSpeedMode: String?

            public var fullVerifySpeedMode: String?

            public var nonePkUkTruncateDstTable: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allowDestTableNotEmpty != nil {
                    map["AllowDestTableNotEmpty"] = self.allowDestTableNotEmpty!
                }
                if self.fullTransferSpeedMode != nil {
                    map["FullTransferSpeedMode"] = self.fullTransferSpeedMode!
                }
                if self.fullVerifySpeedMode != nil {
                    map["FullVerifySpeedMode"] = self.fullVerifySpeedMode!
                }
                if self.nonePkUkTruncateDstTable != nil {
                    map["NonePkUkTruncateDstTable"] = self.nonePkUkTruncateDstTable!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AllowDestTableNotEmpty") {
                    self.allowDestTableNotEmpty = dict["AllowDestTableNotEmpty"] as! Bool
                }
                if dict.keys.contains("FullTransferSpeedMode") {
                    self.fullTransferSpeedMode = dict["FullTransferSpeedMode"] as! String
                }
                if dict.keys.contains("FullVerifySpeedMode") {
                    self.fullVerifySpeedMode = dict["FullVerifySpeedMode"] as! String
                }
                if dict.keys.contains("NonePkUkTruncateDstTable") {
                    self.nonePkUkTruncateDstTable = dict["NonePkUkTruncateDstTable"] as! Bool
                }
            }
        }
        public class IncrTransferConfig : Tea.TeaModel {
            public var enableIncrSyncStatistics: Bool?

            public var enableSequencingWithinTxn: Bool?

            public var incrSyncConcurrency: Int32?

            public var recordTypeWhiteList: [String]?

            public var startTimestamp: Int64?

            public var storeLogKeptHour: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.enableIncrSyncStatistics != nil {
                    map["EnableIncrSyncStatistics"] = self.enableIncrSyncStatistics!
                }
                if self.enableSequencingWithinTxn != nil {
                    map["EnableSequencingWithinTxn"] = self.enableSequencingWithinTxn!
                }
                if self.incrSyncConcurrency != nil {
                    map["IncrSyncConcurrency"] = self.incrSyncConcurrency!
                }
                if self.recordTypeWhiteList != nil {
                    map["RecordTypeWhiteList"] = self.recordTypeWhiteList!
                }
                if self.startTimestamp != nil {
                    map["StartTimestamp"] = self.startTimestamp!
                }
                if self.storeLogKeptHour != nil {
                    map["StoreLogKeptHour"] = self.storeLogKeptHour!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EnableIncrSyncStatistics") {
                    self.enableIncrSyncStatistics = dict["EnableIncrSyncStatistics"] as! Bool
                }
                if dict.keys.contains("EnableSequencingWithinTxn") {
                    self.enableSequencingWithinTxn = dict["EnableSequencingWithinTxn"] as! Bool
                }
                if dict.keys.contains("IncrSyncConcurrency") {
                    self.incrSyncConcurrency = dict["IncrSyncConcurrency"] as! Int32
                }
                if dict.keys.contains("RecordTypeWhiteList") {
                    self.recordTypeWhiteList = dict["RecordTypeWhiteList"] as! [String]
                }
                if dict.keys.contains("StartTimestamp") {
                    self.startTimestamp = dict["StartTimestamp"] as! Int64
                }
                if dict.keys.contains("StoreLogKeptHour") {
                    self.storeLogKeptHour = dict["StoreLogKeptHour"] as! Int32
                }
            }
        }
        public class Labels : Tea.TeaModel {
            public var count: Int32?

            public var creator: String?

            public var id: String?

            public var name: String?

            public var type: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int32
                }
                if dict.keys.contains("Creator") {
                    self.creator = dict["Creator"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! Int32
                }
            }
        }
        public class SinkConnectInfo : Tea.TeaModel {
            public var charset: String?

            public var connExtraAttributes: Any?

            public var connectionInfo: String?

            public var dbEngine: String?

            public var endpointId: String?

            public var endpointName: String?

            public var endpointSide: String?

            public var host: String?

            public var id: String?

            public var nlsLengthSemantics: String?

            public var ocpName: String?

            public var operatingSystem: String?

            public var owner: String?

            public var port: Int32?

            public var region: String?

            public var resourceOwner: String?

            public var timezone: String?

            public var username: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.charset != nil {
                    map["Charset"] = self.charset!
                }
                if self.connExtraAttributes != nil {
                    map["ConnExtraAttributes"] = self.connExtraAttributes!
                }
                if self.connectionInfo != nil {
                    map["ConnectionInfo"] = self.connectionInfo!
                }
                if self.dbEngine != nil {
                    map["DbEngine"] = self.dbEngine!
                }
                if self.endpointId != nil {
                    map["EndpointId"] = self.endpointId!
                }
                if self.endpointName != nil {
                    map["EndpointName"] = self.endpointName!
                }
                if self.endpointSide != nil {
                    map["EndpointSide"] = self.endpointSide!
                }
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.nlsLengthSemantics != nil {
                    map["NlsLengthSemantics"] = self.nlsLengthSemantics!
                }
                if self.ocpName != nil {
                    map["OcpName"] = self.ocpName!
                }
                if self.operatingSystem != nil {
                    map["OperatingSystem"] = self.operatingSystem!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.resourceOwner != nil {
                    map["ResourceOwner"] = self.resourceOwner!
                }
                if self.timezone != nil {
                    map["Timezone"] = self.timezone!
                }
                if self.username != nil {
                    map["Username"] = self.username!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Charset") {
                    self.charset = dict["Charset"] as! String
                }
                if dict.keys.contains("ConnExtraAttributes") {
                    self.connExtraAttributes = dict["ConnExtraAttributes"] as! Any
                }
                if dict.keys.contains("ConnectionInfo") {
                    self.connectionInfo = dict["ConnectionInfo"] as! String
                }
                if dict.keys.contains("DbEngine") {
                    self.dbEngine = dict["DbEngine"] as! String
                }
                if dict.keys.contains("EndpointId") {
                    self.endpointId = dict["EndpointId"] as! String
                }
                if dict.keys.contains("EndpointName") {
                    self.endpointName = dict["EndpointName"] as! String
                }
                if dict.keys.contains("EndpointSide") {
                    self.endpointSide = dict["EndpointSide"] as! String
                }
                if dict.keys.contains("Host") {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("NlsLengthSemantics") {
                    self.nlsLengthSemantics = dict["NlsLengthSemantics"] as! String
                }
                if dict.keys.contains("OcpName") {
                    self.ocpName = dict["OcpName"] as! String
                }
                if dict.keys.contains("OperatingSystem") {
                    self.operatingSystem = dict["OperatingSystem"] as! String
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("ResourceOwner") {
                    self.resourceOwner = dict["ResourceOwner"] as! String
                }
                if dict.keys.contains("Timezone") {
                    self.timezone = dict["Timezone"] as! String
                }
                if dict.keys.contains("Username") {
                    self.username = dict["Username"] as! String
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public class SourceConnectInfo : Tea.TeaModel {
            public var charset: String?

            public var connExtraAttributes: Any?

            public var connectionInfo: String?

            public var dbEngine: String?

            public var endpointId: String?

            public var endpointName: String?

            public var endpointSide: String?

            public var host: String?

            public var id: String?

            public var nlsLengthSemantics: String?

            public var ocpName: String?

            public var operatingSystem: String?

            public var owner: String?

            public var port: Int32?

            public var region: String?

            public var resourceOwner: String?

            public var timezone: String?

            public var username: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.charset != nil {
                    map["Charset"] = self.charset!
                }
                if self.connExtraAttributes != nil {
                    map["ConnExtraAttributes"] = self.connExtraAttributes!
                }
                if self.connectionInfo != nil {
                    map["ConnectionInfo"] = self.connectionInfo!
                }
                if self.dbEngine != nil {
                    map["DbEngine"] = self.dbEngine!
                }
                if self.endpointId != nil {
                    map["EndpointId"] = self.endpointId!
                }
                if self.endpointName != nil {
                    map["EndpointName"] = self.endpointName!
                }
                if self.endpointSide != nil {
                    map["EndpointSide"] = self.endpointSide!
                }
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.nlsLengthSemantics != nil {
                    map["NlsLengthSemantics"] = self.nlsLengthSemantics!
                }
                if self.ocpName != nil {
                    map["OcpName"] = self.ocpName!
                }
                if self.operatingSystem != nil {
                    map["OperatingSystem"] = self.operatingSystem!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.resourceOwner != nil {
                    map["ResourceOwner"] = self.resourceOwner!
                }
                if self.timezone != nil {
                    map["Timezone"] = self.timezone!
                }
                if self.username != nil {
                    map["Username"] = self.username!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Charset") {
                    self.charset = dict["Charset"] as! String
                }
                if dict.keys.contains("ConnExtraAttributes") {
                    self.connExtraAttributes = dict["ConnExtraAttributes"] as! Any
                }
                if dict.keys.contains("ConnectionInfo") {
                    self.connectionInfo = dict["ConnectionInfo"] as! String
                }
                if dict.keys.contains("DbEngine") {
                    self.dbEngine = dict["DbEngine"] as! String
                }
                if dict.keys.contains("EndpointId") {
                    self.endpointId = dict["EndpointId"] as! String
                }
                if dict.keys.contains("EndpointName") {
                    self.endpointName = dict["EndpointName"] as! String
                }
                if dict.keys.contains("EndpointSide") {
                    self.endpointSide = dict["EndpointSide"] as! String
                }
                if dict.keys.contains("Host") {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("NlsLengthSemantics") {
                    self.nlsLengthSemantics = dict["NlsLengthSemantics"] as! String
                }
                if dict.keys.contains("OcpName") {
                    self.ocpName = dict["OcpName"] as! String
                }
                if dict.keys.contains("OperatingSystem") {
                    self.operatingSystem = dict["OperatingSystem"] as! String
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("ResourceOwner") {
                    self.resourceOwner = dict["ResourceOwner"] as! String
                }
                if dict.keys.contains("Timezone") {
                    self.timezone = dict["Timezone"] as! String
                }
                if dict.keys.contains("Username") {
                    self.username = dict["Username"] as! String
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public class Steps : Tea.TeaModel {
            public class ExtraInfo : Tea.TeaModel {
                public class ErrorDetails : Tea.TeaModel {
                    public var code: String?

                    public var extraContext: [String: Any]?

                    public var level: String?

                    public var message: String?

                    public var messageMcmsContext: [String: String]?

                    public var messageMcmsKey: String?

                    public var proposal: String?

                    public var proposalMcmsContext: [String: String]?

                    public var proposalMcmsKey: String?

                    public var reason: String?

                    public var reasonMcmsContext: [String: String]?

                    public var reasonMcmsKey: String?

                    public var upstreamErrorDetail: Any?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.code != nil {
                            map["Code"] = self.code!
                        }
                        if self.extraContext != nil {
                            map["ExtraContext"] = self.extraContext!
                        }
                        if self.level != nil {
                            map["Level"] = self.level!
                        }
                        if self.message != nil {
                            map["Message"] = self.message!
                        }
                        if self.messageMcmsContext != nil {
                            map["MessageMcmsContext"] = self.messageMcmsContext!
                        }
                        if self.messageMcmsKey != nil {
                            map["MessageMcmsKey"] = self.messageMcmsKey!
                        }
                        if self.proposal != nil {
                            map["Proposal"] = self.proposal!
                        }
                        if self.proposalMcmsContext != nil {
                            map["ProposalMcmsContext"] = self.proposalMcmsContext!
                        }
                        if self.proposalMcmsKey != nil {
                            map["ProposalMcmsKey"] = self.proposalMcmsKey!
                        }
                        if self.reason != nil {
                            map["Reason"] = self.reason!
                        }
                        if self.reasonMcmsContext != nil {
                            map["ReasonMcmsContext"] = self.reasonMcmsContext!
                        }
                        if self.reasonMcmsKey != nil {
                            map["ReasonMcmsKey"] = self.reasonMcmsKey!
                        }
                        if self.upstreamErrorDetail != nil {
                            map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Code") {
                            self.code = dict["Code"] as! String
                        }
                        if dict.keys.contains("ExtraContext") {
                            self.extraContext = dict["ExtraContext"] as! [String: Any]
                        }
                        if dict.keys.contains("Level") {
                            self.level = dict["Level"] as! String
                        }
                        if dict.keys.contains("Message") {
                            self.message = dict["Message"] as! String
                        }
                        if dict.keys.contains("MessageMcmsContext") {
                            self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
                        }
                        if dict.keys.contains("MessageMcmsKey") {
                            self.messageMcmsKey = dict["MessageMcmsKey"] as! String
                        }
                        if dict.keys.contains("Proposal") {
                            self.proposal = dict["Proposal"] as! String
                        }
                        if dict.keys.contains("ProposalMcmsContext") {
                            self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
                        }
                        if dict.keys.contains("ProposalMcmsKey") {
                            self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
                        }
                        if dict.keys.contains("Reason") {
                            self.reason = dict["Reason"] as! String
                        }
                        if dict.keys.contains("ReasonMcmsContext") {
                            self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
                        }
                        if dict.keys.contains("ReasonMcmsKey") {
                            self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
                        }
                        if dict.keys.contains("UpstreamErrorDetail") {
                            self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
                        }
                    }
                }
                public var errorCode: String?

                public var errorDetails: [ListProjectsResponseBody.Data.Steps.ExtraInfo.ErrorDetails]?

                public var errorMsg: String?

                public var errorParam: [String: String]?

                public var failedTime: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorDetails != nil {
                        var tmp : [Any] = []
                        for k in self.errorDetails! {
                            tmp.append(k.toMap())
                        }
                        map["ErrorDetails"] = tmp
                    }
                    if self.errorMsg != nil {
                        map["ErrorMsg"] = self.errorMsg!
                    }
                    if self.errorParam != nil {
                        map["ErrorParam"] = self.errorParam!
                    }
                    if self.failedTime != nil {
                        map["FailedTime"] = self.failedTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorCode") {
                        self.errorCode = dict["ErrorCode"] as! String
                    }
                    if dict.keys.contains("ErrorDetails") {
                        var tmp : [ListProjectsResponseBody.Data.Steps.ExtraInfo.ErrorDetails] = []
                        for v in dict["ErrorDetails"] as! [Any] {
                            var model = ListProjectsResponseBody.Data.Steps.ExtraInfo.ErrorDetails()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.errorDetails = tmp
                    }
                    if dict.keys.contains("ErrorMsg") {
                        self.errorMsg = dict["ErrorMsg"] as! String
                    }
                    if dict.keys.contains("ErrorParam") {
                        self.errorParam = dict["ErrorParam"] as! [String: String]
                    }
                    if dict.keys.contains("FailedTime") {
                        self.failedTime = dict["FailedTime"] as! String
                    }
                }
            }
            public var description_: String?

            public var extraInfo: ListProjectsResponseBody.Data.Steps.ExtraInfo?

            public var finishTime: String?

            public var name: String?

            public var order: Int32?

            public var progress: Int32?

            public var startTime: String?

            public var status: String?

            public var stepInfo: [String: Any]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.extraInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.extraInfo != nil {
                    map["ExtraInfo"] = self.extraInfo?.toMap()
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.order != nil {
                    map["Order"] = self.order!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.stepInfo != nil {
                    map["StepInfo"] = self.stepInfo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ExtraInfo") {
                    var model = ListProjectsResponseBody.Data.Steps.ExtraInfo()
                    model.fromMap(dict["ExtraInfo"] as! [String: Any])
                    self.extraInfo = model
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Order") {
                    self.order = dict["Order"] as! Int32
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! Int32
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StepInfo") {
                    self.stepInfo = dict["StepInfo"] as! [String: Any]
                }
            }
        }
        public class StructTransferConfig : Tea.TeaModel {
            public var byteCharConvertStrategy: String?

            public var deferIndexCreation: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.byteCharConvertStrategy != nil {
                    map["ByteCharConvertStrategy"] = self.byteCharConvertStrategy!
                }
                if self.deferIndexCreation != nil {
                    map["DeferIndexCreation"] = self.deferIndexCreation!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ByteCharConvertStrategy") {
                    self.byteCharConvertStrategy = dict["ByteCharConvertStrategy"] as! String
                }
                if dict.keys.contains("DeferIndexCreation") {
                    self.deferIndexCreation = dict["DeferIndexCreation"] as! Bool
                }
            }
        }
        public class TransferMapping : Tea.TeaModel {
            public var mode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mode != nil {
                    map["Mode"] = self.mode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Mode") {
                    self.mode = dict["Mode"] as! String
                }
            }
        }
        public class WorkerGradeInfo : Tea.TeaModel {
            public var autoRenewal: Bool?

            public var chargeType: String?

            public var destRegion: String?

            public var destType: String?

            public var endTime: String?

            public var expired: Bool?

            public var gmtCreate: String?

            public var grade: String?

            public var id: String?

            public var name: String?

            public var sourceRegion: String?

            public var sourceType: String?

            public var spec: String?

            public var specName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoRenewal != nil {
                    map["AutoRenewal"] = self.autoRenewal!
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.destRegion != nil {
                    map["DestRegion"] = self.destRegion!
                }
                if self.destType != nil {
                    map["DestType"] = self.destType!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.expired != nil {
                    map["Expired"] = self.expired!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.grade != nil {
                    map["Grade"] = self.grade!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.sourceRegion != nil {
                    map["SourceRegion"] = self.sourceRegion!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.spec != nil {
                    map["Spec"] = self.spec!
                }
                if self.specName != nil {
                    map["SpecName"] = self.specName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutoRenewal") {
                    self.autoRenewal = dict["AutoRenewal"] as! Bool
                }
                if dict.keys.contains("ChargeType") {
                    self.chargeType = dict["ChargeType"] as! String
                }
                if dict.keys.contains("DestRegion") {
                    self.destRegion = dict["DestRegion"] as! String
                }
                if dict.keys.contains("DestType") {
                    self.destType = dict["DestType"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("Expired") {
                    self.expired = dict["Expired"] as! Bool
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("Grade") {
                    self.grade = dict["Grade"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("SourceRegion") {
                    self.sourceRegion = dict["SourceRegion"] as! String
                }
                if dict.keys.contains("SourceType") {
                    self.sourceType = dict["SourceType"] as! String
                }
                if dict.keys.contains("Spec") {
                    self.spec = dict["Spec"] as! String
                }
                if dict.keys.contains("SpecName") {
                    self.specName = dict["SpecName"] as! String
                }
            }
        }
        public var alarmStats: ListProjectsResponseBody.Data.AlarmStats?

        public var commonTransferConfig: ListProjectsResponseBody.Data.CommonTransferConfig?

        public var destConnId: String?

        public var enableFullTransfer: Bool?

        public var enableFullVerify: Bool?

        public var enableIncrTransfer: Bool?

        public var enableIncrVerify: Bool?

        public var enableReverseIncrTransfer: Bool?

        public var enableStructTransfer: Bool?

        public var extraInfo: ListProjectsResponseBody.Data.ExtraInfo?

        public var fullTransferConfig: ListProjectsResponseBody.Data.FullTransferConfig?

        public var gmtCreate: String?

        public var gmtFinish: String?

        public var gmtModified: String?

        public var gmtStart: String?

        public var id: String?

        public var importance: String?

        public var incrTransferConfig: ListProjectsResponseBody.Data.IncrTransferConfig?

        public var isMerging: Bool?

        public var isModifying: Bool?

        public var isSubProject: Bool?

        public var labels: [ListProjectsResponseBody.Data.Labels]?

        public var name: String?

        public var owner: String?

        public var sinkConnectInfo: ListProjectsResponseBody.Data.SinkConnectInfo?

        public var sinkEndpointType: String?

        public var sourceConnectInfo: ListProjectsResponseBody.Data.SourceConnectInfo?

        public var sourceEndpointType: String?

        public var status: String?

        public var steps: [ListProjectsResponseBody.Data.Steps]?

        public var structTransferConfig: ListProjectsResponseBody.Data.StructTransferConfig?

        public var transferMapping: ListProjectsResponseBody.Data.TransferMapping?

        public var type: String?

        public var workerGradeId: String?

        public var workerGradeInfo: ListProjectsResponseBody.Data.WorkerGradeInfo?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.alarmStats?.validate()
            try self.commonTransferConfig?.validate()
            try self.extraInfo?.validate()
            try self.fullTransferConfig?.validate()
            try self.incrTransferConfig?.validate()
            try self.sinkConnectInfo?.validate()
            try self.sourceConnectInfo?.validate()
            try self.structTransferConfig?.validate()
            try self.transferMapping?.validate()
            try self.workerGradeInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarmStats != nil {
                map["AlarmStats"] = self.alarmStats?.toMap()
            }
            if self.commonTransferConfig != nil {
                map["CommonTransferConfig"] = self.commonTransferConfig?.toMap()
            }
            if self.destConnId != nil {
                map["DestConnId"] = self.destConnId!
            }
            if self.enableFullTransfer != nil {
                map["EnableFullTransfer"] = self.enableFullTransfer!
            }
            if self.enableFullVerify != nil {
                map["EnableFullVerify"] = self.enableFullVerify!
            }
            if self.enableIncrTransfer != nil {
                map["EnableIncrTransfer"] = self.enableIncrTransfer!
            }
            if self.enableIncrVerify != nil {
                map["EnableIncrVerify"] = self.enableIncrVerify!
            }
            if self.enableReverseIncrTransfer != nil {
                map["EnableReverseIncrTransfer"] = self.enableReverseIncrTransfer!
            }
            if self.enableStructTransfer != nil {
                map["EnableStructTransfer"] = self.enableStructTransfer!
            }
            if self.extraInfo != nil {
                map["ExtraInfo"] = self.extraInfo?.toMap()
            }
            if self.fullTransferConfig != nil {
                map["FullTransferConfig"] = self.fullTransferConfig?.toMap()
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtFinish != nil {
                map["GmtFinish"] = self.gmtFinish!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.gmtStart != nil {
                map["GmtStart"] = self.gmtStart!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.importance != nil {
                map["Importance"] = self.importance!
            }
            if self.incrTransferConfig != nil {
                map["IncrTransferConfig"] = self.incrTransferConfig?.toMap()
            }
            if self.isMerging != nil {
                map["IsMerging"] = self.isMerging!
            }
            if self.isModifying != nil {
                map["IsModifying"] = self.isModifying!
            }
            if self.isSubProject != nil {
                map["IsSubProject"] = self.isSubProject!
            }
            if self.labels != nil {
                var tmp : [Any] = []
                for k in self.labels! {
                    tmp.append(k.toMap())
                }
                map["Labels"] = tmp
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.sinkConnectInfo != nil {
                map["SinkConnectInfo"] = self.sinkConnectInfo?.toMap()
            }
            if self.sinkEndpointType != nil {
                map["SinkEndpointType"] = self.sinkEndpointType!
            }
            if self.sourceConnectInfo != nil {
                map["SourceConnectInfo"] = self.sourceConnectInfo?.toMap()
            }
            if self.sourceEndpointType != nil {
                map["SourceEndpointType"] = self.sourceEndpointType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.steps != nil {
                var tmp : [Any] = []
                for k in self.steps! {
                    tmp.append(k.toMap())
                }
                map["Steps"] = tmp
            }
            if self.structTransferConfig != nil {
                map["StructTransferConfig"] = self.structTransferConfig?.toMap()
            }
            if self.transferMapping != nil {
                map["TransferMapping"] = self.transferMapping?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.workerGradeId != nil {
                map["WorkerGradeId"] = self.workerGradeId!
            }
            if self.workerGradeInfo != nil {
                map["WorkerGradeInfo"] = self.workerGradeInfo?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlarmStats") {
                var model = ListProjectsResponseBody.Data.AlarmStats()
                model.fromMap(dict["AlarmStats"] as! [String: Any])
                self.alarmStats = model
            }
            if dict.keys.contains("CommonTransferConfig") {
                var model = ListProjectsResponseBody.Data.CommonTransferConfig()
                model.fromMap(dict["CommonTransferConfig"] as! [String: Any])
                self.commonTransferConfig = model
            }
            if dict.keys.contains("DestConnId") {
                self.destConnId = dict["DestConnId"] as! String
            }
            if dict.keys.contains("EnableFullTransfer") {
                self.enableFullTransfer = dict["EnableFullTransfer"] as! Bool
            }
            if dict.keys.contains("EnableFullVerify") {
                self.enableFullVerify = dict["EnableFullVerify"] as! Bool
            }
            if dict.keys.contains("EnableIncrTransfer") {
                self.enableIncrTransfer = dict["EnableIncrTransfer"] as! Bool
            }
            if dict.keys.contains("EnableIncrVerify") {
                self.enableIncrVerify = dict["EnableIncrVerify"] as! Bool
            }
            if dict.keys.contains("EnableReverseIncrTransfer") {
                self.enableReverseIncrTransfer = dict["EnableReverseIncrTransfer"] as! Bool
            }
            if dict.keys.contains("EnableStructTransfer") {
                self.enableStructTransfer = dict["EnableStructTransfer"] as! Bool
            }
            if dict.keys.contains("ExtraInfo") {
                var model = ListProjectsResponseBody.Data.ExtraInfo()
                model.fromMap(dict["ExtraInfo"] as! [String: Any])
                self.extraInfo = model
            }
            if dict.keys.contains("FullTransferConfig") {
                var model = ListProjectsResponseBody.Data.FullTransferConfig()
                model.fromMap(dict["FullTransferConfig"] as! [String: Any])
                self.fullTransferConfig = model
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtFinish") {
                self.gmtFinish = dict["GmtFinish"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("GmtStart") {
                self.gmtStart = dict["GmtStart"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Importance") {
                self.importance = dict["Importance"] as! String
            }
            if dict.keys.contains("IncrTransferConfig") {
                var model = ListProjectsResponseBody.Data.IncrTransferConfig()
                model.fromMap(dict["IncrTransferConfig"] as! [String: Any])
                self.incrTransferConfig = model
            }
            if dict.keys.contains("IsMerging") {
                self.isMerging = dict["IsMerging"] as! Bool
            }
            if dict.keys.contains("IsModifying") {
                self.isModifying = dict["IsModifying"] as! Bool
            }
            if dict.keys.contains("IsSubProject") {
                self.isSubProject = dict["IsSubProject"] as! Bool
            }
            if dict.keys.contains("Labels") {
                var tmp : [ListProjectsResponseBody.Data.Labels] = []
                for v in dict["Labels"] as! [Any] {
                    var model = ListProjectsResponseBody.Data.Labels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.labels = tmp
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Owner") {
                self.owner = dict["Owner"] as! String
            }
            if dict.keys.contains("SinkConnectInfo") {
                var model = ListProjectsResponseBody.Data.SinkConnectInfo()
                model.fromMap(dict["SinkConnectInfo"] as! [String: Any])
                self.sinkConnectInfo = model
            }
            if dict.keys.contains("SinkEndpointType") {
                self.sinkEndpointType = dict["SinkEndpointType"] as! String
            }
            if dict.keys.contains("SourceConnectInfo") {
                var model = ListProjectsResponseBody.Data.SourceConnectInfo()
                model.fromMap(dict["SourceConnectInfo"] as! [String: Any])
                self.sourceConnectInfo = model
            }
            if dict.keys.contains("SourceEndpointType") {
                self.sourceEndpointType = dict["SourceEndpointType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Steps") {
                var tmp : [ListProjectsResponseBody.Data.Steps] = []
                for v in dict["Steps"] as! [Any] {
                    var model = ListProjectsResponseBody.Data.Steps()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.steps = tmp
            }
            if dict.keys.contains("StructTransferConfig") {
                var model = ListProjectsResponseBody.Data.StructTransferConfig()
                model.fromMap(dict["StructTransferConfig"] as! [String: Any])
                self.structTransferConfig = model
            }
            if dict.keys.contains("TransferMapping") {
                var model = ListProjectsResponseBody.Data.TransferMapping()
                model.fromMap(dict["TransferMapping"] as! [String: Any])
                self.transferMapping = model
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("WorkerGradeId") {
                self.workerGradeId = dict["WorkerGradeId"] as! String
            }
            if dict.keys.contains("WorkerGradeInfo") {
                var model = ListProjectsResponseBody.Data.WorkerGradeInfo()
                model.fromMap(dict["WorkerGradeInfo"] as! [String: Any])
                self.workerGradeInfo = model
            }
        }
    }
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: [ListProjectsResponseBody.Data]?

    public var errorDetail: ListProjectsResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [ListProjectsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListProjectsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorDetail") {
            var model = ListProjectsResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListProjectsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProjectsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListProjectsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListWorkerInstancesRequest : Tea.TeaModel {
    public var destType: String?

    public var instanceName: String?

    public var onlyBindable: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var sourceType: String?

    public var specs: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destType != nil {
            map["DestType"] = self.destType!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.onlyBindable != nil {
            map["OnlyBindable"] = self.onlyBindable!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        if self.specs != nil {
            map["Specs"] = self.specs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestType") {
            self.destType = dict["DestType"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("OnlyBindable") {
            self.onlyBindable = dict["OnlyBindable"] as! Bool
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
        if dict.keys.contains("Specs") {
            self.specs = dict["Specs"] as! [String]
        }
    }
}

public class ListWorkerInstancesShrinkRequest : Tea.TeaModel {
    public var destType: String?

    public var instanceName: String?

    public var onlyBindable: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var sourceType: String?

    public var specsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destType != nil {
            map["DestType"] = self.destType!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.onlyBindable != nil {
            map["OnlyBindable"] = self.onlyBindable!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        if self.specsShrink != nil {
            map["Specs"] = self.specsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestType") {
            self.destType = dict["DestType"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("OnlyBindable") {
            self.onlyBindable = dict["OnlyBindable"] as! Bool
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
        if dict.keys.contains("Specs") {
            self.specsShrink = dict["Specs"] as! String
        }
    }
}

public class ListWorkerInstancesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var gmtCreate: String?

        public var id: String?

        public var name: String?

        public var projectId: String?

        public var projectName: String?

        public var projectType: String?

        public var region: String?

        public var spec: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            if self.projectType != nil {
                map["ProjectType"] = self.projectType!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.spec != nil {
                map["Spec"] = self.spec!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("ProjectName") {
                self.projectName = dict["ProjectName"] as! String
            }
            if dict.keys.contains("ProjectType") {
                self.projectType = dict["ProjectType"] as! String
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("Spec") {
                self.spec = dict["Spec"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: [ListWorkerInstancesResponseBody.Data]?

    public var errorDetail: ListWorkerInstancesResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [ListWorkerInstancesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListWorkerInstancesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorDetail") {
            var model = ListWorkerInstancesResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListWorkerInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWorkerInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListWorkerInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDatabaseDescriptionRequest : Tea.TeaModel {
    public var databaseName: String?

    public var description_: String?

    public var instanceId: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatabaseName") {
            self.databaseName = dict["DatabaseName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class ModifyDatabaseDescriptionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDatabaseDescriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDatabaseDescriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDatabaseDescriptionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDatabaseUserRolesRequest : Tea.TeaModel {
    public var databaseName: String?

    public var instanceId: String?

    public var tenantId: String?

    public var users: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.users != nil {
            map["Users"] = self.users!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatabaseName") {
            self.databaseName = dict["DatabaseName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("Users") {
            self.users = dict["Users"] as! String
        }
    }
}

public class ModifyDatabaseUserRolesResponseBody : Tea.TeaModel {
    public class TenantUser : Tea.TeaModel {
        public class Users : Tea.TeaModel {
            public var role: String?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Role") {
                    self.role = dict["Role"] as! String
                }
                if dict.keys.contains("UserName") {
                    self.userName = dict["UserName"] as! String
                }
            }
        }
        public var databaseName: String?

        public var tenantId: String?

        public var users: [ModifyDatabaseUserRolesResponseBody.TenantUser.Users]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.databaseName != nil {
                map["DatabaseName"] = self.databaseName!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.users != nil {
                var tmp : [Any] = []
                for k in self.users! {
                    tmp.append(k.toMap())
                }
                map["Users"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DatabaseName") {
                self.databaseName = dict["DatabaseName"] as! String
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! String
            }
            if dict.keys.contains("Users") {
                var tmp : [ModifyDatabaseUserRolesResponseBody.TenantUser.Users] = []
                for v in dict["Users"] as! [Any] {
                    var model = ModifyDatabaseUserRolesResponseBody.TenantUser.Users()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.users = tmp
            }
        }
    }
    public var requestId: String?

    public var tenantUser: ModifyDatabaseUserRolesResponseBody.TenantUser?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantUser?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tenantUser != nil {
            map["TenantUser"] = self.tenantUser?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TenantUser") {
            var model = ModifyDatabaseUserRolesResponseBody.TenantUser()
            model.fromMap(dict["TenantUser"] as! [String: Any])
            self.tenantUser = model
        }
    }
}

public class ModifyDatabaseUserRolesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDatabaseUserRolesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDatabaseUserRolesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceNameRequest : Tea.TeaModel {
    public var instanceId: String?

    public var instanceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
    }
}

public class ModifyInstanceNameResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceNodeNumRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var instanceId: String?

    public var nodeNum: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeNum != nil {
            map["NodeNum"] = self.nodeNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeNum") {
            self.nodeNum = dict["NodeNum"] as! String
        }
    }
}

public class ModifyInstanceNodeNumResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var dryRunResult: Bool?

        public var orderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dryRunResult != nil {
                map["DryRunResult"] = self.dryRunResult!
            }
            if self.orderId != nil {
                map["OrderId"] = self.orderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DryRunResult") {
                self.dryRunResult = dict["DryRunResult"] as! Bool
            }
            if dict.keys.contains("OrderId") {
                self.orderId = dict["OrderId"] as! String
            }
        }
    }
    public var data: ModifyInstanceNodeNumResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ModifyInstanceNodeNumResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceNodeNumResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceNodeNumResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceNodeNumResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceSSLRequest : Tea.TeaModel {
    public var enableSSL: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableSSL != nil {
            map["EnableSSL"] = self.enableSSL!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnableSSL") {
            self.enableSSL = dict["EnableSSL"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ModifyInstanceSSLResponseBody : Tea.TeaModel {
    public class InstanceSSL : Tea.TeaModel {
        public var enableSSL: String?

        public var instanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableSSL != nil {
                map["EnableSSL"] = self.enableSSL!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableSSL") {
                self.enableSSL = dict["EnableSSL"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
        }
    }
    public var instanceSSL: ModifyInstanceSSLResponseBody.InstanceSSL?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceSSL?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceSSL != nil {
            map["InstanceSSL"] = self.instanceSSL?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceSSL") {
            var model = ModifyInstanceSSLResponseBody.InstanceSSL()
            model.fromMap(dict["InstanceSSL"] as! [String: Any])
            self.instanceSSL = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceSSLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceSSLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceSSLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceSpecRequest : Tea.TeaModel {
    public var diskSize: Int64?

    public var diskType: String?

    public var dryRun: Bool?

    public var instanceClass: String?

    public var instanceId: String?

    public var upgradeSpecNative: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskSize != nil {
            map["DiskSize"] = self.diskSize!
        }
        if self.diskType != nil {
            map["DiskType"] = self.diskType!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.instanceClass != nil {
            map["InstanceClass"] = self.instanceClass!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.upgradeSpecNative != nil {
            map["UpgradeSpecNative"] = self.upgradeSpecNative!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiskSize") {
            self.diskSize = dict["DiskSize"] as! Int64
        }
        if dict.keys.contains("DiskType") {
            self.diskType = dict["DiskType"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("InstanceClass") {
            self.instanceClass = dict["InstanceClass"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("UpgradeSpecNative") {
            self.upgradeSpecNative = dict["UpgradeSpecNative"] as! Bool
        }
    }
}

public class ModifyInstanceSpecResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var dryRunResult: Bool?

        public var orderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dryRunResult != nil {
                map["DryRunResult"] = self.dryRunResult!
            }
            if self.orderId != nil {
                map["OrderId"] = self.orderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DryRunResult") {
                self.dryRunResult = dict["DryRunResult"] as! Bool
            }
            if dict.keys.contains("OrderId") {
                self.orderId = dict["OrderId"] as! String
            }
        }
    }
    public var data: ModifyInstanceSpecResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = ModifyInstanceSpecResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceSpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceTagsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var tags: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
    }
}

public class ModifyInstanceTagsResponseBody : Tea.TeaModel {
    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceTemporaryCapacityRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var diskSize: String?

    public var instanceId: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.diskSize != nil {
            map["DiskSize"] = self.diskSize!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("DiskSize") {
            self.diskSize = dict["DiskSize"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
    }
}

public class ModifyInstanceTemporaryCapacityResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceTemporaryCapacityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceTemporaryCapacityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceTemporaryCapacityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyParametersRequest : Tea.TeaModel {
    public var dimension: String?

    public var dimensionValue: String?

    public var instanceId: String?

    public var parameters: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dimension != nil {
            map["Dimension"] = self.dimension!
        }
        if self.dimensionValue != nil {
            map["DimensionValue"] = self.dimensionValue!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Dimension") {
            self.dimension = dict["Dimension"] as! String
        }
        if dict.keys.contains("DimensionValue") {
            self.dimensionValue = dict["DimensionValue"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Parameters") {
            self.parameters = dict["Parameters"] as! String
        }
    }
}

public class ModifyParametersResponseBody : Tea.TeaModel {
    public class Results : Tea.TeaModel {
        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var results: ModifyParametersResponseBody.Results?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.results?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.results != nil {
            map["Results"] = self.results?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Results") {
            var model = ModifyParametersResponseBody.Results()
            model.fromMap(dict["Results"] as! [String: Any])
            self.results = model
        }
    }
}

public class ModifyParametersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyParametersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyParametersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySecurityIpsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var securityIpGroupName: String?

    public var securityIps: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.securityIpGroupName != nil {
            map["SecurityIpGroupName"] = self.securityIpGroupName!
        }
        if self.securityIps != nil {
            map["SecurityIps"] = self.securityIps!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SecurityIpGroupName") {
            self.securityIpGroupName = dict["SecurityIpGroupName"] as! String
        }
        if dict.keys.contains("SecurityIps") {
            self.securityIps = dict["SecurityIps"] as! String
        }
    }
}

public class ModifySecurityIpsResponseBody : Tea.TeaModel {
    public class SecurityIpGroup : Tea.TeaModel {
        public var instanceId: String?

        public var securityIpGroupName: String?

        public var securityIps: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.securityIpGroupName != nil {
                map["SecurityIpGroupName"] = self.securityIpGroupName!
            }
            if self.securityIps != nil {
                map["SecurityIps"] = self.securityIps!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("SecurityIpGroupName") {
                self.securityIpGroupName = dict["SecurityIpGroupName"] as! String
            }
            if dict.keys.contains("SecurityIps") {
                self.securityIps = dict["SecurityIps"] as! String
            }
        }
    }
    public var requestId: String?

    public var securityIpGroup: ModifySecurityIpsResponseBody.SecurityIpGroup?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.securityIpGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityIpGroup != nil {
            map["SecurityIpGroup"] = self.securityIpGroup?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityIpGroup") {
            var model = ModifySecurityIpsResponseBody.SecurityIpGroup()
            model.fromMap(dict["SecurityIpGroup"] as! [String: Any])
            self.securityIpGroup = model
        }
    }
}

public class ModifySecurityIpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySecurityIpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifySecurityIpsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyTagNameRequest : Tea.TeaModel {
    public var key: String?

    public var newKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.newKey != nil {
            map["NewKey"] = self.newKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Key") {
            self.key = dict["Key"] as! String
        }
        if dict.keys.contains("NewKey") {
            self.newKey = dict["NewKey"] as! String
        }
    }
}

public class ModifyTagNameResponseBody : Tea.TeaModel {
    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyTagNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyTagNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyTagNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyTagValueNameRequest : Tea.TeaModel {
    public var key: String?

    public var newValue: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.newValue != nil {
            map["NewValue"] = self.newValue!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Key") {
            self.key = dict["Key"] as! String
        }
        if dict.keys.contains("NewValue") {
            self.newValue = dict["NewValue"] as! String
        }
        if dict.keys.contains("Value") {
            self.value = dict["Value"] as! String
        }
    }
}

public class ModifyTagValueNameResponseBody : Tea.TeaModel {
    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyTagValueNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyTagValueNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyTagValueNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyTenantEncryptionRequest : Tea.TeaModel {
    public var encryptionKeyId: String?

    public var encryptionType: String?

    public var instanceId: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.encryptionKeyId != nil {
            map["EncryptionKeyId"] = self.encryptionKeyId!
        }
        if self.encryptionType != nil {
            map["EncryptionType"] = self.encryptionType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EncryptionKeyId") {
            self.encryptionKeyId = dict["EncryptionKeyId"] as! String
        }
        if dict.keys.contains("EncryptionType") {
            self.encryptionType = dict["EncryptionType"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class ModifyTenantEncryptionResponseBody : Tea.TeaModel {
    public class TenantEncryption : Tea.TeaModel {
        public var encryptionType: String?

        public var instanceId: String?

        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.encryptionType != nil {
                map["EncryptionType"] = self.encryptionType!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EncryptionType") {
                self.encryptionType = dict["EncryptionType"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! String
            }
        }
    }
    public var requestId: String?

    public var tenantEncryption: ModifyTenantEncryptionResponseBody.TenantEncryption?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantEncryption?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tenantEncryption != nil {
            map["TenantEncryption"] = self.tenantEncryption?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TenantEncryption") {
            var model = ModifyTenantEncryptionResponseBody.TenantEncryption()
            model.fromMap(dict["TenantEncryption"] as! [String: Any])
            self.tenantEncryption = model
        }
    }
}

public class ModifyTenantEncryptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyTenantEncryptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyTenantEncryptionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyTenantPrimaryZoneRequest : Tea.TeaModel {
    public var instanceId: String?

    public var masterIntranetAddressZone: String?

    public var primaryZone: String?

    public var tenantEndpointDirectId: String?

    public var tenantEndpointId: String?

    public var tenantId: String?

    public var userDirectVSwitchId: String?

    public var userVSwitchId: String?

    public var userVpcOwnerId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.masterIntranetAddressZone != nil {
            map["MasterIntranetAddressZone"] = self.masterIntranetAddressZone!
        }
        if self.primaryZone != nil {
            map["PrimaryZone"] = self.primaryZone!
        }
        if self.tenantEndpointDirectId != nil {
            map["TenantEndpointDirectId"] = self.tenantEndpointDirectId!
        }
        if self.tenantEndpointId != nil {
            map["TenantEndpointId"] = self.tenantEndpointId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.userDirectVSwitchId != nil {
            map["UserDirectVSwitchId"] = self.userDirectVSwitchId!
        }
        if self.userVSwitchId != nil {
            map["UserVSwitchId"] = self.userVSwitchId!
        }
        if self.userVpcOwnerId != nil {
            map["UserVpcOwnerId"] = self.userVpcOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MasterIntranetAddressZone") {
            self.masterIntranetAddressZone = dict["MasterIntranetAddressZone"] as! String
        }
        if dict.keys.contains("PrimaryZone") {
            self.primaryZone = dict["PrimaryZone"] as! String
        }
        if dict.keys.contains("TenantEndpointDirectId") {
            self.tenantEndpointDirectId = dict["TenantEndpointDirectId"] as! String
        }
        if dict.keys.contains("TenantEndpointId") {
            self.tenantEndpointId = dict["TenantEndpointId"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("UserDirectVSwitchId") {
            self.userDirectVSwitchId = dict["UserDirectVSwitchId"] as! String
        }
        if dict.keys.contains("UserVSwitchId") {
            self.userVSwitchId = dict["UserVSwitchId"] as! String
        }
        if dict.keys.contains("UserVpcOwnerId") {
            self.userVpcOwnerId = dict["UserVpcOwnerId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class ModifyTenantPrimaryZoneResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyTenantPrimaryZoneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyTenantPrimaryZoneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyTenantPrimaryZoneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyTenantResourceRequest : Tea.TeaModel {
    public var cpu: Int32?

    public var instanceId: String?

    public var logDisk: Int64?

    public var memory: Int32?

    public var readOnlyZoneList: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.logDisk != nil {
            map["LogDisk"] = self.logDisk!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.readOnlyZoneList != nil {
            map["ReadOnlyZoneList"] = self.readOnlyZoneList!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cpu") {
            self.cpu = dict["Cpu"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("LogDisk") {
            self.logDisk = dict["LogDisk"] as! Int64
        }
        if dict.keys.contains("Memory") {
            self.memory = dict["Memory"] as! Int32
        }
        if dict.keys.contains("ReadOnlyZoneList") {
            self.readOnlyZoneList = dict["ReadOnlyZoneList"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class ModifyTenantResourceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class ModifyTenantResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyTenantResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyTenantResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyTenantSecurityIpGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var securityIpGroupName: String?

    public var securityIps: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.securityIpGroupName != nil {
            map["SecurityIpGroupName"] = self.securityIpGroupName!
        }
        if self.securityIps != nil {
            map["SecurityIps"] = self.securityIps!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SecurityIpGroupName") {
            self.securityIpGroupName = dict["SecurityIpGroupName"] as! String
        }
        if dict.keys.contains("SecurityIps") {
            self.securityIps = dict["SecurityIps"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class ModifyTenantSecurityIpGroupResponseBody : Tea.TeaModel {
    public class SecurityIpGroup : Tea.TeaModel {
        public var instanceId: String?

        public var securityIpGroupName: String?

        public var securityIps: String?

        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.securityIpGroupName != nil {
                map["SecurityIpGroupName"] = self.securityIpGroupName!
            }
            if self.securityIps != nil {
                map["SecurityIps"] = self.securityIps!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("SecurityIpGroupName") {
                self.securityIpGroupName = dict["SecurityIpGroupName"] as! String
            }
            if dict.keys.contains("SecurityIps") {
                self.securityIps = dict["SecurityIps"] as! String
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! String
            }
        }
    }
    public var requestId: String?

    public var securityIpGroup: ModifyTenantSecurityIpGroupResponseBody.SecurityIpGroup?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.securityIpGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityIpGroup != nil {
            map["SecurityIpGroup"] = self.securityIpGroup?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityIpGroup") {
            var model = ModifyTenantSecurityIpGroupResponseBody.SecurityIpGroup()
            model.fromMap(dict["SecurityIpGroup"] as! [String: Any])
            self.securityIpGroup = model
        }
    }
}

public class ModifyTenantSecurityIpGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyTenantSecurityIpGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyTenantSecurityIpGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyTenantTagsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var tags: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class ModifyTenantTagsResponseBody : Tea.TeaModel {
    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyTenantTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyTenantTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyTenantTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyTenantUserDescriptionRequest : Tea.TeaModel {
    public var description_: String?

    public var instanceId: String?

    public var tenantId: String?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
    }
}

public class ModifyTenantUserDescriptionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyTenantUserDescriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyTenantUserDescriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyTenantUserDescriptionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyTenantUserPasswordRequest : Tea.TeaModel {
    public var encryptionType: String?

    public var instanceId: String?

    public var tenantId: String?

    public var userName: String?

    public var userPassword: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.encryptionType != nil {
            map["EncryptionType"] = self.encryptionType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        if self.userPassword != nil {
            map["UserPassword"] = self.userPassword!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EncryptionType") {
            self.encryptionType = dict["EncryptionType"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
        if dict.keys.contains("UserPassword") {
            self.userPassword = dict["UserPassword"] as! String
        }
    }
}

public class ModifyTenantUserPasswordResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyTenantUserPasswordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyTenantUserPasswordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyTenantUserPasswordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyTenantUserRolesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var modifyType: String?

    public var tenantId: String?

    public var userName: String?

    public var userRole: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.modifyType != nil {
            map["ModifyType"] = self.modifyType!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        if self.userRole != nil {
            map["UserRole"] = self.userRole!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ModifyType") {
            self.modifyType = dict["ModifyType"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
        if dict.keys.contains("UserRole") {
            self.userRole = dict["UserRole"] as! String
        }
    }
}

public class ModifyTenantUserRolesResponseBody : Tea.TeaModel {
    public class TenantUser : Tea.TeaModel {
        public class UserRole : Tea.TeaModel {
            public var database: String?

            public var isSuccess: Bool?

            public var role: String?

            public var table: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.database != nil {
                    map["Database"] = self.database!
                }
                if self.isSuccess != nil {
                    map["IsSuccess"] = self.isSuccess!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.table != nil {
                    map["Table"] = self.table!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Database") {
                    self.database = dict["Database"] as! String
                }
                if dict.keys.contains("IsSuccess") {
                    self.isSuccess = dict["IsSuccess"] as! Bool
                }
                if dict.keys.contains("Role") {
                    self.role = dict["Role"] as! String
                }
                if dict.keys.contains("Table") {
                    self.table = dict["Table"] as! String
                }
            }
        }
        public var tenantId: String?

        public var userName: String?

        public var userRole: [ModifyTenantUserRolesResponseBody.TenantUser.UserRole]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            if self.userRole != nil {
                var tmp : [Any] = []
                for k in self.userRole! {
                    tmp.append(k.toMap())
                }
                map["UserRole"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! String
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
            if dict.keys.contains("UserRole") {
                var tmp : [ModifyTenantUserRolesResponseBody.TenantUser.UserRole] = []
                for v in dict["UserRole"] as! [Any] {
                    var model = ModifyTenantUserRolesResponseBody.TenantUser.UserRole()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.userRole = tmp
            }
        }
    }
    public var requestId: String?

    public var tenantUser: ModifyTenantUserRolesResponseBody.TenantUser?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantUser?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tenantUser != nil {
            map["TenantUser"] = self.tenantUser?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TenantUser") {
            var model = ModifyTenantUserRolesResponseBody.TenantUser()
            model.fromMap(dict["TenantUser"] as! [String: Any])
            self.tenantUser = model
        }
    }
}

public class ModifyTenantUserRolesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyTenantUserRolesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyTenantUserRolesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyTenantUserStatusRequest : Tea.TeaModel {
    public var instanceId: String?

    public var tenantId: String?

    public var userName: String?

    public var userStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        if self.userStatus != nil {
            map["UserStatus"] = self.userStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
        if dict.keys.contains("UserStatus") {
            self.userStatus = dict["UserStatus"] as! String
        }
    }
}

public class ModifyTenantUserStatusResponseBody : Tea.TeaModel {
    public class TenantUser : Tea.TeaModel {
        public var tenantId: String?

        public var userName: String?

        public var userStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            if self.userStatus != nil {
                map["UserStatus"] = self.userStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! String
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
            if dict.keys.contains("UserStatus") {
                self.userStatus = dict["UserStatus"] as! String
            }
        }
    }
    public var requestId: String?

    public var tenantUser: [ModifyTenantUserStatusResponseBody.TenantUser]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tenantUser != nil {
            var tmp : [Any] = []
            for k in self.tenantUser! {
                tmp.append(k.toMap())
            }
            map["TenantUser"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TenantUser") {
            var tmp : [ModifyTenantUserStatusResponseBody.TenantUser] = []
            for v in dict["TenantUser"] as! [Any] {
                var model = ModifyTenantUserStatusResponseBody.TenantUser()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tenantUser = tmp
        }
    }
}

public class ModifyTenantUserStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyTenantUserStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyTenantUserStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReleaseProjectRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class ReleaseProjectResponseBody : Tea.TeaModel {
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: Any?

    public var errorDetail: ReleaseProjectResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("ErrorDetail") {
            var model = ReleaseProjectResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ReleaseProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReleaseProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReleaseWorkerInstanceRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class ReleaseWorkerInstanceResponseBody : Tea.TeaModel {
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: String?

    public var errorDetail: ReleaseWorkerInstanceResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("ErrorDetail") {
            var model = ReleaseWorkerInstanceResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ReleaseWorkerInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseWorkerInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReleaseWorkerInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResumeProjectRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class ResumeProjectResponseBody : Tea.TeaModel {
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: Any?

    public var errorDetail: ResumeProjectResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("ErrorDetail") {
            var model = ResumeProjectResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ResumeProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResumeProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResumeProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RetryProjectModifyRecordsRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class RetryProjectModifyRecordsResponseBody : Tea.TeaModel {
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: Any?

    public var errorDetail: RetryProjectModifyRecordsResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("ErrorDetail") {
            var model = RetryProjectModifyRecordsResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class RetryProjectModifyRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RetryProjectModifyRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RetryProjectModifyRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartProjectRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class StartProjectResponseBody : Tea.TeaModel {
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: String?

    public var errorDetail: StartProjectResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("ErrorDetail") {
            var model = StartProjectResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class StartProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartProjectsByLabelRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class StartProjectsByLabelResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var failedProjectIds: [String]?

        public var succeedProjectIds: [String]?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failedProjectIds != nil {
                map["FailedProjectIds"] = self.failedProjectIds!
            }
            if self.succeedProjectIds != nil {
                map["SucceedProjectIds"] = self.succeedProjectIds!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailedProjectIds") {
                self.failedProjectIds = dict["FailedProjectIds"] as! [String]
            }
            if dict.keys.contains("SucceedProjectIds") {
                self.succeedProjectIds = dict["SucceedProjectIds"] as! [String]
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: StartProjectsByLabelResponseBody.Data?

    public var errorDetail: StartProjectsByLabelResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            var model = StartProjectsByLabelResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorDetail") {
            var model = StartProjectsByLabelResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class StartProjectsByLabelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartProjectsByLabelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartProjectsByLabelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopProjectRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class StopProjectResponseBody : Tea.TeaModel {
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: String?

    public var errorDetail: StopProjectResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("ErrorDetail") {
            var model = StopProjectResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class StopProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopProjectModifyRecordsRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class StopProjectModifyRecordsResponseBody : Tea.TeaModel {
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: Any?

    public var errorDetail: StopProjectModifyRecordsResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("ErrorDetail") {
            var model = StopProjectModifyRecordsResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class StopProjectModifyRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopProjectModifyRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopProjectModifyRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopProjectsByLabelRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class StopProjectsByLabelResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var failedProjectIds: [String]?

        public var succeedProjectIds: [String]?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failedProjectIds != nil {
                map["FailedProjectIds"] = self.failedProjectIds!
            }
            if self.succeedProjectIds != nil {
                map["SucceedProjectIds"] = self.succeedProjectIds!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailedProjectIds") {
                self.failedProjectIds = dict["FailedProjectIds"] as! [String]
            }
            if dict.keys.contains("SucceedProjectIds") {
                self.succeedProjectIds = dict["SucceedProjectIds"] as! [String]
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: StopProjectsByLabelResponseBody.Data?

    public var errorDetail: StopProjectsByLabelResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            var model = StopProjectsByLabelResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorDetail") {
            var model = StopProjectsByLabelResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class StopProjectsByLabelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopProjectsByLabelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopProjectsByLabelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SwitchoverInstanceRequest : Tea.TeaModel {
    public var forced: Bool?

    public var instanceId: String?

    public var targetInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forced != nil {
            map["Forced"] = self.forced!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.targetInstanceId != nil {
            map["TargetInstanceId"] = self.targetInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Forced") {
            self.forced = dict["Forced"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TargetInstanceId") {
            self.targetInstanceId = dict["TargetInstanceId"] as! String
        }
    }
}

public class SwitchoverInstanceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var data: SwitchoverInstanceResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = SwitchoverInstanceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SwitchoverInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SwitchoverInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SwitchoverInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateProjectConfigRequest : Tea.TeaModel {
    public class CommonTransferConfig : Tea.TeaModel {
        public var sinkStoreFormat: String?

        public var sourceStoreFormat: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sinkStoreFormat != nil {
                map["SinkStoreFormat"] = self.sinkStoreFormat!
            }
            if self.sourceStoreFormat != nil {
                map["SourceStoreFormat"] = self.sourceStoreFormat!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SinkStoreFormat") {
                self.sinkStoreFormat = dict["SinkStoreFormat"] as! String
            }
            if dict.keys.contains("SourceStoreFormat") {
                self.sourceStoreFormat = dict["SourceStoreFormat"] as! String
            }
        }
    }
    public class FullTransferConfig : Tea.TeaModel {
        public var readWorkerNum: Int32?

        public var throttleIOPS: Int32?

        public var throttleRps: Int32?

        public var writeWorkerNum: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.readWorkerNum != nil {
                map["ReadWorkerNum"] = self.readWorkerNum!
            }
            if self.throttleIOPS != nil {
                map["ThrottleIOPS"] = self.throttleIOPS!
            }
            if self.throttleRps != nil {
                map["ThrottleRps"] = self.throttleRps!
            }
            if self.writeWorkerNum != nil {
                map["WriteWorkerNum"] = self.writeWorkerNum!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ReadWorkerNum") {
                self.readWorkerNum = dict["ReadWorkerNum"] as! Int32
            }
            if dict.keys.contains("ThrottleIOPS") {
                self.throttleIOPS = dict["ThrottleIOPS"] as! Int32
            }
            if dict.keys.contains("ThrottleRps") {
                self.throttleRps = dict["ThrottleRps"] as! Int32
            }
            if dict.keys.contains("WriteWorkerNum") {
                self.writeWorkerNum = dict["WriteWorkerNum"] as! Int32
            }
        }
    }
    public class IncrTransferConfig : Tea.TeaModel {
        public var incrSyncThreadCount: Int32?

        public var recordTypeWhiteList: [String]?

        public var supportDDLTypes: [String]?

        public var throttleIOPS: Int32?

        public var throttleRps: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.incrSyncThreadCount != nil {
                map["IncrSyncThreadCount"] = self.incrSyncThreadCount!
            }
            if self.recordTypeWhiteList != nil {
                map["RecordTypeWhiteList"] = self.recordTypeWhiteList!
            }
            if self.supportDDLTypes != nil {
                map["SupportDDLTypes"] = self.supportDDLTypes!
            }
            if self.throttleIOPS != nil {
                map["ThrottleIOPS"] = self.throttleIOPS!
            }
            if self.throttleRps != nil {
                map["ThrottleRps"] = self.throttleRps!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IncrSyncThreadCount") {
                self.incrSyncThreadCount = dict["IncrSyncThreadCount"] as! Int32
            }
            if dict.keys.contains("RecordTypeWhiteList") {
                self.recordTypeWhiteList = dict["RecordTypeWhiteList"] as! [String]
            }
            if dict.keys.contains("SupportDDLTypes") {
                self.supportDDLTypes = dict["SupportDDLTypes"] as! [String]
            }
            if dict.keys.contains("ThrottleIOPS") {
                self.throttleIOPS = dict["ThrottleIOPS"] as! Int32
            }
            if dict.keys.contains("ThrottleRps") {
                self.throttleRps = dict["ThrottleRps"] as! Int32
            }
        }
    }
    public class ReverseIncrTransferConfig : Tea.TeaModel {
        public var incrSyncThreadCount: Int32?

        public var recordTypeWhiteList: [String]?

        public var supportDDLTypes: [String]?

        public var throttleIOPS: Int32?

        public var throttleRps: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.incrSyncThreadCount != nil {
                map["IncrSyncThreadCount"] = self.incrSyncThreadCount!
            }
            if self.recordTypeWhiteList != nil {
                map["RecordTypeWhiteList"] = self.recordTypeWhiteList!
            }
            if self.supportDDLTypes != nil {
                map["SupportDDLTypes"] = self.supportDDLTypes!
            }
            if self.throttleIOPS != nil {
                map["ThrottleIOPS"] = self.throttleIOPS!
            }
            if self.throttleRps != nil {
                map["ThrottleRps"] = self.throttleRps!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IncrSyncThreadCount") {
                self.incrSyncThreadCount = dict["IncrSyncThreadCount"] as! Int32
            }
            if dict.keys.contains("RecordTypeWhiteList") {
                self.recordTypeWhiteList = dict["RecordTypeWhiteList"] as! [String]
            }
            if dict.keys.contains("SupportDDLTypes") {
                self.supportDDLTypes = dict["SupportDDLTypes"] as! [String]
            }
            if dict.keys.contains("ThrottleIOPS") {
                self.throttleIOPS = dict["ThrottleIOPS"] as! Int32
            }
            if dict.keys.contains("ThrottleRps") {
                self.throttleRps = dict["ThrottleRps"] as! Int32
            }
        }
    }
    public var commonTransferConfig: UpdateProjectConfigRequest.CommonTransferConfig?

    public var fullTransferConfig: UpdateProjectConfigRequest.FullTransferConfig?

    public var id: String?

    public var incrTransferConfig: UpdateProjectConfigRequest.IncrTransferConfig?

    public var reverseIncrTransferConfig: UpdateProjectConfigRequest.ReverseIncrTransferConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.commonTransferConfig?.validate()
        try self.fullTransferConfig?.validate()
        try self.incrTransferConfig?.validate()
        try self.reverseIncrTransferConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonTransferConfig != nil {
            map["CommonTransferConfig"] = self.commonTransferConfig?.toMap()
        }
        if self.fullTransferConfig != nil {
            map["FullTransferConfig"] = self.fullTransferConfig?.toMap()
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.incrTransferConfig != nil {
            map["IncrTransferConfig"] = self.incrTransferConfig?.toMap()
        }
        if self.reverseIncrTransferConfig != nil {
            map["ReverseIncrTransferConfig"] = self.reverseIncrTransferConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommonTransferConfig") {
            var model = UpdateProjectConfigRequest.CommonTransferConfig()
            model.fromMap(dict["CommonTransferConfig"] as! [String: Any])
            self.commonTransferConfig = model
        }
        if dict.keys.contains("FullTransferConfig") {
            var model = UpdateProjectConfigRequest.FullTransferConfig()
            model.fromMap(dict["FullTransferConfig"] as! [String: Any])
            self.fullTransferConfig = model
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("IncrTransferConfig") {
            var model = UpdateProjectConfigRequest.IncrTransferConfig()
            model.fromMap(dict["IncrTransferConfig"] as! [String: Any])
            self.incrTransferConfig = model
        }
        if dict.keys.contains("ReverseIncrTransferConfig") {
            var model = UpdateProjectConfigRequest.ReverseIncrTransferConfig()
            model.fromMap(dict["ReverseIncrTransferConfig"] as! [String: Any])
            self.reverseIncrTransferConfig = model
        }
    }
}

public class UpdateProjectConfigShrinkRequest : Tea.TeaModel {
    public var commonTransferConfigShrink: String?

    public var fullTransferConfigShrink: String?

    public var id: String?

    public var incrTransferConfigShrink: String?

    public var reverseIncrTransferConfigShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonTransferConfigShrink != nil {
            map["CommonTransferConfig"] = self.commonTransferConfigShrink!
        }
        if self.fullTransferConfigShrink != nil {
            map["FullTransferConfig"] = self.fullTransferConfigShrink!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.incrTransferConfigShrink != nil {
            map["IncrTransferConfig"] = self.incrTransferConfigShrink!
        }
        if self.reverseIncrTransferConfigShrink != nil {
            map["ReverseIncrTransferConfig"] = self.reverseIncrTransferConfigShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommonTransferConfig") {
            self.commonTransferConfigShrink = dict["CommonTransferConfig"] as! String
        }
        if dict.keys.contains("FullTransferConfig") {
            self.fullTransferConfigShrink = dict["FullTransferConfig"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("IncrTransferConfig") {
            self.incrTransferConfigShrink = dict["IncrTransferConfig"] as! String
        }
        if dict.keys.contains("ReverseIncrTransferConfig") {
            self.reverseIncrTransferConfigShrink = dict["ReverseIncrTransferConfig"] as! String
        }
    }
}

public class UpdateProjectConfigResponseBody : Tea.TeaModel {
    public class ErrorDetail : Tea.TeaModel {
        public var code: String?

        public var extraContext: [String: Any]?

        public var level: String?

        public var message: String?

        public var messageMcmsContext: [String: String]?

        public var messageMcmsKey: String?

        public var proposal: String?

        public var proposalMcmsContext: [String: String]?

        public var proposalMcmsKey: String?

        public var reason: String?

        public var reasonMcmsContext: [String: String]?

        public var reasonMcmsKey: String?

        public var upstreamErrorDetail: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.extraContext != nil {
                map["ExtraContext"] = self.extraContext!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.messageMcmsContext != nil {
                map["MessageMcmsContext"] = self.messageMcmsContext!
            }
            if self.messageMcmsKey != nil {
                map["MessageMcmsKey"] = self.messageMcmsKey!
            }
            if self.proposal != nil {
                map["Proposal"] = self.proposal!
            }
            if self.proposalMcmsContext != nil {
                map["ProposalMcmsContext"] = self.proposalMcmsContext!
            }
            if self.proposalMcmsKey != nil {
                map["ProposalMcmsKey"] = self.proposalMcmsKey!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonMcmsContext != nil {
                map["ReasonMcmsContext"] = self.reasonMcmsContext!
            }
            if self.reasonMcmsKey != nil {
                map["ReasonMcmsKey"] = self.reasonMcmsKey!
            }
            if self.upstreamErrorDetail != nil {
                map["UpstreamErrorDetail"] = self.upstreamErrorDetail!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ExtraContext") {
                self.extraContext = dict["ExtraContext"] as! [String: Any]
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("MessageMcmsContext") {
                self.messageMcmsContext = dict["MessageMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("MessageMcmsKey") {
                self.messageMcmsKey = dict["MessageMcmsKey"] as! String
            }
            if dict.keys.contains("Proposal") {
                self.proposal = dict["Proposal"] as! String
            }
            if dict.keys.contains("ProposalMcmsContext") {
                self.proposalMcmsContext = dict["ProposalMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ProposalMcmsKey") {
                self.proposalMcmsKey = dict["ProposalMcmsKey"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("ReasonMcmsContext") {
                self.reasonMcmsContext = dict["ReasonMcmsContext"] as! [String: String]
            }
            if dict.keys.contains("ReasonMcmsKey") {
                self.reasonMcmsKey = dict["ReasonMcmsKey"] as! String
            }
            if dict.keys.contains("UpstreamErrorDetail") {
                self.upstreamErrorDetail = dict["UpstreamErrorDetail"] as! Any
            }
        }
    }
    public var advice: String?

    public var code: String?

    public var cost: String?

    public var data: String?

    public var errorDetail: UpdateProjectConfigResponseBody.ErrorDetail?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.errorDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cost != nil {
            map["Cost"] = self.cost!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorDetail != nil {
            map["ErrorDetail"] = self.errorDetail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Cost") {
            self.cost = dict["Cost"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("ErrorDetail") {
            var model = UpdateProjectConfigResponseBody.ErrorDetail()
            model.fromMap(dict["ErrorDetail"] as! [String: Any])
            self.errorDetail = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class UpdateProjectConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateProjectConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateProjectConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
