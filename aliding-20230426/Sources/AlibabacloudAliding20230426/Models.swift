import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AddAttendeeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: AddAttendeeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = AddAttendeeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class AddAttendeeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class AddAttendeeRequest : Tea.TeaModel {
    public class AttendeesToAdd : Tea.TeaModel {
        public var id: String?

        public var isOptional: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.isOptional != nil {
                map["isOptional"] = self.isOptional!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") && dict["id"] != nil {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("isOptional") && dict["isOptional"] != nil {
                self.isOptional = dict["isOptional"] as! Bool
            }
        }
    }
    public var attendeesToAdd: [AddAttendeeRequest.AttendeesToAdd]?

    public var calendarId: String?

    public var eventId: String?

    public var chatNotification: Bool?

    public var pushNotification: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendeesToAdd != nil {
            var tmp : [Any] = []
            for k in self.attendeesToAdd! {
                tmp.append(k.toMap())
            }
            map["AttendeesToAdd"] = tmp
        }
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.chatNotification != nil {
            map["chatNotification"] = self.chatNotification!
        }
        if self.pushNotification != nil {
            map["pushNotification"] = self.pushNotification!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttendeesToAdd") && dict["AttendeesToAdd"] != nil {
            var tmp : [AddAttendeeRequest.AttendeesToAdd] = []
            for v in dict["AttendeesToAdd"] as! [Any] {
                var model = AddAttendeeRequest.AttendeesToAdd()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.attendeesToAdd = tmp
        }
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("chatNotification") && dict["chatNotification"] != nil {
            self.chatNotification = dict["chatNotification"] as! Bool
        }
        if dict.keys.contains("pushNotification") && dict["pushNotification"] != nil {
            self.pushNotification = dict["pushNotification"] as! Bool
        }
    }
}

public class AddAttendeeShrinkRequest : Tea.TeaModel {
    public var attendeesToAddShrink: String?

    public var calendarId: String?

    public var eventId: String?

    public var chatNotification: Bool?

    public var pushNotification: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendeesToAddShrink != nil {
            map["AttendeesToAdd"] = self.attendeesToAddShrink!
        }
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.chatNotification != nil {
            map["chatNotification"] = self.chatNotification!
        }
        if self.pushNotification != nil {
            map["pushNotification"] = self.pushNotification!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttendeesToAdd") && dict["AttendeesToAdd"] != nil {
            self.attendeesToAddShrink = dict["AttendeesToAdd"] as! String
        }
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("chatNotification") && dict["chatNotification"] != nil {
            self.chatNotification = dict["chatNotification"] as! Bool
        }
        if dict.keys.contains("pushNotification") && dict["pushNotification"] != nil {
            self.pushNotification = dict["pushNotification"] as! Bool
        }
    }
}

public class AddAttendeeResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public var data: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! Any
            }
        }
    }
    public var content: AddAttendeeResponseBody.Content?

    public var errorCode: String?

    public var errorCtx: [String: Any]?

    public var errorMsg: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorCtx != nil {
            map["ErrorCtx"] = self.errorCtx!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") && dict["Content"] != nil {
            var model = AddAttendeeResponseBody.Content()
            model.fromMap(dict["Content"] as! [String: Any])
            self.content = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorCtx") && dict["ErrorCtx"] != nil {
            self.errorCtx = dict["ErrorCtx"] as! [String: Any]
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddAttendeeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddAttendeeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddAttendeeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddMeetingRoomsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: AddMeetingRoomsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = AddMeetingRoomsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class AddMeetingRoomsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class AddMeetingRoomsRequest : Tea.TeaModel {
    public class MeetingRoomsToAdd : Tea.TeaModel {
        public var roomId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.roomId != nil {
                map["RoomId"] = self.roomId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RoomId") && dict["RoomId"] != nil {
                self.roomId = dict["RoomId"] as! String
            }
        }
    }
    public var calendarId: String?

    public var eventId: String?

    public var meetingRoomsToAdd: [AddMeetingRoomsRequest.MeetingRoomsToAdd]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.meetingRoomsToAdd != nil {
            var tmp : [Any] = []
            for k in self.meetingRoomsToAdd! {
                tmp.append(k.toMap())
            }
            map["MeetingRoomsToAdd"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("MeetingRoomsToAdd") && dict["MeetingRoomsToAdd"] != nil {
            var tmp : [AddMeetingRoomsRequest.MeetingRoomsToAdd] = []
            for v in dict["MeetingRoomsToAdd"] as! [Any] {
                var model = AddMeetingRoomsRequest.MeetingRoomsToAdd()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.meetingRoomsToAdd = tmp
        }
    }
}

public class AddMeetingRoomsShrinkRequest : Tea.TeaModel {
    public var calendarId: String?

    public var eventId: String?

    public var meetingRoomsToAddShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.meetingRoomsToAddShrink != nil {
            map["MeetingRoomsToAdd"] = self.meetingRoomsToAddShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("MeetingRoomsToAdd") && dict["MeetingRoomsToAdd"] != nil {
            self.meetingRoomsToAddShrink = dict["MeetingRoomsToAdd"] as! String
        }
    }
}

public class AddMeetingRoomsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! Bool
        }
    }
}

public class AddMeetingRoomsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddMeetingRoomsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddMeetingRoomsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddScenegroupMemberHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: AddScenegroupMemberHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = AddScenegroupMemberHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class AddScenegroupMemberShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class AddScenegroupMemberRequest : Tea.TeaModel {
    public var openConversationId: String?

    public var userIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.openConversationId != nil {
            map["OpenConversationId"] = self.openConversationId!
        }
        if self.userIds != nil {
            map["UserIds"] = self.userIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OpenConversationId") && dict["OpenConversationId"] != nil {
            self.openConversationId = dict["OpenConversationId"] as! String
        }
        if dict.keys.contains("UserIds") && dict["UserIds"] != nil {
            self.userIds = dict["UserIds"] as! String
        }
    }
}

public class AddScenegroupMemberResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
    }
}

public class AddScenegroupMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddScenegroupMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddScenegroupMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddWorkspaceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: AddWorkspaceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = AddWorkspaceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class AddWorkspaceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class AddWorkspaceRequest : Tea.TeaModel {
    public class Option : Tea.TeaModel {
        public var description_: String?

        public var teamId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.teamId != nil {
                map["TeamId"] = self.teamId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("TeamId") && dict["TeamId"] != nil {
                self.teamId = dict["TeamId"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var name: String?

    public var option: AddWorkspaceRequest.Option?

    public var tenantContext: AddWorkspaceRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.option?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.option != nil {
            map["Option"] = self.option?.toMap()
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Option") && dict["Option"] != nil {
            var model = AddWorkspaceRequest.Option()
            model.fromMap(dict["Option"] as! [String: Any])
            self.option = model
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = AddWorkspaceRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class AddWorkspaceShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var optionShrink: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.optionShrink != nil {
            map["Option"] = self.optionShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Option") && dict["Option"] != nil {
            self.optionShrink = dict["Option"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class AddWorkspaceResponseBody : Tea.TeaModel {
    public class Workspace : Tea.TeaModel {
        public class Icon : Tea.TeaModel {
            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var corpId: String?

        public var cover: String?

        public var createTime: String?

        public var creatorId: String?

        public var description_: String?

        public var icon: AddWorkspaceResponseBody.Workspace.Icon?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var permissionRole: String?

        public var rootNodeId: String?

        public var teamId: String?

        public var type: String?

        public var url: String?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.icon?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.cover != nil {
                map["Cover"] = self.cover!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.icon != nil {
                map["Icon"] = self.icon?.toMap()
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.permissionRole != nil {
                map["PermissionRole"] = self.permissionRole!
            }
            if self.rootNodeId != nil {
                map["RootNodeId"] = self.rootNodeId!
            }
            if self.teamId != nil {
                map["TeamId"] = self.teamId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") && dict["CorpId"] != nil {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("Cover") && dict["Cover"] != nil {
                self.cover = dict["Cover"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Icon") && dict["Icon"] != nil {
                var model = AddWorkspaceResponseBody.Workspace.Icon()
                model.fromMap(dict["Icon"] as! [String: Any])
                self.icon = model
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") && dict["ModifierId"] != nil {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PermissionRole") && dict["PermissionRole"] != nil {
                self.permissionRole = dict["PermissionRole"] as! String
            }
            if dict.keys.contains("RootNodeId") && dict["RootNodeId"] != nil {
                self.rootNodeId = dict["RootNodeId"] as! String
            }
            if dict.keys.contains("TeamId") && dict["TeamId"] != nil {
                self.teamId = dict["TeamId"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var requestId: String?

    public var workspace: AddWorkspaceResponseBody.Workspace?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workspace?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.workspace != nil {
            map["workspace"] = self.workspace?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("workspace") && dict["workspace"] != nil {
            var model = AddWorkspaceResponseBody.Workspace()
            model.fromMap(dict["workspace"] as! [String: Any])
            self.workspace = model
        }
    }
}

public class AddWorkspaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddWorkspaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddWorkspaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddWorkspaceDocMembersHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: AddWorkspaceDocMembersHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = AddWorkspaceDocMembersHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class AddWorkspaceDocMembersShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class AddWorkspaceDocMembersRequest : Tea.TeaModel {
    public class Members : Tea.TeaModel {
        public var memberId: String?

        public var memberType: String?

        public var roleType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.memberId != nil {
                map["MemberId"] = self.memberId!
            }
            if self.memberType != nil {
                map["MemberType"] = self.memberType!
            }
            if self.roleType != nil {
                map["RoleType"] = self.roleType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MemberId") && dict["MemberId"] != nil {
                self.memberId = dict["MemberId"] as! String
            }
            if dict.keys.contains("MemberType") && dict["MemberType"] != nil {
                self.memberType = dict["MemberType"] as! String
            }
            if dict.keys.contains("RoleType") && dict["RoleType"] != nil {
                self.roleType = dict["RoleType"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var members: [AddWorkspaceDocMembersRequest.Members]?

    public var nodeId: String?

    public var tenantContext: AddWorkspaceDocMembersRequest.TenantContext?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.members != nil {
            var tmp : [Any] = []
            for k in self.members! {
                tmp.append(k.toMap())
            }
            map["Members"] = tmp
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") && dict["Members"] != nil {
            var tmp : [AddWorkspaceDocMembersRequest.Members] = []
            for v in dict["Members"] as! [Any] {
                var model = AddWorkspaceDocMembersRequest.Members()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.members = tmp
        }
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = AddWorkspaceDocMembersRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class AddWorkspaceDocMembersShrinkRequest : Tea.TeaModel {
    public var membersShrink: String?

    public var nodeId: String?

    public var tenantContextShrink: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.membersShrink != nil {
            map["Members"] = self.membersShrink!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") && dict["Members"] != nil {
            self.membersShrink = dict["Members"] as! String
        }
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class AddWorkspaceDocMembersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class AddWorkspaceDocMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddWorkspaceDocMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddWorkspaceDocMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddWorkspaceMembersHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: AddWorkspaceMembersHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = AddWorkspaceMembersHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class AddWorkspaceMembersShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class AddWorkspaceMembersRequest : Tea.TeaModel {
    public class Members : Tea.TeaModel {
        public var memberId: String?

        public var memberType: String?

        public var roleType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.memberId != nil {
                map["MemberId"] = self.memberId!
            }
            if self.memberType != nil {
                map["MemberType"] = self.memberType!
            }
            if self.roleType != nil {
                map["RoleType"] = self.roleType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MemberId") && dict["MemberId"] != nil {
                self.memberId = dict["MemberId"] as! String
            }
            if dict.keys.contains("MemberType") && dict["MemberType"] != nil {
                self.memberType = dict["MemberType"] as! String
            }
            if dict.keys.contains("RoleType") && dict["RoleType"] != nil {
                self.roleType = dict["RoleType"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var members: [AddWorkspaceMembersRequest.Members]?

    public var tenantContext: AddWorkspaceMembersRequest.TenantContext?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.members != nil {
            var tmp : [Any] = []
            for k in self.members! {
                tmp.append(k.toMap())
            }
            map["Members"] = tmp
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") && dict["Members"] != nil {
            var tmp : [AddWorkspaceMembersRequest.Members] = []
            for v in dict["Members"] as! [Any] {
                var model = AddWorkspaceMembersRequest.Members()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.members = tmp
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = AddWorkspaceMembersRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class AddWorkspaceMembersShrinkRequest : Tea.TeaModel {
    public var membersShrink: String?

    public var tenantContextShrink: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.membersShrink != nil {
            map["Members"] = self.membersShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") && dict["Members"] != nil {
            self.membersShrink = dict["Members"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class AddWorkspaceMembersResponseBody : Tea.TeaModel {
    public var notInOrgList: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notInOrgList != nil {
            map["NotInOrgList"] = self.notInOrgList!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NotInOrgList") && dict["NotInOrgList"] != nil {
            self.notInOrgList = dict["NotInOrgList"] as! [String]
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class AddWorkspaceMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddWorkspaceMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddWorkspaceMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchGetFormDataByIdListHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: BatchGetFormDataByIdListHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = BatchGetFormDataByIdListHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class BatchGetFormDataByIdListShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class BatchGetFormDataByIdListRequest : Tea.TeaModel {
    public var appType: String?

    public var formInstanceIdList: [String]?

    public var formUuid: String?

    public var needFormInstanceValue: Bool?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.formInstanceIdList != nil {
            map["FormInstanceIdList"] = self.formInstanceIdList!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.needFormInstanceValue != nil {
            map["NeedFormInstanceValue"] = self.needFormInstanceValue!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FormInstanceIdList") && dict["FormInstanceIdList"] != nil {
            self.formInstanceIdList = dict["FormInstanceIdList"] as! [String]
        }
        if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("NeedFormInstanceValue") && dict["NeedFormInstanceValue"] != nil {
            self.needFormInstanceValue = dict["NeedFormInstanceValue"] as! Bool
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class BatchGetFormDataByIdListShrinkRequest : Tea.TeaModel {
    public var appType: String?

    public var formInstanceIdListShrink: String?

    public var formUuid: String?

    public var needFormInstanceValue: Bool?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.formInstanceIdListShrink != nil {
            map["FormInstanceIdList"] = self.formInstanceIdListShrink!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.needFormInstanceValue != nil {
            map["NeedFormInstanceValue"] = self.needFormInstanceValue!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FormInstanceIdList") && dict["FormInstanceIdList"] != nil {
            self.formInstanceIdListShrink = dict["FormInstanceIdList"] as! String
        }
        if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("NeedFormInstanceValue") && dict["NeedFormInstanceValue"] != nil {
            self.needFormInstanceValue = dict["NeedFormInstanceValue"] as! Bool
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class BatchGetFormDataByIdListResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ModifyUser : Tea.TeaModel {
            public class Name : Tea.TeaModel {
                public var nameInChinese: String?

                public var nameInEnglish: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nameInChinese != nil {
                        map["NameInChinese"] = self.nameInChinese!
                    }
                    if self.nameInEnglish != nil {
                        map["NameInEnglish"] = self.nameInEnglish!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NameInChinese") && dict["NameInChinese"] != nil {
                        self.nameInChinese = dict["NameInChinese"] as! String
                    }
                    if dict.keys.contains("NameInEnglish") && dict["NameInEnglish"] != nil {
                        self.nameInEnglish = dict["NameInEnglish"] as! String
                    }
                }
            }
            public var name: BatchGetFormDataByIdListResponseBody.Result.ModifyUser.Name?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.name?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name?.toMap()
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    var model = BatchGetFormDataByIdListResponseBody.Result.ModifyUser.Name()
                    model.fromMap(dict["Name"] as! [String: Any])
                    self.name = model
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public class Originator : Tea.TeaModel {
            public class Name : Tea.TeaModel {
                public var nameInChinese: String?

                public var nameInEnglish: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nameInChinese != nil {
                        map["NameInChinese"] = self.nameInChinese!
                    }
                    if self.nameInEnglish != nil {
                        map["NameInEnglish"] = self.nameInEnglish!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NameInChinese") && dict["NameInChinese"] != nil {
                        self.nameInChinese = dict["NameInChinese"] as! String
                    }
                    if dict.keys.contains("NameInEnglish") && dict["NameInEnglish"] != nil {
                        self.nameInEnglish = dict["NameInEnglish"] as! String
                    }
                }
            }
            public var name: BatchGetFormDataByIdListResponseBody.Result.Originator.Name?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.name?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name?.toMap()
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    var model = BatchGetFormDataByIdListResponseBody.Result.Originator.Name()
                    model.fromMap(dict["Name"] as! [String: Any])
                    self.name = model
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var createTimeGMT: String?

        public var creatorUserId: String?

        public var formData: [String: Any]?

        public var formInstanceId: String?

        public var formUuid: String?

        public var id: Int64?

        public var instanceValue: String?

        public var modifiedTimeGMT: String?

        public var modifier: String?

        public var modifyUser: BatchGetFormDataByIdListResponseBody.Result.ModifyUser?

        public var originator: BatchGetFormDataByIdListResponseBody.Result.Originator?

        public var sequence: String?

        public var serialNumber: String?

        public var title: String?

        public var version: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.modifyUser?.validate()
            try self.originator?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTimeGMT != nil {
                map["CreateTimeGMT"] = self.createTimeGMT!
            }
            if self.creatorUserId != nil {
                map["CreatorUserId"] = self.creatorUserId!
            }
            if self.formData != nil {
                map["FormData"] = self.formData!
            }
            if self.formInstanceId != nil {
                map["FormInstanceId"] = self.formInstanceId!
            }
            if self.formUuid != nil {
                map["FormUuid"] = self.formUuid!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.instanceValue != nil {
                map["InstanceValue"] = self.instanceValue!
            }
            if self.modifiedTimeGMT != nil {
                map["ModifiedTimeGMT"] = self.modifiedTimeGMT!
            }
            if self.modifier != nil {
                map["Modifier"] = self.modifier!
            }
            if self.modifyUser != nil {
                map["ModifyUser"] = self.modifyUser?.toMap()
            }
            if self.originator != nil {
                map["Originator"] = self.originator?.toMap()
            }
            if self.sequence != nil {
                map["Sequence"] = self.sequence!
            }
            if self.serialNumber != nil {
                map["SerialNumber"] = self.serialNumber!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTimeGMT") && dict["CreateTimeGMT"] != nil {
                self.createTimeGMT = dict["CreateTimeGMT"] as! String
            }
            if dict.keys.contains("CreatorUserId") && dict["CreatorUserId"] != nil {
                self.creatorUserId = dict["CreatorUserId"] as! String
            }
            if dict.keys.contains("FormData") && dict["FormData"] != nil {
                self.formData = dict["FormData"] as! [String: Any]
            }
            if dict.keys.contains("FormInstanceId") && dict["FormInstanceId"] != nil {
                self.formInstanceId = dict["FormInstanceId"] as! String
            }
            if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
                self.formUuid = dict["FormUuid"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("InstanceValue") && dict["InstanceValue"] != nil {
                self.instanceValue = dict["InstanceValue"] as! String
            }
            if dict.keys.contains("ModifiedTimeGMT") && dict["ModifiedTimeGMT"] != nil {
                self.modifiedTimeGMT = dict["ModifiedTimeGMT"] as! String
            }
            if dict.keys.contains("Modifier") && dict["Modifier"] != nil {
                self.modifier = dict["Modifier"] as! String
            }
            if dict.keys.contains("ModifyUser") && dict["ModifyUser"] != nil {
                var model = BatchGetFormDataByIdListResponseBody.Result.ModifyUser()
                model.fromMap(dict["ModifyUser"] as! [String: Any])
                self.modifyUser = model
            }
            if dict.keys.contains("Originator") && dict["Originator"] != nil {
                var model = BatchGetFormDataByIdListResponseBody.Result.Originator()
                model.fromMap(dict["Originator"] as! [String: Any])
                self.originator = model
            }
            if dict.keys.contains("Sequence") && dict["Sequence"] != nil {
                self.sequence = dict["Sequence"] as! String
            }
            if dict.keys.contains("SerialNumber") && dict["SerialNumber"] != nil {
                self.serialNumber = dict["SerialNumber"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("Version") && dict["Version"] != nil {
                self.version = dict["Version"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var result: [BatchGetFormDataByIdListResponseBody.Result]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            var tmp : [BatchGetFormDataByIdListResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = BatchGetFormDataByIdListResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class BatchGetFormDataByIdListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchGetFormDataByIdListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BatchGetFormDataByIdListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchRemovalByFormInstanceIdListHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: BatchRemovalByFormInstanceIdListHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = BatchRemovalByFormInstanceIdListHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class BatchRemovalByFormInstanceIdListShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class BatchRemovalByFormInstanceIdListRequest : Tea.TeaModel {
    public var appType: String?

    public var asynchronousExecution: Bool?

    public var executeExpression: Bool?

    public var formInstanceIdList: [String]?

    public var formUuid: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.asynchronousExecution != nil {
            map["AsynchronousExecution"] = self.asynchronousExecution!
        }
        if self.executeExpression != nil {
            map["ExecuteExpression"] = self.executeExpression!
        }
        if self.formInstanceIdList != nil {
            map["FormInstanceIdList"] = self.formInstanceIdList!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("AsynchronousExecution") && dict["AsynchronousExecution"] != nil {
            self.asynchronousExecution = dict["AsynchronousExecution"] as! Bool
        }
        if dict.keys.contains("ExecuteExpression") && dict["ExecuteExpression"] != nil {
            self.executeExpression = dict["ExecuteExpression"] as! Bool
        }
        if dict.keys.contains("FormInstanceIdList") && dict["FormInstanceIdList"] != nil {
            self.formInstanceIdList = dict["FormInstanceIdList"] as! [String]
        }
        if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class BatchRemovalByFormInstanceIdListShrinkRequest : Tea.TeaModel {
    public var appType: String?

    public var asynchronousExecution: Bool?

    public var executeExpression: Bool?

    public var formInstanceIdListShrink: String?

    public var formUuid: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.asynchronousExecution != nil {
            map["AsynchronousExecution"] = self.asynchronousExecution!
        }
        if self.executeExpression != nil {
            map["ExecuteExpression"] = self.executeExpression!
        }
        if self.formInstanceIdListShrink != nil {
            map["FormInstanceIdList"] = self.formInstanceIdListShrink!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("AsynchronousExecution") && dict["AsynchronousExecution"] != nil {
            self.asynchronousExecution = dict["AsynchronousExecution"] as! Bool
        }
        if dict.keys.contains("ExecuteExpression") && dict["ExecuteExpression"] != nil {
            self.executeExpression = dict["ExecuteExpression"] as! Bool
        }
        if dict.keys.contains("FormInstanceIdList") && dict["FormInstanceIdList"] != nil {
            self.formInstanceIdListShrink = dict["FormInstanceIdList"] as! String
        }
        if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class BatchRemovalByFormInstanceIdListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class BatchRemovalByFormInstanceIdListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchRemovalByFormInstanceIdListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BatchRemovalByFormInstanceIdListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchSaveFormDataHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: BatchSaveFormDataHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = BatchSaveFormDataHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class BatchSaveFormDataShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class BatchSaveFormDataRequest : Tea.TeaModel {
    public var appType: String?

    public var asynchronousExecution: Bool?

    public var formDataJsonList: [String]?

    public var formUuid: String?

    public var keepRunningAfterException: Bool?

    public var noExecuteExpression: Bool?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.asynchronousExecution != nil {
            map["AsynchronousExecution"] = self.asynchronousExecution!
        }
        if self.formDataJsonList != nil {
            map["FormDataJsonList"] = self.formDataJsonList!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.keepRunningAfterException != nil {
            map["KeepRunningAfterException"] = self.keepRunningAfterException!
        }
        if self.noExecuteExpression != nil {
            map["NoExecuteExpression"] = self.noExecuteExpression!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("AsynchronousExecution") && dict["AsynchronousExecution"] != nil {
            self.asynchronousExecution = dict["AsynchronousExecution"] as! Bool
        }
        if dict.keys.contains("FormDataJsonList") && dict["FormDataJsonList"] != nil {
            self.formDataJsonList = dict["FormDataJsonList"] as! [String]
        }
        if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("KeepRunningAfterException") && dict["KeepRunningAfterException"] != nil {
            self.keepRunningAfterException = dict["KeepRunningAfterException"] as! Bool
        }
        if dict.keys.contains("NoExecuteExpression") && dict["NoExecuteExpression"] != nil {
            self.noExecuteExpression = dict["NoExecuteExpression"] as! Bool
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class BatchSaveFormDataShrinkRequest : Tea.TeaModel {
    public var appType: String?

    public var asynchronousExecution: Bool?

    public var formDataJsonListShrink: String?

    public var formUuid: String?

    public var keepRunningAfterException: Bool?

    public var noExecuteExpression: Bool?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.asynchronousExecution != nil {
            map["AsynchronousExecution"] = self.asynchronousExecution!
        }
        if self.formDataJsonListShrink != nil {
            map["FormDataJsonList"] = self.formDataJsonListShrink!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.keepRunningAfterException != nil {
            map["KeepRunningAfterException"] = self.keepRunningAfterException!
        }
        if self.noExecuteExpression != nil {
            map["NoExecuteExpression"] = self.noExecuteExpression!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("AsynchronousExecution") && dict["AsynchronousExecution"] != nil {
            self.asynchronousExecution = dict["AsynchronousExecution"] as! Bool
        }
        if dict.keys.contains("FormDataJsonList") && dict["FormDataJsonList"] != nil {
            self.formDataJsonListShrink = dict["FormDataJsonList"] as! String
        }
        if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("KeepRunningAfterException") && dict["KeepRunningAfterException"] != nil {
            self.keepRunningAfterException = dict["KeepRunningAfterException"] as! Bool
        }
        if dict.keys.contains("NoExecuteExpression") && dict["NoExecuteExpression"] != nil {
            self.noExecuteExpression = dict["NoExecuteExpression"] as! Bool
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class BatchSaveFormDataResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [String]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! [String]
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class BatchSaveFormDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchSaveFormDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BatchSaveFormDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchUpdateFormDataByInstanceIdHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: BatchUpdateFormDataByInstanceIdHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = BatchUpdateFormDataByInstanceIdHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class BatchUpdateFormDataByInstanceIdShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class BatchUpdateFormDataByInstanceIdRequest : Tea.TeaModel {
    public var appType: String?

    public var asynchronousExecution: Bool?

    public var formInstanceIdList: [String]?

    public var formUuid: String?

    public var ignoreEmpty: Bool?

    public var noExecuteExpression: Bool?

    public var systemToken: String?

    public var updateFormDataJson: String?

    public var useLatestFormSchemaVersion: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.asynchronousExecution != nil {
            map["AsynchronousExecution"] = self.asynchronousExecution!
        }
        if self.formInstanceIdList != nil {
            map["FormInstanceIdList"] = self.formInstanceIdList!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.ignoreEmpty != nil {
            map["IgnoreEmpty"] = self.ignoreEmpty!
        }
        if self.noExecuteExpression != nil {
            map["NoExecuteExpression"] = self.noExecuteExpression!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.updateFormDataJson != nil {
            map["UpdateFormDataJson"] = self.updateFormDataJson!
        }
        if self.useLatestFormSchemaVersion != nil {
            map["UseLatestFormSchemaVersion"] = self.useLatestFormSchemaVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("AsynchronousExecution") && dict["AsynchronousExecution"] != nil {
            self.asynchronousExecution = dict["AsynchronousExecution"] as! Bool
        }
        if dict.keys.contains("FormInstanceIdList") && dict["FormInstanceIdList"] != nil {
            self.formInstanceIdList = dict["FormInstanceIdList"] as! [String]
        }
        if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("IgnoreEmpty") && dict["IgnoreEmpty"] != nil {
            self.ignoreEmpty = dict["IgnoreEmpty"] as! Bool
        }
        if dict.keys.contains("NoExecuteExpression") && dict["NoExecuteExpression"] != nil {
            self.noExecuteExpression = dict["NoExecuteExpression"] as! Bool
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("UpdateFormDataJson") && dict["UpdateFormDataJson"] != nil {
            self.updateFormDataJson = dict["UpdateFormDataJson"] as! String
        }
        if dict.keys.contains("UseLatestFormSchemaVersion") && dict["UseLatestFormSchemaVersion"] != nil {
            self.useLatestFormSchemaVersion = dict["UseLatestFormSchemaVersion"] as! Bool
        }
    }
}

public class BatchUpdateFormDataByInstanceIdShrinkRequest : Tea.TeaModel {
    public var appType: String?

    public var asynchronousExecution: Bool?

    public var formInstanceIdListShrink: String?

    public var formUuid: String?

    public var ignoreEmpty: Bool?

    public var noExecuteExpression: Bool?

    public var systemToken: String?

    public var updateFormDataJson: String?

    public var useLatestFormSchemaVersion: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.asynchronousExecution != nil {
            map["AsynchronousExecution"] = self.asynchronousExecution!
        }
        if self.formInstanceIdListShrink != nil {
            map["FormInstanceIdList"] = self.formInstanceIdListShrink!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.ignoreEmpty != nil {
            map["IgnoreEmpty"] = self.ignoreEmpty!
        }
        if self.noExecuteExpression != nil {
            map["NoExecuteExpression"] = self.noExecuteExpression!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.updateFormDataJson != nil {
            map["UpdateFormDataJson"] = self.updateFormDataJson!
        }
        if self.useLatestFormSchemaVersion != nil {
            map["UseLatestFormSchemaVersion"] = self.useLatestFormSchemaVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("AsynchronousExecution") && dict["AsynchronousExecution"] != nil {
            self.asynchronousExecution = dict["AsynchronousExecution"] as! Bool
        }
        if dict.keys.contains("FormInstanceIdList") && dict["FormInstanceIdList"] != nil {
            self.formInstanceIdListShrink = dict["FormInstanceIdList"] as! String
        }
        if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("IgnoreEmpty") && dict["IgnoreEmpty"] != nil {
            self.ignoreEmpty = dict["IgnoreEmpty"] as! Bool
        }
        if dict.keys.contains("NoExecuteExpression") && dict["NoExecuteExpression"] != nil {
            self.noExecuteExpression = dict["NoExecuteExpression"] as! Bool
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("UpdateFormDataJson") && dict["UpdateFormDataJson"] != nil {
            self.updateFormDataJson = dict["UpdateFormDataJson"] as! String
        }
        if dict.keys.contains("UseLatestFormSchemaVersion") && dict["UseLatestFormSchemaVersion"] != nil {
            self.useLatestFormSchemaVersion = dict["UseLatestFormSchemaVersion"] as! Bool
        }
    }
}

public class BatchUpdateFormDataByInstanceIdResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [String]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! [String]
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class BatchUpdateFormDataByInstanceIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchUpdateFormDataByInstanceIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BatchUpdateFormDataByInstanceIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchUpdateFormDataByInstanceMapHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: BatchUpdateFormDataByInstanceMapHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = BatchUpdateFormDataByInstanceMapHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class BatchUpdateFormDataByInstanceMapShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class BatchUpdateFormDataByInstanceMapRequest : Tea.TeaModel {
    public var appType: String?

    public var asynchronousExecution: Bool?

    public var formUuid: String?

    public var ignoreEmpty: Bool?

    public var noExecuteExpression: Bool?

    public var systemToken: String?

    public var updateFormDataJsonMap: [String: Any]?

    public var useLatestFormSchemaVersion: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.asynchronousExecution != nil {
            map["AsynchronousExecution"] = self.asynchronousExecution!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.ignoreEmpty != nil {
            map["IgnoreEmpty"] = self.ignoreEmpty!
        }
        if self.noExecuteExpression != nil {
            map["NoExecuteExpression"] = self.noExecuteExpression!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.updateFormDataJsonMap != nil {
            map["UpdateFormDataJsonMap"] = self.updateFormDataJsonMap!
        }
        if self.useLatestFormSchemaVersion != nil {
            map["UseLatestFormSchemaVersion"] = self.useLatestFormSchemaVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("AsynchronousExecution") && dict["AsynchronousExecution"] != nil {
            self.asynchronousExecution = dict["AsynchronousExecution"] as! Bool
        }
        if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("IgnoreEmpty") && dict["IgnoreEmpty"] != nil {
            self.ignoreEmpty = dict["IgnoreEmpty"] as! Bool
        }
        if dict.keys.contains("NoExecuteExpression") && dict["NoExecuteExpression"] != nil {
            self.noExecuteExpression = dict["NoExecuteExpression"] as! Bool
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("UpdateFormDataJsonMap") && dict["UpdateFormDataJsonMap"] != nil {
            self.updateFormDataJsonMap = dict["UpdateFormDataJsonMap"] as! [String: Any]
        }
        if dict.keys.contains("UseLatestFormSchemaVersion") && dict["UseLatestFormSchemaVersion"] != nil {
            self.useLatestFormSchemaVersion = dict["UseLatestFormSchemaVersion"] as! Bool
        }
    }
}

public class BatchUpdateFormDataByInstanceMapShrinkRequest : Tea.TeaModel {
    public var appType: String?

    public var asynchronousExecution: Bool?

    public var formUuid: String?

    public var ignoreEmpty: Bool?

    public var noExecuteExpression: Bool?

    public var systemToken: String?

    public var updateFormDataJsonMapShrink: String?

    public var useLatestFormSchemaVersion: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.asynchronousExecution != nil {
            map["AsynchronousExecution"] = self.asynchronousExecution!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.ignoreEmpty != nil {
            map["IgnoreEmpty"] = self.ignoreEmpty!
        }
        if self.noExecuteExpression != nil {
            map["NoExecuteExpression"] = self.noExecuteExpression!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.updateFormDataJsonMapShrink != nil {
            map["UpdateFormDataJsonMap"] = self.updateFormDataJsonMapShrink!
        }
        if self.useLatestFormSchemaVersion != nil {
            map["UseLatestFormSchemaVersion"] = self.useLatestFormSchemaVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("AsynchronousExecution") && dict["AsynchronousExecution"] != nil {
            self.asynchronousExecution = dict["AsynchronousExecution"] as! Bool
        }
        if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("IgnoreEmpty") && dict["IgnoreEmpty"] != nil {
            self.ignoreEmpty = dict["IgnoreEmpty"] as! Bool
        }
        if dict.keys.contains("NoExecuteExpression") && dict["NoExecuteExpression"] != nil {
            self.noExecuteExpression = dict["NoExecuteExpression"] as! Bool
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("UpdateFormDataJsonMap") && dict["UpdateFormDataJsonMap"] != nil {
            self.updateFormDataJsonMapShrink = dict["UpdateFormDataJsonMap"] as! String
        }
        if dict.keys.contains("UseLatestFormSchemaVersion") && dict["UseLatestFormSchemaVersion"] != nil {
            self.useLatestFormSchemaVersion = dict["UseLatestFormSchemaVersion"] as! Bool
        }
    }
}

public class BatchUpdateFormDataByInstanceMapResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [String]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! [String]
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class BatchUpdateFormDataByInstanceMapResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchUpdateFormDataByInstanceMapResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BatchUpdateFormDataByInstanceMapResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelScheduleConferenceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CancelScheduleConferenceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CancelScheduleConferenceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CancelScheduleConferenceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CancelScheduleConferenceRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var scheduleConferenceId: String?

    public var tenantContext: CancelScheduleConferenceRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.scheduleConferenceId != nil {
            map["ScheduleConferenceId"] = self.scheduleConferenceId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ScheduleConferenceId") && dict["ScheduleConferenceId"] != nil {
            self.scheduleConferenceId = dict["ScheduleConferenceId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = CancelScheduleConferenceRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class CancelScheduleConferenceShrinkRequest : Tea.TeaModel {
    public var scheduleConferenceId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.scheduleConferenceId != nil {
            map["ScheduleConferenceId"] = self.scheduleConferenceId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ScheduleConferenceId") && dict["ScheduleConferenceId"] != nil {
            self.scheduleConferenceId = dict["ScheduleConferenceId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class CancelScheduleConferenceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CancelScheduleConferenceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelScheduleConferenceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CancelScheduleConferenceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ClearHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ClearHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = ClearHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ClearShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ClearRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var rangeAddress: String?

    public var sheetId: String?

    public var tenantContext: ClearRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.rangeAddress != nil {
            map["RangeAddress"] = self.rangeAddress!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RangeAddress") && dict["RangeAddress"] != nil {
            self.rangeAddress = dict["RangeAddress"] as! String
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = ClearRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class ClearShrinkRequest : Tea.TeaModel {
    public var rangeAddress: String?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.rangeAddress != nil {
            map["RangeAddress"] = self.rangeAddress!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RangeAddress") && dict["RangeAddress"] != nil {
            self.rangeAddress = dict["RangeAddress"] as! String
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class ClearResponseBody : Tea.TeaModel {
    public var a1Notation: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.a1Notation != nil {
            map["a1Notation"] = self.a1Notation!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("a1Notation") && dict["a1Notation"] != nil {
            self.a1Notation = dict["a1Notation"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ClearResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ClearResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ClearResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ClearDataHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ClearDataHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = ClearDataHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ClearDataShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ClearDataRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var rangeAddress: String?

    public var sheetId: String?

    public var tenantContext: ClearDataRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.rangeAddress != nil {
            map["RangeAddress"] = self.rangeAddress!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RangeAddress") && dict["RangeAddress"] != nil {
            self.rangeAddress = dict["RangeAddress"] as! String
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = ClearDataRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class ClearDataShrinkRequest : Tea.TeaModel {
    public var rangeAddress: String?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.rangeAddress != nil {
            map["RangeAddress"] = self.rangeAddress!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RangeAddress") && dict["RangeAddress"] != nil {
            self.rangeAddress = dict["RangeAddress"] as! String
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class ClearDataResponseBody : Tea.TeaModel {
    public var a1Notation: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.a1Notation != nil {
            map["a1Notation"] = self.a1Notation!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("a1Notation") && dict["a1Notation"] != nil {
            self.a1Notation = dict["a1Notation"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ClearDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ClearDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ClearDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CommentListReportHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CommentListReportHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CommentListReportHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CommentListReportShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CommentListReportRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var offset: Int64?

    public var reportId: String?

    public var size: Int64?

    public var tenantContext: CommentListReportRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Offset") && dict["Offset"] != nil {
            self.offset = dict["Offset"] as! Int64
        }
        if dict.keys.contains("ReportId") && dict["ReportId"] != nil {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = CommentListReportRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class CommentListReportShrinkRequest : Tea.TeaModel {
    public var offset: Int64?

    public var reportId: String?

    public var size: Int64?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Offset") && dict["Offset"] != nil {
            self.offset = dict["Offset"] as! Int64
        }
        if dict.keys.contains("ReportId") && dict["ReportId"] != nil {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class CommentListReportResponseBody : Tea.TeaModel {
    public class Comments : Tea.TeaModel {
        public var content: String?

        public var createTime: String?

        public var userid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.userid != nil {
                map["Userid"] = self.userid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") && dict["Content"] != nil {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Userid") && dict["Userid"] != nil {
                self.userid = dict["Userid"] as! String
            }
        }
    }
    public var comments: [CommentListReportResponseBody.Comments]?

    public var hasMore: Bool?

    public var nextCursor: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comments != nil {
            var tmp : [Any] = []
            for k in self.comments! {
                tmp.append(k.toMap())
            }
            map["comments"] = tmp
        }
        if self.hasMore != nil {
            map["hasMore"] = self.hasMore!
        }
        if self.nextCursor != nil {
            map["nextCursor"] = self.nextCursor!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("comments") && dict["comments"] != nil {
            var tmp : [CommentListReportResponseBody.Comments] = []
            for v in dict["comments"] as! [Any] {
                var model = CommentListReportResponseBody.Comments()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.comments = tmp
        }
        if dict.keys.contains("hasMore") && dict["hasMore"] != nil {
            self.hasMore = dict["hasMore"] as! Bool
        }
        if dict.keys.contains("nextCursor") && dict["nextCursor"] != nil {
            self.nextCursor = dict["nextCursor"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CommentListReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CommentListReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CommentListReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDeliveryPlanHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var userToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userToken != nil {
                map["userToken"] = self.userToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("userToken") && dict["userToken"] != nil {
                self.userToken = dict["userToken"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateDeliveryPlanHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateDeliveryPlanHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateDeliveryPlanShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateDeliveryPlanRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var content: [String: Any]?

    public var endTime: Int64?

    public var resId: String?

    public var startTime: Int64?

    public var tenantContext: CreateDeliveryPlanRequest.TenantContext?

    public var userIdList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.resId != nil {
            map["ResId"] = self.resId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.userIdList != nil {
            map["UserIdList"] = self.userIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.content = dict["Content"] as! [String: Any]
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ResId") && dict["ResId"] != nil {
            self.resId = dict["ResId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = CreateDeliveryPlanRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("UserIdList") && dict["UserIdList"] != nil {
            self.userIdList = dict["UserIdList"] as! [String]
        }
    }
}

public class CreateDeliveryPlanShrinkRequest : Tea.TeaModel {
    public var contentShrink: String?

    public var endTime: Int64?

    public var resId: String?

    public var startTime: Int64?

    public var tenantContextShrink: String?

    public var userIdListShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contentShrink != nil {
            map["Content"] = self.contentShrink!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.resId != nil {
            map["ResId"] = self.resId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.userIdListShrink != nil {
            map["UserIdList"] = self.userIdListShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.contentShrink = dict["Content"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ResId") && dict["ResId"] != nil {
            self.resId = dict["ResId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("UserIdList") && dict["UserIdList"] != nil {
            self.userIdListShrink = dict["UserIdList"] as! String
        }
    }
}

public class CreateDeliveryPlanResponseBody : Tea.TeaModel {
    public var arguments: [Any]?

    public var requestId: String?

    public var success: Bool?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.arguments != nil {
            map["arguments"] = self.arguments!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("arguments") && dict["arguments"] != nil {
            self.arguments = dict["arguments"] as! [Any]
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class CreateDeliveryPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDeliveryPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateDeliveryPlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEventHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateEventHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateEventHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateEventShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateEventRequest : Tea.TeaModel {
    public class Attendees : Tea.TeaModel {
        public var id: String?

        public var isOptional: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.isOptional != nil {
                map["isOptional"] = self.isOptional!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") && dict["id"] != nil {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("isOptional") && dict["isOptional"] != nil {
                self.isOptional = dict["isOptional"] as! Bool
            }
        }
    }
    public class End : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["date"] = self.date!
            }
            if self.dateTime != nil {
                map["dateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["timeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("date") && dict["date"] != nil {
                self.date = dict["date"] as! String
            }
            if dict.keys.contains("dateTime") && dict["dateTime"] != nil {
                self.dateTime = dict["dateTime"] as! String
            }
            if dict.keys.contains("timeZone") && dict["timeZone"] != nil {
                self.timeZone = dict["timeZone"] as! String
            }
        }
    }
    public class Location : Tea.TeaModel {
        public var displayName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["displayName"] = self.displayName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("displayName") && dict["displayName"] != nil {
                self.displayName = dict["displayName"] as! String
            }
        }
    }
    public class OnlineMeetingInfo : Tea.TeaModel {
        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("type") && dict["type"] != nil {
                self.type = dict["type"] as! String
            }
        }
    }
    public class Recurrence : Tea.TeaModel {
        public class Pattern : Tea.TeaModel {
            public var dayOfMonth: Int32?

            public var daysOfWeek: String?

            public var index: String?

            public var interval: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dayOfMonth != nil {
                    map["dayOfMonth"] = self.dayOfMonth!
                }
                if self.daysOfWeek != nil {
                    map["daysOfWeek"] = self.daysOfWeek!
                }
                if self.index != nil {
                    map["index"] = self.index!
                }
                if self.interval != nil {
                    map["interval"] = self.interval!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("dayOfMonth") && dict["dayOfMonth"] != nil {
                    self.dayOfMonth = dict["dayOfMonth"] as! Int32
                }
                if dict.keys.contains("daysOfWeek") && dict["daysOfWeek"] != nil {
                    self.daysOfWeek = dict["daysOfWeek"] as! String
                }
                if dict.keys.contains("index") && dict["index"] != nil {
                    self.index = dict["index"] as! String
                }
                if dict.keys.contains("interval") && dict["interval"] != nil {
                    self.interval = dict["interval"] as! Int32
                }
                if dict.keys.contains("type") && dict["type"] != nil {
                    self.type = dict["type"] as! String
                }
            }
        }
        public class Range : Tea.TeaModel {
            public var endDate: String?

            public var numberOfOccurrences: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endDate != nil {
                    map["endDate"] = self.endDate!
                }
                if self.numberOfOccurrences != nil {
                    map["numberOfOccurrences"] = self.numberOfOccurrences!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("endDate") && dict["endDate"] != nil {
                    self.endDate = dict["endDate"] as! String
                }
                if dict.keys.contains("numberOfOccurrences") && dict["numberOfOccurrences"] != nil {
                    self.numberOfOccurrences = dict["numberOfOccurrences"] as! Int32
                }
                if dict.keys.contains("type") && dict["type"] != nil {
                    self.type = dict["type"] as! String
                }
            }
        }
        public var pattern: CreateEventRequest.Recurrence.Pattern?

        public var range: CreateEventRequest.Recurrence.Range?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pattern?.validate()
            try self.range?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pattern != nil {
                map["pattern"] = self.pattern?.toMap()
            }
            if self.range != nil {
                map["range"] = self.range?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("pattern") && dict["pattern"] != nil {
                var model = CreateEventRequest.Recurrence.Pattern()
                model.fromMap(dict["pattern"] as! [String: Any])
                self.pattern = model
            }
            if dict.keys.contains("range") && dict["range"] != nil {
                var model = CreateEventRequest.Recurrence.Range()
                model.fromMap(dict["range"] as! [String: Any])
                self.range = model
            }
        }
    }
    public class Reminders : Tea.TeaModel {
        public var method: String?

        public var minutes: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.method != nil {
                map["method"] = self.method!
            }
            if self.minutes != nil {
                map["minutes"] = self.minutes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("method") && dict["method"] != nil {
                self.method = dict["method"] as! String
            }
            if dict.keys.contains("minutes") && dict["minutes"] != nil {
                self.minutes = dict["minutes"] as! Int32
            }
        }
    }
    public class UiConfigs : Tea.TeaModel {
        public var uiName: String?

        public var uiStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.uiName != nil {
                map["uiName"] = self.uiName!
            }
            if self.uiStatus != nil {
                map["uiStatus"] = self.uiStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("uiName") && dict["uiName"] != nil {
                self.uiName = dict["uiName"] as! String
            }
            if dict.keys.contains("uiStatus") && dict["uiStatus"] != nil {
                self.uiStatus = dict["uiStatus"] as! String
            }
        }
    }
    public class Start : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["date"] = self.date!
            }
            if self.dateTime != nil {
                map["dateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["timeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("date") && dict["date"] != nil {
                self.date = dict["date"] as! String
            }
            if dict.keys.contains("dateTime") && dict["dateTime"] != nil {
                self.dateTime = dict["dateTime"] as! String
            }
            if dict.keys.contains("timeZone") && dict["timeZone"] != nil {
                self.timeZone = dict["timeZone"] as! String
            }
        }
    }
    public var attendees: [CreateEventRequest.Attendees]?

    public var description_: String?

    public var end: CreateEventRequest.End?

    public var extra: [String: String]?

    public var isAllDay: Bool?

    public var location: CreateEventRequest.Location?

    public var onlineMeetingInfo: CreateEventRequest.OnlineMeetingInfo?

    public var recurrence: CreateEventRequest.Recurrence?

    public var reminders: [CreateEventRequest.Reminders]?

    public var summary: String?

    public var uiConfigs: [CreateEventRequest.UiConfigs]?

    public var calendarId: String?

    public var start: CreateEventRequest.Start?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.end?.validate()
        try self.location?.validate()
        try self.onlineMeetingInfo?.validate()
        try self.recurrence?.validate()
        try self.start?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendees != nil {
            var tmp : [Any] = []
            for k in self.attendees! {
                tmp.append(k.toMap())
            }
            map["Attendees"] = tmp
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.end != nil {
            map["End"] = self.end?.toMap()
        }
        if self.extra != nil {
            map["Extra"] = self.extra!
        }
        if self.isAllDay != nil {
            map["IsAllDay"] = self.isAllDay!
        }
        if self.location != nil {
            map["Location"] = self.location?.toMap()
        }
        if self.onlineMeetingInfo != nil {
            map["OnlineMeetingInfo"] = self.onlineMeetingInfo?.toMap()
        }
        if self.recurrence != nil {
            map["Recurrence"] = self.recurrence?.toMap()
        }
        if self.reminders != nil {
            var tmp : [Any] = []
            for k in self.reminders! {
                tmp.append(k.toMap())
            }
            map["Reminders"] = tmp
        }
        if self.summary != nil {
            map["Summary"] = self.summary!
        }
        if self.uiConfigs != nil {
            var tmp : [Any] = []
            for k in self.uiConfigs! {
                tmp.append(k.toMap())
            }
            map["UiConfigs"] = tmp
        }
        if self.calendarId != nil {
            map["calendarId"] = self.calendarId!
        }
        if self.start != nil {
            map["start"] = self.start?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Attendees") && dict["Attendees"] != nil {
            var tmp : [CreateEventRequest.Attendees] = []
            for v in dict["Attendees"] as! [Any] {
                var model = CreateEventRequest.Attendees()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.attendees = tmp
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("End") && dict["End"] != nil {
            var model = CreateEventRequest.End()
            model.fromMap(dict["End"] as! [String: Any])
            self.end = model
        }
        if dict.keys.contains("Extra") && dict["Extra"] != nil {
            self.extra = dict["Extra"] as! [String: String]
        }
        if dict.keys.contains("IsAllDay") && dict["IsAllDay"] != nil {
            self.isAllDay = dict["IsAllDay"] as! Bool
        }
        if dict.keys.contains("Location") && dict["Location"] != nil {
            var model = CreateEventRequest.Location()
            model.fromMap(dict["Location"] as! [String: Any])
            self.location = model
        }
        if dict.keys.contains("OnlineMeetingInfo") && dict["OnlineMeetingInfo"] != nil {
            var model = CreateEventRequest.OnlineMeetingInfo()
            model.fromMap(dict["OnlineMeetingInfo"] as! [String: Any])
            self.onlineMeetingInfo = model
        }
        if dict.keys.contains("Recurrence") && dict["Recurrence"] != nil {
            var model = CreateEventRequest.Recurrence()
            model.fromMap(dict["Recurrence"] as! [String: Any])
            self.recurrence = model
        }
        if dict.keys.contains("Reminders") && dict["Reminders"] != nil {
            var tmp : [CreateEventRequest.Reminders] = []
            for v in dict["Reminders"] as! [Any] {
                var model = CreateEventRequest.Reminders()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.reminders = tmp
        }
        if dict.keys.contains("Summary") && dict["Summary"] != nil {
            self.summary = dict["Summary"] as! String
        }
        if dict.keys.contains("UiConfigs") && dict["UiConfigs"] != nil {
            var tmp : [CreateEventRequest.UiConfigs] = []
            for v in dict["UiConfigs"] as! [Any] {
                var model = CreateEventRequest.UiConfigs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.uiConfigs = tmp
        }
        if dict.keys.contains("calendarId") && dict["calendarId"] != nil {
            self.calendarId = dict["calendarId"] as! String
        }
        if dict.keys.contains("start") && dict["start"] != nil {
            var model = CreateEventRequest.Start()
            model.fromMap(dict["start"] as! [String: Any])
            self.start = model
        }
    }
}

public class CreateEventShrinkRequest : Tea.TeaModel {
    public var attendeesShrink: String?

    public var description_: String?

    public var endShrink: String?

    public var extraShrink: String?

    public var isAllDay: Bool?

    public var locationShrink: String?

    public var onlineMeetingInfoShrink: String?

    public var recurrenceShrink: String?

    public var remindersShrink: String?

    public var summary: String?

    public var uiConfigsShrink: String?

    public var calendarId: String?

    public var startShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendeesShrink != nil {
            map["Attendees"] = self.attendeesShrink!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endShrink != nil {
            map["End"] = self.endShrink!
        }
        if self.extraShrink != nil {
            map["Extra"] = self.extraShrink!
        }
        if self.isAllDay != nil {
            map["IsAllDay"] = self.isAllDay!
        }
        if self.locationShrink != nil {
            map["Location"] = self.locationShrink!
        }
        if self.onlineMeetingInfoShrink != nil {
            map["OnlineMeetingInfo"] = self.onlineMeetingInfoShrink!
        }
        if self.recurrenceShrink != nil {
            map["Recurrence"] = self.recurrenceShrink!
        }
        if self.remindersShrink != nil {
            map["Reminders"] = self.remindersShrink!
        }
        if self.summary != nil {
            map["Summary"] = self.summary!
        }
        if self.uiConfigsShrink != nil {
            map["UiConfigs"] = self.uiConfigsShrink!
        }
        if self.calendarId != nil {
            map["calendarId"] = self.calendarId!
        }
        if self.startShrink != nil {
            map["start"] = self.startShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Attendees") && dict["Attendees"] != nil {
            self.attendeesShrink = dict["Attendees"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("End") && dict["End"] != nil {
            self.endShrink = dict["End"] as! String
        }
        if dict.keys.contains("Extra") && dict["Extra"] != nil {
            self.extraShrink = dict["Extra"] as! String
        }
        if dict.keys.contains("IsAllDay") && dict["IsAllDay"] != nil {
            self.isAllDay = dict["IsAllDay"] as! Bool
        }
        if dict.keys.contains("Location") && dict["Location"] != nil {
            self.locationShrink = dict["Location"] as! String
        }
        if dict.keys.contains("OnlineMeetingInfo") && dict["OnlineMeetingInfo"] != nil {
            self.onlineMeetingInfoShrink = dict["OnlineMeetingInfo"] as! String
        }
        if dict.keys.contains("Recurrence") && dict["Recurrence"] != nil {
            self.recurrenceShrink = dict["Recurrence"] as! String
        }
        if dict.keys.contains("Reminders") && dict["Reminders"] != nil {
            self.remindersShrink = dict["Reminders"] as! String
        }
        if dict.keys.contains("Summary") && dict["Summary"] != nil {
            self.summary = dict["Summary"] as! String
        }
        if dict.keys.contains("UiConfigs") && dict["UiConfigs"] != nil {
            self.uiConfigsShrink = dict["UiConfigs"] as! String
        }
        if dict.keys.contains("calendarId") && dict["calendarId"] != nil {
            self.calendarId = dict["calendarId"] as! String
        }
        if dict.keys.contains("start") && dict["start"] != nil {
            self.startShrink = dict["start"] as! String
        }
    }
}

public class CreateEventResponseBody : Tea.TeaModel {
    public class Attendees : Tea.TeaModel {
        public var displayName: String?

        public var isOptional: Bool?

        public var responseStatus: String?

        public var self_: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.isOptional != nil {
                map["IsOptional"] = self.isOptional!
            }
            if self.responseStatus != nil {
                map["ResponseStatus"] = self.responseStatus!
            }
            if self.self_ != nil {
                map["Self"] = self.self_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("IsOptional") && dict["IsOptional"] != nil {
                self.isOptional = dict["IsOptional"] as! Bool
            }
            if dict.keys.contains("ResponseStatus") && dict["ResponseStatus"] != nil {
                self.responseStatus = dict["ResponseStatus"] as! String
            }
            if dict.keys.contains("Self") && dict["Self"] != nil {
                self.self_ = dict["Self"] as! Bool
            }
        }
    }
    public class End : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["Date"] = self.date!
            }
            if self.dateTime != nil {
                map["DateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["TimeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Date") && dict["Date"] != nil {
                self.date = dict["Date"] as! String
            }
            if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                self.dateTime = dict["DateTime"] as! String
            }
            if dict.keys.contains("TimeZone") && dict["TimeZone"] != nil {
                self.timeZone = dict["TimeZone"] as! String
            }
        }
    }
    public class Location : Tea.TeaModel {
        public var displayName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
        }
    }
    public class OnlineMeetingInfo : Tea.TeaModel {
        public var conferenceId: String?

        public var extraInfo: [String: Any]?

        public var type: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.conferenceId != nil {
                map["ConferenceId"] = self.conferenceId!
            }
            if self.extraInfo != nil {
                map["ExtraInfo"] = self.extraInfo!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConferenceId") && dict["ConferenceId"] != nil {
                self.conferenceId = dict["ConferenceId"] as! String
            }
            if dict.keys.contains("ExtraInfo") && dict["ExtraInfo"] != nil {
                self.extraInfo = dict["ExtraInfo"] as! [String: Any]
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
        }
    }
    public class Organizer : Tea.TeaModel {
        public var displayName: String?

        public var id: String?

        public var responseStatus: String?

        public var self_: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.responseStatus != nil {
                map["ResponseStatus"] = self.responseStatus!
            }
            if self.self_ != nil {
                map["Self"] = self.self_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("ResponseStatus") && dict["ResponseStatus"] != nil {
                self.responseStatus = dict["ResponseStatus"] as! String
            }
            if dict.keys.contains("Self") && dict["Self"] != nil {
                self.self_ = dict["Self"] as! Bool
            }
        }
    }
    public class Recurrence : Tea.TeaModel {
        public class Pattern : Tea.TeaModel {
            public var dayOfMonth: Int32?

            public var daysOfWeek: String?

            public var index: String?

            public var interval: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dayOfMonth != nil {
                    map["DayOfMonth"] = self.dayOfMonth!
                }
                if self.daysOfWeek != nil {
                    map["DaysOfWeek"] = self.daysOfWeek!
                }
                if self.index != nil {
                    map["Index"] = self.index!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DayOfMonth") && dict["DayOfMonth"] != nil {
                    self.dayOfMonth = dict["DayOfMonth"] as! Int32
                }
                if dict.keys.contains("DaysOfWeek") && dict["DaysOfWeek"] != nil {
                    self.daysOfWeek = dict["DaysOfWeek"] as! String
                }
                if dict.keys.contains("Index") && dict["Index"] != nil {
                    self.index = dict["Index"] as! String
                }
                if dict.keys.contains("Interval") && dict["Interval"] != nil {
                    self.interval = dict["Interval"] as! Int32
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Range : Tea.TeaModel {
            public var endDate: String?

            public var numberOfOccurrences: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endDate != nil {
                    map["EndDate"] = self.endDate!
                }
                if self.numberOfOccurrences != nil {
                    map["NumberOfOccurrences"] = self.numberOfOccurrences!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndDate") && dict["EndDate"] != nil {
                    self.endDate = dict["EndDate"] as! String
                }
                if dict.keys.contains("NumberOfOccurrences") && dict["NumberOfOccurrences"] != nil {
                    self.numberOfOccurrences = dict["NumberOfOccurrences"] as! Int32
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var pattern: CreateEventResponseBody.Recurrence.Pattern?

        public var range: CreateEventResponseBody.Recurrence.Range?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pattern?.validate()
            try self.range?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pattern != nil {
                map["Pattern"] = self.pattern?.toMap()
            }
            if self.range != nil {
                map["Range"] = self.range?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Pattern") && dict["Pattern"] != nil {
                var model = CreateEventResponseBody.Recurrence.Pattern()
                model.fromMap(dict["Pattern"] as! [String: Any])
                self.pattern = model
            }
            if dict.keys.contains("Range") && dict["Range"] != nil {
                var model = CreateEventResponseBody.Recurrence.Range()
                model.fromMap(dict["Range"] as! [String: Any])
                self.range = model
            }
        }
    }
    public class Reminders : Tea.TeaModel {
        public var method: String?

        public var minutes: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.method != nil {
                map["Method"] = self.method!
            }
            if self.minutes != nil {
                map["Minutes"] = self.minutes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Method") && dict["Method"] != nil {
                self.method = dict["Method"] as! String
            }
            if dict.keys.contains("Minutes") && dict["Minutes"] != nil {
                self.minutes = dict["Minutes"] as! String
            }
        }
    }
    public class Start : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["Date"] = self.date!
            }
            if self.dateTime != nil {
                map["DateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["TimeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Date") && dict["Date"] != nil {
                self.date = dict["Date"] as! String
            }
            if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                self.dateTime = dict["DateTime"] as! String
            }
            if dict.keys.contains("TimeZone") && dict["TimeZone"] != nil {
                self.timeZone = dict["TimeZone"] as! String
            }
        }
    }
    public class UiConfigs : Tea.TeaModel {
        public var uiName: String?

        public var uiStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.uiName != nil {
                map["UiName"] = self.uiName!
            }
            if self.uiStatus != nil {
                map["UiStatus"] = self.uiStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UiName") && dict["UiName"] != nil {
                self.uiName = dict["UiName"] as! String
            }
            if dict.keys.contains("UiStatus") && dict["UiStatus"] != nil {
                self.uiStatus = dict["UiStatus"] as! String
            }
        }
    }
    public var attendees: [CreateEventResponseBody.Attendees]?

    public var createTime: String?

    public var description_: String?

    public var end: CreateEventResponseBody.End?

    public var id: String?

    public var isAllDay: Bool?

    public var location: CreateEventResponseBody.Location?

    public var onlineMeetingInfo: CreateEventResponseBody.OnlineMeetingInfo?

    public var organizer: CreateEventResponseBody.Organizer?

    public var recurrence: CreateEventResponseBody.Recurrence?

    public var reminders: [CreateEventResponseBody.Reminders]?

    public var requestId: String?

    public var start: CreateEventResponseBody.Start?

    public var summary: String?

    public var uiConfigs: [CreateEventResponseBody.UiConfigs]?

    public var updateTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.end?.validate()
        try self.location?.validate()
        try self.onlineMeetingInfo?.validate()
        try self.organizer?.validate()
        try self.recurrence?.validate()
        try self.start?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendees != nil {
            var tmp : [Any] = []
            for k in self.attendees! {
                tmp.append(k.toMap())
            }
            map["attendees"] = tmp
        }
        if self.createTime != nil {
            map["createTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.end != nil {
            map["end"] = self.end?.toMap()
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.isAllDay != nil {
            map["isAllDay"] = self.isAllDay!
        }
        if self.location != nil {
            map["location"] = self.location?.toMap()
        }
        if self.onlineMeetingInfo != nil {
            map["onlineMeetingInfo"] = self.onlineMeetingInfo?.toMap()
        }
        if self.organizer != nil {
            map["organizer"] = self.organizer?.toMap()
        }
        if self.recurrence != nil {
            map["recurrence"] = self.recurrence?.toMap()
        }
        if self.reminders != nil {
            var tmp : [Any] = []
            for k in self.reminders! {
                tmp.append(k.toMap())
            }
            map["reminders"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.start != nil {
            map["start"] = self.start?.toMap()
        }
        if self.summary != nil {
            map["summary"] = self.summary!
        }
        if self.uiConfigs != nil {
            var tmp : [Any] = []
            for k in self.uiConfigs! {
                tmp.append(k.toMap())
            }
            map["uiConfigs"] = tmp
        }
        if self.updateTime != nil {
            map["updateTime"] = self.updateTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("attendees") && dict["attendees"] != nil {
            var tmp : [CreateEventResponseBody.Attendees] = []
            for v in dict["attendees"] as! [Any] {
                var model = CreateEventResponseBody.Attendees()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.attendees = tmp
        }
        if dict.keys.contains("createTime") && dict["createTime"] != nil {
            self.createTime = dict["createTime"] as! String
        }
        if dict.keys.contains("description") && dict["description"] != nil {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("end") && dict["end"] != nil {
            var model = CreateEventResponseBody.End()
            model.fromMap(dict["end"] as! [String: Any])
            self.end = model
        }
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("isAllDay") && dict["isAllDay"] != nil {
            self.isAllDay = dict["isAllDay"] as! Bool
        }
        if dict.keys.contains("location") && dict["location"] != nil {
            var model = CreateEventResponseBody.Location()
            model.fromMap(dict["location"] as! [String: Any])
            self.location = model
        }
        if dict.keys.contains("onlineMeetingInfo") && dict["onlineMeetingInfo"] != nil {
            var model = CreateEventResponseBody.OnlineMeetingInfo()
            model.fromMap(dict["onlineMeetingInfo"] as! [String: Any])
            self.onlineMeetingInfo = model
        }
        if dict.keys.contains("organizer") && dict["organizer"] != nil {
            var model = CreateEventResponseBody.Organizer()
            model.fromMap(dict["organizer"] as! [String: Any])
            self.organizer = model
        }
        if dict.keys.contains("recurrence") && dict["recurrence"] != nil {
            var model = CreateEventResponseBody.Recurrence()
            model.fromMap(dict["recurrence"] as! [String: Any])
            self.recurrence = model
        }
        if dict.keys.contains("reminders") && dict["reminders"] != nil {
            var tmp : [CreateEventResponseBody.Reminders] = []
            for v in dict["reminders"] as! [Any] {
                var model = CreateEventResponseBody.Reminders()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.reminders = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("start") && dict["start"] != nil {
            var model = CreateEventResponseBody.Start()
            model.fromMap(dict["start"] as! [String: Any])
            self.start = model
        }
        if dict.keys.contains("summary") && dict["summary"] != nil {
            self.summary = dict["summary"] as! String
        }
        if dict.keys.contains("uiConfigs") && dict["uiConfigs"] != nil {
            var tmp : [CreateEventResponseBody.UiConfigs] = []
            for v in dict["uiConfigs"] as! [Any] {
                var model = CreateEventResponseBody.UiConfigs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.uiConfigs = tmp
        }
        if dict.keys.contains("updateTime") && dict["updateTime"] != nil {
            self.updateTime = dict["updateTime"] as! String
        }
    }
}

public class CreateEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLiveHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateLiveHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateLiveHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateLiveShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateLiveRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var coverUrl: String?

    public var introduction: String?

    public var preEndTime: Int64?

    public var preStartTime: Int64?

    public var publicType: Int64?

    public var tenantContext: CreateLiveRequest.TenantContext?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coverUrl != nil {
            map["CoverUrl"] = self.coverUrl!
        }
        if self.introduction != nil {
            map["Introduction"] = self.introduction!
        }
        if self.preEndTime != nil {
            map["PreEndTime"] = self.preEndTime!
        }
        if self.preStartTime != nil {
            map["PreStartTime"] = self.preStartTime!
        }
        if self.publicType != nil {
            map["PublicType"] = self.publicType!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CoverUrl") && dict["CoverUrl"] != nil {
            self.coverUrl = dict["CoverUrl"] as! String
        }
        if dict.keys.contains("Introduction") && dict["Introduction"] != nil {
            self.introduction = dict["Introduction"] as! String
        }
        if dict.keys.contains("PreEndTime") && dict["PreEndTime"] != nil {
            self.preEndTime = dict["PreEndTime"] as! Int64
        }
        if dict.keys.contains("PreStartTime") && dict["PreStartTime"] != nil {
            self.preStartTime = dict["PreStartTime"] as! Int64
        }
        if dict.keys.contains("PublicType") && dict["PublicType"] != nil {
            self.publicType = dict["PublicType"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = CreateLiveRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class CreateLiveShrinkRequest : Tea.TeaModel {
    public var coverUrl: String?

    public var introduction: String?

    public var preEndTime: Int64?

    public var preStartTime: Int64?

    public var publicType: Int64?

    public var tenantContextShrink: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coverUrl != nil {
            map["CoverUrl"] = self.coverUrl!
        }
        if self.introduction != nil {
            map["Introduction"] = self.introduction!
        }
        if self.preEndTime != nil {
            map["PreEndTime"] = self.preEndTime!
        }
        if self.preStartTime != nil {
            map["PreStartTime"] = self.preStartTime!
        }
        if self.publicType != nil {
            map["PublicType"] = self.publicType!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CoverUrl") && dict["CoverUrl"] != nil {
            self.coverUrl = dict["CoverUrl"] as! String
        }
        if dict.keys.contains("Introduction") && dict["Introduction"] != nil {
            self.introduction = dict["Introduction"] as! String
        }
        if dict.keys.contains("PreEndTime") && dict["PreEndTime"] != nil {
            self.preEndTime = dict["PreEndTime"] as! Int64
        }
        if dict.keys.contains("PreStartTime") && dict["PreStartTime"] != nil {
            self.preStartTime = dict["PreStartTime"] as! Int64
        }
        if dict.keys.contains("PublicType") && dict["PublicType"] != nil {
            self.publicType = dict["PublicType"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class CreateLiveResponseBody : Tea.TeaModel {
    public var liveId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveId != nil {
            map["liveId"] = self.liveId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("liveId") && dict["liveId"] != nil {
            self.liveId = dict["liveId"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateLiveResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLiveResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateLiveResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMeetingRoomHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateMeetingRoomHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateMeetingRoomHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateMeetingRoomShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateMeetingRoomRequest : Tea.TeaModel {
    public class ReservationAuthority : Tea.TeaModel {
        public class AuthorizedMembers : Tea.TeaModel {
            public var memberId: String?

            public var memberName: String?

            public var memberType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.memberId != nil {
                    map["MemberId"] = self.memberId!
                }
                if self.memberName != nil {
                    map["MemberName"] = self.memberName!
                }
                if self.memberType != nil {
                    map["MemberType"] = self.memberType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MemberId") && dict["MemberId"] != nil {
                    self.memberId = dict["MemberId"] as! String
                }
                if dict.keys.contains("MemberName") && dict["MemberName"] != nil {
                    self.memberName = dict["MemberName"] as! String
                }
                if dict.keys.contains("MemberType") && dict["MemberType"] != nil {
                    self.memberType = dict["MemberType"] as! String
                }
            }
        }
        public var authorizedMembers: [CreateMeetingRoomRequest.ReservationAuthority.AuthorizedMembers]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authorizedMembers != nil {
                var tmp : [Any] = []
                for k in self.authorizedMembers! {
                    tmp.append(k.toMap())
                }
                map["AuthorizedMembers"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthorizedMembers") && dict["AuthorizedMembers"] != nil {
                var tmp : [CreateMeetingRoomRequest.ReservationAuthority.AuthorizedMembers] = []
                for v in dict["AuthorizedMembers"] as! [Any] {
                    var model = CreateMeetingRoomRequest.ReservationAuthority.AuthorizedMembers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.authorizedMembers = tmp
            }
        }
    }
    public class RoomLocation : Tea.TeaModel {
        public var desc: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.desc != nil {
                map["Desc"] = self.desc!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Desc") && dict["Desc"] != nil {
                self.desc = dict["Desc"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var enableCycleReservation: Bool?

    public var groupId: Int64?

    public var isvRoomId: String?

    public var reservationAuthority: CreateMeetingRoomRequest.ReservationAuthority?

    public var roomCapacity: Int32?

    public var roomLabelIds: [Int64]?

    public var roomLocation: CreateMeetingRoomRequest.RoomLocation?

    public var roomName: String?

    public var roomPicture: String?

    public var roomStatus: Int32?

    public var tenantContext: CreateMeetingRoomRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.reservationAuthority?.validate()
        try self.roomLocation?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableCycleReservation != nil {
            map["EnableCycleReservation"] = self.enableCycleReservation!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.isvRoomId != nil {
            map["IsvRoomId"] = self.isvRoomId!
        }
        if self.reservationAuthority != nil {
            map["ReservationAuthority"] = self.reservationAuthority?.toMap()
        }
        if self.roomCapacity != nil {
            map["RoomCapacity"] = self.roomCapacity!
        }
        if self.roomLabelIds != nil {
            map["RoomLabelIds"] = self.roomLabelIds!
        }
        if self.roomLocation != nil {
            map["RoomLocation"] = self.roomLocation?.toMap()
        }
        if self.roomName != nil {
            map["RoomName"] = self.roomName!
        }
        if self.roomPicture != nil {
            map["RoomPicture"] = self.roomPicture!
        }
        if self.roomStatus != nil {
            map["RoomStatus"] = self.roomStatus!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnableCycleReservation") && dict["EnableCycleReservation"] != nil {
            self.enableCycleReservation = dict["EnableCycleReservation"] as! Bool
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("IsvRoomId") && dict["IsvRoomId"] != nil {
            self.isvRoomId = dict["IsvRoomId"] as! String
        }
        if dict.keys.contains("ReservationAuthority") && dict["ReservationAuthority"] != nil {
            var model = CreateMeetingRoomRequest.ReservationAuthority()
            model.fromMap(dict["ReservationAuthority"] as! [String: Any])
            self.reservationAuthority = model
        }
        if dict.keys.contains("RoomCapacity") && dict["RoomCapacity"] != nil {
            self.roomCapacity = dict["RoomCapacity"] as! Int32
        }
        if dict.keys.contains("RoomLabelIds") && dict["RoomLabelIds"] != nil {
            self.roomLabelIds = dict["RoomLabelIds"] as! [Int64]
        }
        if dict.keys.contains("RoomLocation") && dict["RoomLocation"] != nil {
            var model = CreateMeetingRoomRequest.RoomLocation()
            model.fromMap(dict["RoomLocation"] as! [String: Any])
            self.roomLocation = model
        }
        if dict.keys.contains("RoomName") && dict["RoomName"] != nil {
            self.roomName = dict["RoomName"] as! String
        }
        if dict.keys.contains("RoomPicture") && dict["RoomPicture"] != nil {
            self.roomPicture = dict["RoomPicture"] as! String
        }
        if dict.keys.contains("RoomStatus") && dict["RoomStatus"] != nil {
            self.roomStatus = dict["RoomStatus"] as! Int32
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = CreateMeetingRoomRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class CreateMeetingRoomShrinkRequest : Tea.TeaModel {
    public var enableCycleReservation: Bool?

    public var groupId: Int64?

    public var isvRoomId: String?

    public var reservationAuthorityShrink: String?

    public var roomCapacity: Int32?

    public var roomLabelIdsShrink: String?

    public var roomLocationShrink: String?

    public var roomName: String?

    public var roomPicture: String?

    public var roomStatus: Int32?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableCycleReservation != nil {
            map["EnableCycleReservation"] = self.enableCycleReservation!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.isvRoomId != nil {
            map["IsvRoomId"] = self.isvRoomId!
        }
        if self.reservationAuthorityShrink != nil {
            map["ReservationAuthority"] = self.reservationAuthorityShrink!
        }
        if self.roomCapacity != nil {
            map["RoomCapacity"] = self.roomCapacity!
        }
        if self.roomLabelIdsShrink != nil {
            map["RoomLabelIds"] = self.roomLabelIdsShrink!
        }
        if self.roomLocationShrink != nil {
            map["RoomLocation"] = self.roomLocationShrink!
        }
        if self.roomName != nil {
            map["RoomName"] = self.roomName!
        }
        if self.roomPicture != nil {
            map["RoomPicture"] = self.roomPicture!
        }
        if self.roomStatus != nil {
            map["RoomStatus"] = self.roomStatus!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnableCycleReservation") && dict["EnableCycleReservation"] != nil {
            self.enableCycleReservation = dict["EnableCycleReservation"] as! Bool
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("IsvRoomId") && dict["IsvRoomId"] != nil {
            self.isvRoomId = dict["IsvRoomId"] as! String
        }
        if dict.keys.contains("ReservationAuthority") && dict["ReservationAuthority"] != nil {
            self.reservationAuthorityShrink = dict["ReservationAuthority"] as! String
        }
        if dict.keys.contains("RoomCapacity") && dict["RoomCapacity"] != nil {
            self.roomCapacity = dict["RoomCapacity"] as! Int32
        }
        if dict.keys.contains("RoomLabelIds") && dict["RoomLabelIds"] != nil {
            self.roomLabelIdsShrink = dict["RoomLabelIds"] as! String
        }
        if dict.keys.contains("RoomLocation") && dict["RoomLocation"] != nil {
            self.roomLocationShrink = dict["RoomLocation"] as! String
        }
        if dict.keys.contains("RoomName") && dict["RoomName"] != nil {
            self.roomName = dict["RoomName"] as! String
        }
        if dict.keys.contains("RoomPicture") && dict["RoomPicture"] != nil {
            self.roomPicture = dict["RoomPicture"] as! String
        }
        if dict.keys.contains("RoomStatus") && dict["RoomStatus"] != nil {
            self.roomStatus = dict["RoomStatus"] as! Int32
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class CreateMeetingRoomResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! String
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class CreateMeetingRoomResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMeetingRoomResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMeetingRoomResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMeetingRoomGroupHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateMeetingRoomGroupHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateMeetingRoomGroupHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateMeetingRoomGroupShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateMeetingRoomGroupRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var groupName: String?

    public var parentGroupId: Int64?

    public var tenantContext: CreateMeetingRoomGroupRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.parentGroupId != nil {
            map["ParentGroupId"] = self.parentGroupId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("ParentGroupId") && dict["ParentGroupId"] != nil {
            self.parentGroupId = dict["ParentGroupId"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = CreateMeetingRoomGroupRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class CreateMeetingRoomGroupShrinkRequest : Tea.TeaModel {
    public var groupName: String?

    public var parentGroupId: Int64?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.parentGroupId != nil {
            map["ParentGroupId"] = self.parentGroupId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("ParentGroupId") && dict["ParentGroupId"] != nil {
            self.parentGroupId = dict["ParentGroupId"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class CreateMeetingRoomGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! Int64
        }
    }
}

public class CreateMeetingRoomGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMeetingRoomGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMeetingRoomGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrUpdateFormDataHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateOrUpdateFormDataHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateOrUpdateFormDataHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateOrUpdateFormDataShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateOrUpdateFormDataRequest : Tea.TeaModel {
    public var appType: String?

    public var formDataJson: String?

    public var formUuid: String?

    public var noExecuteExpression: Bool?

    public var searchCondition: String?

    public var systemToken: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.formDataJson != nil {
            map["FormDataJson"] = self.formDataJson!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.noExecuteExpression != nil {
            map["NoExecuteExpression"] = self.noExecuteExpression!
        }
        if self.searchCondition != nil {
            map["SearchCondition"] = self.searchCondition!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FormDataJson") && dict["FormDataJson"] != nil {
            self.formDataJson = dict["FormDataJson"] as! String
        }
        if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("NoExecuteExpression") && dict["NoExecuteExpression"] != nil {
            self.noExecuteExpression = dict["NoExecuteExpression"] as! Bool
        }
        if dict.keys.contains("SearchCondition") && dict["SearchCondition"] != nil {
            self.searchCondition = dict["SearchCondition"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class CreateOrUpdateFormDataResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [String]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! [String]
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class CreateOrUpdateFormDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrUpdateFormDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateOrUpdateFormDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrgHonorTemplateHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateOrgHonorTemplateHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateOrgHonorTemplateHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateOrgHonorTemplateShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateOrgHonorTemplateRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: CreateOrgHonorTemplateRequest.TenantContext?

    public var avatarFrameMediaId: String?

    public var defaultBgColor: String?

    public var medalDesc: String?

    public var medalMediaId: String?

    public var medalName: String?

    public var orgId: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.avatarFrameMediaId != nil {
            map["avatarFrameMediaId"] = self.avatarFrameMediaId!
        }
        if self.defaultBgColor != nil {
            map["defaultBgColor"] = self.defaultBgColor!
        }
        if self.medalDesc != nil {
            map["medalDesc"] = self.medalDesc!
        }
        if self.medalMediaId != nil {
            map["medalMediaId"] = self.medalMediaId!
        }
        if self.medalName != nil {
            map["medalName"] = self.medalName!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = CreateOrgHonorTemplateRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("avatarFrameMediaId") && dict["avatarFrameMediaId"] != nil {
            self.avatarFrameMediaId = dict["avatarFrameMediaId"] as! String
        }
        if dict.keys.contains("defaultBgColor") && dict["defaultBgColor"] != nil {
            self.defaultBgColor = dict["defaultBgColor"] as! String
        }
        if dict.keys.contains("medalDesc") && dict["medalDesc"] != nil {
            self.medalDesc = dict["medalDesc"] as! String
        }
        if dict.keys.contains("medalMediaId") && dict["medalMediaId"] != nil {
            self.medalMediaId = dict["medalMediaId"] as! String
        }
        if dict.keys.contains("medalName") && dict["medalName"] != nil {
            self.medalName = dict["medalName"] as! String
        }
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! String
        }
    }
}

public class CreateOrgHonorTemplateShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var avatarFrameMediaId: String?

    public var defaultBgColor: String?

    public var medalDesc: String?

    public var medalMediaId: String?

    public var medalName: String?

    public var orgId: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.avatarFrameMediaId != nil {
            map["avatarFrameMediaId"] = self.avatarFrameMediaId!
        }
        if self.defaultBgColor != nil {
            map["defaultBgColor"] = self.defaultBgColor!
        }
        if self.medalDesc != nil {
            map["medalDesc"] = self.medalDesc!
        }
        if self.medalMediaId != nil {
            map["medalMediaId"] = self.medalMediaId!
        }
        if self.medalName != nil {
            map["medalName"] = self.medalName!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("avatarFrameMediaId") && dict["avatarFrameMediaId"] != nil {
            self.avatarFrameMediaId = dict["avatarFrameMediaId"] as! String
        }
        if dict.keys.contains("defaultBgColor") && dict["defaultBgColor"] != nil {
            self.defaultBgColor = dict["defaultBgColor"] as! String
        }
        if dict.keys.contains("medalDesc") && dict["medalDesc"] != nil {
            self.medalDesc = dict["medalDesc"] as! String
        }
        if dict.keys.contains("medalMediaId") && dict["medalMediaId"] != nil {
            self.medalMediaId = dict["medalMediaId"] as! String
        }
        if dict.keys.contains("medalName") && dict["medalName"] != nil {
            self.medalName = dict["medalName"] as! String
        }
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! String
        }
    }
}

public class CreateOrgHonorTemplateResponseBody : Tea.TeaModel {
    public var honorId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.honorId != nil {
            map["honorId"] = self.honorId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("honorId") && dict["honorId"] != nil {
            self.honorId = dict["honorId"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateOrgHonorTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrgHonorTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateOrgHonorTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePersonalTodoTaskHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var userToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userToken != nil {
                map["userToken"] = self.userToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("userToken") && dict["userToken"] != nil {
                self.userToken = dict["userToken"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreatePersonalTodoTaskHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreatePersonalTodoTaskHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreatePersonalTodoTaskShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreatePersonalTodoTaskRequest : Tea.TeaModel {
    public class NotifyConfigs : Tea.TeaModel {
        public var dingNotify: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dingNotify != nil {
                map["DingNotify"] = self.dingNotify!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DingNotify") && dict["DingNotify"] != nil {
                self.dingNotify = dict["DingNotify"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var description_: String?

    public var dueTime: Int64?

    public var executorIds: [String]?

    public var notifyConfigs: CreatePersonalTodoTaskRequest.NotifyConfigs?

    public var participantIds: [String]?

    public var subject: String?

    public var tenantContext: CreatePersonalTodoTaskRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notifyConfigs?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dueTime != nil {
            map["DueTime"] = self.dueTime!
        }
        if self.executorIds != nil {
            map["ExecutorIds"] = self.executorIds!
        }
        if self.notifyConfigs != nil {
            map["NotifyConfigs"] = self.notifyConfigs?.toMap()
        }
        if self.participantIds != nil {
            map["ParticipantIds"] = self.participantIds!
        }
        if self.subject != nil {
            map["Subject"] = self.subject!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DueTime") && dict["DueTime"] != nil {
            self.dueTime = dict["DueTime"] as! Int64
        }
        if dict.keys.contains("ExecutorIds") && dict["ExecutorIds"] != nil {
            self.executorIds = dict["ExecutorIds"] as! [String]
        }
        if dict.keys.contains("NotifyConfigs") && dict["NotifyConfigs"] != nil {
            var model = CreatePersonalTodoTaskRequest.NotifyConfigs()
            model.fromMap(dict["NotifyConfigs"] as! [String: Any])
            self.notifyConfigs = model
        }
        if dict.keys.contains("ParticipantIds") && dict["ParticipantIds"] != nil {
            self.participantIds = dict["ParticipantIds"] as! [String]
        }
        if dict.keys.contains("Subject") && dict["Subject"] != nil {
            self.subject = dict["Subject"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = CreatePersonalTodoTaskRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class CreatePersonalTodoTaskShrinkRequest : Tea.TeaModel {
    public var description_: String?

    public var dueTime: Int64?

    public var executorIdsShrink: String?

    public var notifyConfigsShrink: String?

    public var participantIdsShrink: String?

    public var subject: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dueTime != nil {
            map["DueTime"] = self.dueTime!
        }
        if self.executorIdsShrink != nil {
            map["ExecutorIds"] = self.executorIdsShrink!
        }
        if self.notifyConfigsShrink != nil {
            map["NotifyConfigs"] = self.notifyConfigsShrink!
        }
        if self.participantIdsShrink != nil {
            map["ParticipantIds"] = self.participantIdsShrink!
        }
        if self.subject != nil {
            map["Subject"] = self.subject!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DueTime") && dict["DueTime"] != nil {
            self.dueTime = dict["DueTime"] as! Int64
        }
        if dict.keys.contains("ExecutorIds") && dict["ExecutorIds"] != nil {
            self.executorIdsShrink = dict["ExecutorIds"] as! String
        }
        if dict.keys.contains("NotifyConfigs") && dict["NotifyConfigs"] != nil {
            self.notifyConfigsShrink = dict["NotifyConfigs"] as! String
        }
        if dict.keys.contains("ParticipantIds") && dict["ParticipantIds"] != nil {
            self.participantIdsShrink = dict["ParticipantIds"] as! String
        }
        if dict.keys.contains("Subject") && dict["Subject"] != nil {
            self.subject = dict["Subject"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class CreatePersonalTodoTaskResponseBody : Tea.TeaModel {
    public var createdTime: Int64?

    public var requestId: String?

    public var taskId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createdTime != nil {
            map["createdTime"] = self.createdTime!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("createdTime") && dict["createdTime"] != nil {
            self.createdTime = dict["createdTime"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("taskId") && dict["taskId"] != nil {
            self.taskId = dict["taskId"] as! String
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class CreatePersonalTodoTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePersonalTodoTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreatePersonalTodoTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateReportHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateReportHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateReportHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateReportShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateReportRequest : Tea.TeaModel {
    public class Contents : Tea.TeaModel {
        public var content: String?

        public var contentType: String?

        public var key: String?

        public var sort: Int64?

        public var type: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.contentType != nil {
                map["ContentType"] = self.contentType!
            }
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.sort != nil {
                map["Sort"] = self.sort!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") && dict["Content"] != nil {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("ContentType") && dict["ContentType"] != nil {
                self.contentType = dict["ContentType"] as! String
            }
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Sort") && dict["Sort"] != nil {
                self.sort = dict["Sort"] as! Int64
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! Int64
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var contents: [CreateReportRequest.Contents]?

    public var ddFrom: String?

    public var templateId: String?

    public var tenantContext: CreateReportRequest.TenantContext?

    public var toChat: Bool?

    public var toCids: [String]?

    public var toUserids: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contents != nil {
            var tmp : [Any] = []
            for k in self.contents! {
                tmp.append(k.toMap())
            }
            map["Contents"] = tmp
        }
        if self.ddFrom != nil {
            map["DdFrom"] = self.ddFrom!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.toChat != nil {
            map["ToChat"] = self.toChat!
        }
        if self.toCids != nil {
            map["ToCids"] = self.toCids!
        }
        if self.toUserids != nil {
            map["ToUserids"] = self.toUserids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Contents") && dict["Contents"] != nil {
            var tmp : [CreateReportRequest.Contents] = []
            for v in dict["Contents"] as! [Any] {
                var model = CreateReportRequest.Contents()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.contents = tmp
        }
        if dict.keys.contains("DdFrom") && dict["DdFrom"] != nil {
            self.ddFrom = dict["DdFrom"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = CreateReportRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("ToChat") && dict["ToChat"] != nil {
            self.toChat = dict["ToChat"] as! Bool
        }
        if dict.keys.contains("ToCids") && dict["ToCids"] != nil {
            self.toCids = dict["ToCids"] as! [String]
        }
        if dict.keys.contains("ToUserids") && dict["ToUserids"] != nil {
            self.toUserids = dict["ToUserids"] as! [String]
        }
    }
}

public class CreateReportShrinkRequest : Tea.TeaModel {
    public var contentsShrink: String?

    public var ddFrom: String?

    public var templateId: String?

    public var tenantContextShrink: String?

    public var toChat: Bool?

    public var toCidsShrink: String?

    public var toUseridsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contentsShrink != nil {
            map["Contents"] = self.contentsShrink!
        }
        if self.ddFrom != nil {
            map["DdFrom"] = self.ddFrom!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.toChat != nil {
            map["ToChat"] = self.toChat!
        }
        if self.toCidsShrink != nil {
            map["ToCids"] = self.toCidsShrink!
        }
        if self.toUseridsShrink != nil {
            map["ToUserids"] = self.toUseridsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Contents") && dict["Contents"] != nil {
            self.contentsShrink = dict["Contents"] as! String
        }
        if dict.keys.contains("DdFrom") && dict["DdFrom"] != nil {
            self.ddFrom = dict["DdFrom"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("ToChat") && dict["ToChat"] != nil {
            self.toChat = dict["ToChat"] as! Bool
        }
        if dict.keys.contains("ToCids") && dict["ToCids"] != nil {
            self.toCidsShrink = dict["ToCids"] as! String
        }
        if dict.keys.contains("ToUserids") && dict["ToUserids"] != nil {
            self.toUseridsShrink = dict["ToUserids"] as! String
        }
    }
}

public class CreateReportResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreateReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateScenegroupHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateScenegroupHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateScenegroupHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateScenegroupShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateScenegroupRequest : Tea.TeaModel {
    public var addFriendForbidden: Int64?

    public var allMembersCanCreateCalendar: Int64?

    public var allMembersCanCreateMcsConf: Int64?

    public var chatBannedType: Int64?

    public var groupEmailDisabled: Int64?

    public var groupLiveSwitch: Int64?

    public var icon: String?

    public var managementType: Int64?

    public var membersToAdminChat: Int64?

    public var mentionAllAuthority: Int64?

    public var onlyAdminCanDing: Int64?

    public var onlyAdminCanSetMsgTop: Int64?

    public var searchable: Int64?

    public var showHistoryType: Int64?

    public var subadminIds: String?

    public var templateId: String?

    public var title: String?

    public var userIds: String?

    public var uuid: String?

    public var validationType: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addFriendForbidden != nil {
            map["AddFriendForbidden"] = self.addFriendForbidden!
        }
        if self.allMembersCanCreateCalendar != nil {
            map["AllMembersCanCreateCalendar"] = self.allMembersCanCreateCalendar!
        }
        if self.allMembersCanCreateMcsConf != nil {
            map["AllMembersCanCreateMcsConf"] = self.allMembersCanCreateMcsConf!
        }
        if self.chatBannedType != nil {
            map["ChatBannedType"] = self.chatBannedType!
        }
        if self.groupEmailDisabled != nil {
            map["GroupEmailDisabled"] = self.groupEmailDisabled!
        }
        if self.groupLiveSwitch != nil {
            map["GroupLiveSwitch"] = self.groupLiveSwitch!
        }
        if self.icon != nil {
            map["Icon"] = self.icon!
        }
        if self.managementType != nil {
            map["ManagementType"] = self.managementType!
        }
        if self.membersToAdminChat != nil {
            map["MembersToAdminChat"] = self.membersToAdminChat!
        }
        if self.mentionAllAuthority != nil {
            map["MentionAllAuthority"] = self.mentionAllAuthority!
        }
        if self.onlyAdminCanDing != nil {
            map["OnlyAdminCanDing"] = self.onlyAdminCanDing!
        }
        if self.onlyAdminCanSetMsgTop != nil {
            map["OnlyAdminCanSetMsgTop"] = self.onlyAdminCanSetMsgTop!
        }
        if self.searchable != nil {
            map["Searchable"] = self.searchable!
        }
        if self.showHistoryType != nil {
            map["ShowHistoryType"] = self.showHistoryType!
        }
        if self.subadminIds != nil {
            map["SubadminIds"] = self.subadminIds!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userIds != nil {
            map["UserIds"] = self.userIds!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        if self.validationType != nil {
            map["ValidationType"] = self.validationType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddFriendForbidden") && dict["AddFriendForbidden"] != nil {
            self.addFriendForbidden = dict["AddFriendForbidden"] as! Int64
        }
        if dict.keys.contains("AllMembersCanCreateCalendar") && dict["AllMembersCanCreateCalendar"] != nil {
            self.allMembersCanCreateCalendar = dict["AllMembersCanCreateCalendar"] as! Int64
        }
        if dict.keys.contains("AllMembersCanCreateMcsConf") && dict["AllMembersCanCreateMcsConf"] != nil {
            self.allMembersCanCreateMcsConf = dict["AllMembersCanCreateMcsConf"] as! Int64
        }
        if dict.keys.contains("ChatBannedType") && dict["ChatBannedType"] != nil {
            self.chatBannedType = dict["ChatBannedType"] as! Int64
        }
        if dict.keys.contains("GroupEmailDisabled") && dict["GroupEmailDisabled"] != nil {
            self.groupEmailDisabled = dict["GroupEmailDisabled"] as! Int64
        }
        if dict.keys.contains("GroupLiveSwitch") && dict["GroupLiveSwitch"] != nil {
            self.groupLiveSwitch = dict["GroupLiveSwitch"] as! Int64
        }
        if dict.keys.contains("Icon") && dict["Icon"] != nil {
            self.icon = dict["Icon"] as! String
        }
        if dict.keys.contains("ManagementType") && dict["ManagementType"] != nil {
            self.managementType = dict["ManagementType"] as! Int64
        }
        if dict.keys.contains("MembersToAdminChat") && dict["MembersToAdminChat"] != nil {
            self.membersToAdminChat = dict["MembersToAdminChat"] as! Int64
        }
        if dict.keys.contains("MentionAllAuthority") && dict["MentionAllAuthority"] != nil {
            self.mentionAllAuthority = dict["MentionAllAuthority"] as! Int64
        }
        if dict.keys.contains("OnlyAdminCanDing") && dict["OnlyAdminCanDing"] != nil {
            self.onlyAdminCanDing = dict["OnlyAdminCanDing"] as! Int64
        }
        if dict.keys.contains("OnlyAdminCanSetMsgTop") && dict["OnlyAdminCanSetMsgTop"] != nil {
            self.onlyAdminCanSetMsgTop = dict["OnlyAdminCanSetMsgTop"] as! Int64
        }
        if dict.keys.contains("Searchable") && dict["Searchable"] != nil {
            self.searchable = dict["Searchable"] as! Int64
        }
        if dict.keys.contains("ShowHistoryType") && dict["ShowHistoryType"] != nil {
            self.showHistoryType = dict["ShowHistoryType"] as! Int64
        }
        if dict.keys.contains("SubadminIds") && dict["SubadminIds"] != nil {
            self.subadminIds = dict["SubadminIds"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserIds") && dict["UserIds"] != nil {
            self.userIds = dict["UserIds"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
        if dict.keys.contains("ValidationType") && dict["ValidationType"] != nil {
            self.validationType = dict["ValidationType"] as! Int64
        }
    }
}

public class CreateScenegroupResponseBody : Tea.TeaModel {
    public var openConversationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.openConversationId != nil {
            map["openConversationId"] = self.openConversationId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("openConversationId") && dict["openConversationId"] != nil {
            self.openConversationId = dict["openConversationId"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateScenegroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateScenegroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateScenegroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateScheduleConferenceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateScheduleConferenceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateScheduleConferenceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateScheduleConferenceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateScheduleConferenceRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var endTime: Int64?

    public var startTime: Int64?

    public var tenantContext: CreateScheduleConferenceRequest.TenantContext?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = CreateScheduleConferenceRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class CreateScheduleConferenceShrinkRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var startTime: Int64?

    public var tenantContextShrink: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class CreateScheduleConferenceResponseBody : Tea.TeaModel {
    public var phones: [String]?

    public var requestId: String?

    public var roomCode: String?

    public var scheduleConferenceId: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.phones != nil {
            map["phones"] = self.phones!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.roomCode != nil {
            map["roomCode"] = self.roomCode!
        }
        if self.scheduleConferenceId != nil {
            map["scheduleConferenceId"] = self.scheduleConferenceId!
        }
        if self.url != nil {
            map["url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("phones") && dict["phones"] != nil {
            self.phones = dict["phones"] as! [String]
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("roomCode") && dict["roomCode"] != nil {
            self.roomCode = dict["roomCode"] as! String
        }
        if dict.keys.contains("scheduleConferenceId") && dict["scheduleConferenceId"] != nil {
            self.scheduleConferenceId = dict["scheduleConferenceId"] as! String
        }
        if dict.keys.contains("url") && dict["url"] != nil {
            self.url = dict["url"] as! String
        }
    }
}

public class CreateScheduleConferenceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateScheduleConferenceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateScheduleConferenceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSheetHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateSheetHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateSheetHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateSheetShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateSheetRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var name: String?

    public var tenantContext: CreateSheetRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = CreateSheetRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class CreateSheetShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class CreateSheetResponseBody : Tea.TeaModel {
    public var id: String?

    public var name: String?

    public var requestId: String?

    public var visibility: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.visibility != nil {
            map["visibility"] = self.visibility!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("name") && dict["name"] != nil {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("visibility") && dict["visibility"] != nil {
            self.visibility = dict["visibility"] as! String
        }
    }
}

public class CreateSheetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSheetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateSheetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSubscribedCalendarHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateSubscribedCalendarHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateSubscribedCalendarHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateSubscribedCalendarShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateSubscribedCalendarRequest : Tea.TeaModel {
    public class SubscribeScope : Tea.TeaModel {
        public var userIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userIds != nil {
                map["UserIds"] = self.userIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UserIds") && dict["UserIds"] != nil {
                self.userIds = dict["UserIds"] as! [String]
            }
        }
    }
    public var description_: String?

    public var managers: [String]?

    public var name: String?

    public var subscribeScope: CreateSubscribedCalendarRequest.SubscribeScope?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.subscribeScope?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.managers != nil {
            map["Managers"] = self.managers!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.subscribeScope != nil {
            map["SubscribeScope"] = self.subscribeScope?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Managers") && dict["Managers"] != nil {
            self.managers = dict["Managers"] as! [String]
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("SubscribeScope") && dict["SubscribeScope"] != nil {
            var model = CreateSubscribedCalendarRequest.SubscribeScope()
            model.fromMap(dict["SubscribeScope"] as! [String: Any])
            self.subscribeScope = model
        }
    }
}

public class CreateSubscribedCalendarShrinkRequest : Tea.TeaModel {
    public var description_: String?

    public var managersShrink: String?

    public var name: String?

    public var subscribeScopeShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.managersShrink != nil {
            map["Managers"] = self.managersShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.subscribeScopeShrink != nil {
            map["SubscribeScope"] = self.subscribeScopeShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Managers") && dict["Managers"] != nil {
            self.managersShrink = dict["Managers"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("SubscribeScope") && dict["SubscribeScope"] != nil {
            self.subscribeScopeShrink = dict["SubscribeScope"] as! String
        }
    }
}

public class CreateSubscribedCalendarResponseBody : Tea.TeaModel {
    public var calendarId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["calendarId"] = self.calendarId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("calendarId") && dict["calendarId"] != nil {
            self.calendarId = dict["calendarId"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateSubscribedCalendarResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSubscribedCalendarResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateSubscribedCalendarResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTodoTaskHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateTodoTaskHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateTodoTaskHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateTodoTaskShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateTodoTaskRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public class ContentFieldList : Tea.TeaModel {
        public var fieldKey: String?

        public var fieldValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldKey != nil {
                map["fieldKey"] = self.fieldKey!
            }
            if self.fieldValue != nil {
                map["fieldValue"] = self.fieldValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("fieldKey") && dict["fieldKey"] != nil {
                self.fieldKey = dict["fieldKey"] as! String
            }
            if dict.keys.contains("fieldValue") && dict["fieldValue"] != nil {
                self.fieldValue = dict["fieldValue"] as! String
            }
        }
    }
    public class DetailUrl : Tea.TeaModel {
        public var appUrl: String?

        public var pcUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appUrl != nil {
                map["appUrl"] = self.appUrl!
            }
            if self.pcUrl != nil {
                map["pcUrl"] = self.pcUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("appUrl") && dict["appUrl"] != nil {
                self.appUrl = dict["appUrl"] as! String
            }
            if dict.keys.contains("pcUrl") && dict["pcUrl"] != nil {
                self.pcUrl = dict["pcUrl"] as! String
            }
        }
    }
    public class NotifyConfigs : Tea.TeaModel {
        public var dingNotify: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dingNotify != nil {
                map["dingNotify"] = self.dingNotify!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("dingNotify") && dict["dingNotify"] != nil {
                self.dingNotify = dict["dingNotify"] as! String
            }
        }
    }
    public var tenantContext: CreateTodoTaskRequest.TenantContext?

    public var contentFieldList: [CreateTodoTaskRequest.ContentFieldList]?

    public var creatorId: String?

    public var description_: String?

    public var detailUrl: CreateTodoTaskRequest.DetailUrl?

    public var dueTime: Int64?

    public var executorIds: [String]?

    public var isOnlyShowExecutor: Bool?

    public var notifyConfigs: CreateTodoTaskRequest.NotifyConfigs?

    public var operatorId: String?

    public var participantIds: [String]?

    public var priority: Int32?

    public var sourceId: String?

    public var subject: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
        try self.detailUrl?.validate()
        try self.notifyConfigs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.contentFieldList != nil {
            var tmp : [Any] = []
            for k in self.contentFieldList! {
                tmp.append(k.toMap())
            }
            map["contentFieldList"] = tmp
        }
        if self.creatorId != nil {
            map["creatorId"] = self.creatorId!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.detailUrl != nil {
            map["detailUrl"] = self.detailUrl?.toMap()
        }
        if self.dueTime != nil {
            map["dueTime"] = self.dueTime!
        }
        if self.executorIds != nil {
            map["executorIds"] = self.executorIds!
        }
        if self.isOnlyShowExecutor != nil {
            map["isOnlyShowExecutor"] = self.isOnlyShowExecutor!
        }
        if self.notifyConfigs != nil {
            map["notifyConfigs"] = self.notifyConfigs?.toMap()
        }
        if self.operatorId != nil {
            map["operatorId"] = self.operatorId!
        }
        if self.participantIds != nil {
            map["participantIds"] = self.participantIds!
        }
        if self.priority != nil {
            map["priority"] = self.priority!
        }
        if self.sourceId != nil {
            map["sourceId"] = self.sourceId!
        }
        if self.subject != nil {
            map["subject"] = self.subject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = CreateTodoTaskRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("contentFieldList") && dict["contentFieldList"] != nil {
            var tmp : [CreateTodoTaskRequest.ContentFieldList] = []
            for v in dict["contentFieldList"] as! [Any] {
                var model = CreateTodoTaskRequest.ContentFieldList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.contentFieldList = tmp
        }
        if dict.keys.contains("creatorId") && dict["creatorId"] != nil {
            self.creatorId = dict["creatorId"] as! String
        }
        if dict.keys.contains("description") && dict["description"] != nil {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("detailUrl") && dict["detailUrl"] != nil {
            var model = CreateTodoTaskRequest.DetailUrl()
            model.fromMap(dict["detailUrl"] as! [String: Any])
            self.detailUrl = model
        }
        if dict.keys.contains("dueTime") && dict["dueTime"] != nil {
            self.dueTime = dict["dueTime"] as! Int64
        }
        if dict.keys.contains("executorIds") && dict["executorIds"] != nil {
            self.executorIds = dict["executorIds"] as! [String]
        }
        if dict.keys.contains("isOnlyShowExecutor") && dict["isOnlyShowExecutor"] != nil {
            self.isOnlyShowExecutor = dict["isOnlyShowExecutor"] as! Bool
        }
        if dict.keys.contains("notifyConfigs") && dict["notifyConfigs"] != nil {
            var model = CreateTodoTaskRequest.NotifyConfigs()
            model.fromMap(dict["notifyConfigs"] as! [String: Any])
            self.notifyConfigs = model
        }
        if dict.keys.contains("operatorId") && dict["operatorId"] != nil {
            self.operatorId = dict["operatorId"] as! String
        }
        if dict.keys.contains("participantIds") && dict["participantIds"] != nil {
            self.participantIds = dict["participantIds"] as! [String]
        }
        if dict.keys.contains("priority") && dict["priority"] != nil {
            self.priority = dict["priority"] as! Int32
        }
        if dict.keys.contains("sourceId") && dict["sourceId"] != nil {
            self.sourceId = dict["sourceId"] as! String
        }
        if dict.keys.contains("subject") && dict["subject"] != nil {
            self.subject = dict["subject"] as! String
        }
    }
}

public class CreateTodoTaskShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var contentFieldListShrink: String?

    public var creatorId: String?

    public var description_: String?

    public var detailUrlShrink: String?

    public var dueTime: Int64?

    public var executorIdsShrink: String?

    public var isOnlyShowExecutor: Bool?

    public var notifyConfigsShrink: String?

    public var operatorId: String?

    public var participantIdsShrink: String?

    public var priority: Int32?

    public var sourceId: String?

    public var subject: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.contentFieldListShrink != nil {
            map["contentFieldList"] = self.contentFieldListShrink!
        }
        if self.creatorId != nil {
            map["creatorId"] = self.creatorId!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.detailUrlShrink != nil {
            map["detailUrl"] = self.detailUrlShrink!
        }
        if self.dueTime != nil {
            map["dueTime"] = self.dueTime!
        }
        if self.executorIdsShrink != nil {
            map["executorIds"] = self.executorIdsShrink!
        }
        if self.isOnlyShowExecutor != nil {
            map["isOnlyShowExecutor"] = self.isOnlyShowExecutor!
        }
        if self.notifyConfigsShrink != nil {
            map["notifyConfigs"] = self.notifyConfigsShrink!
        }
        if self.operatorId != nil {
            map["operatorId"] = self.operatorId!
        }
        if self.participantIdsShrink != nil {
            map["participantIds"] = self.participantIdsShrink!
        }
        if self.priority != nil {
            map["priority"] = self.priority!
        }
        if self.sourceId != nil {
            map["sourceId"] = self.sourceId!
        }
        if self.subject != nil {
            map["subject"] = self.subject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("contentFieldList") && dict["contentFieldList"] != nil {
            self.contentFieldListShrink = dict["contentFieldList"] as! String
        }
        if dict.keys.contains("creatorId") && dict["creatorId"] != nil {
            self.creatorId = dict["creatorId"] as! String
        }
        if dict.keys.contains("description") && dict["description"] != nil {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("detailUrl") && dict["detailUrl"] != nil {
            self.detailUrlShrink = dict["detailUrl"] as! String
        }
        if dict.keys.contains("dueTime") && dict["dueTime"] != nil {
            self.dueTime = dict["dueTime"] as! Int64
        }
        if dict.keys.contains("executorIds") && dict["executorIds"] != nil {
            self.executorIdsShrink = dict["executorIds"] as! String
        }
        if dict.keys.contains("isOnlyShowExecutor") && dict["isOnlyShowExecutor"] != nil {
            self.isOnlyShowExecutor = dict["isOnlyShowExecutor"] as! Bool
        }
        if dict.keys.contains("notifyConfigs") && dict["notifyConfigs"] != nil {
            self.notifyConfigsShrink = dict["notifyConfigs"] as! String
        }
        if dict.keys.contains("operatorId") && dict["operatorId"] != nil {
            self.operatorId = dict["operatorId"] as! String
        }
        if dict.keys.contains("participantIds") && dict["participantIds"] != nil {
            self.participantIdsShrink = dict["participantIds"] as! String
        }
        if dict.keys.contains("priority") && dict["priority"] != nil {
            self.priority = dict["priority"] as! Int32
        }
        if dict.keys.contains("sourceId") && dict["sourceId"] != nil {
            self.sourceId = dict["sourceId"] as! String
        }
        if dict.keys.contains("subject") && dict["subject"] != nil {
            self.subject = dict["subject"] as! String
        }
    }
}

public class CreateTodoTaskResponseBody : Tea.TeaModel {
    public class ContentFieldList : Tea.TeaModel {
        public var fieldKey: String?

        public var fieldValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldKey != nil {
                map["fieldKey"] = self.fieldKey!
            }
            if self.fieldValue != nil {
                map["fieldValue"] = self.fieldValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("fieldKey") && dict["fieldKey"] != nil {
                self.fieldKey = dict["fieldKey"] as! String
            }
            if dict.keys.contains("fieldValue") && dict["fieldValue"] != nil {
                self.fieldValue = dict["fieldValue"] as! String
            }
        }
    }
    public class DetailUrl : Tea.TeaModel {
        public var appUrl: String?

        public var pcUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appUrl != nil {
                map["appUrl"] = self.appUrl!
            }
            if self.pcUrl != nil {
                map["pcUrl"] = self.pcUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("appUrl") && dict["appUrl"] != nil {
                self.appUrl = dict["appUrl"] as! String
            }
            if dict.keys.contains("pcUrl") && dict["pcUrl"] != nil {
                self.pcUrl = dict["pcUrl"] as! String
            }
        }
    }
    public class NotifyConfigs : Tea.TeaModel {
        public var dingNotify: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dingNotify != nil {
                map["dingNotify"] = self.dingNotify!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("dingNotify") && dict["dingNotify"] != nil {
                self.dingNotify = dict["dingNotify"] as! String
            }
        }
    }
    public var bizTag: String?

    public var contentFieldList: [CreateTodoTaskResponseBody.ContentFieldList]?

    public var createdTime: Int64?

    public var creatorId: String?

    public var description_: String?

    public var detailUrl: CreateTodoTaskResponseBody.DetailUrl?

    public var done: Bool?

    public var dueTime: Int64?

    public var executorIds: [String]?

    public var finishTime: Int64?

    public var id: String?

    public var isOnlyShowExecutor: Bool?

    public var modifiedTime: Int64?

    public var modifierId: String?

    public var notifyConfigs: CreateTodoTaskResponseBody.NotifyConfigs?

    public var participantIds: [String]?

    public var priority: Int32?

    public var requestId: String?

    public var source: String?

    public var sourceId: String?

    public var startTime: Int64?

    public var subject: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.detailUrl?.validate()
        try self.notifyConfigs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizTag != nil {
            map["bizTag"] = self.bizTag!
        }
        if self.contentFieldList != nil {
            var tmp : [Any] = []
            for k in self.contentFieldList! {
                tmp.append(k.toMap())
            }
            map["contentFieldList"] = tmp
        }
        if self.createdTime != nil {
            map["createdTime"] = self.createdTime!
        }
        if self.creatorId != nil {
            map["creatorId"] = self.creatorId!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.detailUrl != nil {
            map["detailUrl"] = self.detailUrl?.toMap()
        }
        if self.done != nil {
            map["done"] = self.done!
        }
        if self.dueTime != nil {
            map["dueTime"] = self.dueTime!
        }
        if self.executorIds != nil {
            map["executorIds"] = self.executorIds!
        }
        if self.finishTime != nil {
            map["finishTime"] = self.finishTime!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.isOnlyShowExecutor != nil {
            map["isOnlyShowExecutor"] = self.isOnlyShowExecutor!
        }
        if self.modifiedTime != nil {
            map["modifiedTime"] = self.modifiedTime!
        }
        if self.modifierId != nil {
            map["modifierId"] = self.modifierId!
        }
        if self.notifyConfigs != nil {
            map["notifyConfigs"] = self.notifyConfigs?.toMap()
        }
        if self.participantIds != nil {
            map["participantIds"] = self.participantIds!
        }
        if self.priority != nil {
            map["priority"] = self.priority!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.source != nil {
            map["source"] = self.source!
        }
        if self.sourceId != nil {
            map["sourceId"] = self.sourceId!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.subject != nil {
            map["subject"] = self.subject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("bizTag") && dict["bizTag"] != nil {
            self.bizTag = dict["bizTag"] as! String
        }
        if dict.keys.contains("contentFieldList") && dict["contentFieldList"] != nil {
            var tmp : [CreateTodoTaskResponseBody.ContentFieldList] = []
            for v in dict["contentFieldList"] as! [Any] {
                var model = CreateTodoTaskResponseBody.ContentFieldList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.contentFieldList = tmp
        }
        if dict.keys.contains("createdTime") && dict["createdTime"] != nil {
            self.createdTime = dict["createdTime"] as! Int64
        }
        if dict.keys.contains("creatorId") && dict["creatorId"] != nil {
            self.creatorId = dict["creatorId"] as! String
        }
        if dict.keys.contains("description") && dict["description"] != nil {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("detailUrl") && dict["detailUrl"] != nil {
            var model = CreateTodoTaskResponseBody.DetailUrl()
            model.fromMap(dict["detailUrl"] as! [String: Any])
            self.detailUrl = model
        }
        if dict.keys.contains("done") && dict["done"] != nil {
            self.done = dict["done"] as! Bool
        }
        if dict.keys.contains("dueTime") && dict["dueTime"] != nil {
            self.dueTime = dict["dueTime"] as! Int64
        }
        if dict.keys.contains("executorIds") && dict["executorIds"] != nil {
            self.executorIds = dict["executorIds"] as! [String]
        }
        if dict.keys.contains("finishTime") && dict["finishTime"] != nil {
            self.finishTime = dict["finishTime"] as! Int64
        }
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("isOnlyShowExecutor") && dict["isOnlyShowExecutor"] != nil {
            self.isOnlyShowExecutor = dict["isOnlyShowExecutor"] as! Bool
        }
        if dict.keys.contains("modifiedTime") && dict["modifiedTime"] != nil {
            self.modifiedTime = dict["modifiedTime"] as! Int64
        }
        if dict.keys.contains("modifierId") && dict["modifierId"] != nil {
            self.modifierId = dict["modifierId"] as! String
        }
        if dict.keys.contains("notifyConfigs") && dict["notifyConfigs"] != nil {
            var model = CreateTodoTaskResponseBody.NotifyConfigs()
            model.fromMap(dict["notifyConfigs"] as! [String: Any])
            self.notifyConfigs = model
        }
        if dict.keys.contains("participantIds") && dict["participantIds"] != nil {
            self.participantIds = dict["participantIds"] as! [String]
        }
        if dict.keys.contains("priority") && dict["priority"] != nil {
            self.priority = dict["priority"] as! Int32
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("source") && dict["source"] != nil {
            self.source = dict["source"] as! String
        }
        if dict.keys.contains("sourceId") && dict["sourceId"] != nil {
            self.sourceId = dict["sourceId"] as! String
        }
        if dict.keys.contains("startTime") && dict["startTime"] != nil {
            self.startTime = dict["startTime"] as! Int64
        }
        if dict.keys.contains("subject") && dict["subject"] != nil {
            self.subject = dict["subject"] as! String
        }
    }
}

public class CreateTodoTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTodoTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateTodoTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVideoConferenceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateVideoConferenceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateVideoConferenceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateVideoConferenceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateVideoConferenceRequest : Tea.TeaModel {
    public var confTitle: String?

    public var inviteCaller: Bool?

    public var inviteUserIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.confTitle != nil {
            map["ConfTitle"] = self.confTitle!
        }
        if self.inviteCaller != nil {
            map["InviteCaller"] = self.inviteCaller!
        }
        if self.inviteUserIds != nil {
            map["InviteUserIds"] = self.inviteUserIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfTitle") && dict["ConfTitle"] != nil {
            self.confTitle = dict["ConfTitle"] as! String
        }
        if dict.keys.contains("InviteCaller") && dict["InviteCaller"] != nil {
            self.inviteCaller = dict["InviteCaller"] as! Bool
        }
        if dict.keys.contains("InviteUserIds") && dict["InviteUserIds"] != nil {
            self.inviteUserIds = dict["InviteUserIds"] as! [String]
        }
    }
}

public class CreateVideoConferenceShrinkRequest : Tea.TeaModel {
    public var confTitle: String?

    public var inviteCaller: Bool?

    public var inviteUserIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.confTitle != nil {
            map["ConfTitle"] = self.confTitle!
        }
        if self.inviteCaller != nil {
            map["InviteCaller"] = self.inviteCaller!
        }
        if self.inviteUserIdsShrink != nil {
            map["InviteUserIds"] = self.inviteUserIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfTitle") && dict["ConfTitle"] != nil {
            self.confTitle = dict["ConfTitle"] as! String
        }
        if dict.keys.contains("InviteCaller") && dict["InviteCaller"] != nil {
            self.inviteCaller = dict["InviteCaller"] as! Bool
        }
        if dict.keys.contains("InviteUserIds") && dict["InviteUserIds"] != nil {
            self.inviteUserIdsShrink = dict["InviteUserIds"] as! String
        }
    }
}

public class CreateVideoConferenceResponseBody : Tea.TeaModel {
    public var conferenceId: String?

    public var conferencePassword: String?

    public var externalLinkUrl: String?

    public var hostPassword: String?

    public var phoneNumbers: [String]?

    public var requestId: String?

    public var roomCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        if self.conferencePassword != nil {
            map["conferencePassword"] = self.conferencePassword!
        }
        if self.externalLinkUrl != nil {
            map["externalLinkUrl"] = self.externalLinkUrl!
        }
        if self.hostPassword != nil {
            map["hostPassword"] = self.hostPassword!
        }
        if self.phoneNumbers != nil {
            map["phoneNumbers"] = self.phoneNumbers!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.roomCode != nil {
            map["roomCode"] = self.roomCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("conferenceId") && dict["conferenceId"] != nil {
            self.conferenceId = dict["conferenceId"] as! String
        }
        if dict.keys.contains("conferencePassword") && dict["conferencePassword"] != nil {
            self.conferencePassword = dict["conferencePassword"] as! String
        }
        if dict.keys.contains("externalLinkUrl") && dict["externalLinkUrl"] != nil {
            self.externalLinkUrl = dict["externalLinkUrl"] as! String
        }
        if dict.keys.contains("hostPassword") && dict["hostPassword"] != nil {
            self.hostPassword = dict["hostPassword"] as! String
        }
        if dict.keys.contains("phoneNumbers") && dict["phoneNumbers"] != nil {
            self.phoneNumbers = dict["phoneNumbers"] as! [String]
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("roomCode") && dict["roomCode"] != nil {
            self.roomCode = dict["roomCode"] as! String
        }
    }
}

public class CreateVideoConferenceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVideoConferenceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateVideoConferenceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateWorkspaceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateWorkspaceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateWorkspaceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateWorkspaceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateWorkspaceRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var description_: String?

    public var name: String?

    public var tenantContext: CreateWorkspaceRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = CreateWorkspaceRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class CreateWorkspaceShrinkRequest : Tea.TeaModel {
    public var description_: String?

    public var name: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class CreateWorkspaceResponseBody : Tea.TeaModel {
    public var description_: String?

    public var name: String?

    public var requestId: String?

    public var url: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.url != nil {
            map["url"] = self.url!
        }
        if self.workspaceId != nil {
            map["workspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("description") && dict["description"] != nil {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("name") && dict["name"] != nil {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("url") && dict["url"] != nil {
            self.url = dict["url"] as! String
        }
        if dict.keys.contains("workspaceId") && dict["workspaceId"] != nil {
            self.workspaceId = dict["workspaceId"] as! String
        }
    }
}

public class CreateWorkspaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateWorkspaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateWorkspaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateWorkspaceDocHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: CreateWorkspaceDocHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = CreateWorkspaceDocHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class CreateWorkspaceDocShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class CreateWorkspaceDocRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var docType: String?

    public var name: String?

    public var parentNodeId: String?

    public var templateId: String?

    public var templateType: String?

    public var tenantContext: CreateWorkspaceDocRequest.TenantContext?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.docType != nil {
            map["DocType"] = self.docType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.parentNodeId != nil {
            map["ParentNodeId"] = self.parentNodeId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DocType") && dict["DocType"] != nil {
            self.docType = dict["DocType"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ParentNodeId") && dict["ParentNodeId"] != nil {
            self.parentNodeId = dict["ParentNodeId"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateType") && dict["TemplateType"] != nil {
            self.templateType = dict["TemplateType"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = CreateWorkspaceDocRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class CreateWorkspaceDocShrinkRequest : Tea.TeaModel {
    public var docType: String?

    public var name: String?

    public var parentNodeId: String?

    public var templateId: String?

    public var templateType: String?

    public var tenantContextShrink: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.docType != nil {
            map["DocType"] = self.docType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.parentNodeId != nil {
            map["ParentNodeId"] = self.parentNodeId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DocType") && dict["DocType"] != nil {
            self.docType = dict["DocType"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ParentNodeId") && dict["ParentNodeId"] != nil {
            self.parentNodeId = dict["ParentNodeId"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateType") && dict["TemplateType"] != nil {
            self.templateType = dict["TemplateType"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class CreateWorkspaceDocResponseBody : Tea.TeaModel {
    public var docKey: String?

    public var nodeId: String?

    public var requestId: String?

    public var url: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.docKey != nil {
            map["docKey"] = self.docKey!
        }
        if self.nodeId != nil {
            map["nodeId"] = self.nodeId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.url != nil {
            map["url"] = self.url!
        }
        if self.workspaceId != nil {
            map["workspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("docKey") && dict["docKey"] != nil {
            self.docKey = dict["docKey"] as! String
        }
        if dict.keys.contains("nodeId") && dict["nodeId"] != nil {
            self.nodeId = dict["nodeId"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("url") && dict["url"] != nil {
            self.url = dict["url"] as! String
        }
        if dict.keys.contains("workspaceId") && dict["workspaceId"] != nil {
            self.workspaceId = dict["workspaceId"] as! String
        }
    }
}

public class CreateWorkspaceDocResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateWorkspaceDocResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateWorkspaceDocResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteColumnsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteColumnsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = DeleteColumnsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteColumnsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteColumnsRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var column: Int64?

    public var columnCount: Int64?

    public var sheetId: String?

    public var tenantContext: DeleteColumnsRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.column != nil {
            map["Column"] = self.column!
        }
        if self.columnCount != nil {
            map["ColumnCount"] = self.columnCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Column") && dict["Column"] != nil {
            self.column = dict["Column"] as! Int64
        }
        if dict.keys.contains("ColumnCount") && dict["ColumnCount"] != nil {
            self.columnCount = dict["ColumnCount"] as! Int64
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = DeleteColumnsRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class DeleteColumnsShrinkRequest : Tea.TeaModel {
    public var column: Int64?

    public var columnCount: Int64?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.column != nil {
            map["Column"] = self.column!
        }
        if self.columnCount != nil {
            map["ColumnCount"] = self.columnCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Column") && dict["Column"] != nil {
            self.column = dict["Column"] as! Int64
        }
        if dict.keys.contains("ColumnCount") && dict["ColumnCount"] != nil {
            self.columnCount = dict["ColumnCount"] as! Int64
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class DeleteColumnsResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DeleteColumnsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteColumnsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteColumnsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEventHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteEventHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = DeleteEventHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteEventShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteEventRequest : Tea.TeaModel {
    public var calendarId: String?

    public var eventId: String?

    public var pushNotification: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.pushNotification != nil {
            map["pushNotification"] = self.pushNotification!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("pushNotification") && dict["pushNotification"] != nil {
            self.pushNotification = dict["pushNotification"] as! Bool
        }
    }
}

public class DeleteEventResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public var data: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["data"] = self.data!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("data") && dict["data"] != nil {
                self.data = dict["data"] as! Any
            }
        }
    }
    public var content: DeleteEventResponseBody.Content?

    public var errorCode: String?

    public var errorCtx: [String: Any]?

    public var errorMsg: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["content"] = self.content?.toMap()
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorCtx != nil {
            map["errorCtx"] = self.errorCtx!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("content") && dict["content"] != nil {
            var model = DeleteEventResponseBody.Content()
            model.fromMap(dict["content"] as! [String: Any])
            self.content = model
        }
        if dict.keys.contains("errorCode") && dict["errorCode"] != nil {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorCtx") && dict["errorCtx"] != nil {
            self.errorCtx = dict["errorCtx"] as! [String: Any]
        }
        if dict.keys.contains("errorMsg") && dict["errorMsg"] != nil {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("httpStatusCode") && dict["httpStatusCode"] != nil {
            self.httpStatusCode = dict["httpStatusCode"] as! Int32
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteFormDataHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteFormDataHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = DeleteFormDataHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteFormDataShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteFormDataRequest : Tea.TeaModel {
    public var appType: String?

    public var formInstanceId: String?

    public var language: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.formInstanceId != nil {
            map["FormInstanceId"] = self.formInstanceId!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FormInstanceId") && dict["FormInstanceId"] != nil {
            self.formInstanceId = dict["FormInstanceId"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class DeleteFormDataResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class DeleteFormDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFormDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteFormDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteInstanceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteInstanceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = DeleteInstanceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteInstanceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteInstanceRequest : Tea.TeaModel {
    public var appType: String?

    public var language: String?

    public var processInstanceId: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.processInstanceId != nil {
            map["ProcessInstanceId"] = self.processInstanceId!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("ProcessInstanceId") && dict["ProcessInstanceId"] != nil {
            self.processInstanceId = dict["ProcessInstanceId"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class DeleteInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class DeleteInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteLiveHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = DeleteLiveHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteLiveShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteLiveRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var liveId: String?

    public var tenantContext: DeleteLiveRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveId") && dict["LiveId"] != nil {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = DeleteLiveRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class DeleteLiveShrinkRequest : Tea.TeaModel {
    public var liveId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveId") && dict["LiveId"] != nil {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class DeleteLiveResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteLiveResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteLiveResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMeetingRoomHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteMeetingRoomHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = DeleteMeetingRoomHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteMeetingRoomShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteMeetingRoomRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var roomId: String?

    public var tenantContext: DeleteMeetingRoomRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.roomId != nil {
            map["RoomId"] = self.roomId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RoomId") && dict["RoomId"] != nil {
            self.roomId = dict["RoomId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = DeleteMeetingRoomRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class DeleteMeetingRoomShrinkRequest : Tea.TeaModel {
    public var roomId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.roomId != nil {
            map["RoomId"] = self.roomId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RoomId") && dict["RoomId"] != nil {
            self.roomId = dict["RoomId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class DeleteMeetingRoomResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! Bool
        }
    }
}

public class DeleteMeetingRoomResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMeetingRoomResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMeetingRoomResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMeetingRoomGroupHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteMeetingRoomGroupHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = DeleteMeetingRoomGroupHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteMeetingRoomGroupShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteMeetingRoomGroupRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var groupId: String?

    public var tenantContext: DeleteMeetingRoomGroupRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = DeleteMeetingRoomGroupRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class DeleteMeetingRoomGroupShrinkRequest : Tea.TeaModel {
    public var groupId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class DeleteMeetingRoomGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! Bool
        }
    }
}

public class DeleteMeetingRoomGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMeetingRoomGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMeetingRoomGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteRowsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteRowsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = DeleteRowsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteRowsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteRowsRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var row: Int64?

    public var rowCount: Int64?

    public var sheetId: String?

    public var tenantContext: DeleteRowsRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.row != nil {
            map["Row"] = self.row!
        }
        if self.rowCount != nil {
            map["RowCount"] = self.rowCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Row") && dict["Row"] != nil {
            self.row = dict["Row"] as! Int64
        }
        if dict.keys.contains("RowCount") && dict["RowCount"] != nil {
            self.rowCount = dict["RowCount"] as! Int64
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = DeleteRowsRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class DeleteRowsShrinkRequest : Tea.TeaModel {
    public var row: Int64?

    public var rowCount: Int64?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.row != nil {
            map["Row"] = self.row!
        }
        if self.rowCount != nil {
            map["RowCount"] = self.rowCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Row") && dict["Row"] != nil {
            self.row = dict["Row"] as! Int64
        }
        if dict.keys.contains("RowCount") && dict["RowCount"] != nil {
            self.rowCount = dict["RowCount"] as! Int64
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class DeleteRowsResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DeleteRowsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRowsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteRowsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteScenegroupMemberHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteScenegroupMemberHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = DeleteScenegroupMemberHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteScenegroupMemberShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteScenegroupMemberRequest : Tea.TeaModel {
    public var openConversationId: String?

    public var userIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.openConversationId != nil {
            map["OpenConversationId"] = self.openConversationId!
        }
        if self.userIds != nil {
            map["UserIds"] = self.userIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OpenConversationId") && dict["OpenConversationId"] != nil {
            self.openConversationId = dict["OpenConversationId"] as! String
        }
        if dict.keys.contains("UserIds") && dict["UserIds"] != nil {
            self.userIds = dict["UserIds"] as! String
        }
    }
}

public class DeleteScenegroupMemberResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteScenegroupMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteScenegroupMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteScenegroupMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSheetHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteSheetHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = DeleteSheetHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteSheetShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteSheetRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var sheetId: String?

    public var tenantContext: DeleteSheetRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = DeleteSheetRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class DeleteSheetShrinkRequest : Tea.TeaModel {
    public var sheetId: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class DeleteSheetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteSheetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSheetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteSheetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSubscribedCalendarHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteSubscribedCalendarHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = DeleteSubscribedCalendarHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteSubscribedCalendarShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteSubscribedCalendarRequest : Tea.TeaModel {
    public var calendarId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
    }
}

public class DeleteSubscribedCalendarResponseBody : Tea.TeaModel {
    public var result: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! Bool
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DeleteSubscribedCalendarResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSubscribedCalendarResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteSubscribedCalendarResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTodoTaskHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteTodoTaskHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = DeleteTodoTaskHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteTodoTaskShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteTodoTaskRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: DeleteTodoTaskRequest.TenantContext?

    public var operatorId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.operatorId != nil {
            map["operatorId"] = self.operatorId!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = DeleteTodoTaskRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("operatorId") && dict["operatorId"] != nil {
            self.operatorId = dict["operatorId"] as! String
        }
        if dict.keys.contains("taskId") && dict["taskId"] != nil {
            self.taskId = dict["taskId"] as! String
        }
    }
}

public class DeleteTodoTaskShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var operatorId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.operatorId != nil {
            map["operatorId"] = self.operatorId!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("operatorId") && dict["operatorId"] != nil {
            self.operatorId = dict["operatorId"] as! String
        }
        if dict.keys.contains("taskId") && dict["taskId"] != nil {
            self.taskId = dict["taskId"] as! String
        }
    }
}

public class DeleteTodoTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! Bool
        }
    }
}

public class DeleteTodoTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTodoTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteTodoTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteWorkspaceDocMembersHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteWorkspaceDocMembersHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = DeleteWorkspaceDocMembersHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteWorkspaceDocMembersShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteWorkspaceDocMembersRequest : Tea.TeaModel {
    public class Members : Tea.TeaModel {
        public var memberId: String?

        public var memberType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.memberId != nil {
                map["MemberId"] = self.memberId!
            }
            if self.memberType != nil {
                map["MemberType"] = self.memberType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MemberId") && dict["MemberId"] != nil {
                self.memberId = dict["MemberId"] as! String
            }
            if dict.keys.contains("MemberType") && dict["MemberType"] != nil {
                self.memberType = dict["MemberType"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var members: [DeleteWorkspaceDocMembersRequest.Members]?

    public var nodeId: String?

    public var tenantContext: DeleteWorkspaceDocMembersRequest.TenantContext?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.members != nil {
            var tmp : [Any] = []
            for k in self.members! {
                tmp.append(k.toMap())
            }
            map["Members"] = tmp
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") && dict["Members"] != nil {
            var tmp : [DeleteWorkspaceDocMembersRequest.Members] = []
            for v in dict["Members"] as! [Any] {
                var model = DeleteWorkspaceDocMembersRequest.Members()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.members = tmp
        }
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = DeleteWorkspaceDocMembersRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class DeleteWorkspaceDocMembersShrinkRequest : Tea.TeaModel {
    public var membersShrink: String?

    public var nodeId: String?

    public var tenantContextShrink: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.membersShrink != nil {
            map["Members"] = self.membersShrink!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") && dict["Members"] != nil {
            self.membersShrink = dict["Members"] as! String
        }
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class DeleteWorkspaceDocMembersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DeleteWorkspaceDocMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteWorkspaceDocMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteWorkspaceDocMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteWorkspaceMembersHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: DeleteWorkspaceMembersHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = DeleteWorkspaceMembersHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class DeleteWorkspaceMembersShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class DeleteWorkspaceMembersRequest : Tea.TeaModel {
    public class Members : Tea.TeaModel {
        public var memberId: String?

        public var memberType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.memberId != nil {
                map["MemberId"] = self.memberId!
            }
            if self.memberType != nil {
                map["MemberType"] = self.memberType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MemberId") && dict["MemberId"] != nil {
                self.memberId = dict["MemberId"] as! String
            }
            if dict.keys.contains("MemberType") && dict["MemberType"] != nil {
                self.memberType = dict["MemberType"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var members: [DeleteWorkspaceMembersRequest.Members]?

    public var tenantContext: DeleteWorkspaceMembersRequest.TenantContext?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.members != nil {
            var tmp : [Any] = []
            for k in self.members! {
                tmp.append(k.toMap())
            }
            map["Members"] = tmp
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") && dict["Members"] != nil {
            var tmp : [DeleteWorkspaceMembersRequest.Members] = []
            for v in dict["Members"] as! [Any] {
                var model = DeleteWorkspaceMembersRequest.Members()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.members = tmp
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = DeleteWorkspaceMembersRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class DeleteWorkspaceMembersShrinkRequest : Tea.TeaModel {
    public var membersShrink: String?

    public var tenantContextShrink: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.membersShrink != nil {
            map["Members"] = self.membersShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") && dict["Members"] != nil {
            self.membersShrink = dict["Members"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class DeleteWorkspaceMembersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DeleteWorkspaceMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteWorkspaceMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteWorkspaceMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExecuteBatchTaskHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ExecuteBatchTaskHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = ExecuteBatchTaskHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ExecuteBatchTaskShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ExecuteBatchTaskRequest : Tea.TeaModel {
    public var appType: String?

    public var outResult: String?

    public var remark: String?

    public var systemToken: String?

    public var taskInformationList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.outResult != nil {
            map["OutResult"] = self.outResult!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.taskInformationList != nil {
            map["TaskInformationList"] = self.taskInformationList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("OutResult") && dict["OutResult"] != nil {
            self.outResult = dict["OutResult"] as! String
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("TaskInformationList") && dict["TaskInformationList"] != nil {
            self.taskInformationList = dict["TaskInformationList"] as! String
        }
    }
}

public class ExecuteBatchTaskResponseBody : Tea.TeaModel {
    public var failNumber: Int32?

    public var requestId: String?

    public var successNumber: Int32?

    public var total: Int32?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failNumber != nil {
            map["failNumber"] = self.failNumber!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.successNumber != nil {
            map["successNumber"] = self.successNumber!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("failNumber") && dict["failNumber"] != nil {
            self.failNumber = dict["failNumber"] as! Int32
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("successNumber") && dict["successNumber"] != nil {
            self.successNumber = dict["successNumber"] as! Int32
        }
        if dict.keys.contains("total") && dict["total"] != nil {
            self.total = dict["total"] as! Int32
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class ExecuteBatchTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecuteBatchTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ExecuteBatchTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExecutePlatformTaskHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ExecutePlatformTaskHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = ExecutePlatformTaskHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ExecutePlatformTaskShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ExecutePlatformTaskRequest : Tea.TeaModel {
    public var appType: String?

    public var formDataJson: String?

    public var language: String?

    public var noExecuteExpressions: String?

    public var outResult: String?

    public var processInstanceId: String?

    public var remark: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.formDataJson != nil {
            map["FormDataJson"] = self.formDataJson!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.noExecuteExpressions != nil {
            map["NoExecuteExpressions"] = self.noExecuteExpressions!
        }
        if self.outResult != nil {
            map["OutResult"] = self.outResult!
        }
        if self.processInstanceId != nil {
            map["ProcessInstanceId"] = self.processInstanceId!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FormDataJson") && dict["FormDataJson"] != nil {
            self.formDataJson = dict["FormDataJson"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("NoExecuteExpressions") && dict["NoExecuteExpressions"] != nil {
            self.noExecuteExpressions = dict["NoExecuteExpressions"] as! String
        }
        if dict.keys.contains("OutResult") && dict["OutResult"] != nil {
            self.outResult = dict["OutResult"] as! String
        }
        if dict.keys.contains("ProcessInstanceId") && dict["ProcessInstanceId"] != nil {
            self.processInstanceId = dict["ProcessInstanceId"] as! String
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class ExecutePlatformTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class ExecutePlatformTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecutePlatformTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ExecutePlatformTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExecuteTaskHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ExecuteTaskHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = ExecuteTaskHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ExecuteTaskShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ExecuteTaskRequest : Tea.TeaModel {
    public var appType: String?

    public var digitalSignUrl: String?

    public var formDataJson: String?

    public var language: String?

    public var noExecuteExpressions: String?

    public var outResult: String?

    public var processInstanceId: String?

    public var remark: String?

    public var systemToken: String?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.digitalSignUrl != nil {
            map["DigitalSignUrl"] = self.digitalSignUrl!
        }
        if self.formDataJson != nil {
            map["FormDataJson"] = self.formDataJson!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.noExecuteExpressions != nil {
            map["NoExecuteExpressions"] = self.noExecuteExpressions!
        }
        if self.outResult != nil {
            map["OutResult"] = self.outResult!
        }
        if self.processInstanceId != nil {
            map["ProcessInstanceId"] = self.processInstanceId!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("DigitalSignUrl") && dict["DigitalSignUrl"] != nil {
            self.digitalSignUrl = dict["DigitalSignUrl"] as! String
        }
        if dict.keys.contains("FormDataJson") && dict["FormDataJson"] != nil {
            self.formDataJson = dict["FormDataJson"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("NoExecuteExpressions") && dict["NoExecuteExpressions"] != nil {
            self.noExecuteExpressions = dict["NoExecuteExpressions"] as! String
        }
        if dict.keys.contains("OutResult") && dict["OutResult"] != nil {
            self.outResult = dict["OutResult"] as! String
        }
        if dict.keys.contains("ProcessInstanceId") && dict["ProcessInstanceId"] != nil {
            self.processInstanceId = dict["ProcessInstanceId"] as! String
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! Int64
        }
    }
}

public class ExecuteTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class ExecuteTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecuteTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ExecuteTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetActivityListHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetActivityListHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetActivityListHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetActivityListShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetActivityListRequest : Tea.TeaModel {
    public var appType: String?

    public var language: String?

    public var processCode: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.processCode != nil {
            map["ProcessCode"] = self.processCode!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("ProcessCode") && dict["ProcessCode"] != nil {
            self.processCode = dict["ProcessCode"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class GetActivityListResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var activityId: String?

        public var activityName: String?

        public var activityNameInEnglish: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activityId != nil {
                map["ActivityId"] = self.activityId!
            }
            if self.activityName != nil {
                map["ActivityName"] = self.activityName!
            }
            if self.activityNameInEnglish != nil {
                map["ActivityNameInEnglish"] = self.activityNameInEnglish!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActivityId") && dict["ActivityId"] != nil {
                self.activityId = dict["ActivityId"] as! String
            }
            if dict.keys.contains("ActivityName") && dict["ActivityName"] != nil {
                self.activityName = dict["ActivityName"] as! String
            }
            if dict.keys.contains("ActivityNameInEnglish") && dict["ActivityNameInEnglish"] != nil {
                self.activityNameInEnglish = dict["ActivityNameInEnglish"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [GetActivityListResponseBody.Result]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            var tmp : [GetActivityListResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = GetActivityListResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetActivityListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetActivityListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetActivityListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAllSheetsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetAllSheetsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetAllSheetsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetAllSheetsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetAllSheetsRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: GetAllSheetsRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GetAllSheetsRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class GetAllSheetsShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class GetAllSheetsResponseBody : Tea.TeaModel {
    public class Value : Tea.TeaModel {
        public var id: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var requestId: String?

    public var value: [GetAllSheetsResponseBody.Value]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.value != nil {
            var tmp : [Any] = []
            for k in self.value! {
                tmp.append(k.toMap())
            }
            map["value"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("value") && dict["value"] != nil {
            var tmp : [GetAllSheetsResponseBody.Value] = []
            for v in dict["value"] as! [Any] {
                var model = GetAllSheetsResponseBody.Value()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.value = tmp
        }
    }
}

public class GetAllSheetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAllSheetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAllSheetsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCorpAccomplishmentTasksHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetCorpAccomplishmentTasksHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetCorpAccomplishmentTasksHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetCorpAccomplishmentTasksShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetCorpAccomplishmentTasksRequest : Tea.TeaModel {
    public var appTypes: String?

    public var corpId: String?

    public var createFromTimeGMT: Int64?

    public var createToTimeGMT: Int64?

    public var keyword: String?

    public var language: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var processCodes: String?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appTypes != nil {
            map["AppTypes"] = self.appTypes!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.createFromTimeGMT != nil {
            map["CreateFromTimeGMT"] = self.createFromTimeGMT!
        }
        if self.createToTimeGMT != nil {
            map["CreateToTimeGMT"] = self.createToTimeGMT!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.processCodes != nil {
            map["ProcessCodes"] = self.processCodes!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppTypes") && dict["AppTypes"] != nil {
            self.appTypes = dict["AppTypes"] as! String
        }
        if dict.keys.contains("CorpId") && dict["CorpId"] != nil {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("CreateFromTimeGMT") && dict["CreateFromTimeGMT"] != nil {
            self.createFromTimeGMT = dict["CreateFromTimeGMT"] as! Int64
        }
        if dict.keys.contains("CreateToTimeGMT") && dict["CreateToTimeGMT"] != nil {
            self.createToTimeGMT = dict["CreateToTimeGMT"] as! Int64
        }
        if dict.keys.contains("Keyword") && dict["Keyword"] != nil {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProcessCodes") && dict["ProcessCodes"] != nil {
            self.processCodes = dict["ProcessCodes"] as! String
        }
        if dict.keys.contains("Token") && dict["Token"] != nil {
            self.token = dict["Token"] as! String
        }
    }
}

public class GetCorpAccomplishmentTasksResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var activeTimeGMT: String?

        public var actualActionerId: String?

        public var appType: String?

        public var createTimeGMT: String?

        public var finishTimeGMT: String?

        public var originatorEmail: String?

        public var originatorId: String?

        public var originatorName: String?

        public var originatorNameInEnglish: String?

        public var originatorNickName: String?

        public var originatorNickNameInEnglish: String?

        public var originatorPhoto: String?

        public var outResult: String?

        public var outResultName: String?

        public var processInstanceId: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activeTimeGMT != nil {
                map["ActiveTimeGMT"] = self.activeTimeGMT!
            }
            if self.actualActionerId != nil {
                map["ActualActionerId"] = self.actualActionerId!
            }
            if self.appType != nil {
                map["AppType"] = self.appType!
            }
            if self.createTimeGMT != nil {
                map["CreateTimeGMT"] = self.createTimeGMT!
            }
            if self.finishTimeGMT != nil {
                map["FinishTimeGMT"] = self.finishTimeGMT!
            }
            if self.originatorEmail != nil {
                map["OriginatorEmail"] = self.originatorEmail!
            }
            if self.originatorId != nil {
                map["OriginatorId"] = self.originatorId!
            }
            if self.originatorName != nil {
                map["OriginatorName"] = self.originatorName!
            }
            if self.originatorNameInEnglish != nil {
                map["OriginatorNameInEnglish"] = self.originatorNameInEnglish!
            }
            if self.originatorNickName != nil {
                map["OriginatorNickName"] = self.originatorNickName!
            }
            if self.originatorNickNameInEnglish != nil {
                map["OriginatorNickNameInEnglish"] = self.originatorNickNameInEnglish!
            }
            if self.originatorPhoto != nil {
                map["OriginatorPhoto"] = self.originatorPhoto!
            }
            if self.outResult != nil {
                map["OutResult"] = self.outResult!
            }
            if self.outResultName != nil {
                map["OutResultName"] = self.outResultName!
            }
            if self.processInstanceId != nil {
                map["ProcessInstanceId"] = self.processInstanceId!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActiveTimeGMT") && dict["ActiveTimeGMT"] != nil {
                self.activeTimeGMT = dict["ActiveTimeGMT"] as! String
            }
            if dict.keys.contains("ActualActionerId") && dict["ActualActionerId"] != nil {
                self.actualActionerId = dict["ActualActionerId"] as! String
            }
            if dict.keys.contains("AppType") && dict["AppType"] != nil {
                self.appType = dict["AppType"] as! String
            }
            if dict.keys.contains("CreateTimeGMT") && dict["CreateTimeGMT"] != nil {
                self.createTimeGMT = dict["CreateTimeGMT"] as! String
            }
            if dict.keys.contains("FinishTimeGMT") && dict["FinishTimeGMT"] != nil {
                self.finishTimeGMT = dict["FinishTimeGMT"] as! String
            }
            if dict.keys.contains("OriginatorEmail") && dict["OriginatorEmail"] != nil {
                self.originatorEmail = dict["OriginatorEmail"] as! String
            }
            if dict.keys.contains("OriginatorId") && dict["OriginatorId"] != nil {
                self.originatorId = dict["OriginatorId"] as! String
            }
            if dict.keys.contains("OriginatorName") && dict["OriginatorName"] != nil {
                self.originatorName = dict["OriginatorName"] as! String
            }
            if dict.keys.contains("OriginatorNameInEnglish") && dict["OriginatorNameInEnglish"] != nil {
                self.originatorNameInEnglish = dict["OriginatorNameInEnglish"] as! String
            }
            if dict.keys.contains("OriginatorNickName") && dict["OriginatorNickName"] != nil {
                self.originatorNickName = dict["OriginatorNickName"] as! String
            }
            if dict.keys.contains("OriginatorNickNameInEnglish") && dict["OriginatorNickNameInEnglish"] != nil {
                self.originatorNickNameInEnglish = dict["OriginatorNickNameInEnglish"] as! String
            }
            if dict.keys.contains("OriginatorPhoto") && dict["OriginatorPhoto"] != nil {
                self.originatorPhoto = dict["OriginatorPhoto"] as! String
            }
            if dict.keys.contains("OutResult") && dict["OutResult"] != nil {
                self.outResult = dict["OutResult"] as! String
            }
            if dict.keys.contains("OutResultName") && dict["OutResultName"] != nil {
                self.outResultName = dict["OutResultName"] as! String
            }
            if dict.keys.contains("ProcessInstanceId") && dict["ProcessInstanceId"] != nil {
                self.processInstanceId = dict["ProcessInstanceId"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var data: [GetCorpAccomplishmentTasksResponseBody.Data]?

    public var pageNumber: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [GetCorpAccomplishmentTasksResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = GetCorpAccomplishmentTasksResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetCorpAccomplishmentTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCorpAccomplishmentTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetCorpAccomplishmentTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCorpTasksHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetCorpTasksHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetCorpTasksHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetCorpTasksShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetCorpTasksRequest : Tea.TeaModel {
    public var appTypes: String?

    public var corpId: String?

    public var createFromTimeGMT: Int64?

    public var createToTimeGMT: Int64?

    public var keyword: String?

    public var language: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var processCodes: String?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appTypes != nil {
            map["AppTypes"] = self.appTypes!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.createFromTimeGMT != nil {
            map["CreateFromTimeGMT"] = self.createFromTimeGMT!
        }
        if self.createToTimeGMT != nil {
            map["CreateToTimeGMT"] = self.createToTimeGMT!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.processCodes != nil {
            map["ProcessCodes"] = self.processCodes!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppTypes") && dict["AppTypes"] != nil {
            self.appTypes = dict["AppTypes"] as! String
        }
        if dict.keys.contains("CorpId") && dict["CorpId"] != nil {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("CreateFromTimeGMT") && dict["CreateFromTimeGMT"] != nil {
            self.createFromTimeGMT = dict["CreateFromTimeGMT"] as! Int64
        }
        if dict.keys.contains("CreateToTimeGMT") && dict["CreateToTimeGMT"] != nil {
            self.createToTimeGMT = dict["CreateToTimeGMT"] as! Int64
        }
        if dict.keys.contains("Keyword") && dict["Keyword"] != nil {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProcessCodes") && dict["ProcessCodes"] != nil {
            self.processCodes = dict["ProcessCodes"] as! String
        }
        if dict.keys.contains("Token") && dict["Token"] != nil {
            self.token = dict["Token"] as! String
        }
    }
}

public class GetCorpTasksResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var activeTimeGMT: String?

        public var actualActionerId: String?

        public var appType: String?

        public var createTimeGMT: String?

        public var finishTimeGMT: String?

        public var originatorEmail: String?

        public var originatorId: String?

        public var originatorName: String?

        public var originatorNameInEnglish: String?

        public var originatorNickName: String?

        public var originatorNickNameEn: String?

        public var originatorNickNameInEnglish: String?

        public var originatorPhoto: String?

        public var outResult: String?

        public var outResultName: String?

        public var processInstanceId: String?

        public var status: String?

        public var taskId: String?

        public var taskType: String?

        public var title: String?

        public var titleInEnglish: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activeTimeGMT != nil {
                map["ActiveTimeGMT"] = self.activeTimeGMT!
            }
            if self.actualActionerId != nil {
                map["ActualActionerId"] = self.actualActionerId!
            }
            if self.appType != nil {
                map["AppType"] = self.appType!
            }
            if self.createTimeGMT != nil {
                map["CreateTimeGMT"] = self.createTimeGMT!
            }
            if self.finishTimeGMT != nil {
                map["FinishTimeGMT"] = self.finishTimeGMT!
            }
            if self.originatorEmail != nil {
                map["OriginatorEmail"] = self.originatorEmail!
            }
            if self.originatorId != nil {
                map["OriginatorId"] = self.originatorId!
            }
            if self.originatorName != nil {
                map["OriginatorName"] = self.originatorName!
            }
            if self.originatorNameInEnglish != nil {
                map["OriginatorNameInEnglish"] = self.originatorNameInEnglish!
            }
            if self.originatorNickName != nil {
                map["OriginatorNickName"] = self.originatorNickName!
            }
            if self.originatorNickNameEn != nil {
                map["OriginatorNickNameEn"] = self.originatorNickNameEn!
            }
            if self.originatorNickNameInEnglish != nil {
                map["OriginatorNickNameInEnglish"] = self.originatorNickNameInEnglish!
            }
            if self.originatorPhoto != nil {
                map["OriginatorPhoto"] = self.originatorPhoto!
            }
            if self.outResult != nil {
                map["OutResult"] = self.outResult!
            }
            if self.outResultName != nil {
                map["OutResultName"] = self.outResultName!
            }
            if self.processInstanceId != nil {
                map["ProcessInstanceId"] = self.processInstanceId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.titleInEnglish != nil {
                map["TitleInEnglish"] = self.titleInEnglish!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActiveTimeGMT") && dict["ActiveTimeGMT"] != nil {
                self.activeTimeGMT = dict["ActiveTimeGMT"] as! String
            }
            if dict.keys.contains("ActualActionerId") && dict["ActualActionerId"] != nil {
                self.actualActionerId = dict["ActualActionerId"] as! String
            }
            if dict.keys.contains("AppType") && dict["AppType"] != nil {
                self.appType = dict["AppType"] as! String
            }
            if dict.keys.contains("CreateTimeGMT") && dict["CreateTimeGMT"] != nil {
                self.createTimeGMT = dict["CreateTimeGMT"] as! String
            }
            if dict.keys.contains("FinishTimeGMT") && dict["FinishTimeGMT"] != nil {
                self.finishTimeGMT = dict["FinishTimeGMT"] as! String
            }
            if dict.keys.contains("OriginatorEmail") && dict["OriginatorEmail"] != nil {
                self.originatorEmail = dict["OriginatorEmail"] as! String
            }
            if dict.keys.contains("OriginatorId") && dict["OriginatorId"] != nil {
                self.originatorId = dict["OriginatorId"] as! String
            }
            if dict.keys.contains("OriginatorName") && dict["OriginatorName"] != nil {
                self.originatorName = dict["OriginatorName"] as! String
            }
            if dict.keys.contains("OriginatorNameInEnglish") && dict["OriginatorNameInEnglish"] != nil {
                self.originatorNameInEnglish = dict["OriginatorNameInEnglish"] as! String
            }
            if dict.keys.contains("OriginatorNickName") && dict["OriginatorNickName"] != nil {
                self.originatorNickName = dict["OriginatorNickName"] as! String
            }
            if dict.keys.contains("OriginatorNickNameEn") && dict["OriginatorNickNameEn"] != nil {
                self.originatorNickNameEn = dict["OriginatorNickNameEn"] as! String
            }
            if dict.keys.contains("OriginatorNickNameInEnglish") && dict["OriginatorNickNameInEnglish"] != nil {
                self.originatorNickNameInEnglish = dict["OriginatorNickNameInEnglish"] as! String
            }
            if dict.keys.contains("OriginatorPhoto") && dict["OriginatorPhoto"] != nil {
                self.originatorPhoto = dict["OriginatorPhoto"] as! String
            }
            if dict.keys.contains("OutResult") && dict["OutResult"] != nil {
                self.outResult = dict["OutResult"] as! String
            }
            if dict.keys.contains("OutResultName") && dict["OutResultName"] != nil {
                self.outResultName = dict["OutResultName"] as! String
            }
            if dict.keys.contains("ProcessInstanceId") && dict["ProcessInstanceId"] != nil {
                self.processInstanceId = dict["ProcessInstanceId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
                self.taskType = dict["TaskType"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("TitleInEnglish") && dict["TitleInEnglish"] != nil {
                self.titleInEnglish = dict["TitleInEnglish"] as! String
            }
        }
    }
    public var data: [GetCorpTasksResponseBody.Data]?

    public var pageNumber: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [GetCorpTasksResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = GetCorpTasksResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetCorpTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCorpTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetCorpTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEventHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetEventHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetEventHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetEventShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetEventRequest : Tea.TeaModel {
    public var calendarId: String?

    public var eventId: String?

    public var maxAttendees: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.maxAttendees != nil {
            map["MaxAttendees"] = self.maxAttendees!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("MaxAttendees") && dict["MaxAttendees"] != nil {
            self.maxAttendees = dict["MaxAttendees"] as! Int64
        }
    }
}

public class GetEventResponseBody : Tea.TeaModel {
    public class Attendees : Tea.TeaModel {
        public var displayName: String?

        public var id: String?

        public var isOptional: Bool?

        public var responseStatus: String?

        public var self_: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.isOptional != nil {
                map["IsOptional"] = self.isOptional!
            }
            if self.responseStatus != nil {
                map["ResponseStatus"] = self.responseStatus!
            }
            if self.self_ != nil {
                map["Self"] = self.self_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("IsOptional") && dict["IsOptional"] != nil {
                self.isOptional = dict["IsOptional"] as! Bool
            }
            if dict.keys.contains("ResponseStatus") && dict["ResponseStatus"] != nil {
                self.responseStatus = dict["ResponseStatus"] as! String
            }
            if dict.keys.contains("Self") && dict["Self"] != nil {
                self.self_ = dict["Self"] as! Bool
            }
        }
    }
    public class Categories : Tea.TeaModel {
        public var displayName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
        }
    }
    public class End : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["Date"] = self.date!
            }
            if self.dateTime != nil {
                map["DateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["TimeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Date") && dict["Date"] != nil {
                self.date = dict["Date"] as! String
            }
            if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                self.dateTime = dict["DateTime"] as! String
            }
            if dict.keys.contains("TimeZone") && dict["TimeZone"] != nil {
                self.timeZone = dict["TimeZone"] as! String
            }
        }
    }
    public class ExtendedProperties : Tea.TeaModel {
        public class SharedProperties : Tea.TeaModel {
            public var belongCorpId: String?

            public var sourceOpenCid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.belongCorpId != nil {
                    map["BelongCorpId"] = self.belongCorpId!
                }
                if self.sourceOpenCid != nil {
                    map["SourceOpenCid"] = self.sourceOpenCid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BelongCorpId") && dict["BelongCorpId"] != nil {
                    self.belongCorpId = dict["BelongCorpId"] as! String
                }
                if dict.keys.contains("SourceOpenCid") && dict["SourceOpenCid"] != nil {
                    self.sourceOpenCid = dict["SourceOpenCid"] as! String
                }
            }
        }
        public var sharedProperties: GetEventResponseBody.ExtendedProperties.SharedProperties?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.sharedProperties?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sharedProperties != nil {
                map["SharedProperties"] = self.sharedProperties?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SharedProperties") && dict["SharedProperties"] != nil {
                var model = GetEventResponseBody.ExtendedProperties.SharedProperties()
                model.fromMap(dict["SharedProperties"] as! [String: Any])
                self.sharedProperties = model
            }
        }
    }
    public class Location : Tea.TeaModel {
        public var displayName: String?

        public var meetingRooms: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.meetingRooms != nil {
                map["MeetingRooms"] = self.meetingRooms!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("MeetingRooms") && dict["MeetingRooms"] != nil {
                self.meetingRooms = dict["MeetingRooms"] as! [String]
            }
        }
    }
    public class MeetingRooms : Tea.TeaModel {
        public var displayName: String?

        public var responseStatus: String?

        public var roomId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.responseStatus != nil {
                map["ResponseStatus"] = self.responseStatus!
            }
            if self.roomId != nil {
                map["RoomId"] = self.roomId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("ResponseStatus") && dict["ResponseStatus"] != nil {
                self.responseStatus = dict["ResponseStatus"] as! String
            }
            if dict.keys.contains("RoomId") && dict["RoomId"] != nil {
                self.roomId = dict["RoomId"] as! String
            }
        }
    }
    public class OnlineMeetingInfo : Tea.TeaModel {
        public var conferenceId: String?

        public var extraInfo: [String: Any]?

        public var type: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.conferenceId != nil {
                map["ConferenceId"] = self.conferenceId!
            }
            if self.extraInfo != nil {
                map["ExtraInfo"] = self.extraInfo!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConferenceId") && dict["ConferenceId"] != nil {
                self.conferenceId = dict["ConferenceId"] as! String
            }
            if dict.keys.contains("ExtraInfo") && dict["ExtraInfo"] != nil {
                self.extraInfo = dict["ExtraInfo"] as! [String: Any]
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
        }
    }
    public class Organizer : Tea.TeaModel {
        public var displayName: String?

        public var id: String?

        public var responseStatus: String?

        public var self_: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.responseStatus != nil {
                map["ResponseStatus"] = self.responseStatus!
            }
            if self.self_ != nil {
                map["Self"] = self.self_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("ResponseStatus") && dict["ResponseStatus"] != nil {
                self.responseStatus = dict["ResponseStatus"] as! String
            }
            if dict.keys.contains("Self") && dict["Self"] != nil {
                self.self_ = dict["Self"] as! Bool
            }
        }
    }
    public class OriginStart : Tea.TeaModel {
        public var dateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dateTime != nil {
                map["DateTime"] = self.dateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                self.dateTime = dict["DateTime"] as! String
            }
        }
    }
    public class Recurrence : Tea.TeaModel {
        public class Pattern : Tea.TeaModel {
            public var dayOfMonth: Int32?

            public var daysOfWeek: String?

            public var index: String?

            public var interval: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dayOfMonth != nil {
                    map["DayOfMonth"] = self.dayOfMonth!
                }
                if self.daysOfWeek != nil {
                    map["DaysOfWeek"] = self.daysOfWeek!
                }
                if self.index != nil {
                    map["Index"] = self.index!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DayOfMonth") && dict["DayOfMonth"] != nil {
                    self.dayOfMonth = dict["DayOfMonth"] as! Int32
                }
                if dict.keys.contains("DaysOfWeek") && dict["DaysOfWeek"] != nil {
                    self.daysOfWeek = dict["DaysOfWeek"] as! String
                }
                if dict.keys.contains("Index") && dict["Index"] != nil {
                    self.index = dict["Index"] as! String
                }
                if dict.keys.contains("Interval") && dict["Interval"] != nil {
                    self.interval = dict["Interval"] as! Int32
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Range : Tea.TeaModel {
            public var endDate: String?

            public var numberOfOccurrences: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endDate != nil {
                    map["EndDate"] = self.endDate!
                }
                if self.numberOfOccurrences != nil {
                    map["NumberOfOccurrences"] = self.numberOfOccurrences!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndDate") && dict["EndDate"] != nil {
                    self.endDate = dict["EndDate"] as! String
                }
                if dict.keys.contains("NumberOfOccurrences") && dict["NumberOfOccurrences"] != nil {
                    self.numberOfOccurrences = dict["NumberOfOccurrences"] as! Int32
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var pattern: GetEventResponseBody.Recurrence.Pattern?

        public var range: GetEventResponseBody.Recurrence.Range?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pattern?.validate()
            try self.range?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pattern != nil {
                map["Pattern"] = self.pattern?.toMap()
            }
            if self.range != nil {
                map["Range"] = self.range?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Pattern") && dict["Pattern"] != nil {
                var model = GetEventResponseBody.Recurrence.Pattern()
                model.fromMap(dict["Pattern"] as! [String: Any])
                self.pattern = model
            }
            if dict.keys.contains("Range") && dict["Range"] != nil {
                var model = GetEventResponseBody.Recurrence.Range()
                model.fromMap(dict["Range"] as! [String: Any])
                self.range = model
            }
        }
    }
    public class Reminders : Tea.TeaModel {
        public var method: String?

        public var minutes: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.method != nil {
                map["Method"] = self.method!
            }
            if self.minutes != nil {
                map["Minutes"] = self.minutes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Method") && dict["Method"] != nil {
                self.method = dict["Method"] as! String
            }
            if dict.keys.contains("Minutes") && dict["Minutes"] != nil {
                self.minutes = dict["Minutes"] as! String
            }
        }
    }
    public class RichTextDescription : Tea.TeaModel {
        public var text: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.text != nil {
                map["Text"] = self.text!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Text") && dict["Text"] != nil {
                self.text = dict["Text"] as! String
            }
        }
    }
    public class Start : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["Date"] = self.date!
            }
            if self.dateTime != nil {
                map["DateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["TimeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Date") && dict["Date"] != nil {
                self.date = dict["Date"] as! String
            }
            if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                self.dateTime = dict["DateTime"] as! String
            }
            if dict.keys.contains("TimeZone") && dict["TimeZone"] != nil {
                self.timeZone = dict["TimeZone"] as! String
            }
        }
    }
    public var attendees: [GetEventResponseBody.Attendees]?

    public var categories: [GetEventResponseBody.Categories]?

    public var createTime: String?

    public var description_: String?

    public var end: GetEventResponseBody.End?

    public var extendedProperties: GetEventResponseBody.ExtendedProperties?

    public var id: String?

    public var isAllDay: Bool?

    public var location: GetEventResponseBody.Location?

    public var meetingRooms: [GetEventResponseBody.MeetingRooms]?

    public var onlineMeetingInfo: GetEventResponseBody.OnlineMeetingInfo?

    public var organizer: GetEventResponseBody.Organizer?

    public var originStart: GetEventResponseBody.OriginStart?

    public var recurrence: GetEventResponseBody.Recurrence?

    public var reminders: [GetEventResponseBody.Reminders]?

    public var requestId: String?

    public var richTextDescription: GetEventResponseBody.RichTextDescription?

    public var seriesMasterId: String?

    public var start: GetEventResponseBody.Start?

    public var status: String?

    public var summary: String?

    public var updateTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.end?.validate()
        try self.extendedProperties?.validate()
        try self.location?.validate()
        try self.onlineMeetingInfo?.validate()
        try self.organizer?.validate()
        try self.originStart?.validate()
        try self.recurrence?.validate()
        try self.richTextDescription?.validate()
        try self.start?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendees != nil {
            var tmp : [Any] = []
            for k in self.attendees! {
                tmp.append(k.toMap())
            }
            map["attendees"] = tmp
        }
        if self.categories != nil {
            var tmp : [Any] = []
            for k in self.categories! {
                tmp.append(k.toMap())
            }
            map["categories"] = tmp
        }
        if self.createTime != nil {
            map["createTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.end != nil {
            map["end"] = self.end?.toMap()
        }
        if self.extendedProperties != nil {
            map["extendedProperties"] = self.extendedProperties?.toMap()
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.isAllDay != nil {
            map["isAllDay"] = self.isAllDay!
        }
        if self.location != nil {
            map["location"] = self.location?.toMap()
        }
        if self.meetingRooms != nil {
            var tmp : [Any] = []
            for k in self.meetingRooms! {
                tmp.append(k.toMap())
            }
            map["meetingRooms"] = tmp
        }
        if self.onlineMeetingInfo != nil {
            map["onlineMeetingInfo"] = self.onlineMeetingInfo?.toMap()
        }
        if self.organizer != nil {
            map["organizer"] = self.organizer?.toMap()
        }
        if self.originStart != nil {
            map["originStart"] = self.originStart?.toMap()
        }
        if self.recurrence != nil {
            map["recurrence"] = self.recurrence?.toMap()
        }
        if self.reminders != nil {
            var tmp : [Any] = []
            for k in self.reminders! {
                tmp.append(k.toMap())
            }
            map["reminders"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.richTextDescription != nil {
            map["richTextDescription"] = self.richTextDescription?.toMap()
        }
        if self.seriesMasterId != nil {
            map["seriesMasterId"] = self.seriesMasterId!
        }
        if self.start != nil {
            map["start"] = self.start?.toMap()
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.summary != nil {
            map["summary"] = self.summary!
        }
        if self.updateTime != nil {
            map["updateTime"] = self.updateTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("attendees") && dict["attendees"] != nil {
            var tmp : [GetEventResponseBody.Attendees] = []
            for v in dict["attendees"] as! [Any] {
                var model = GetEventResponseBody.Attendees()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.attendees = tmp
        }
        if dict.keys.contains("categories") && dict["categories"] != nil {
            var tmp : [GetEventResponseBody.Categories] = []
            for v in dict["categories"] as! [Any] {
                var model = GetEventResponseBody.Categories()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.categories = tmp
        }
        if dict.keys.contains("createTime") && dict["createTime"] != nil {
            self.createTime = dict["createTime"] as! String
        }
        if dict.keys.contains("description") && dict["description"] != nil {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("end") && dict["end"] != nil {
            var model = GetEventResponseBody.End()
            model.fromMap(dict["end"] as! [String: Any])
            self.end = model
        }
        if dict.keys.contains("extendedProperties") && dict["extendedProperties"] != nil {
            var model = GetEventResponseBody.ExtendedProperties()
            model.fromMap(dict["extendedProperties"] as! [String: Any])
            self.extendedProperties = model
        }
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("isAllDay") && dict["isAllDay"] != nil {
            self.isAllDay = dict["isAllDay"] as! Bool
        }
        if dict.keys.contains("location") && dict["location"] != nil {
            var model = GetEventResponseBody.Location()
            model.fromMap(dict["location"] as! [String: Any])
            self.location = model
        }
        if dict.keys.contains("meetingRooms") && dict["meetingRooms"] != nil {
            var tmp : [GetEventResponseBody.MeetingRooms] = []
            for v in dict["meetingRooms"] as! [Any] {
                var model = GetEventResponseBody.MeetingRooms()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.meetingRooms = tmp
        }
        if dict.keys.contains("onlineMeetingInfo") && dict["onlineMeetingInfo"] != nil {
            var model = GetEventResponseBody.OnlineMeetingInfo()
            model.fromMap(dict["onlineMeetingInfo"] as! [String: Any])
            self.onlineMeetingInfo = model
        }
        if dict.keys.contains("organizer") && dict["organizer"] != nil {
            var model = GetEventResponseBody.Organizer()
            model.fromMap(dict["organizer"] as! [String: Any])
            self.organizer = model
        }
        if dict.keys.contains("originStart") && dict["originStart"] != nil {
            var model = GetEventResponseBody.OriginStart()
            model.fromMap(dict["originStart"] as! [String: Any])
            self.originStart = model
        }
        if dict.keys.contains("recurrence") && dict["recurrence"] != nil {
            var model = GetEventResponseBody.Recurrence()
            model.fromMap(dict["recurrence"] as! [String: Any])
            self.recurrence = model
        }
        if dict.keys.contains("reminders") && dict["reminders"] != nil {
            var tmp : [GetEventResponseBody.Reminders] = []
            for v in dict["reminders"] as! [Any] {
                var model = GetEventResponseBody.Reminders()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.reminders = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("richTextDescription") && dict["richTextDescription"] != nil {
            var model = GetEventResponseBody.RichTextDescription()
            model.fromMap(dict["richTextDescription"] as! [String: Any])
            self.richTextDescription = model
        }
        if dict.keys.contains("seriesMasterId") && dict["seriesMasterId"] != nil {
            self.seriesMasterId = dict["seriesMasterId"] as! String
        }
        if dict.keys.contains("start") && dict["start"] != nil {
            var model = GetEventResponseBody.Start()
            model.fromMap(dict["start"] as! [String: Any])
            self.start = model
        }
        if dict.keys.contains("status") && dict["status"] != nil {
            self.status = dict["status"] as! String
        }
        if dict.keys.contains("summary") && dict["summary"] != nil {
            self.summary = dict["summary"] as! String
        }
        if dict.keys.contains("updateTime") && dict["updateTime"] != nil {
            self.updateTime = dict["updateTime"] as! String
        }
    }
}

public class GetEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFieldDefByUuidHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetFieldDefByUuidHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetFieldDefByUuidHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetFieldDefByUuidShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetFieldDefByUuidRequest : Tea.TeaModel {
    public var appType: String?

    public var formUuid: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class GetFieldDefByUuidResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var behavior: String?

        public var children: String?

        public var componentName: String?

        public var fieldId: String?

        public var label: Any?

        public var props: Any?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.behavior != nil {
                map["Behavior"] = self.behavior!
            }
            if self.children != nil {
                map["Children"] = self.children!
            }
            if self.componentName != nil {
                map["ComponentName"] = self.componentName!
            }
            if self.fieldId != nil {
                map["FieldId"] = self.fieldId!
            }
            if self.label != nil {
                map["Label"] = self.label!
            }
            if self.props != nil {
                map["Props"] = self.props!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Behavior") && dict["Behavior"] != nil {
                self.behavior = dict["Behavior"] as! String
            }
            if dict.keys.contains("Children") && dict["Children"] != nil {
                self.children = dict["Children"] as! String
            }
            if dict.keys.contains("ComponentName") && dict["ComponentName"] != nil {
                self.componentName = dict["ComponentName"] as! String
            }
            if dict.keys.contains("FieldId") && dict["FieldId"] != nil {
                self.fieldId = dict["FieldId"] as! String
            }
            if dict.keys.contains("Label") && dict["Label"] != nil {
                self.label = dict["Label"] as! Any
            }
            if dict.keys.contains("Props") && dict["Props"] != nil {
                self.props = dict["Props"] as! Any
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var result: [GetFieldDefByUuidResponseBody.Result]?

    public var success: Bool?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            var tmp : [GetFieldDefByUuidResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = GetFieldDefByUuidResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetFieldDefByUuidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFieldDefByUuidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetFieldDefByUuidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFormComponentDefinitionListHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetFormComponentDefinitionListHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetFormComponentDefinitionListHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetFormComponentDefinitionListShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetFormComponentDefinitionListRequest : Tea.TeaModel {
    public var appType: String?

    public var formUuid: String?

    public var language: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class GetFormComponentDefinitionListResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var componentName: String?

        public var fieldId: String?

        public var label: String?

        public var parentId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.componentName != nil {
                map["ComponentName"] = self.componentName!
            }
            if self.fieldId != nil {
                map["FieldId"] = self.fieldId!
            }
            if self.label != nil {
                map["Label"] = self.label!
            }
            if self.parentId != nil {
                map["ParentId"] = self.parentId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ComponentName") && dict["ComponentName"] != nil {
                self.componentName = dict["ComponentName"] as! String
            }
            if dict.keys.contains("FieldId") && dict["FieldId"] != nil {
                self.fieldId = dict["FieldId"] as! String
            }
            if dict.keys.contains("Label") && dict["Label"] != nil {
                self.label = dict["Label"] as! String
            }
            if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
                self.parentId = dict["ParentId"] as! String
            }
        }
    }
    public var result: [GetFormComponentDefinitionListResponseBody.Result]?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Result") && dict["Result"] != nil {
            var tmp : [GetFormComponentDefinitionListResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = GetFormComponentDefinitionListResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetFormComponentDefinitionListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFormComponentDefinitionListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetFormComponentDefinitionListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFormDataByIDHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetFormDataByIDHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetFormDataByIDHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetFormDataByIDShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetFormDataByIDRequest : Tea.TeaModel {
    public var appType: String?

    public var id: String?

    public var language: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class GetFormDataByIDResponseBody : Tea.TeaModel {
    public class Originator : Tea.TeaModel {
        public class Name : Tea.TeaModel {
            public var nameInChinese: String?

            public var nameInEnglish: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.nameInChinese != nil {
                    map["NameInChinese"] = self.nameInChinese!
                }
                if self.nameInEnglish != nil {
                    map["NameInEnglish"] = self.nameInEnglish!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NameInChinese") && dict["NameInChinese"] != nil {
                    self.nameInChinese = dict["NameInChinese"] as! String
                }
                if dict.keys.contains("NameInEnglish") && dict["NameInEnglish"] != nil {
                    self.nameInEnglish = dict["NameInEnglish"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var departmentName: String?

        public var email: String?

        public var name: GetFormDataByIDResponseBody.Originator.Name?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.name?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.departmentName != nil {
                map["DepartmentName"] = self.departmentName!
            }
            if self.email != nil {
                map["Email"] = self.email!
            }
            if self.name != nil {
                map["Name"] = self.name?.toMap()
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DepartmentName") && dict["DepartmentName"] != nil {
                self.departmentName = dict["DepartmentName"] as! String
            }
            if dict.keys.contains("Email") && dict["Email"] != nil {
                self.email = dict["Email"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                var model = GetFormDataByIDResponseBody.Originator.Name()
                model.fromMap(dict["Name"] as! [String: Any])
                self.name = model
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var formData: [String: Any]?

    public var formInstId: String?

    public var modifiedTimeGMT: String?

    public var originator: GetFormDataByIDResponseBody.Originator?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.originator?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.formData != nil {
            map["formData"] = self.formData!
        }
        if self.formInstId != nil {
            map["formInstId"] = self.formInstId!
        }
        if self.modifiedTimeGMT != nil {
            map["modifiedTimeGMT"] = self.modifiedTimeGMT!
        }
        if self.originator != nil {
            map["originator"] = self.originator?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("formData") && dict["formData"] != nil {
            self.formData = dict["formData"] as! [String: Any]
        }
        if dict.keys.contains("formInstId") && dict["formInstId"] != nil {
            self.formInstId = dict["formInstId"] as! String
        }
        if dict.keys.contains("modifiedTimeGMT") && dict["modifiedTimeGMT"] != nil {
            self.modifiedTimeGMT = dict["modifiedTimeGMT"] as! String
        }
        if dict.keys.contains("originator") && dict["originator"] != nil {
            var model = GetFormDataByIDResponseBody.Originator()
            model.fromMap(dict["originator"] as! [String: Any])
            self.originator = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetFormDataByIDResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFormDataByIDResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetFormDataByIDResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFormListInAppHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetFormListInAppHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetFormListInAppHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetFormListInAppShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetFormListInAppRequest : Tea.TeaModel {
    public var appType: String?

    public var formTypes: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.formTypes != nil {
            map["FormTypes"] = self.formTypes!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FormTypes") && dict["FormTypes"] != nil {
            self.formTypes = dict["FormTypes"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class GetFormListInAppResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Title : Tea.TeaModel {
            public var enUS: String?

            public var zhCN: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.enUS != nil {
                    map["EnUS"] = self.enUS!
                }
                if self.zhCN != nil {
                    map["ZhCN"] = self.zhCN!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EnUS") && dict["EnUS"] != nil {
                    self.enUS = dict["EnUS"] as! String
                }
                if dict.keys.contains("ZhCN") && dict["ZhCN"] != nil {
                    self.zhCN = dict["ZhCN"] as! String
                }
            }
        }
        public var creator: String?

        public var formType: String?

        public var formUuid: String?

        public var gmtCreate: String?

        public var title: GetFormListInAppResponseBody.Data.Title?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.title?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.formType != nil {
                map["FormType"] = self.formType!
            }
            if self.formUuid != nil {
                map["FormUuid"] = self.formUuid!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.title != nil {
                map["Title"] = self.title?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Creator") && dict["Creator"] != nil {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("FormType") && dict["FormType"] != nil {
                self.formType = dict["FormType"] as! String
            }
            if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
                self.formUuid = dict["FormUuid"] as! String
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                var model = GetFormListInAppResponseBody.Data.Title()
                model.fromMap(dict["Title"] as! [String: Any])
                self.title = model
            }
        }
    }
    public var currentPage: Int32?

    public var data: [GetFormListInAppResponseBody.Data]?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("currentPage") && dict["currentPage"] != nil {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [GetFormListInAppResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = GetFormListInAppResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int32
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetFormListInAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFormListInAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetFormListInAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInstanceByIdHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetInstanceByIdHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetInstanceByIdHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetInstanceByIdShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetInstanceByIdRequest : Tea.TeaModel {
    public var appType: String?

    public var id: String?

    public var language: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class GetInstanceByIdResponseBody : Tea.TeaModel {
    public class ActionExecutor : Tea.TeaModel {
        public class Name : Tea.TeaModel {
            public var nameInChinese: String?

            public var nameInEnglish: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.nameInChinese != nil {
                    map["NameInChinese"] = self.nameInChinese!
                }
                if self.nameInEnglish != nil {
                    map["NameInEnglish"] = self.nameInEnglish!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NameInChinese") && dict["NameInChinese"] != nil {
                    self.nameInChinese = dict["NameInChinese"] as! String
                }
                if dict.keys.contains("NameInEnglish") && dict["NameInEnglish"] != nil {
                    self.nameInEnglish = dict["NameInEnglish"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var deptName: String?

        public var email: String?

        public var name: GetInstanceByIdResponseBody.ActionExecutor.Name?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.name?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deptName != nil {
                map["DeptName"] = self.deptName!
            }
            if self.email != nil {
                map["Email"] = self.email!
            }
            if self.name != nil {
                map["Name"] = self.name?.toMap()
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeptName") && dict["DeptName"] != nil {
                self.deptName = dict["DeptName"] as! String
            }
            if dict.keys.contains("Email") && dict["Email"] != nil {
                self.email = dict["Email"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                var model = GetInstanceByIdResponseBody.ActionExecutor.Name()
                model.fromMap(dict["Name"] as! [String: Any])
                self.name = model
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public class Originator : Tea.TeaModel {
        public class Name : Tea.TeaModel {
            public var nameInChinese: String?

            public var nameInEnglish: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.nameInChinese != nil {
                    map["NameInChinese"] = self.nameInChinese!
                }
                if self.nameInEnglish != nil {
                    map["NameInEnglish"] = self.nameInEnglish!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NameInChinese") && dict["NameInChinese"] != nil {
                    self.nameInChinese = dict["NameInChinese"] as! String
                }
                if dict.keys.contains("NameInEnglish") && dict["NameInEnglish"] != nil {
                    self.nameInEnglish = dict["NameInEnglish"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var deptName: String?

        public var email: String?

        public var name: GetInstanceByIdResponseBody.Originator.Name?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.name?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deptName != nil {
                map["DeptName"] = self.deptName!
            }
            if self.email != nil {
                map["Email"] = self.email!
            }
            if self.name != nil {
                map["Name"] = self.name?.toMap()
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeptName") && dict["DeptName"] != nil {
                self.deptName = dict["DeptName"] as! String
            }
            if dict.keys.contains("Email") && dict["Email"] != nil {
                self.email = dict["Email"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                var model = GetInstanceByIdResponseBody.Originator.Name()
                model.fromMap(dict["Name"] as! [String: Any])
                self.name = model
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var actionExecutor: [GetInstanceByIdResponseBody.ActionExecutor]?

    public var approvedResult: String?

    public var createTimeGMT: String?

    public var data: [String: Any]?

    public var formUuid: String?

    public var instanceStatus: String?

    public var modifiedTimeGMT: String?

    public var originator: GetInstanceByIdResponseBody.Originator?

    public var processCode: String?

    public var processInstanceId: String?

    public var requestId: String?

    public var title: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public var version: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.originator?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionExecutor != nil {
            var tmp : [Any] = []
            for k in self.actionExecutor! {
                tmp.append(k.toMap())
            }
            map["actionExecutor"] = tmp
        }
        if self.approvedResult != nil {
            map["approvedResult"] = self.approvedResult!
        }
        if self.createTimeGMT != nil {
            map["createTimeGMT"] = self.createTimeGMT!
        }
        if self.data != nil {
            map["data"] = self.data!
        }
        if self.formUuid != nil {
            map["formUuid"] = self.formUuid!
        }
        if self.instanceStatus != nil {
            map["instanceStatus"] = self.instanceStatus!
        }
        if self.modifiedTimeGMT != nil {
            map["modifiedTimeGMT"] = self.modifiedTimeGMT!
        }
        if self.originator != nil {
            map["originator"] = self.originator?.toMap()
        }
        if self.processCode != nil {
            map["processCode"] = self.processCode!
        }
        if self.processInstanceId != nil {
            map["processInstanceId"] = self.processInstanceId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        if self.version != nil {
            map["version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("actionExecutor") && dict["actionExecutor"] != nil {
            var tmp : [GetInstanceByIdResponseBody.ActionExecutor] = []
            for v in dict["actionExecutor"] as! [Any] {
                var model = GetInstanceByIdResponseBody.ActionExecutor()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.actionExecutor = tmp
        }
        if dict.keys.contains("approvedResult") && dict["approvedResult"] != nil {
            self.approvedResult = dict["approvedResult"] as! String
        }
        if dict.keys.contains("createTimeGMT") && dict["createTimeGMT"] != nil {
            self.createTimeGMT = dict["createTimeGMT"] as! String
        }
        if dict.keys.contains("data") && dict["data"] != nil {
            self.data = dict["data"] as! [String: Any]
        }
        if dict.keys.contains("formUuid") && dict["formUuid"] != nil {
            self.formUuid = dict["formUuid"] as! String
        }
        if dict.keys.contains("instanceStatus") && dict["instanceStatus"] != nil {
            self.instanceStatus = dict["instanceStatus"] as! String
        }
        if dict.keys.contains("modifiedTimeGMT") && dict["modifiedTimeGMT"] != nil {
            self.modifiedTimeGMT = dict["modifiedTimeGMT"] as! String
        }
        if dict.keys.contains("originator") && dict["originator"] != nil {
            var model = GetInstanceByIdResponseBody.Originator()
            model.fromMap(dict["originator"] as! [String: Any])
            self.originator = model
        }
        if dict.keys.contains("processCode") && dict["processCode"] != nil {
            self.processCode = dict["processCode"] as! String
        }
        if dict.keys.contains("processInstanceId") && dict["processInstanceId"] != nil {
            self.processInstanceId = dict["processInstanceId"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("title") && dict["title"] != nil {
            self.title = dict["title"] as! String
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
        if dict.keys.contains("version") && dict["version"] != nil {
            self.version = dict["version"] as! Int64
        }
    }
}

public class GetInstanceByIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceByIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetInstanceByIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInstanceIdListHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetInstanceIdListHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetInstanceIdListHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetInstanceIdListShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetInstanceIdListRequest : Tea.TeaModel {
    public var appType: String?

    public var approvedResult: String?

    public var createFromTimeGMT: String?

    public var createToTimeGMT: String?

    public var formUuid: String?

    public var instanceStatus: String?

    public var language: String?

    public var modifiedFromTimeGMT: String?

    public var modifiedToTimeGMT: String?

    public var originatorId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchFieldJson: String?

    public var systemToken: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.approvedResult != nil {
            map["ApprovedResult"] = self.approvedResult!
        }
        if self.createFromTimeGMT != nil {
            map["CreateFromTimeGMT"] = self.createFromTimeGMT!
        }
        if self.createToTimeGMT != nil {
            map["CreateToTimeGMT"] = self.createToTimeGMT!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.instanceStatus != nil {
            map["InstanceStatus"] = self.instanceStatus!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.modifiedFromTimeGMT != nil {
            map["ModifiedFromTimeGMT"] = self.modifiedFromTimeGMT!
        }
        if self.modifiedToTimeGMT != nil {
            map["ModifiedToTimeGMT"] = self.modifiedToTimeGMT!
        }
        if self.originatorId != nil {
            map["OriginatorId"] = self.originatorId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchFieldJson != nil {
            map["SearchFieldJson"] = self.searchFieldJson!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("ApprovedResult") && dict["ApprovedResult"] != nil {
            self.approvedResult = dict["ApprovedResult"] as! String
        }
        if dict.keys.contains("CreateFromTimeGMT") && dict["CreateFromTimeGMT"] != nil {
            self.createFromTimeGMT = dict["CreateFromTimeGMT"] as! String
        }
        if dict.keys.contains("CreateToTimeGMT") && dict["CreateToTimeGMT"] != nil {
            self.createToTimeGMT = dict["CreateToTimeGMT"] as! String
        }
        if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("InstanceStatus") && dict["InstanceStatus"] != nil {
            self.instanceStatus = dict["InstanceStatus"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("ModifiedFromTimeGMT") && dict["ModifiedFromTimeGMT"] != nil {
            self.modifiedFromTimeGMT = dict["ModifiedFromTimeGMT"] as! String
        }
        if dict.keys.contains("ModifiedToTimeGMT") && dict["ModifiedToTimeGMT"] != nil {
            self.modifiedToTimeGMT = dict["ModifiedToTimeGMT"] as! String
        }
        if dict.keys.contains("OriginatorId") && dict["OriginatorId"] != nil {
            self.originatorId = dict["OriginatorId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchFieldJson") && dict["SearchFieldJson"] != nil {
            self.searchFieldJson = dict["SearchFieldJson"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class GetInstanceIdListResponseBody : Tea.TeaModel {
    public var data: [String]?

    public var pageNumber: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data!
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            self.data = dict["data"] as! [String]
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetInstanceIdListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceIdListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetInstanceIdListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInstancesHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetInstancesHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetInstancesHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetInstancesShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetInstancesRequest : Tea.TeaModel {
    public var appType: String?

    public var approvedResult: String?

    public var createFromTimeGMT: String?

    public var createToTimeGMT: String?

    public var formUuid: String?

    public var instanceStatus: String?

    public var language: String?

    public var modifiedFromTimeGMT: String?

    public var modifiedToTimeGMT: String?

    public var orderConfigJson: String?

    public var originatorId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchFieldJson: String?

    public var systemToken: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.approvedResult != nil {
            map["ApprovedResult"] = self.approvedResult!
        }
        if self.createFromTimeGMT != nil {
            map["CreateFromTimeGMT"] = self.createFromTimeGMT!
        }
        if self.createToTimeGMT != nil {
            map["CreateToTimeGMT"] = self.createToTimeGMT!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.instanceStatus != nil {
            map["InstanceStatus"] = self.instanceStatus!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.modifiedFromTimeGMT != nil {
            map["ModifiedFromTimeGMT"] = self.modifiedFromTimeGMT!
        }
        if self.modifiedToTimeGMT != nil {
            map["ModifiedToTimeGMT"] = self.modifiedToTimeGMT!
        }
        if self.orderConfigJson != nil {
            map["OrderConfigJson"] = self.orderConfigJson!
        }
        if self.originatorId != nil {
            map["OriginatorId"] = self.originatorId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchFieldJson != nil {
            map["SearchFieldJson"] = self.searchFieldJson!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("ApprovedResult") && dict["ApprovedResult"] != nil {
            self.approvedResult = dict["ApprovedResult"] as! String
        }
        if dict.keys.contains("CreateFromTimeGMT") && dict["CreateFromTimeGMT"] != nil {
            self.createFromTimeGMT = dict["CreateFromTimeGMT"] as! String
        }
        if dict.keys.contains("CreateToTimeGMT") && dict["CreateToTimeGMT"] != nil {
            self.createToTimeGMT = dict["CreateToTimeGMT"] as! String
        }
        if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("InstanceStatus") && dict["InstanceStatus"] != nil {
            self.instanceStatus = dict["InstanceStatus"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("ModifiedFromTimeGMT") && dict["ModifiedFromTimeGMT"] != nil {
            self.modifiedFromTimeGMT = dict["ModifiedFromTimeGMT"] as! String
        }
        if dict.keys.contains("ModifiedToTimeGMT") && dict["ModifiedToTimeGMT"] != nil {
            self.modifiedToTimeGMT = dict["ModifiedToTimeGMT"] as! String
        }
        if dict.keys.contains("OrderConfigJson") && dict["OrderConfigJson"] != nil {
            self.orderConfigJson = dict["OrderConfigJson"] as! String
        }
        if dict.keys.contains("OriginatorId") && dict["OriginatorId"] != nil {
            self.originatorId = dict["OriginatorId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchFieldJson") && dict["SearchFieldJson"] != nil {
            self.searchFieldJson = dict["SearchFieldJson"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class GetInstancesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ActionExecutor : Tea.TeaModel {
            public class Name : Tea.TeaModel {
                public var nameInChinese: String?

                public var nameInEnglish: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nameInChinese != nil {
                        map["NameInChinese"] = self.nameInChinese!
                    }
                    if self.nameInEnglish != nil {
                        map["NameInEnglish"] = self.nameInEnglish!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NameInChinese") && dict["NameInChinese"] != nil {
                        self.nameInChinese = dict["NameInChinese"] as! String
                    }
                    if dict.keys.contains("NameInEnglish") && dict["NameInEnglish"] != nil {
                        self.nameInEnglish = dict["NameInEnglish"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var deptName: String?

            public var email: String?

            public var name: GetInstancesResponseBody.Data.ActionExecutor.Name?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.name?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.deptName != nil {
                    map["DeptName"] = self.deptName!
                }
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.name != nil {
                    map["Name"] = self.name?.toMap()
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DeptName") && dict["DeptName"] != nil {
                    self.deptName = dict["DeptName"] as! String
                }
                if dict.keys.contains("Email") && dict["Email"] != nil {
                    self.email = dict["Email"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    var model = GetInstancesResponseBody.Data.ActionExecutor.Name()
                    model.fromMap(dict["Name"] as! [String: Any])
                    self.name = model
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public class Originator : Tea.TeaModel {
            public class Name : Tea.TeaModel {
                public var nameInChinese: String?

                public var nameInEnglish: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nameInChinese != nil {
                        map["NameInChinese"] = self.nameInChinese!
                    }
                    if self.nameInEnglish != nil {
                        map["NameInEnglish"] = self.nameInEnglish!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NameInChinese") && dict["NameInChinese"] != nil {
                        self.nameInChinese = dict["NameInChinese"] as! String
                    }
                    if dict.keys.contains("NameInEnglish") && dict["NameInEnglish"] != nil {
                        self.nameInEnglish = dict["NameInEnglish"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var deptName: String?

            public var email: String?

            public var name: GetInstancesResponseBody.Data.Originator.Name?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.name?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.deptName != nil {
                    map["DeptName"] = self.deptName!
                }
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.name != nil {
                    map["Name"] = self.name?.toMap()
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DeptName") && dict["DeptName"] != nil {
                    self.deptName = dict["DeptName"] as! String
                }
                if dict.keys.contains("Email") && dict["Email"] != nil {
                    self.email = dict["Email"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    var model = GetInstancesResponseBody.Data.Originator.Name()
                    model.fromMap(dict["Name"] as! [String: Any])
                    self.name = model
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var actionExecutor: [GetInstancesResponseBody.Data.ActionExecutor]?

        public var approvedResult: String?

        public var createTimeGMT: String?

        public var data: [String: Any]?

        public var formUuid: String?

        public var instanceStatus: String?

        public var modifiedTimeGMT: String?

        public var originator: GetInstancesResponseBody.Data.Originator?

        public var processCode: String?

        public var processInstanceId: String?

        public var title: String?

        public var version: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.originator?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actionExecutor != nil {
                var tmp : [Any] = []
                for k in self.actionExecutor! {
                    tmp.append(k.toMap())
                }
                map["ActionExecutor"] = tmp
            }
            if self.approvedResult != nil {
                map["ApprovedResult"] = self.approvedResult!
            }
            if self.createTimeGMT != nil {
                map["CreateTimeGMT"] = self.createTimeGMT!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.formUuid != nil {
                map["FormUuid"] = self.formUuid!
            }
            if self.instanceStatus != nil {
                map["InstanceStatus"] = self.instanceStatus!
            }
            if self.modifiedTimeGMT != nil {
                map["ModifiedTimeGMT"] = self.modifiedTimeGMT!
            }
            if self.originator != nil {
                map["Originator"] = self.originator?.toMap()
            }
            if self.processCode != nil {
                map["ProcessCode"] = self.processCode!
            }
            if self.processInstanceId != nil {
                map["ProcessInstanceId"] = self.processInstanceId!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActionExecutor") && dict["ActionExecutor"] != nil {
                var tmp : [GetInstancesResponseBody.Data.ActionExecutor] = []
                for v in dict["ActionExecutor"] as! [Any] {
                    var model = GetInstancesResponseBody.Data.ActionExecutor()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.actionExecutor = tmp
            }
            if dict.keys.contains("ApprovedResult") && dict["ApprovedResult"] != nil {
                self.approvedResult = dict["ApprovedResult"] as! String
            }
            if dict.keys.contains("CreateTimeGMT") && dict["CreateTimeGMT"] != nil {
                self.createTimeGMT = dict["CreateTimeGMT"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! [String: Any]
            }
            if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
                self.formUuid = dict["FormUuid"] as! String
            }
            if dict.keys.contains("InstanceStatus") && dict["InstanceStatus"] != nil {
                self.instanceStatus = dict["InstanceStatus"] as! String
            }
            if dict.keys.contains("ModifiedTimeGMT") && dict["ModifiedTimeGMT"] != nil {
                self.modifiedTimeGMT = dict["ModifiedTimeGMT"] as! String
            }
            if dict.keys.contains("Originator") && dict["Originator"] != nil {
                var model = GetInstancesResponseBody.Data.Originator()
                model.fromMap(dict["Originator"] as! [String: Any])
                self.originator = model
            }
            if dict.keys.contains("ProcessCode") && dict["ProcessCode"] != nil {
                self.processCode = dict["ProcessCode"] as! String
            }
            if dict.keys.contains("ProcessInstanceId") && dict["ProcessInstanceId"] != nil {
                self.processInstanceId = dict["ProcessInstanceId"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("Version") && dict["Version"] != nil {
                self.version = dict["Version"] as! Int64
            }
        }
    }
    public var data: [GetInstancesResponseBody.Data]?

    public var pageNumber: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [GetInstancesResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = GetInstancesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInstancesByIdListHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetInstancesByIdListHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetInstancesByIdListHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetInstancesByIdListShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetInstancesByIdListRequest : Tea.TeaModel {
    public var appType: String?

    public var language: String?

    public var processInstanceIds: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.processInstanceIds != nil {
            map["ProcessInstanceIds"] = self.processInstanceIds!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("ProcessInstanceIds") && dict["ProcessInstanceIds"] != nil {
            self.processInstanceIds = dict["ProcessInstanceIds"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class GetInstancesByIdListResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ActionExecutor : Tea.TeaModel {
            public class Name : Tea.TeaModel {
                public var nameInChinese: String?

                public var nameInEnglish: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nameInChinese != nil {
                        map["NameInChinese"] = self.nameInChinese!
                    }
                    if self.nameInEnglish != nil {
                        map["NameInEnglish"] = self.nameInEnglish!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NameInChinese") && dict["NameInChinese"] != nil {
                        self.nameInChinese = dict["NameInChinese"] as! String
                    }
                    if dict.keys.contains("NameInEnglish") && dict["NameInEnglish"] != nil {
                        self.nameInEnglish = dict["NameInEnglish"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var departmentName: String?

            public var email: String?

            public var name: GetInstancesByIdListResponseBody.Result.ActionExecutor.Name?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.name?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.departmentName != nil {
                    map["DepartmentName"] = self.departmentName!
                }
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.name != nil {
                    map["Name"] = self.name?.toMap()
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DepartmentName") && dict["DepartmentName"] != nil {
                    self.departmentName = dict["DepartmentName"] as! String
                }
                if dict.keys.contains("Email") && dict["Email"] != nil {
                    self.email = dict["Email"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    var model = GetInstancesByIdListResponseBody.Result.ActionExecutor.Name()
                    model.fromMap(dict["Name"] as! [String: Any])
                    self.name = model
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public class Originator : Tea.TeaModel {
            public class Name : Tea.TeaModel {
                public var nameInChinese: String?

                public var nameInEnglish: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nameInChinese != nil {
                        map["NameInChinese"] = self.nameInChinese!
                    }
                    if self.nameInEnglish != nil {
                        map["NameInEnglish"] = self.nameInEnglish!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NameInChinese") && dict["NameInChinese"] != nil {
                        self.nameInChinese = dict["NameInChinese"] as! String
                    }
                    if dict.keys.contains("NameInEnglish") && dict["NameInEnglish"] != nil {
                        self.nameInEnglish = dict["NameInEnglish"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var departmentName: String?

            public var email: String?

            public var name: GetInstancesByIdListResponseBody.Result.Originator.Name?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.name?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.departmentName != nil {
                    map["DepartmentName"] = self.departmentName!
                }
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.name != nil {
                    map["Name"] = self.name?.toMap()
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DepartmentName") && dict["DepartmentName"] != nil {
                    self.departmentName = dict["DepartmentName"] as! String
                }
                if dict.keys.contains("Email") && dict["Email"] != nil {
                    self.email = dict["Email"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    var model = GetInstancesByIdListResponseBody.Result.Originator.Name()
                    model.fromMap(dict["Name"] as! [String: Any])
                    self.name = model
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var actionExecutor: [GetInstancesByIdListResponseBody.Result.ActionExecutor]?

        public var approvedResult: String?

        public var data: [String: Any]?

        public var formUuid: String?

        public var instanceStatus: String?

        public var originator: GetInstancesByIdListResponseBody.Result.Originator?

        public var processCode: String?

        public var processInstanceId: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.originator?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actionExecutor != nil {
                var tmp : [Any] = []
                for k in self.actionExecutor! {
                    tmp.append(k.toMap())
                }
                map["ActionExecutor"] = tmp
            }
            if self.approvedResult != nil {
                map["ApprovedResult"] = self.approvedResult!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.formUuid != nil {
                map["FormUuid"] = self.formUuid!
            }
            if self.instanceStatus != nil {
                map["InstanceStatus"] = self.instanceStatus!
            }
            if self.originator != nil {
                map["Originator"] = self.originator?.toMap()
            }
            if self.processCode != nil {
                map["ProcessCode"] = self.processCode!
            }
            if self.processInstanceId != nil {
                map["ProcessInstanceId"] = self.processInstanceId!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActionExecutor") && dict["ActionExecutor"] != nil {
                var tmp : [GetInstancesByIdListResponseBody.Result.ActionExecutor] = []
                for v in dict["ActionExecutor"] as! [Any] {
                    var model = GetInstancesByIdListResponseBody.Result.ActionExecutor()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.actionExecutor = tmp
            }
            if dict.keys.contains("ApprovedResult") && dict["ApprovedResult"] != nil {
                self.approvedResult = dict["ApprovedResult"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! [String: Any]
            }
            if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
                self.formUuid = dict["FormUuid"] as! String
            }
            if dict.keys.contains("InstanceStatus") && dict["InstanceStatus"] != nil {
                self.instanceStatus = dict["InstanceStatus"] as! String
            }
            if dict.keys.contains("Originator") && dict["Originator"] != nil {
                var model = GetInstancesByIdListResponseBody.Result.Originator()
                model.fromMap(dict["Originator"] as! [String: Any])
                self.originator = model
            }
            if dict.keys.contains("ProcessCode") && dict["ProcessCode"] != nil {
                self.processCode = dict["ProcessCode"] as! String
            }
            if dict.keys.contains("ProcessInstanceId") && dict["ProcessInstanceId"] != nil {
                self.processInstanceId = dict["ProcessInstanceId"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [GetInstancesByIdListResponseBody.Result]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            var tmp : [GetInstancesByIdListResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = GetInstancesByIdListResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetInstancesByIdListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstancesByIdListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetInstancesByIdListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMeCorpSubmissionHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetMeCorpSubmissionHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetMeCorpSubmissionHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetMeCorpSubmissionShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetMeCorpSubmissionRequest : Tea.TeaModel {
    public var appTypes: String?

    public var corpId: String?

    public var createFromTimeGMT: Int64?

    public var createToTimeGMT: Int64?

    public var keyword: String?

    public var language: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var processCodes: String?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appTypes != nil {
            map["AppTypes"] = self.appTypes!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.createFromTimeGMT != nil {
            map["CreateFromTimeGMT"] = self.createFromTimeGMT!
        }
        if self.createToTimeGMT != nil {
            map["CreateToTimeGMT"] = self.createToTimeGMT!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.processCodes != nil {
            map["ProcessCodes"] = self.processCodes!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppTypes") && dict["AppTypes"] != nil {
            self.appTypes = dict["AppTypes"] as! String
        }
        if dict.keys.contains("CorpId") && dict["CorpId"] != nil {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("CreateFromTimeGMT") && dict["CreateFromTimeGMT"] != nil {
            self.createFromTimeGMT = dict["CreateFromTimeGMT"] as! Int64
        }
        if dict.keys.contains("CreateToTimeGMT") && dict["CreateToTimeGMT"] != nil {
            self.createToTimeGMT = dict["CreateToTimeGMT"] as! Int64
        }
        if dict.keys.contains("Keyword") && dict["Keyword"] != nil {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProcessCodes") && dict["ProcessCodes"] != nil {
            self.processCodes = dict["ProcessCodes"] as! String
        }
        if dict.keys.contains("Token") && dict["Token"] != nil {
            self.token = dict["Token"] as! String
        }
    }
}

public class GetMeCorpSubmissionResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Actioner : Tea.TeaModel {
            public var buName: String?

            public var email: String?

            public var employeeType: String?

            public var employeeTypeInformation: String?

            public var humanResourceGroupWorkNumber: String?

            public var isSystemAdmin: Bool?

            public var level: String?

            public var name: String?

            public var nickName: String?

            public var orderNumber: String?

            public var personalPhoto: String?

            public var personalPhotoUrl: String?

            public var pinyinNameAll: String?

            public var pinyinNickName: String?

            public var state: String?

            public var superUserId: String?

            public var tbWang: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.buName != nil {
                    map["BuName"] = self.buName!
                }
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.employeeType != nil {
                    map["EmployeeType"] = self.employeeType!
                }
                if self.employeeTypeInformation != nil {
                    map["EmployeeTypeInformation"] = self.employeeTypeInformation!
                }
                if self.humanResourceGroupWorkNumber != nil {
                    map["HumanResourceGroupWorkNumber"] = self.humanResourceGroupWorkNumber!
                }
                if self.isSystemAdmin != nil {
                    map["IsSystemAdmin"] = self.isSystemAdmin!
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.nickName != nil {
                    map["NickName"] = self.nickName!
                }
                if self.orderNumber != nil {
                    map["OrderNumber"] = self.orderNumber!
                }
                if self.personalPhoto != nil {
                    map["PersonalPhoto"] = self.personalPhoto!
                }
                if self.personalPhotoUrl != nil {
                    map["PersonalPhotoUrl"] = self.personalPhotoUrl!
                }
                if self.pinyinNameAll != nil {
                    map["PinyinNameAll"] = self.pinyinNameAll!
                }
                if self.pinyinNickName != nil {
                    map["PinyinNickName"] = self.pinyinNickName!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.superUserId != nil {
                    map["SuperUserId"] = self.superUserId!
                }
                if self.tbWang != nil {
                    map["TbWang"] = self.tbWang!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BuName") && dict["BuName"] != nil {
                    self.buName = dict["BuName"] as! String
                }
                if dict.keys.contains("Email") && dict["Email"] != nil {
                    self.email = dict["Email"] as! String
                }
                if dict.keys.contains("EmployeeType") && dict["EmployeeType"] != nil {
                    self.employeeType = dict["EmployeeType"] as! String
                }
                if dict.keys.contains("EmployeeTypeInformation") && dict["EmployeeTypeInformation"] != nil {
                    self.employeeTypeInformation = dict["EmployeeTypeInformation"] as! String
                }
                if dict.keys.contains("HumanResourceGroupWorkNumber") && dict["HumanResourceGroupWorkNumber"] != nil {
                    self.humanResourceGroupWorkNumber = dict["HumanResourceGroupWorkNumber"] as! String
                }
                if dict.keys.contains("IsSystemAdmin") && dict["IsSystemAdmin"] != nil {
                    self.isSystemAdmin = dict["IsSystemAdmin"] as! Bool
                }
                if dict.keys.contains("Level") && dict["Level"] != nil {
                    self.level = dict["Level"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NickName") && dict["NickName"] != nil {
                    self.nickName = dict["NickName"] as! String
                }
                if dict.keys.contains("OrderNumber") && dict["OrderNumber"] != nil {
                    self.orderNumber = dict["OrderNumber"] as! String
                }
                if dict.keys.contains("PersonalPhoto") && dict["PersonalPhoto"] != nil {
                    self.personalPhoto = dict["PersonalPhoto"] as! String
                }
                if dict.keys.contains("PersonalPhotoUrl") && dict["PersonalPhotoUrl"] != nil {
                    self.personalPhotoUrl = dict["PersonalPhotoUrl"] as! String
                }
                if dict.keys.contains("PinyinNameAll") && dict["PinyinNameAll"] != nil {
                    self.pinyinNameAll = dict["PinyinNameAll"] as! String
                }
                if dict.keys.contains("PinyinNickName") && dict["PinyinNickName"] != nil {
                    self.pinyinNickName = dict["PinyinNickName"] as! String
                }
                if dict.keys.contains("State") && dict["State"] != nil {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("SuperUserId") && dict["SuperUserId"] != nil {
                    self.superUserId = dict["SuperUserId"] as! String
                }
                if dict.keys.contains("TbWang") && dict["TbWang"] != nil {
                    self.tbWang = dict["TbWang"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public class CurrentActivityInstances : Tea.TeaModel {
            public var activityId: String?

            public var activityInstanceStatus: String?

            public var activityName: String?

            public var activityNameEn: String?

            public var id: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activityId != nil {
                    map["ActivityId"] = self.activityId!
                }
                if self.activityInstanceStatus != nil {
                    map["ActivityInstanceStatus"] = self.activityInstanceStatus!
                }
                if self.activityName != nil {
                    map["ActivityName"] = self.activityName!
                }
                if self.activityNameEn != nil {
                    map["ActivityNameEn"] = self.activityNameEn!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActivityId") && dict["ActivityId"] != nil {
                    self.activityId = dict["ActivityId"] as! String
                }
                if dict.keys.contains("ActivityInstanceStatus") && dict["ActivityInstanceStatus"] != nil {
                    self.activityInstanceStatus = dict["ActivityInstanceStatus"] as! String
                }
                if dict.keys.contains("ActivityName") && dict["ActivityName"] != nil {
                    self.activityName = dict["ActivityName"] as! String
                }
                if dict.keys.contains("ActivityNameEn") && dict["ActivityNameEn"] != nil {
                    self.activityNameEn = dict["ActivityNameEn"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
            }
        }
        public var actioner: [GetMeCorpSubmissionResponseBody.Data.Actioner]?

        public var actionerId: [String]?

        public var actionerName: [String]?

        public var appType: String?

        public var createTimeGMT: String?

        public var currentActivityInstances: [GetMeCorpSubmissionResponseBody.Data.CurrentActivityInstances]?

        public var dataMap: [String: Any]?

        public var dataType: String?

        public var finishTimeGMT: String?

        public var formInstanceId: String?

        public var formUuid: String?

        public var instanceValue: String?

        public var modifiedTimeGMT: String?

        public var originatorAvatar: String?

        public var originatorDisplayName: String?

        public var originatorId: String?

        public var processApprovedResult: String?

        public var processApprovedResultText: String?

        public var processCode: String?

        public var processId: Int64?

        public var processInstanceId: String?

        public var processInstanceStatus: String?

        public var processInstanceStatusText: String?

        public var processName: String?

        public var title: String?

        public var version: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actioner != nil {
                var tmp : [Any] = []
                for k in self.actioner! {
                    tmp.append(k.toMap())
                }
                map["Actioner"] = tmp
            }
            if self.actionerId != nil {
                map["ActionerId"] = self.actionerId!
            }
            if self.actionerName != nil {
                map["ActionerName"] = self.actionerName!
            }
            if self.appType != nil {
                map["AppType"] = self.appType!
            }
            if self.createTimeGMT != nil {
                map["CreateTimeGMT"] = self.createTimeGMT!
            }
            if self.currentActivityInstances != nil {
                var tmp : [Any] = []
                for k in self.currentActivityInstances! {
                    tmp.append(k.toMap())
                }
                map["CurrentActivityInstances"] = tmp
            }
            if self.dataMap != nil {
                map["DataMap"] = self.dataMap!
            }
            if self.dataType != nil {
                map["DataType"] = self.dataType!
            }
            if self.finishTimeGMT != nil {
                map["FinishTimeGMT"] = self.finishTimeGMT!
            }
            if self.formInstanceId != nil {
                map["FormInstanceId"] = self.formInstanceId!
            }
            if self.formUuid != nil {
                map["FormUuid"] = self.formUuid!
            }
            if self.instanceValue != nil {
                map["InstanceValue"] = self.instanceValue!
            }
            if self.modifiedTimeGMT != nil {
                map["ModifiedTimeGMT"] = self.modifiedTimeGMT!
            }
            if self.originatorAvatar != nil {
                map["OriginatorAvatar"] = self.originatorAvatar!
            }
            if self.originatorDisplayName != nil {
                map["OriginatorDisplayName"] = self.originatorDisplayName!
            }
            if self.originatorId != nil {
                map["OriginatorId"] = self.originatorId!
            }
            if self.processApprovedResult != nil {
                map["ProcessApprovedResult"] = self.processApprovedResult!
            }
            if self.processApprovedResultText != nil {
                map["ProcessApprovedResultText"] = self.processApprovedResultText!
            }
            if self.processCode != nil {
                map["ProcessCode"] = self.processCode!
            }
            if self.processId != nil {
                map["ProcessId"] = self.processId!
            }
            if self.processInstanceId != nil {
                map["ProcessInstanceId"] = self.processInstanceId!
            }
            if self.processInstanceStatus != nil {
                map["ProcessInstanceStatus"] = self.processInstanceStatus!
            }
            if self.processInstanceStatusText != nil {
                map["ProcessInstanceStatusText"] = self.processInstanceStatusText!
            }
            if self.processName != nil {
                map["ProcessName"] = self.processName!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Actioner") && dict["Actioner"] != nil {
                var tmp : [GetMeCorpSubmissionResponseBody.Data.Actioner] = []
                for v in dict["Actioner"] as! [Any] {
                    var model = GetMeCorpSubmissionResponseBody.Data.Actioner()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.actioner = tmp
            }
            if dict.keys.contains("ActionerId") && dict["ActionerId"] != nil {
                self.actionerId = dict["ActionerId"] as! [String]
            }
            if dict.keys.contains("ActionerName") && dict["ActionerName"] != nil {
                self.actionerName = dict["ActionerName"] as! [String]
            }
            if dict.keys.contains("AppType") && dict["AppType"] != nil {
                self.appType = dict["AppType"] as! String
            }
            if dict.keys.contains("CreateTimeGMT") && dict["CreateTimeGMT"] != nil {
                self.createTimeGMT = dict["CreateTimeGMT"] as! String
            }
            if dict.keys.contains("CurrentActivityInstances") && dict["CurrentActivityInstances"] != nil {
                var tmp : [GetMeCorpSubmissionResponseBody.Data.CurrentActivityInstances] = []
                for v in dict["CurrentActivityInstances"] as! [Any] {
                    var model = GetMeCorpSubmissionResponseBody.Data.CurrentActivityInstances()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.currentActivityInstances = tmp
            }
            if dict.keys.contains("DataMap") && dict["DataMap"] != nil {
                self.dataMap = dict["DataMap"] as! [String: Any]
            }
            if dict.keys.contains("DataType") && dict["DataType"] != nil {
                self.dataType = dict["DataType"] as! String
            }
            if dict.keys.contains("FinishTimeGMT") && dict["FinishTimeGMT"] != nil {
                self.finishTimeGMT = dict["FinishTimeGMT"] as! String
            }
            if dict.keys.contains("FormInstanceId") && dict["FormInstanceId"] != nil {
                self.formInstanceId = dict["FormInstanceId"] as! String
            }
            if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
                self.formUuid = dict["FormUuid"] as! String
            }
            if dict.keys.contains("InstanceValue") && dict["InstanceValue"] != nil {
                self.instanceValue = dict["InstanceValue"] as! String
            }
            if dict.keys.contains("ModifiedTimeGMT") && dict["ModifiedTimeGMT"] != nil {
                self.modifiedTimeGMT = dict["ModifiedTimeGMT"] as! String
            }
            if dict.keys.contains("OriginatorAvatar") && dict["OriginatorAvatar"] != nil {
                self.originatorAvatar = dict["OriginatorAvatar"] as! String
            }
            if dict.keys.contains("OriginatorDisplayName") && dict["OriginatorDisplayName"] != nil {
                self.originatorDisplayName = dict["OriginatorDisplayName"] as! String
            }
            if dict.keys.contains("OriginatorId") && dict["OriginatorId"] != nil {
                self.originatorId = dict["OriginatorId"] as! String
            }
            if dict.keys.contains("ProcessApprovedResult") && dict["ProcessApprovedResult"] != nil {
                self.processApprovedResult = dict["ProcessApprovedResult"] as! String
            }
            if dict.keys.contains("ProcessApprovedResultText") && dict["ProcessApprovedResultText"] != nil {
                self.processApprovedResultText = dict["ProcessApprovedResultText"] as! String
            }
            if dict.keys.contains("ProcessCode") && dict["ProcessCode"] != nil {
                self.processCode = dict["ProcessCode"] as! String
            }
            if dict.keys.contains("ProcessId") && dict["ProcessId"] != nil {
                self.processId = dict["ProcessId"] as! Int64
            }
            if dict.keys.contains("ProcessInstanceId") && dict["ProcessInstanceId"] != nil {
                self.processInstanceId = dict["ProcessInstanceId"] as! String
            }
            if dict.keys.contains("ProcessInstanceStatus") && dict["ProcessInstanceStatus"] != nil {
                self.processInstanceStatus = dict["ProcessInstanceStatus"] as! String
            }
            if dict.keys.contains("ProcessInstanceStatusText") && dict["ProcessInstanceStatusText"] != nil {
                self.processInstanceStatusText = dict["ProcessInstanceStatusText"] as! String
            }
            if dict.keys.contains("ProcessName") && dict["ProcessName"] != nil {
                self.processName = dict["ProcessName"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("Version") && dict["Version"] != nil {
                self.version = dict["Version"] as! Int64
            }
        }
    }
    public var data: [GetMeCorpSubmissionResponseBody.Data]?

    public var pageNumber: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [GetMeCorpSubmissionResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = GetMeCorpSubmissionResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetMeCorpSubmissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMeCorpSubmissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMeCorpSubmissionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMeetingRoomsScheduleHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetMeetingRoomsScheduleHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetMeetingRoomsScheduleHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetMeetingRoomsScheduleShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetMeetingRoomsScheduleRequest : Tea.TeaModel {
    public var endTime: String?

    public var roomIds: [String]?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.roomIds != nil {
            map["RoomIds"] = self.roomIds!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("RoomIds") && dict["RoomIds"] != nil {
            self.roomIds = dict["RoomIds"] as! [String]
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class GetMeetingRoomsScheduleShrinkRequest : Tea.TeaModel {
    public var endTime: String?

    public var roomIdsShrink: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.roomIdsShrink != nil {
            map["RoomIds"] = self.roomIdsShrink!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("RoomIds") && dict["RoomIds"] != nil {
            self.roomIdsShrink = dict["RoomIds"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class GetMeetingRoomsScheduleResponseBody : Tea.TeaModel {
    public class ScheduleInformation : Tea.TeaModel {
        public class ScheduleItems : Tea.TeaModel {
            public class End : Tea.TeaModel {
                public var dateTime: String?

                public var timeZone: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dateTime != nil {
                        map["DateTime"] = self.dateTime!
                    }
                    if self.timeZone != nil {
                        map["TimeZone"] = self.timeZone!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                        self.dateTime = dict["DateTime"] as! String
                    }
                    if dict.keys.contains("TimeZone") && dict["TimeZone"] != nil {
                        self.timeZone = dict["TimeZone"] as! String
                    }
                }
            }
            public class Organizer : Tea.TeaModel {
                public var id: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! String
                    }
                }
            }
            public class Start : Tea.TeaModel {
                public var dateTime: String?

                public var timeZone: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dateTime != nil {
                        map["DateTime"] = self.dateTime!
                    }
                    if self.timeZone != nil {
                        map["TimeZone"] = self.timeZone!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                        self.dateTime = dict["DateTime"] as! String
                    }
                    if dict.keys.contains("TimeZone") && dict["TimeZone"] != nil {
                        self.timeZone = dict["TimeZone"] as! String
                    }
                }
            }
            public var end: GetMeetingRoomsScheduleResponseBody.ScheduleInformation.ScheduleItems.End?

            public var eventId: String?

            public var organizer: GetMeetingRoomsScheduleResponseBody.ScheduleInformation.ScheduleItems.Organizer?

            public var start: GetMeetingRoomsScheduleResponseBody.ScheduleInformation.ScheduleItems.Start?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.end?.validate()
                try self.organizer?.validate()
                try self.start?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.end != nil {
                    map["End"] = self.end?.toMap()
                }
                if self.eventId != nil {
                    map["EventId"] = self.eventId!
                }
                if self.organizer != nil {
                    map["Organizer"] = self.organizer?.toMap()
                }
                if self.start != nil {
                    map["Start"] = self.start?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("End") && dict["End"] != nil {
                    var model = GetMeetingRoomsScheduleResponseBody.ScheduleInformation.ScheduleItems.End()
                    model.fromMap(dict["End"] as! [String: Any])
                    self.end = model
                }
                if dict.keys.contains("EventId") && dict["EventId"] != nil {
                    self.eventId = dict["EventId"] as! String
                }
                if dict.keys.contains("Organizer") && dict["Organizer"] != nil {
                    var model = GetMeetingRoomsScheduleResponseBody.ScheduleInformation.ScheduleItems.Organizer()
                    model.fromMap(dict["Organizer"] as! [String: Any])
                    self.organizer = model
                }
                if dict.keys.contains("Start") && dict["Start"] != nil {
                    var model = GetMeetingRoomsScheduleResponseBody.ScheduleInformation.ScheduleItems.Start()
                    model.fromMap(dict["Start"] as! [String: Any])
                    self.start = model
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var error: String?

        public var roomId: String?

        public var scheduleItems: [GetMeetingRoomsScheduleResponseBody.ScheduleInformation.ScheduleItems]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.error != nil {
                map["Error"] = self.error!
            }
            if self.roomId != nil {
                map["RoomId"] = self.roomId!
            }
            if self.scheduleItems != nil {
                var tmp : [Any] = []
                for k in self.scheduleItems! {
                    tmp.append(k.toMap())
                }
                map["ScheduleItems"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Error") && dict["Error"] != nil {
                self.error = dict["Error"] as! String
            }
            if dict.keys.contains("RoomId") && dict["RoomId"] != nil {
                self.roomId = dict["RoomId"] as! String
            }
            if dict.keys.contains("ScheduleItems") && dict["ScheduleItems"] != nil {
                var tmp : [GetMeetingRoomsScheduleResponseBody.ScheduleInformation.ScheduleItems] = []
                for v in dict["ScheduleItems"] as! [Any] {
                    var model = GetMeetingRoomsScheduleResponseBody.ScheduleInformation.ScheduleItems()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.scheduleItems = tmp
            }
        }
    }
    public var requestId: String?

    public var scheduleInformation: [GetMeetingRoomsScheduleResponseBody.ScheduleInformation]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.scheduleInformation != nil {
            var tmp : [Any] = []
            for k in self.scheduleInformation! {
                tmp.append(k.toMap())
            }
            map["scheduleInformation"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("scheduleInformation") && dict["scheduleInformation"] != nil {
            var tmp : [GetMeetingRoomsScheduleResponseBody.ScheduleInformation] = []
            for v in dict["scheduleInformation"] as! [Any] {
                var model = GetMeetingRoomsScheduleResponseBody.ScheduleInformation()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scheduleInformation = tmp
        }
    }
}

public class GetMeetingRoomsScheduleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMeetingRoomsScheduleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMeetingRoomsScheduleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMineWorkspaceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetMineWorkspaceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetMineWorkspaceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetMineWorkspaceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetMineWorkspaceRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var request: [String: Any]?

    public var tenantContext: GetMineWorkspaceRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.request != nil {
            map["Request"] = self.request!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Request") && dict["Request"] != nil {
            self.request = dict["Request"] as! [String: Any]
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GetMineWorkspaceRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetMineWorkspaceShrinkRequest : Tea.TeaModel {
    public var requestShrink: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestShrink != nil {
            map["Request"] = self.requestShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Request") && dict["Request"] != nil {
            self.requestShrink = dict["Request"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetMineWorkspaceResponseBody : Tea.TeaModel {
    public class Workspace : Tea.TeaModel {
        public class Icon : Tea.TeaModel {
            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var corpId: String?

        public var cover: String?

        public var createTime: String?

        public var creatorId: String?

        public var description_: String?

        public var icon: GetMineWorkspaceResponseBody.Workspace.Icon?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var permissionRole: String?

        public var rootNodeId: String?

        public var teamId: String?

        public var type: String?

        public var url: String?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.icon?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.cover != nil {
                map["Cover"] = self.cover!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.icon != nil {
                map["Icon"] = self.icon?.toMap()
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.permissionRole != nil {
                map["PermissionRole"] = self.permissionRole!
            }
            if self.rootNodeId != nil {
                map["RootNodeId"] = self.rootNodeId!
            }
            if self.teamId != nil {
                map["TeamId"] = self.teamId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") && dict["CorpId"] != nil {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("Cover") && dict["Cover"] != nil {
                self.cover = dict["Cover"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Icon") && dict["Icon"] != nil {
                var model = GetMineWorkspaceResponseBody.Workspace.Icon()
                model.fromMap(dict["Icon"] as! [String: Any])
                self.icon = model
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") && dict["ModifierId"] != nil {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PermissionRole") && dict["PermissionRole"] != nil {
                self.permissionRole = dict["PermissionRole"] as! String
            }
            if dict.keys.contains("RootNodeId") && dict["RootNodeId"] != nil {
                self.rootNodeId = dict["RootNodeId"] as! String
            }
            if dict.keys.contains("TeamId") && dict["TeamId"] != nil {
                self.teamId = dict["TeamId"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var requestId: String?

    public var workspace: GetMineWorkspaceResponseBody.Workspace?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workspace?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.workspace != nil {
            map["workspace"] = self.workspace?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("workspace") && dict["workspace"] != nil {
            var model = GetMineWorkspaceResponseBody.Workspace()
            model.fromMap(dict["workspace"] as! [String: Any])
            self.workspace = model
        }
    }
}

public class GetMineWorkspaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMineWorkspaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMineWorkspaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNodeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetNodeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetNodeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetNodeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetNodeRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var nodeId: String?

    public var tenantContext: GetNodeRequest.TenantContext?

    public var withPermissionRole: Bool?

    public var withStatisticalInfo: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.withPermissionRole != nil {
            map["WithPermissionRole"] = self.withPermissionRole!
        }
        if self.withStatisticalInfo != nil {
            map["WithStatisticalInfo"] = self.withStatisticalInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GetNodeRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WithPermissionRole") && dict["WithPermissionRole"] != nil {
            self.withPermissionRole = dict["WithPermissionRole"] as! Bool
        }
        if dict.keys.contains("WithStatisticalInfo") && dict["WithStatisticalInfo"] != nil {
            self.withStatisticalInfo = dict["WithStatisticalInfo"] as! Bool
        }
    }
}

public class GetNodeShrinkRequest : Tea.TeaModel {
    public var nodeId: String?

    public var tenantContextShrink: String?

    public var withPermissionRole: Bool?

    public var withStatisticalInfo: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.withPermissionRole != nil {
            map["WithPermissionRole"] = self.withPermissionRole!
        }
        if self.withStatisticalInfo != nil {
            map["WithStatisticalInfo"] = self.withStatisticalInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WithPermissionRole") && dict["WithPermissionRole"] != nil {
            self.withPermissionRole = dict["WithPermissionRole"] as! Bool
        }
        if dict.keys.contains("WithStatisticalInfo") && dict["WithStatisticalInfo"] != nil {
            self.withStatisticalInfo = dict["WithStatisticalInfo"] as! Bool
        }
    }
}

public class GetNodeResponseBody : Tea.TeaModel {
    public class Node : Tea.TeaModel {
        public class StatisticalInfo : Tea.TeaModel {
            public var wordCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.wordCount != nil {
                    map["WordCount"] = self.wordCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("WordCount") && dict["WordCount"] != nil {
                    self.wordCount = dict["WordCount"] as! Int64
                }
            }
        }
        public var category: String?

        public var createTime: String?

        public var creatorId: String?

        public var extension_: String?

        public var hasChildren: Bool?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var nodeId: String?

        public var permissionRole: String?

        public var size: Int64?

        public var statisticalInfo: GetNodeResponseBody.Node.StatisticalInfo?

        public var type: String?

        public var url: String?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.statisticalInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.hasChildren != nil {
                map["HasChildren"] = self.hasChildren!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.permissionRole != nil {
                map["PermissionRole"] = self.permissionRole!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.statisticalInfo != nil {
                map["StatisticalInfo"] = self.statisticalInfo?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Extension") && dict["Extension"] != nil {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("HasChildren") && dict["HasChildren"] != nil {
                self.hasChildren = dict["HasChildren"] as! Bool
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") && dict["ModifierId"] != nil {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("PermissionRole") && dict["PermissionRole"] != nil {
                self.permissionRole = dict["PermissionRole"] as! String
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("StatisticalInfo") && dict["StatisticalInfo"] != nil {
                var model = GetNodeResponseBody.Node.StatisticalInfo()
                model.fromMap(dict["StatisticalInfo"] as! [String: Any])
                self.statisticalInfo = model
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var node: GetNodeResponseBody.Node?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.node?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.node != nil {
            map["node"] = self.node?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("node") && dict["node"] != nil {
            var model = GetNodeResponseBody.Node()
            model.fromMap(dict["node"] as! [String: Any])
            self.node = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetNodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNodeByUrlHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetNodeByUrlHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetNodeByUrlHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetNodeByUrlShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetNodeByUrlRequest : Tea.TeaModel {
    public class Option : Tea.TeaModel {
        public var withPermissionRole: Bool?

        public var withStatisticalInfo: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.withPermissionRole != nil {
                map["WithPermissionRole"] = self.withPermissionRole!
            }
            if self.withStatisticalInfo != nil {
                map["WithStatisticalInfo"] = self.withStatisticalInfo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("WithPermissionRole") && dict["WithPermissionRole"] != nil {
                self.withPermissionRole = dict["WithPermissionRole"] as! Bool
            }
            if dict.keys.contains("WithStatisticalInfo") && dict["WithStatisticalInfo"] != nil {
                self.withStatisticalInfo = dict["WithStatisticalInfo"] as! Bool
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var option: GetNodeByUrlRequest.Option?

    public var tenantContext: GetNodeByUrlRequest.TenantContext?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.option?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.option != nil {
            map["Option"] = self.option?.toMap()
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Option") && dict["Option"] != nil {
            var model = GetNodeByUrlRequest.Option()
            model.fromMap(dict["Option"] as! [String: Any])
            self.option = model
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GetNodeByUrlRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("Url") && dict["Url"] != nil {
            self.url = dict["Url"] as! String
        }
    }
}

public class GetNodeByUrlShrinkRequest : Tea.TeaModel {
    public var optionShrink: String?

    public var tenantContextShrink: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.optionShrink != nil {
            map["Option"] = self.optionShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Option") && dict["Option"] != nil {
            self.optionShrink = dict["Option"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("Url") && dict["Url"] != nil {
            self.url = dict["Url"] as! String
        }
    }
}

public class GetNodeByUrlResponseBody : Tea.TeaModel {
    public class Node : Tea.TeaModel {
        public class StatisticalInfo : Tea.TeaModel {
            public var wordCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.wordCount != nil {
                    map["WordCount"] = self.wordCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("WordCount") && dict["WordCount"] != nil {
                    self.wordCount = dict["WordCount"] as! Int64
                }
            }
        }
        public var category: String?

        public var createTime: String?

        public var creatorId: String?

        public var extension_: String?

        public var hasChildren: Bool?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var nodeId: String?

        public var permissionRole: String?

        public var size: Int64?

        public var statisticalInfo: GetNodeByUrlResponseBody.Node.StatisticalInfo?

        public var type: String?

        public var url: String?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.statisticalInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.hasChildren != nil {
                map["HasChildren"] = self.hasChildren!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.permissionRole != nil {
                map["PermissionRole"] = self.permissionRole!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.statisticalInfo != nil {
                map["StatisticalInfo"] = self.statisticalInfo?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Extension") && dict["Extension"] != nil {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("HasChildren") && dict["HasChildren"] != nil {
                self.hasChildren = dict["HasChildren"] as! Bool
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") && dict["ModifierId"] != nil {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("PermissionRole") && dict["PermissionRole"] != nil {
                self.permissionRole = dict["PermissionRole"] as! String
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("StatisticalInfo") && dict["StatisticalInfo"] != nil {
                var model = GetNodeByUrlResponseBody.Node.StatisticalInfo()
                model.fromMap(dict["StatisticalInfo"] as! [String: Any])
                self.statisticalInfo = model
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var node: GetNodeByUrlResponseBody.Node?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.node?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.node != nil {
            map["node"] = self.node?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("node") && dict["node"] != nil {
            var model = GetNodeByUrlResponseBody.Node()
            model.fromMap(dict["node"] as! [String: Any])
            self.node = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetNodeByUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNodeByUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetNodeByUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNodesHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetNodesHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetNodesHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetNodesShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetNodesRequest : Tea.TeaModel {
    public class Option : Tea.TeaModel {
        public var withPermissionRole: Bool?

        public var withStatisticalInfo: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.withPermissionRole != nil {
                map["WithPermissionRole"] = self.withPermissionRole!
            }
            if self.withStatisticalInfo != nil {
                map["WithStatisticalInfo"] = self.withStatisticalInfo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("WithPermissionRole") && dict["WithPermissionRole"] != nil {
                self.withPermissionRole = dict["WithPermissionRole"] as! Bool
            }
            if dict.keys.contains("WithStatisticalInfo") && dict["WithStatisticalInfo"] != nil {
                self.withStatisticalInfo = dict["WithStatisticalInfo"] as! Bool
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var nodeIds: [String]?

    public var option: GetNodesRequest.Option?

    public var tenantContext: GetNodesRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.option?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeIds != nil {
            map["NodeIds"] = self.nodeIds!
        }
        if self.option != nil {
            map["Option"] = self.option?.toMap()
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeIds") && dict["NodeIds"] != nil {
            self.nodeIds = dict["NodeIds"] as! [String]
        }
        if dict.keys.contains("Option") && dict["Option"] != nil {
            var model = GetNodesRequest.Option()
            model.fromMap(dict["Option"] as! [String: Any])
            self.option = model
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GetNodesRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetNodesShrinkRequest : Tea.TeaModel {
    public var nodeIdsShrink: String?

    public var optionShrink: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeIdsShrink != nil {
            map["NodeIds"] = self.nodeIdsShrink!
        }
        if self.optionShrink != nil {
            map["Option"] = self.optionShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeIds") && dict["NodeIds"] != nil {
            self.nodeIdsShrink = dict["NodeIds"] as! String
        }
        if dict.keys.contains("Option") && dict["Option"] != nil {
            self.optionShrink = dict["Option"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetNodesResponseBody : Tea.TeaModel {
    public class Nodes : Tea.TeaModel {
        public class StatisticalInfo : Tea.TeaModel {
            public var wordCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.wordCount != nil {
                    map["WordCount"] = self.wordCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("WordCount") && dict["WordCount"] != nil {
                    self.wordCount = dict["WordCount"] as! Int64
                }
            }
        }
        public var category: String?

        public var createTime: String?

        public var creatorId: String?

        public var extension_: String?

        public var hasChildren: Bool?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var nodeId: String?

        public var permissionRole: String?

        public var size: Int64?

        public var statisticalInfo: GetNodesResponseBody.Nodes.StatisticalInfo?

        public var type: String?

        public var url: String?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.statisticalInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.hasChildren != nil {
                map["HasChildren"] = self.hasChildren!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.permissionRole != nil {
                map["PermissionRole"] = self.permissionRole!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.statisticalInfo != nil {
                map["StatisticalInfo"] = self.statisticalInfo?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Extension") && dict["Extension"] != nil {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("HasChildren") && dict["HasChildren"] != nil {
                self.hasChildren = dict["HasChildren"] as! Bool
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") && dict["ModifierId"] != nil {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("PermissionRole") && dict["PermissionRole"] != nil {
                self.permissionRole = dict["PermissionRole"] as! String
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("StatisticalInfo") && dict["StatisticalInfo"] != nil {
                var model = GetNodesResponseBody.Nodes.StatisticalInfo()
                model.fromMap(dict["StatisticalInfo"] as! [String: Any])
                self.statisticalInfo = model
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var nodes: [GetNodesResponseBody.Nodes]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodes != nil {
            var tmp : [Any] = []
            for k in self.nodes! {
                tmp.append(k.toMap())
            }
            map["nodes"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("nodes") && dict["nodes"] != nil {
            var tmp : [GetNodesResponseBody.Nodes] = []
            for v in dict["nodes"] as! [Any] {
                var model = GetNodesResponseBody.Nodes()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.nodes = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetNodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNotifyMeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetNotifyMeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetNotifyMeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetNotifyMeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetNotifyMeRequest : Tea.TeaModel {
    public var appTypes: String?

    public var corpId: String?

    public var createFromTimeGMT: Int64?

    public var createToTimeGMT: Int64?

    public var instanceCreateFromTimeGMT: Int64?

    public var instanceCreateToTimeGMT: Int64?

    public var keyword: String?

    public var language: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var processCodes: String?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appTypes != nil {
            map["AppTypes"] = self.appTypes!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.createFromTimeGMT != nil {
            map["CreateFromTimeGMT"] = self.createFromTimeGMT!
        }
        if self.createToTimeGMT != nil {
            map["CreateToTimeGMT"] = self.createToTimeGMT!
        }
        if self.instanceCreateFromTimeGMT != nil {
            map["InstanceCreateFromTimeGMT"] = self.instanceCreateFromTimeGMT!
        }
        if self.instanceCreateToTimeGMT != nil {
            map["InstanceCreateToTimeGMT"] = self.instanceCreateToTimeGMT!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.processCodes != nil {
            map["ProcessCodes"] = self.processCodes!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppTypes") && dict["AppTypes"] != nil {
            self.appTypes = dict["AppTypes"] as! String
        }
        if dict.keys.contains("CorpId") && dict["CorpId"] != nil {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("CreateFromTimeGMT") && dict["CreateFromTimeGMT"] != nil {
            self.createFromTimeGMT = dict["CreateFromTimeGMT"] as! Int64
        }
        if dict.keys.contains("CreateToTimeGMT") && dict["CreateToTimeGMT"] != nil {
            self.createToTimeGMT = dict["CreateToTimeGMT"] as! Int64
        }
        if dict.keys.contains("InstanceCreateFromTimeGMT") && dict["InstanceCreateFromTimeGMT"] != nil {
            self.instanceCreateFromTimeGMT = dict["InstanceCreateFromTimeGMT"] as! Int64
        }
        if dict.keys.contains("InstanceCreateToTimeGMT") && dict["InstanceCreateToTimeGMT"] != nil {
            self.instanceCreateToTimeGMT = dict["InstanceCreateToTimeGMT"] as! Int64
        }
        if dict.keys.contains("Keyword") && dict["Keyword"] != nil {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProcessCodes") && dict["ProcessCodes"] != nil {
            self.processCodes = dict["ProcessCodes"] as! String
        }
        if dict.keys.contains("Token") && dict["Token"] != nil {
            self.token = dict["Token"] as! String
        }
    }
}

public class GetNotifyMeResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var activityId: String?

        public var appType: String?

        public var corpId: String?

        public var createTimeGMT: String?

        public var creatorUserId: String?

        public var formInstanceId: String?

        public var instStatus: String?

        public var mobileUrl: String?

        public var modifiedTimeGMT: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activityId != nil {
                map["ActivityId"] = self.activityId!
            }
            if self.appType != nil {
                map["AppType"] = self.appType!
            }
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.createTimeGMT != nil {
                map["CreateTimeGMT"] = self.createTimeGMT!
            }
            if self.creatorUserId != nil {
                map["CreatorUserId"] = self.creatorUserId!
            }
            if self.formInstanceId != nil {
                map["FormInstanceId"] = self.formInstanceId!
            }
            if self.instStatus != nil {
                map["InstStatus"] = self.instStatus!
            }
            if self.mobileUrl != nil {
                map["MobileUrl"] = self.mobileUrl!
            }
            if self.modifiedTimeGMT != nil {
                map["ModifiedTimeGMT"] = self.modifiedTimeGMT!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActivityId") && dict["ActivityId"] != nil {
                self.activityId = dict["ActivityId"] as! String
            }
            if dict.keys.contains("AppType") && dict["AppType"] != nil {
                self.appType = dict["AppType"] as! String
            }
            if dict.keys.contains("CorpId") && dict["CorpId"] != nil {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("CreateTimeGMT") && dict["CreateTimeGMT"] != nil {
                self.createTimeGMT = dict["CreateTimeGMT"] as! String
            }
            if dict.keys.contains("CreatorUserId") && dict["CreatorUserId"] != nil {
                self.creatorUserId = dict["CreatorUserId"] as! String
            }
            if dict.keys.contains("FormInstanceId") && dict["FormInstanceId"] != nil {
                self.formInstanceId = dict["FormInstanceId"] as! String
            }
            if dict.keys.contains("InstStatus") && dict["InstStatus"] != nil {
                self.instStatus = dict["InstStatus"] as! String
            }
            if dict.keys.contains("MobileUrl") && dict["MobileUrl"] != nil {
                self.mobileUrl = dict["MobileUrl"] as! String
            }
            if dict.keys.contains("ModifiedTimeGMT") && dict["ModifiedTimeGMT"] != nil {
                self.modifiedTimeGMT = dict["ModifiedTimeGMT"] as! String
            }
        }
    }
    public var data: [GetNotifyMeResponseBody.Data]?

    public var pageNumber: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [GetNotifyMeResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = GetNotifyMeResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetNotifyMeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNotifyMeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetNotifyMeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOpenUrlHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetOpenUrlHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetOpenUrlHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetOpenUrlShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetOpenUrlRequest : Tea.TeaModel {
    public var appType: String?

    public var fileUrl: String?

    public var language: String?

    public var systemToken: String?

    public var timeout: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.fileUrl != nil {
            map["FileUrl"] = self.fileUrl!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
            self.fileUrl = dict["FileUrl"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
            self.timeout = dict["Timeout"] as! Int64
        }
    }
}

public class GetOpenUrlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! String
        }
    }
}

public class GetOpenUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOpenUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetOpenUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOperationRecordsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetOperationRecordsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetOperationRecordsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetOperationRecordsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetOperationRecordsRequest : Tea.TeaModel {
    public var appType: String?

    public var language: String?

    public var processInstanceId: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.processInstanceId != nil {
            map["ProcessInstanceId"] = self.processInstanceId!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("ProcessInstanceId") && dict["ProcessInstanceId"] != nil {
            self.processInstanceId = dict["ProcessInstanceId"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class GetOperationRecordsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var action: String?

        public var actionExit: String?

        public var activeTimeGMT: String?

        public var activityId: String?

        public var dataId: Int64?

        public var digitalSign: String?

        public var files: String?

        public var operateTimeGMT: String?

        public var operateType: String?

        public var operatorDisplayName: String?

        public var operatorName: String?

        public var operatorNickName: String?

        public var operatorPhotoUrl: String?

        public var operatorStatus: String?

        public var operatorUserId: String?

        public var processInstanceId: String?

        public var remark: String?

        public var showName: String?

        public var size: Int32?

        public var taskExecuteType: String?

        public var taskHoldTimeGMT: Int64?

        public var taskId: String?

        public var taskType: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.actionExit != nil {
                map["ActionExit"] = self.actionExit!
            }
            if self.activeTimeGMT != nil {
                map["ActiveTimeGMT"] = self.activeTimeGMT!
            }
            if self.activityId != nil {
                map["ActivityId"] = self.activityId!
            }
            if self.dataId != nil {
                map["DataId"] = self.dataId!
            }
            if self.digitalSign != nil {
                map["DigitalSign"] = self.digitalSign!
            }
            if self.files != nil {
                map["Files"] = self.files!
            }
            if self.operateTimeGMT != nil {
                map["OperateTimeGMT"] = self.operateTimeGMT!
            }
            if self.operateType != nil {
                map["OperateType"] = self.operateType!
            }
            if self.operatorDisplayName != nil {
                map["OperatorDisplayName"] = self.operatorDisplayName!
            }
            if self.operatorName != nil {
                map["OperatorName"] = self.operatorName!
            }
            if self.operatorNickName != nil {
                map["OperatorNickName"] = self.operatorNickName!
            }
            if self.operatorPhotoUrl != nil {
                map["OperatorPhotoUrl"] = self.operatorPhotoUrl!
            }
            if self.operatorStatus != nil {
                map["OperatorStatus"] = self.operatorStatus!
            }
            if self.operatorUserId != nil {
                map["OperatorUserId"] = self.operatorUserId!
            }
            if self.processInstanceId != nil {
                map["ProcessInstanceId"] = self.processInstanceId!
            }
            if self.remark != nil {
                map["Remark"] = self.remark!
            }
            if self.showName != nil {
                map["ShowName"] = self.showName!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.taskExecuteType != nil {
                map["TaskExecuteType"] = self.taskExecuteType!
            }
            if self.taskHoldTimeGMT != nil {
                map["TaskHoldTimeGMT"] = self.taskHoldTimeGMT!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Action") && dict["Action"] != nil {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("ActionExit") && dict["ActionExit"] != nil {
                self.actionExit = dict["ActionExit"] as! String
            }
            if dict.keys.contains("ActiveTimeGMT") && dict["ActiveTimeGMT"] != nil {
                self.activeTimeGMT = dict["ActiveTimeGMT"] as! String
            }
            if dict.keys.contains("ActivityId") && dict["ActivityId"] != nil {
                self.activityId = dict["ActivityId"] as! String
            }
            if dict.keys.contains("DataId") && dict["DataId"] != nil {
                self.dataId = dict["DataId"] as! Int64
            }
            if dict.keys.contains("DigitalSign") && dict["DigitalSign"] != nil {
                self.digitalSign = dict["DigitalSign"] as! String
            }
            if dict.keys.contains("Files") && dict["Files"] != nil {
                self.files = dict["Files"] as! String
            }
            if dict.keys.contains("OperateTimeGMT") && dict["OperateTimeGMT"] != nil {
                self.operateTimeGMT = dict["OperateTimeGMT"] as! String
            }
            if dict.keys.contains("OperateType") && dict["OperateType"] != nil {
                self.operateType = dict["OperateType"] as! String
            }
            if dict.keys.contains("OperatorDisplayName") && dict["OperatorDisplayName"] != nil {
                self.operatorDisplayName = dict["OperatorDisplayName"] as! String
            }
            if dict.keys.contains("OperatorName") && dict["OperatorName"] != nil {
                self.operatorName = dict["OperatorName"] as! String
            }
            if dict.keys.contains("OperatorNickName") && dict["OperatorNickName"] != nil {
                self.operatorNickName = dict["OperatorNickName"] as! String
            }
            if dict.keys.contains("OperatorPhotoUrl") && dict["OperatorPhotoUrl"] != nil {
                self.operatorPhotoUrl = dict["OperatorPhotoUrl"] as! String
            }
            if dict.keys.contains("OperatorStatus") && dict["OperatorStatus"] != nil {
                self.operatorStatus = dict["OperatorStatus"] as! String
            }
            if dict.keys.contains("OperatorUserId") && dict["OperatorUserId"] != nil {
                self.operatorUserId = dict["OperatorUserId"] as! String
            }
            if dict.keys.contains("ProcessInstanceId") && dict["ProcessInstanceId"] != nil {
                self.processInstanceId = dict["ProcessInstanceId"] as! String
            }
            if dict.keys.contains("Remark") && dict["Remark"] != nil {
                self.remark = dict["Remark"] as! String
            }
            if dict.keys.contains("ShowName") && dict["ShowName"] != nil {
                self.showName = dict["ShowName"] as! String
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int32
            }
            if dict.keys.contains("TaskExecuteType") && dict["TaskExecuteType"] != nil {
                self.taskExecuteType = dict["TaskExecuteType"] as! String
            }
            if dict.keys.contains("TaskHoldTimeGMT") && dict["TaskHoldTimeGMT"] != nil {
                self.taskHoldTimeGMT = dict["TaskHoldTimeGMT"] as! Int64
            }
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
                self.taskType = dict["TaskType"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [GetOperationRecordsResponseBody.Result]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            var tmp : [GetOperationRecordsResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = GetOperationRecordsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetOperationRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOperationRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetOperationRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetProcessDefinitionHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetProcessDefinitionHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetProcessDefinitionHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetProcessDefinitionShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetProcessDefinitionRequest : Tea.TeaModel {
    public var appType: String?

    public var corpId: String?

    public var groupId: String?

    public var language: String?

    public var nameSpace: String?

    public var orderNumber: String?

    public var processInstanceId: String?

    public var systemToken: String?

    public var systemType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.nameSpace != nil {
            map["NameSpace"] = self.nameSpace!
        }
        if self.orderNumber != nil {
            map["OrderNumber"] = self.orderNumber!
        }
        if self.processInstanceId != nil {
            map["ProcessInstanceId"] = self.processInstanceId!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.systemType != nil {
            map["SystemType"] = self.systemType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("CorpId") && dict["CorpId"] != nil {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("NameSpace") && dict["NameSpace"] != nil {
            self.nameSpace = dict["NameSpace"] as! String
        }
        if dict.keys.contains("OrderNumber") && dict["OrderNumber"] != nil {
            self.orderNumber = dict["OrderNumber"] as! String
        }
        if dict.keys.contains("ProcessInstanceId") && dict["ProcessInstanceId"] != nil {
            self.processInstanceId = dict["ProcessInstanceId"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("SystemType") && dict["SystemType"] != nil {
            self.systemType = dict["SystemType"] as! String
        }
    }
}

public class GetProcessDefinitionResponseBody : Tea.TeaModel {
    public class Originator : Tea.TeaModel {
        public class MasterDataDepartments : Tea.TeaModel {
            public var deptName: String?

            public var deptNameInEnglish: String?

            public var deptNo: String?

            public var deptPath: String?

            public var humanSourceGroupOrderNumber: String?

            public var humanSourceGroupWorkNo: String?

            public var id: Int64?

            public var masterWorkNo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.deptName != nil {
                    map["DeptName"] = self.deptName!
                }
                if self.deptNameInEnglish != nil {
                    map["DeptNameInEnglish"] = self.deptNameInEnglish!
                }
                if self.deptNo != nil {
                    map["DeptNo"] = self.deptNo!
                }
                if self.deptPath != nil {
                    map["DeptPath"] = self.deptPath!
                }
                if self.humanSourceGroupOrderNumber != nil {
                    map["HumanSourceGroupOrderNumber"] = self.humanSourceGroupOrderNumber!
                }
                if self.humanSourceGroupWorkNo != nil {
                    map["HumanSourceGroupWorkNo"] = self.humanSourceGroupWorkNo!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.masterWorkNo != nil {
                    map["MasterWorkNo"] = self.masterWorkNo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DeptName") && dict["DeptName"] != nil {
                    self.deptName = dict["DeptName"] as! String
                }
                if dict.keys.contains("DeptNameInEnglish") && dict["DeptNameInEnglish"] != nil {
                    self.deptNameInEnglish = dict["DeptNameInEnglish"] as! String
                }
                if dict.keys.contains("DeptNo") && dict["DeptNo"] != nil {
                    self.deptNo = dict["DeptNo"] as! String
                }
                if dict.keys.contains("DeptPath") && dict["DeptPath"] != nil {
                    self.deptPath = dict["DeptPath"] as! String
                }
                if dict.keys.contains("HumanSourceGroupOrderNumber") && dict["HumanSourceGroupOrderNumber"] != nil {
                    self.humanSourceGroupOrderNumber = dict["HumanSourceGroupOrderNumber"] as! String
                }
                if dict.keys.contains("HumanSourceGroupWorkNo") && dict["HumanSourceGroupWorkNo"] != nil {
                    self.humanSourceGroupWorkNo = dict["HumanSourceGroupWorkNo"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("MasterWorkNo") && dict["MasterWorkNo"] != nil {
                    self.masterWorkNo = dict["MasterWorkNo"] as! String
                }
            }
        }
        public var departmentDescription: String?

        public var displayEnName: String?

        public var displayName: String?

        public var masterDataDepartments: [GetProcessDefinitionResponseBody.Originator.MasterDataDepartments]?

        public var orderNumber: String?

        public var personalPhoto: String?

        public var status: String?

        public var tbWang: String?

        public var userId: String?

        public var userInfo: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.departmentDescription != nil {
                map["DepartmentDescription"] = self.departmentDescription!
            }
            if self.displayEnName != nil {
                map["DisplayEnName"] = self.displayEnName!
            }
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.masterDataDepartments != nil {
                var tmp : [Any] = []
                for k in self.masterDataDepartments! {
                    tmp.append(k.toMap())
                }
                map["MasterDataDepartments"] = tmp
            }
            if self.orderNumber != nil {
                map["OrderNumber"] = self.orderNumber!
            }
            if self.personalPhoto != nil {
                map["PersonalPhoto"] = self.personalPhoto!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tbWang != nil {
                map["TbWang"] = self.tbWang!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userInfo != nil {
                map["UserInfo"] = self.userInfo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DepartmentDescription") && dict["DepartmentDescription"] != nil {
                self.departmentDescription = dict["DepartmentDescription"] as! String
            }
            if dict.keys.contains("DisplayEnName") && dict["DisplayEnName"] != nil {
                self.displayEnName = dict["DisplayEnName"] as! String
            }
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("MasterDataDepartments") && dict["MasterDataDepartments"] != nil {
                var tmp : [GetProcessDefinitionResponseBody.Originator.MasterDataDepartments] = []
                for v in dict["MasterDataDepartments"] as! [Any] {
                    var model = GetProcessDefinitionResponseBody.Originator.MasterDataDepartments()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.masterDataDepartments = tmp
            }
            if dict.keys.contains("OrderNumber") && dict["OrderNumber"] != nil {
                self.orderNumber = dict["OrderNumber"] as! String
            }
            if dict.keys.contains("PersonalPhoto") && dict["PersonalPhoto"] != nil {
                self.personalPhoto = dict["PersonalPhoto"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TbWang") && dict["TbWang"] != nil {
                self.tbWang = dict["TbWang"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserInfo") && dict["UserInfo"] != nil {
                self.userInfo = dict["UserInfo"] as! String
            }
        }
    }
    public class Owners : Tea.TeaModel {
        public class MasterDataDepartments : Tea.TeaModel {
            public var deptName: String?

            public var deptNameInEnglish: String?

            public var deptNo: String?

            public var deptPath: String?

            public var humanSourceGroupOrderNumber: String?

            public var humanSourceGroupWorkNo: String?

            public var id: Int64?

            public var masterWorkNo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.deptName != nil {
                    map["DeptName"] = self.deptName!
                }
                if self.deptNameInEnglish != nil {
                    map["DeptNameInEnglish"] = self.deptNameInEnglish!
                }
                if self.deptNo != nil {
                    map["DeptNo"] = self.deptNo!
                }
                if self.deptPath != nil {
                    map["DeptPath"] = self.deptPath!
                }
                if self.humanSourceGroupOrderNumber != nil {
                    map["HumanSourceGroupOrderNumber"] = self.humanSourceGroupOrderNumber!
                }
                if self.humanSourceGroupWorkNo != nil {
                    map["HumanSourceGroupWorkNo"] = self.humanSourceGroupWorkNo!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.masterWorkNo != nil {
                    map["MasterWorkNo"] = self.masterWorkNo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DeptName") && dict["DeptName"] != nil {
                    self.deptName = dict["DeptName"] as! String
                }
                if dict.keys.contains("DeptNameInEnglish") && dict["DeptNameInEnglish"] != nil {
                    self.deptNameInEnglish = dict["DeptNameInEnglish"] as! String
                }
                if dict.keys.contains("DeptNo") && dict["DeptNo"] != nil {
                    self.deptNo = dict["DeptNo"] as! String
                }
                if dict.keys.contains("DeptPath") && dict["DeptPath"] != nil {
                    self.deptPath = dict["DeptPath"] as! String
                }
                if dict.keys.contains("HumanSourceGroupOrderNumber") && dict["HumanSourceGroupOrderNumber"] != nil {
                    self.humanSourceGroupOrderNumber = dict["HumanSourceGroupOrderNumber"] as! String
                }
                if dict.keys.contains("HumanSourceGroupWorkNo") && dict["HumanSourceGroupWorkNo"] != nil {
                    self.humanSourceGroupWorkNo = dict["HumanSourceGroupWorkNo"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("MasterWorkNo") && dict["MasterWorkNo"] != nil {
                    self.masterWorkNo = dict["MasterWorkNo"] as! String
                }
            }
        }
        public var departmentDescription: String?

        public var displayEnName: String?

        public var displayName: String?

        public var masterDataDepartments: [GetProcessDefinitionResponseBody.Owners.MasterDataDepartments]?

        public var orderNumber: String?

        public var personalPhoto: String?

        public var status: String?

        public var tbWang: String?

        public var userId: String?

        public var userInfo: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.departmentDescription != nil {
                map["DepartmentDescription"] = self.departmentDescription!
            }
            if self.displayEnName != nil {
                map["DisplayEnName"] = self.displayEnName!
            }
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.masterDataDepartments != nil {
                var tmp : [Any] = []
                for k in self.masterDataDepartments! {
                    tmp.append(k.toMap())
                }
                map["MasterDataDepartments"] = tmp
            }
            if self.orderNumber != nil {
                map["OrderNumber"] = self.orderNumber!
            }
            if self.personalPhoto != nil {
                map["PersonalPhoto"] = self.personalPhoto!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tbWang != nil {
                map["TbWang"] = self.tbWang!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userInfo != nil {
                map["UserInfo"] = self.userInfo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DepartmentDescription") && dict["DepartmentDescription"] != nil {
                self.departmentDescription = dict["DepartmentDescription"] as! String
            }
            if dict.keys.contains("DisplayEnName") && dict["DisplayEnName"] != nil {
                self.displayEnName = dict["DisplayEnName"] as! String
            }
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("MasterDataDepartments") && dict["MasterDataDepartments"] != nil {
                var tmp : [GetProcessDefinitionResponseBody.Owners.MasterDataDepartments] = []
                for v in dict["MasterDataDepartments"] as! [Any] {
                    var model = GetProcessDefinitionResponseBody.Owners.MasterDataDepartments()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.masterDataDepartments = tmp
            }
            if dict.keys.contains("OrderNumber") && dict["OrderNumber"] != nil {
                self.orderNumber = dict["OrderNumber"] as! String
            }
            if dict.keys.contains("PersonalPhoto") && dict["PersonalPhoto"] != nil {
                self.personalPhoto = dict["PersonalPhoto"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TbWang") && dict["TbWang"] != nil {
                self.tbWang = dict["TbWang"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserInfo") && dict["UserInfo"] != nil {
                self.userInfo = dict["UserInfo"] as! String
            }
        }
    }
    public class Tasks : Tea.TeaModel {
        public class Activity : Tea.TeaModel {
            public var activityId: String?

            public var activityInstanceStatus: String?

            public var activityName: String?

            public var activityNameInEnglish: String?

            public var id: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activityId != nil {
                    map["ActivityId"] = self.activityId!
                }
                if self.activityInstanceStatus != nil {
                    map["ActivityInstanceStatus"] = self.activityInstanceStatus!
                }
                if self.activityName != nil {
                    map["ActivityName"] = self.activityName!
                }
                if self.activityNameInEnglish != nil {
                    map["ActivityNameInEnglish"] = self.activityNameInEnglish!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActivityId") && dict["ActivityId"] != nil {
                    self.activityId = dict["ActivityId"] as! String
                }
                if dict.keys.contains("ActivityInstanceStatus") && dict["ActivityInstanceStatus"] != nil {
                    self.activityInstanceStatus = dict["ActivityInstanceStatus"] as! String
                }
                if dict.keys.contains("ActivityName") && dict["ActivityName"] != nil {
                    self.activityName = dict["ActivityName"] as! String
                }
                if dict.keys.contains("ActivityNameInEnglish") && dict["ActivityNameInEnglish"] != nil {
                    self.activityNameInEnglish = dict["ActivityNameInEnglish"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
            }
        }
        public var actionerId: String?

        public var activity: GetProcessDefinitionResponseBody.Tasks.Activity?

        public var status: String?

        public var taskId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.activity?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actionerId != nil {
                map["ActionerId"] = self.actionerId!
            }
            if self.activity != nil {
                map["Activity"] = self.activity?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActionerId") && dict["ActionerId"] != nil {
                self.actionerId = dict["ActionerId"] as! String
            }
            if dict.keys.contains("Activity") && dict["Activity"] != nil {
                var model = GetProcessDefinitionResponseBody.Tasks.Activity()
                model.fromMap(dict["Activity"] as! [String: Any])
                self.activity = model
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! Int64
            }
        }
    }
    public var formUuid: String?

    public var originator: GetProcessDefinitionResponseBody.Originator?

    public var outResult: String?

    public var owners: [GetProcessDefinitionResponseBody.Owners]?

    public var processId: String?

    public var processInstanceId: String?

    public var requestId: String?

    public var status: String?

    public var tasks: [GetProcessDefinitionResponseBody.Tasks]?

    public var title: String?

    public var variables: [String: Any]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.originator?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.formUuid != nil {
            map["formUuid"] = self.formUuid!
        }
        if self.originator != nil {
            map["originator"] = self.originator?.toMap()
        }
        if self.outResult != nil {
            map["outResult"] = self.outResult!
        }
        if self.owners != nil {
            var tmp : [Any] = []
            for k in self.owners! {
                tmp.append(k.toMap())
            }
            map["owners"] = tmp
        }
        if self.processId != nil {
            map["processId"] = self.processId!
        }
        if self.processInstanceId != nil {
            map["processInstanceId"] = self.processInstanceId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.tasks != nil {
            var tmp : [Any] = []
            for k in self.tasks! {
                tmp.append(k.toMap())
            }
            map["tasks"] = tmp
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        if self.variables != nil {
            map["variables"] = self.variables!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("formUuid") && dict["formUuid"] != nil {
            self.formUuid = dict["formUuid"] as! String
        }
        if dict.keys.contains("originator") && dict["originator"] != nil {
            var model = GetProcessDefinitionResponseBody.Originator()
            model.fromMap(dict["originator"] as! [String: Any])
            self.originator = model
        }
        if dict.keys.contains("outResult") && dict["outResult"] != nil {
            self.outResult = dict["outResult"] as! String
        }
        if dict.keys.contains("owners") && dict["owners"] != nil {
            var tmp : [GetProcessDefinitionResponseBody.Owners] = []
            for v in dict["owners"] as! [Any] {
                var model = GetProcessDefinitionResponseBody.Owners()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.owners = tmp
        }
        if dict.keys.contains("processId") && dict["processId"] != nil {
            self.processId = dict["processId"] as! String
        }
        if dict.keys.contains("processInstanceId") && dict["processInstanceId"] != nil {
            self.processInstanceId = dict["processInstanceId"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("status") && dict["status"] != nil {
            self.status = dict["status"] as! String
        }
        if dict.keys.contains("tasks") && dict["tasks"] != nil {
            var tmp : [GetProcessDefinitionResponseBody.Tasks] = []
            for v in dict["tasks"] as! [Any] {
                var model = GetProcessDefinitionResponseBody.Tasks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tasks = tmp
        }
        if dict.keys.contains("title") && dict["title"] != nil {
            self.title = dict["title"] as! String
        }
        if dict.keys.contains("variables") && dict["variables"] != nil {
            self.variables = dict["variables"] as! [String: Any]
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetProcessDefinitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetProcessDefinitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetProcessDefinitionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRangeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetRangeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetRangeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetRangeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetRangeRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var rangeAddress: String?

    public var select: String?

    public var sheetId: String?

    public var tenantContext: GetRangeRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.rangeAddress != nil {
            map["RangeAddress"] = self.rangeAddress!
        }
        if self.select != nil {
            map["Select"] = self.select!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RangeAddress") && dict["RangeAddress"] != nil {
            self.rangeAddress = dict["RangeAddress"] as! String
        }
        if dict.keys.contains("Select") && dict["Select"] != nil {
            self.select = dict["Select"] as! String
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GetRangeRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class GetRangeShrinkRequest : Tea.TeaModel {
    public var rangeAddress: String?

    public var select: String?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.rangeAddress != nil {
            map["RangeAddress"] = self.rangeAddress!
        }
        if self.select != nil {
            map["Select"] = self.select!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RangeAddress") && dict["RangeAddress"] != nil {
            self.rangeAddress = dict["RangeAddress"] as! String
        }
        if dict.keys.contains("Select") && dict["Select"] != nil {
            self.select = dict["Select"] as! String
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class GetRangeResponseBody : Tea.TeaModel {
    public class BackgroundColors : Tea.TeaModel {
        public var red: Int32?

        public var green: Int32?

        public var blue: Int32?

        public var hexString: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.red != nil {
                map["Red"] = self.red!
            }
            if self.green != nil {
                map["Green"] = self.green!
            }
            if self.blue != nil {
                map["Blue"] = self.blue!
            }
            if self.hexString != nil {
                map["HexString"] = self.hexString!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Red") && dict["Red"] != nil {
                self.red = dict["Red"] as! Int32
            }
            if dict.keys.contains("Green") && dict["Green"] != nil {
                self.green = dict["Green"] as! Int32
            }
            if dict.keys.contains("Blue") && dict["Blue"] != nil {
                self.blue = dict["Blue"] as! Int32
            }
            if dict.keys.contains("HexString") && dict["HexString"] != nil {
                self.hexString = dict["HexString"] as! String
            }
        }
    }
    public var backgroundColors: [[GetRangeResponseBody.BackgroundColors]]?

    public var displayValues: [[String]]?

    public var formulas: [[String]]?

    public var requestId: String?

    public var values: [[Any]]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backgroundColors != nil {
            var tmp : [Any] = []
            for k in self.backgroundColors! {
                var l1 : [Any] = []
                for k1 in k {
                    l1.append(k1.toMap())
                }
                tmp.append(l1)
            }
            map["backgroundColors"] = tmp
        }
        if self.displayValues != nil {
            map["displayValues"] = self.displayValues!
        }
        if self.formulas != nil {
            map["formulas"] = self.formulas!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.values != nil {
            map["values"] = self.values!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("backgroundColors") && dict["backgroundColors"] != nil {
            var tmp : [[GetRangeResponseBody.BackgroundColors]] = []
            for v in dict["backgroundColors"] as! [Any] {
                var l1 : [GetRangeResponseBody.BackgroundColors] = []
                for v1 in v as! [Any] {
                    var model = GetRangeResponseBody.BackgroundColors()
                    if v1 != nil {
                        model.fromMap(v1 as! [String: Any])
                    }
                    l1.append(model)
                }
                tmp.append(l1)
            }
            self.backgroundColors = tmp
        }
        if dict.keys.contains("displayValues") && dict["displayValues"] != nil {
            self.displayValues = dict["displayValues"] as! [[String]]
        }
        if dict.keys.contains("formulas") && dict["formulas"] != nil {
            self.formulas = dict["formulas"] as! [[String]]
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("values") && dict["values"] != nil {
            self.values = dict["values"] as! [[Any]]
        }
    }
}

public class GetRangeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRangeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetRangeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetReportTemplateByNameHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetReportTemplateByNameHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetReportTemplateByNameHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetReportTemplateByNameShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetReportTemplateByNameRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var templateName: String?

    public var tenantContext: GetReportTemplateByNameRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GetReportTemplateByNameRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetReportTemplateByNameShrinkRequest : Tea.TeaModel {
    public var templateName: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetReportTemplateByNameResponseBody : Tea.TeaModel {
    public class DefaultReceivedConvs : Tea.TeaModel {
        public var conversationId: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.conversationId != nil {
                map["ConversationId"] = self.conversationId!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConversationId") && dict["ConversationId"] != nil {
                self.conversationId = dict["ConversationId"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
        }
    }
    public class DefaultReceivers : Tea.TeaModel {
        public var userName: String?

        public var userid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            if self.userid != nil {
                map["Userid"] = self.userid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UserName") && dict["UserName"] != nil {
                self.userName = dict["UserName"] as! String
            }
            if dict.keys.contains("Userid") && dict["Userid"] != nil {
                self.userid = dict["Userid"] as! String
            }
        }
    }
    public class Fields : Tea.TeaModel {
        public var fieldName: String?

        public var sort: Int64?

        public var type: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldName != nil {
                map["FieldName"] = self.fieldName!
            }
            if self.sort != nil {
                map["Sort"] = self.sort!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FieldName") && dict["FieldName"] != nil {
                self.fieldName = dict["FieldName"] as! String
            }
            if dict.keys.contains("Sort") && dict["Sort"] != nil {
                self.sort = dict["Sort"] as! Int64
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! Int64
            }
        }
    }
    public var defaultReceivedConvs: [GetReportTemplateByNameResponseBody.DefaultReceivedConvs]?

    public var defaultReceivers: [GetReportTemplateByNameResponseBody.DefaultReceivers]?

    public var fields: [GetReportTemplateByNameResponseBody.Fields]?

    public var id: String?

    public var name: String?

    public var requestId: String?

    public var userName: String?

    public var userid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.defaultReceivedConvs != nil {
            var tmp : [Any] = []
            for k in self.defaultReceivedConvs! {
                tmp.append(k.toMap())
            }
            map["defaultReceivedConvs"] = tmp
        }
        if self.defaultReceivers != nil {
            var tmp : [Any] = []
            for k in self.defaultReceivers! {
                tmp.append(k.toMap())
            }
            map["defaultReceivers"] = tmp
        }
        if self.fields != nil {
            var tmp : [Any] = []
            for k in self.fields! {
                tmp.append(k.toMap())
            }
            map["fields"] = tmp
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.userName != nil {
            map["userName"] = self.userName!
        }
        if self.userid != nil {
            map["userid"] = self.userid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("defaultReceivedConvs") && dict["defaultReceivedConvs"] != nil {
            var tmp : [GetReportTemplateByNameResponseBody.DefaultReceivedConvs] = []
            for v in dict["defaultReceivedConvs"] as! [Any] {
                var model = GetReportTemplateByNameResponseBody.DefaultReceivedConvs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.defaultReceivedConvs = tmp
        }
        if dict.keys.contains("defaultReceivers") && dict["defaultReceivers"] != nil {
            var tmp : [GetReportTemplateByNameResponseBody.DefaultReceivers] = []
            for v in dict["defaultReceivers"] as! [Any] {
                var model = GetReportTemplateByNameResponseBody.DefaultReceivers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.defaultReceivers = tmp
        }
        if dict.keys.contains("fields") && dict["fields"] != nil {
            var tmp : [GetReportTemplateByNameResponseBody.Fields] = []
            for v in dict["fields"] as! [Any] {
                var model = GetReportTemplateByNameResponseBody.Fields()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fields = tmp
        }
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("name") && dict["name"] != nil {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("userName") && dict["userName"] != nil {
            self.userName = dict["userName"] as! String
        }
        if dict.keys.contains("userid") && dict["userid"] != nil {
            self.userid = dict["userid"] as! String
        }
    }
}

public class GetReportTemplateByNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetReportTemplateByNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetReportTemplateByNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetReportUnReadCountHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetReportUnReadCountHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetReportUnReadCountHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetReportUnReadCountShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetReportUnReadCountRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var request: [String: Any]?

    public var tenantContext: GetReportUnReadCountRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.request != nil {
            map["Request"] = self.request!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Request") && dict["Request"] != nil {
            self.request = dict["Request"] as! [String: Any]
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GetReportUnReadCountRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetReportUnReadCountShrinkRequest : Tea.TeaModel {
    public var requestShrink: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestShrink != nil {
            map["Request"] = self.requestShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Request") && dict["Request"] != nil {
            self.requestShrink = dict["Request"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetReportUnReadCountResponseBody : Tea.TeaModel {
    public var count: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["count"] = self.count!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("count") && dict["count"] != nil {
            self.count = dict["count"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetReportUnReadCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetReportUnReadCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetReportUnReadCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRunningTasksHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetRunningTasksHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetRunningTasksHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetRunningTasksShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetRunningTasksRequest : Tea.TeaModel {
    public var appType: String?

    public var language: String?

    public var processCodes: String?

    public var processInstanceId: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.processCodes != nil {
            map["ProcessCodes"] = self.processCodes!
        }
        if self.processInstanceId != nil {
            map["ProcessInstanceId"] = self.processInstanceId!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("ProcessCodes") && dict["ProcessCodes"] != nil {
            self.processCodes = dict["ProcessCodes"] as! String
        }
        if dict.keys.contains("ProcessInstanceId") && dict["ProcessInstanceId"] != nil {
            self.processInstanceId = dict["ProcessInstanceId"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class GetRunningTasksResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var activeTimeGMT: String?

        public var activityId: String?

        public var actualActionerId: String?

        public var createTimeGMT: String?

        public var finishTimeGMT: String?

        public var originatorId: String?

        public var processInstanceId: String?

        public var status: String?

        public var taskId: String?

        public var taskType: String?

        public var title: String?

        public var titleInEnglish: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activeTimeGMT != nil {
                map["ActiveTimeGMT"] = self.activeTimeGMT!
            }
            if self.activityId != nil {
                map["ActivityId"] = self.activityId!
            }
            if self.actualActionerId != nil {
                map["ActualActionerId"] = self.actualActionerId!
            }
            if self.createTimeGMT != nil {
                map["CreateTimeGMT"] = self.createTimeGMT!
            }
            if self.finishTimeGMT != nil {
                map["FinishTimeGMT"] = self.finishTimeGMT!
            }
            if self.originatorId != nil {
                map["OriginatorId"] = self.originatorId!
            }
            if self.processInstanceId != nil {
                map["ProcessInstanceId"] = self.processInstanceId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.titleInEnglish != nil {
                map["TitleInEnglish"] = self.titleInEnglish!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActiveTimeGMT") && dict["ActiveTimeGMT"] != nil {
                self.activeTimeGMT = dict["ActiveTimeGMT"] as! String
            }
            if dict.keys.contains("ActivityId") && dict["ActivityId"] != nil {
                self.activityId = dict["ActivityId"] as! String
            }
            if dict.keys.contains("ActualActionerId") && dict["ActualActionerId"] != nil {
                self.actualActionerId = dict["ActualActionerId"] as! String
            }
            if dict.keys.contains("CreateTimeGMT") && dict["CreateTimeGMT"] != nil {
                self.createTimeGMT = dict["CreateTimeGMT"] as! String
            }
            if dict.keys.contains("FinishTimeGMT") && dict["FinishTimeGMT"] != nil {
                self.finishTimeGMT = dict["FinishTimeGMT"] as! String
            }
            if dict.keys.contains("OriginatorId") && dict["OriginatorId"] != nil {
                self.originatorId = dict["OriginatorId"] as! String
            }
            if dict.keys.contains("ProcessInstanceId") && dict["ProcessInstanceId"] != nil {
                self.processInstanceId = dict["ProcessInstanceId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
                self.taskType = dict["TaskType"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("TitleInEnglish") && dict["TitleInEnglish"] != nil {
                self.titleInEnglish = dict["TitleInEnglish"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [GetRunningTasksResponseBody.Result]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            var tmp : [GetRunningTasksResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = GetRunningTasksResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetRunningTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRunningTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetRunningTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSheetHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetSheetHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetSheetHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetSheetShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetSheetRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var sheetId: String?

    public var tenantContext: GetSheetRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GetSheetRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class GetSheetShrinkRequest : Tea.TeaModel {
    public var sheetId: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class GetSheetResponseBody : Tea.TeaModel {
    public var columnCount: Int64?

    public var id: String?

    public var lastNonEmptyColumn: Int64?

    public var lastNonEmptyRow: Int64?

    public var name: String?

    public var requestId: String?

    public var rowCount: Int64?

    public var visibility: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnCount != nil {
            map["columnCount"] = self.columnCount!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.lastNonEmptyColumn != nil {
            map["lastNonEmptyColumn"] = self.lastNonEmptyColumn!
        }
        if self.lastNonEmptyRow != nil {
            map["lastNonEmptyRow"] = self.lastNonEmptyRow!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.rowCount != nil {
            map["rowCount"] = self.rowCount!
        }
        if self.visibility != nil {
            map["visibility"] = self.visibility!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("columnCount") && dict["columnCount"] != nil {
            self.columnCount = dict["columnCount"] as! Int64
        }
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("lastNonEmptyColumn") && dict["lastNonEmptyColumn"] != nil {
            self.lastNonEmptyColumn = dict["lastNonEmptyColumn"] as! Int64
        }
        if dict.keys.contains("lastNonEmptyRow") && dict["lastNonEmptyRow"] != nil {
            self.lastNonEmptyRow = dict["lastNonEmptyRow"] as! Int64
        }
        if dict.keys.contains("name") && dict["name"] != nil {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("rowCount") && dict["rowCount"] != nil {
            self.rowCount = dict["rowCount"] as! Int64
        }
        if dict.keys.contains("visibility") && dict["visibility"] != nil {
            self.visibility = dict["visibility"] as! String
        }
    }
}

public class GetSheetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSheetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetSheetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSpaceDirectoriesHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetSpaceDirectoriesHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetSpaceDirectoriesHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetSpaceDirectoriesShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetSpaceDirectoriesRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var dentryId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var spaceId: String?

    public var tenantContext: GetSpaceDirectoriesRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dentryId != nil {
            map["DentryId"] = self.dentryId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.spaceId != nil {
            map["SpaceId"] = self.spaceId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DentryId") && dict["DentryId"] != nil {
            self.dentryId = dict["DentryId"] as! String
        }
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("SpaceId") && dict["SpaceId"] != nil {
            self.spaceId = dict["SpaceId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GetSpaceDirectoriesRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetSpaceDirectoriesShrinkRequest : Tea.TeaModel {
    public var dentryId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var spaceId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dentryId != nil {
            map["DentryId"] = self.dentryId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.spaceId != nil {
            map["SpaceId"] = self.spaceId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DentryId") && dict["DentryId"] != nil {
            self.dentryId = dict["DentryId"] as! String
        }
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("SpaceId") && dict["SpaceId"] != nil {
            self.spaceId = dict["SpaceId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetSpaceDirectoriesResponseBody : Tea.TeaModel {
    public class Children : Tea.TeaModel {
        public class Creator : Tea.TeaModel {
            public var name: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public class LinkSourceInfo : Tea.TeaModel {
            public class IconUrl : Tea.TeaModel {
                public var line: String?

                public var small: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.line != nil {
                        map["Line"] = self.line!
                    }
                    if self.small != nil {
                        map["Small"] = self.small!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Line") && dict["Line"] != nil {
                        self.line = dict["Line"] as! String
                    }
                    if dict.keys.contains("Small") && dict["Small"] != nil {
                        self.small = dict["Small"] as! String
                    }
                }
            }
            public var extension_: String?

            public var iconUrl: GetSpaceDirectoriesResponseBody.Children.LinkSourceInfo.IconUrl?

            public var id: String?

            public var linkType: Int64?

            public var spaceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.iconUrl?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.iconUrl != nil {
                    map["IconUrl"] = self.iconUrl?.toMap()
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.linkType != nil {
                    map["LinkType"] = self.linkType!
                }
                if self.spaceId != nil {
                    map["SpaceId"] = self.spaceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("IconUrl") && dict["IconUrl"] != nil {
                    var model = GetSpaceDirectoriesResponseBody.Children.LinkSourceInfo.IconUrl()
                    model.fromMap(dict["IconUrl"] as! [String: Any])
                    self.iconUrl = model
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("LinkType") && dict["LinkType"] != nil {
                    self.linkType = dict["LinkType"] as! Int64
                }
                if dict.keys.contains("SpaceId") && dict["SpaceId"] != nil {
                    self.spaceId = dict["SpaceId"] as! String
                }
            }
        }
        public class Space : Tea.TeaModel {
            public class HdIconVO : Tea.TeaModel {
                public var icon: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.icon != nil {
                        map["Icon"] = self.icon!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Icon") && dict["Icon"] != nil {
                        self.icon = dict["Icon"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class IconVO : Tea.TeaModel {
                public var icon: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.icon != nil {
                        map["Icon"] = self.icon!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Icon") && dict["Icon"] != nil {
                        self.icon = dict["Icon"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class Owner : Tea.TeaModel {
                public var name: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public class VisitorInfo : Tea.TeaModel {
                public var dentryActions: [String]?

                public var roleCode: String?

                public var spaceActions: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dentryActions != nil {
                        map["DentryActions"] = self.dentryActions!
                    }
                    if self.roleCode != nil {
                        map["RoleCode"] = self.roleCode!
                    }
                    if self.spaceActions != nil {
                        map["SpaceActions"] = self.spaceActions!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DentryActions") && dict["DentryActions"] != nil {
                        self.dentryActions = dict["DentryActions"] as! [String]
                    }
                    if dict.keys.contains("RoleCode") && dict["RoleCode"] != nil {
                        self.roleCode = dict["RoleCode"] as! String
                    }
                    if dict.keys.contains("SpaceActions") && dict["SpaceActions"] != nil {
                        self.spaceActions = dict["SpaceActions"] as! [String]
                    }
                }
            }
            public var cover: String?

            public var description_: String?

            public var hdIconVO: GetSpaceDirectoriesResponseBody.Children.Space.HdIconVO?

            public var iconVO: GetSpaceDirectoriesResponseBody.Children.Space.IconVO?

            public var id: String?

            public var name: String?

            public var owner: GetSpaceDirectoriesResponseBody.Children.Space.Owner?

            public var recentList: [Any]?

            public var type: Int32?

            public var url: String?

            public var visitorInfo: GetSpaceDirectoriesResponseBody.Children.Space.VisitorInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.hdIconVO?.validate()
                try self.iconVO?.validate()
                try self.owner?.validate()
                try self.visitorInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cover != nil {
                    map["Cover"] = self.cover!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.hdIconVO != nil {
                    map["HdIconVO"] = self.hdIconVO?.toMap()
                }
                if self.iconVO != nil {
                    map["IconVO"] = self.iconVO?.toMap()
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner?.toMap()
                }
                if self.recentList != nil {
                    map["RecentList"] = self.recentList!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                if self.visitorInfo != nil {
                    map["VisitorInfo"] = self.visitorInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cover") && dict["Cover"] != nil {
                    self.cover = dict["Cover"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("HdIconVO") && dict["HdIconVO"] != nil {
                    var model = GetSpaceDirectoriesResponseBody.Children.Space.HdIconVO()
                    model.fromMap(dict["HdIconVO"] as! [String: Any])
                    self.hdIconVO = model
                }
                if dict.keys.contains("IconVO") && dict["IconVO"] != nil {
                    var model = GetSpaceDirectoriesResponseBody.Children.Space.IconVO()
                    model.fromMap(dict["IconVO"] as! [String: Any])
                    self.iconVO = model
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Owner") && dict["Owner"] != nil {
                    var model = GetSpaceDirectoriesResponseBody.Children.Space.Owner()
                    model.fromMap(dict["Owner"] as! [String: Any])
                    self.owner = model
                }
                if dict.keys.contains("RecentList") && dict["RecentList"] != nil {
                    self.recentList = dict["RecentList"] as! [Any]
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! Int32
                }
                if dict.keys.contains("Url") && dict["Url"] != nil {
                    self.url = dict["Url"] as! String
                }
                if dict.keys.contains("VisitorInfo") && dict["VisitorInfo"] != nil {
                    var model = GetSpaceDirectoriesResponseBody.Children.Space.VisitorInfo()
                    model.fromMap(dict["VisitorInfo"] as! [String: Any])
                    self.visitorInfo = model
                }
            }
        }
        public class StatisticalInfo : Tea.TeaModel {
            public var wordCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.wordCount != nil {
                    map["WordCount"] = self.wordCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("WordCount") && dict["WordCount"] != nil {
                    self.wordCount = dict["WordCount"] as! Int64
                }
            }
        }
        public class Updater : Tea.TeaModel {
            public var name: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public class VisitorInfo : Tea.TeaModel {
            public var dentryActions: [String]?

            public var roleCode: String?

            public var spaceActions: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dentryActions != nil {
                    map["DentryActions"] = self.dentryActions!
                }
                if self.roleCode != nil {
                    map["RoleCode"] = self.roleCode!
                }
                if self.spaceActions != nil {
                    map["SpaceActions"] = self.spaceActions!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DentryActions") && dict["DentryActions"] != nil {
                    self.dentryActions = dict["DentryActions"] as! [String]
                }
                if dict.keys.contains("RoleCode") && dict["RoleCode"] != nil {
                    self.roleCode = dict["RoleCode"] as! String
                }
                if dict.keys.contains("SpaceActions") && dict["SpaceActions"] != nil {
                    self.spaceActions = dict["SpaceActions"] as! [String]
                }
            }
        }
        public var contentType: String?

        public var createdTime: Int64?

        public var creator: GetSpaceDirectoriesResponseBody.Children.Creator?

        public var dentryId: String?

        public var dentryType: String?

        public var dentryUuid: String?

        public var docKey: String?

        public var extension_: String?

        public var hasChildren: Bool?

        public var linkSourceInfo: GetSpaceDirectoriesResponseBody.Children.LinkSourceInfo?

        public var name: String?

        public var path: String?

        public var space: GetSpaceDirectoriesResponseBody.Children.Space?

        public var spaceId: String?

        public var statisticalInfo: GetSpaceDirectoriesResponseBody.Children.StatisticalInfo?

        public var updatedTime: Int64?

        public var updater: GetSpaceDirectoriesResponseBody.Children.Updater?

        public var url: String?

        public var visitorInfo: GetSpaceDirectoriesResponseBody.Children.VisitorInfo?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.creator?.validate()
            try self.linkSourceInfo?.validate()
            try self.space?.validate()
            try self.statisticalInfo?.validate()
            try self.updater?.validate()
            try self.visitorInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contentType != nil {
                map["ContentType"] = self.contentType!
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator?.toMap()
            }
            if self.dentryId != nil {
                map["DentryId"] = self.dentryId!
            }
            if self.dentryType != nil {
                map["DentryType"] = self.dentryType!
            }
            if self.dentryUuid != nil {
                map["DentryUuid"] = self.dentryUuid!
            }
            if self.docKey != nil {
                map["DocKey"] = self.docKey!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.hasChildren != nil {
                map["HasChildren"] = self.hasChildren!
            }
            if self.linkSourceInfo != nil {
                map["LinkSourceInfo"] = self.linkSourceInfo?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.space != nil {
                map["Space"] = self.space?.toMap()
            }
            if self.spaceId != nil {
                map["SpaceId"] = self.spaceId!
            }
            if self.statisticalInfo != nil {
                map["StatisticalInfo"] = self.statisticalInfo?.toMap()
            }
            if self.updatedTime != nil {
                map["UpdatedTime"] = self.updatedTime!
            }
            if self.updater != nil {
                map["Updater"] = self.updater?.toMap()
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.visitorInfo != nil {
                map["VisitorInfo"] = self.visitorInfo?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContentType") && dict["ContentType"] != nil {
                self.contentType = dict["ContentType"] as! String
            }
            if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                self.createdTime = dict["CreatedTime"] as! Int64
            }
            if dict.keys.contains("Creator") && dict["Creator"] != nil {
                var model = GetSpaceDirectoriesResponseBody.Children.Creator()
                model.fromMap(dict["Creator"] as! [String: Any])
                self.creator = model
            }
            if dict.keys.contains("DentryId") && dict["DentryId"] != nil {
                self.dentryId = dict["DentryId"] as! String
            }
            if dict.keys.contains("DentryType") && dict["DentryType"] != nil {
                self.dentryType = dict["DentryType"] as! String
            }
            if dict.keys.contains("DentryUuid") && dict["DentryUuid"] != nil {
                self.dentryUuid = dict["DentryUuid"] as! String
            }
            if dict.keys.contains("DocKey") && dict["DocKey"] != nil {
                self.docKey = dict["DocKey"] as! String
            }
            if dict.keys.contains("Extension") && dict["Extension"] != nil {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("HasChildren") && dict["HasChildren"] != nil {
                self.hasChildren = dict["HasChildren"] as! Bool
            }
            if dict.keys.contains("LinkSourceInfo") && dict["LinkSourceInfo"] != nil {
                var model = GetSpaceDirectoriesResponseBody.Children.LinkSourceInfo()
                model.fromMap(dict["LinkSourceInfo"] as! [String: Any])
                self.linkSourceInfo = model
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") && dict["Path"] != nil {
                self.path = dict["Path"] as! String
            }
            if dict.keys.contains("Space") && dict["Space"] != nil {
                var model = GetSpaceDirectoriesResponseBody.Children.Space()
                model.fromMap(dict["Space"] as! [String: Any])
                self.space = model
            }
            if dict.keys.contains("SpaceId") && dict["SpaceId"] != nil {
                self.spaceId = dict["SpaceId"] as! String
            }
            if dict.keys.contains("StatisticalInfo") && dict["StatisticalInfo"] != nil {
                var model = GetSpaceDirectoriesResponseBody.Children.StatisticalInfo()
                model.fromMap(dict["StatisticalInfo"] as! [String: Any])
                self.statisticalInfo = model
            }
            if dict.keys.contains("UpdatedTime") && dict["UpdatedTime"] != nil {
                self.updatedTime = dict["UpdatedTime"] as! Int64
            }
            if dict.keys.contains("Updater") && dict["Updater"] != nil {
                var model = GetSpaceDirectoriesResponseBody.Children.Updater()
                model.fromMap(dict["Updater"] as! [String: Any])
                self.updater = model
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("VisitorInfo") && dict["VisitorInfo"] != nil {
                var model = GetSpaceDirectoriesResponseBody.Children.VisitorInfo()
                model.fromMap(dict["VisitorInfo"] as! [String: Any])
                self.visitorInfo = model
            }
        }
    }
    public var children: [GetSpaceDirectoriesResponseBody.Children]?

    public var hasMore: Bool?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.children != nil {
            var tmp : [Any] = []
            for k in self.children! {
                tmp.append(k.toMap())
            }
            map["children"] = tmp
        }
        if self.hasMore != nil {
            map["hasMore"] = self.hasMore!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("children") && dict["children"] != nil {
            var tmp : [GetSpaceDirectoriesResponseBody.Children] = []
            for v in dict["children"] as! [Any] {
                var model = GetSpaceDirectoriesResponseBody.Children()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.children = tmp
        }
        if dict.keys.contains("hasMore") && dict["hasMore"] != nil {
            self.hasMore = dict["hasMore"] as! Bool
        }
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetSpaceDirectoriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSpaceDirectoriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetSpaceDirectoriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSubscribedCalendarHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetSubscribedCalendarHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetSubscribedCalendarHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetSubscribedCalendarShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetSubscribedCalendarRequest : Tea.TeaModel {
    public var calendarId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
    }
}

public class GetSubscribedCalendarResponseBody : Tea.TeaModel {
    public class SubscribeScope : Tea.TeaModel {
        public var corpIds: [String]?

        public var openConversationIds: [String]?

        public var userIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpIds != nil {
                map["CorpIds"] = self.corpIds!
            }
            if self.openConversationIds != nil {
                map["OpenConversationIds"] = self.openConversationIds!
            }
            if self.userIds != nil {
                map["UserIds"] = self.userIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpIds") && dict["CorpIds"] != nil {
                self.corpIds = dict["CorpIds"] as! [String]
            }
            if dict.keys.contains("OpenConversationIds") && dict["OpenConversationIds"] != nil {
                self.openConversationIds = dict["OpenConversationIds"] as! [String]
            }
            if dict.keys.contains("UserIds") && dict["UserIds"] != nil {
                self.userIds = dict["UserIds"] as! [String]
            }
        }
    }
    public var author: String?

    public var calendarId: String?

    public var description_: String?

    public var managers: [String]?

    public var name: String?

    public var requestId: String?

    public var subscribeScope: GetSubscribedCalendarResponseBody.SubscribeScope?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.subscribeScope?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.author != nil {
            map["author"] = self.author!
        }
        if self.calendarId != nil {
            map["calendarId"] = self.calendarId!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.managers != nil {
            map["managers"] = self.managers!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.subscribeScope != nil {
            map["subscribeScope"] = self.subscribeScope?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("author") && dict["author"] != nil {
            self.author = dict["author"] as! String
        }
        if dict.keys.contains("calendarId") && dict["calendarId"] != nil {
            self.calendarId = dict["calendarId"] as! String
        }
        if dict.keys.contains("description") && dict["description"] != nil {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("managers") && dict["managers"] != nil {
            self.managers = dict["managers"] as! [String]
        }
        if dict.keys.contains("name") && dict["name"] != nil {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("subscribeScope") && dict["subscribeScope"] != nil {
            var model = GetSubscribedCalendarResponseBody.SubscribeScope()
            model.fromMap(dict["subscribeScope"] as! [String: Any])
            self.subscribeScope = model
        }
    }
}

public class GetSubscribedCalendarResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSubscribedCalendarResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetSubscribedCalendarResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTaskCopiesHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetTaskCopiesHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetTaskCopiesHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetTaskCopiesShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetTaskCopiesRequest : Tea.TeaModel {
    public var appType: String?

    public var createFromTimeGMT: Int64?

    public var createToTimeGMT: Int64?

    public var keyword: String?

    public var language: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var processCodes: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.createFromTimeGMT != nil {
            map["CreateFromTimeGMT"] = self.createFromTimeGMT!
        }
        if self.createToTimeGMT != nil {
            map["CreateToTimeGMT"] = self.createToTimeGMT!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.processCodes != nil {
            map["ProcessCodes"] = self.processCodes!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("CreateFromTimeGMT") && dict["CreateFromTimeGMT"] != nil {
            self.createFromTimeGMT = dict["CreateFromTimeGMT"] as! Int64
        }
        if dict.keys.contains("CreateToTimeGMT") && dict["CreateToTimeGMT"] != nil {
            self.createToTimeGMT = dict["CreateToTimeGMT"] as! Int64
        }
        if dict.keys.contains("Keyword") && dict["Keyword"] != nil {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProcessCodes") && dict["ProcessCodes"] != nil {
            self.processCodes = dict["ProcessCodes"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class GetTaskCopiesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CurrentActivityInstances : Tea.TeaModel {
            public var activityId: String?

            public var activityInstanceStatus: String?

            public var activityName: String?

            public var activityNameInEnglish: String?

            public var id: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activityId != nil {
                    map["ActivityId"] = self.activityId!
                }
                if self.activityInstanceStatus != nil {
                    map["ActivityInstanceStatus"] = self.activityInstanceStatus!
                }
                if self.activityName != nil {
                    map["ActivityName"] = self.activityName!
                }
                if self.activityNameInEnglish != nil {
                    map["ActivityNameInEnglish"] = self.activityNameInEnglish!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActivityId") && dict["ActivityId"] != nil {
                    self.activityId = dict["ActivityId"] as! String
                }
                if dict.keys.contains("ActivityInstanceStatus") && dict["ActivityInstanceStatus"] != nil {
                    self.activityInstanceStatus = dict["ActivityInstanceStatus"] as! String
                }
                if dict.keys.contains("ActivityName") && dict["ActivityName"] != nil {
                    self.activityName = dict["ActivityName"] as! String
                }
                if dict.keys.contains("ActivityNameInEnglish") && dict["ActivityNameInEnglish"] != nil {
                    self.activityNameInEnglish = dict["ActivityNameInEnglish"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
            }
        }
        public var actionExecutorId: [String]?

        public var actionExecutorName: [String]?

        public var appType: String?

        public var carbonActivityId: String?

        public var createTimeGMT: String?

        public var currentActivityInstances: [GetTaskCopiesResponseBody.Data.CurrentActivityInstances]?

        public var dataMap: [String: Any]?

        public var dataType: String?

        public var finishTimeGMT: String?

        public var formInstanceId: String?

        public var formUuid: String?

        public var instanceValue: String?

        public var modifiedTimeGMT: String?

        public var originatorAvatar: String?

        public var originatorDisplayName: String?

        public var originatorId: String?

        public var processApprovedResult: String?

        public var processApprovedResultText: String?

        public var processCode: String?

        public var processId: Int64?

        public var processInstanceId: String?

        public var processInstanceStatus: String?

        public var processInstanceStatusText: String?

        public var processName: String?

        public var serialNumber: String?

        public var title: String?

        public var version: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actionExecutorId != nil {
                map["ActionExecutorId"] = self.actionExecutorId!
            }
            if self.actionExecutorName != nil {
                map["ActionExecutorName"] = self.actionExecutorName!
            }
            if self.appType != nil {
                map["AppType"] = self.appType!
            }
            if self.carbonActivityId != nil {
                map["CarbonActivityId"] = self.carbonActivityId!
            }
            if self.createTimeGMT != nil {
                map["CreateTimeGMT"] = self.createTimeGMT!
            }
            if self.currentActivityInstances != nil {
                var tmp : [Any] = []
                for k in self.currentActivityInstances! {
                    tmp.append(k.toMap())
                }
                map["CurrentActivityInstances"] = tmp
            }
            if self.dataMap != nil {
                map["DataMap"] = self.dataMap!
            }
            if self.dataType != nil {
                map["DataType"] = self.dataType!
            }
            if self.finishTimeGMT != nil {
                map["FinishTimeGMT"] = self.finishTimeGMT!
            }
            if self.formInstanceId != nil {
                map["FormInstanceId"] = self.formInstanceId!
            }
            if self.formUuid != nil {
                map["FormUuid"] = self.formUuid!
            }
            if self.instanceValue != nil {
                map["InstanceValue"] = self.instanceValue!
            }
            if self.modifiedTimeGMT != nil {
                map["ModifiedTimeGMT"] = self.modifiedTimeGMT!
            }
            if self.originatorAvatar != nil {
                map["OriginatorAvatar"] = self.originatorAvatar!
            }
            if self.originatorDisplayName != nil {
                map["OriginatorDisplayName"] = self.originatorDisplayName!
            }
            if self.originatorId != nil {
                map["OriginatorId"] = self.originatorId!
            }
            if self.processApprovedResult != nil {
                map["ProcessApprovedResult"] = self.processApprovedResult!
            }
            if self.processApprovedResultText != nil {
                map["ProcessApprovedResultText"] = self.processApprovedResultText!
            }
            if self.processCode != nil {
                map["ProcessCode"] = self.processCode!
            }
            if self.processId != nil {
                map["ProcessId"] = self.processId!
            }
            if self.processInstanceId != nil {
                map["ProcessInstanceId"] = self.processInstanceId!
            }
            if self.processInstanceStatus != nil {
                map["ProcessInstanceStatus"] = self.processInstanceStatus!
            }
            if self.processInstanceStatusText != nil {
                map["ProcessInstanceStatusText"] = self.processInstanceStatusText!
            }
            if self.processName != nil {
                map["ProcessName"] = self.processName!
            }
            if self.serialNumber != nil {
                map["SerialNumber"] = self.serialNumber!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActionExecutorId") && dict["ActionExecutorId"] != nil {
                self.actionExecutorId = dict["ActionExecutorId"] as! [String]
            }
            if dict.keys.contains("ActionExecutorName") && dict["ActionExecutorName"] != nil {
                self.actionExecutorName = dict["ActionExecutorName"] as! [String]
            }
            if dict.keys.contains("AppType") && dict["AppType"] != nil {
                self.appType = dict["AppType"] as! String
            }
            if dict.keys.contains("CarbonActivityId") && dict["CarbonActivityId"] != nil {
                self.carbonActivityId = dict["CarbonActivityId"] as! String
            }
            if dict.keys.contains("CreateTimeGMT") && dict["CreateTimeGMT"] != nil {
                self.createTimeGMT = dict["CreateTimeGMT"] as! String
            }
            if dict.keys.contains("CurrentActivityInstances") && dict["CurrentActivityInstances"] != nil {
                var tmp : [GetTaskCopiesResponseBody.Data.CurrentActivityInstances] = []
                for v in dict["CurrentActivityInstances"] as! [Any] {
                    var model = GetTaskCopiesResponseBody.Data.CurrentActivityInstances()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.currentActivityInstances = tmp
            }
            if dict.keys.contains("DataMap") && dict["DataMap"] != nil {
                self.dataMap = dict["DataMap"] as! [String: Any]
            }
            if dict.keys.contains("DataType") && dict["DataType"] != nil {
                self.dataType = dict["DataType"] as! String
            }
            if dict.keys.contains("FinishTimeGMT") && dict["FinishTimeGMT"] != nil {
                self.finishTimeGMT = dict["FinishTimeGMT"] as! String
            }
            if dict.keys.contains("FormInstanceId") && dict["FormInstanceId"] != nil {
                self.formInstanceId = dict["FormInstanceId"] as! String
            }
            if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
                self.formUuid = dict["FormUuid"] as! String
            }
            if dict.keys.contains("InstanceValue") && dict["InstanceValue"] != nil {
                self.instanceValue = dict["InstanceValue"] as! String
            }
            if dict.keys.contains("ModifiedTimeGMT") && dict["ModifiedTimeGMT"] != nil {
                self.modifiedTimeGMT = dict["ModifiedTimeGMT"] as! String
            }
            if dict.keys.contains("OriginatorAvatar") && dict["OriginatorAvatar"] != nil {
                self.originatorAvatar = dict["OriginatorAvatar"] as! String
            }
            if dict.keys.contains("OriginatorDisplayName") && dict["OriginatorDisplayName"] != nil {
                self.originatorDisplayName = dict["OriginatorDisplayName"] as! String
            }
            if dict.keys.contains("OriginatorId") && dict["OriginatorId"] != nil {
                self.originatorId = dict["OriginatorId"] as! String
            }
            if dict.keys.contains("ProcessApprovedResult") && dict["ProcessApprovedResult"] != nil {
                self.processApprovedResult = dict["ProcessApprovedResult"] as! String
            }
            if dict.keys.contains("ProcessApprovedResultText") && dict["ProcessApprovedResultText"] != nil {
                self.processApprovedResultText = dict["ProcessApprovedResultText"] as! String
            }
            if dict.keys.contains("ProcessCode") && dict["ProcessCode"] != nil {
                self.processCode = dict["ProcessCode"] as! String
            }
            if dict.keys.contains("ProcessId") && dict["ProcessId"] != nil {
                self.processId = dict["ProcessId"] as! Int64
            }
            if dict.keys.contains("ProcessInstanceId") && dict["ProcessInstanceId"] != nil {
                self.processInstanceId = dict["ProcessInstanceId"] as! String
            }
            if dict.keys.contains("ProcessInstanceStatus") && dict["ProcessInstanceStatus"] != nil {
                self.processInstanceStatus = dict["ProcessInstanceStatus"] as! String
            }
            if dict.keys.contains("ProcessInstanceStatusText") && dict["ProcessInstanceStatusText"] != nil {
                self.processInstanceStatusText = dict["ProcessInstanceStatusText"] as! String
            }
            if dict.keys.contains("ProcessName") && dict["ProcessName"] != nil {
                self.processName = dict["ProcessName"] as! String
            }
            if dict.keys.contains("SerialNumber") && dict["SerialNumber"] != nil {
                self.serialNumber = dict["SerialNumber"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("Version") && dict["Version"] != nil {
                self.version = dict["Version"] as! Int64
            }
        }
    }
    public var data: [GetTaskCopiesResponseBody.Data]?

    public var pageNumber: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [GetTaskCopiesResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = GetTaskCopiesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class GetTaskCopiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTaskCopiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetTaskCopiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTemplateListByUserIdHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetTemplateListByUserIdHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetTemplateListByUserIdHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetTemplateListByUserIdShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetTemplateListByUserIdRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var offset: Int64?

    public var size: Int64?

    public var tenantContext: GetTemplateListByUserIdRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Offset") && dict["Offset"] != nil {
            self.offset = dict["Offset"] as! Int64
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GetTemplateListByUserIdRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class GetTemplateListByUserIdShrinkRequest : Tea.TeaModel {
    public var offset: Int64?

    public var size: Int64?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Offset") && dict["Offset"] != nil {
            self.offset = dict["Offset"] as! Int64
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class GetTemplateListByUserIdResponseBody : Tea.TeaModel {
    public class TemplateList : Tea.TeaModel {
        public var iconUrl: String?

        public var name: String?

        public var reportCode: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.iconUrl != nil {
                map["IconUrl"] = self.iconUrl!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.reportCode != nil {
                map["ReportCode"] = self.reportCode!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IconUrl") && dict["IconUrl"] != nil {
                self.iconUrl = dict["IconUrl"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ReportCode") && dict["ReportCode"] != nil {
                self.reportCode = dict["ReportCode"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var nextCursor: Int64?

    public var requestId: String?

    public var templateList: [GetTemplateListByUserIdResponseBody.TemplateList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextCursor != nil {
            map["nextCursor"] = self.nextCursor!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.templateList != nil {
            var tmp : [Any] = []
            for k in self.templateList! {
                tmp.append(k.toMap())
            }
            map["templateList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("nextCursor") && dict["nextCursor"] != nil {
            self.nextCursor = dict["nextCursor"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("templateList") && dict["templateList"] != nil {
            var tmp : [GetTemplateListByUserIdResponseBody.TemplateList] = []
            for v in dict["templateList"] as! [Any] {
                var model = GetTemplateListByUserIdResponseBody.TemplateList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.templateList = tmp
        }
    }
}

public class GetTemplateListByUserIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTemplateListByUserIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetTemplateListByUserIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUserHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetUserHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetUserHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetUserShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetUserRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: GetUserRequest.TenantContext?

    public var language: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.language != nil {
            map["language"] = self.language!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GetUserRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("language") && dict["language"] != nil {
            self.language = dict["language"] as! String
        }
    }
}

public class GetUserShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var language: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.language != nil {
            map["language"] = self.language!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("language") && dict["language"] != nil {
            self.language = dict["language"] as! String
        }
    }
}

public class GetUserResponseBody : Tea.TeaModel {
    public class DeptOrderList : Tea.TeaModel {
        public var deptId: Int64?

        public var order: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deptId != nil {
                map["deptId"] = self.deptId!
            }
            if self.order != nil {
                map["order"] = self.order!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("deptId") && dict["deptId"] != nil {
                self.deptId = dict["deptId"] as! Int64
            }
            if dict.keys.contains("order") && dict["order"] != nil {
                self.order = dict["order"] as! Int64
            }
        }
    }
    public class LeaderInDept : Tea.TeaModel {
        public var deptId: Int64?

        public var leader: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deptId != nil {
                map["deptId"] = self.deptId!
            }
            if self.leader != nil {
                map["leader"] = self.leader!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("deptId") && dict["deptId"] != nil {
                self.deptId = dict["deptId"] as! Int64
            }
            if dict.keys.contains("leader") && dict["leader"] != nil {
                self.leader = dict["leader"] as! Bool
            }
        }
    }
    public class RoleList : Tea.TeaModel {
        public var groupName: String?

        public var id: Int64?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupName != nil {
                map["groupName"] = self.groupName!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("groupName") && dict["groupName"] != nil {
                self.groupName = dict["groupName"] as! String
            }
            if dict.keys.contains("id") && dict["id"] != nil {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") && dict["name"] != nil {
                self.name = dict["name"] as! String
            }
        }
    }
    public class UnionEmpExt : Tea.TeaModel {
        public class UnionEmpMapList : Tea.TeaModel {
            public var cropId: String?

            public var userid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cropId != nil {
                    map["cropId"] = self.cropId!
                }
                if self.userid != nil {
                    map["userid"] = self.userid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("cropId") && dict["cropId"] != nil {
                    self.cropId = dict["cropId"] as! String
                }
                if dict.keys.contains("userid") && dict["userid"] != nil {
                    self.userid = dict["userid"] as! String
                }
            }
        }
        public var corpId: String?

        public var unionEmpMapList: [GetUserResponseBody.UnionEmpExt.UnionEmpMapList]?

        public var userid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["corpId"] = self.corpId!
            }
            if self.unionEmpMapList != nil {
                var tmp : [Any] = []
                for k in self.unionEmpMapList! {
                    tmp.append(k.toMap())
                }
                map["unionEmpMapList"] = tmp
            }
            if self.userid != nil {
                map["userid"] = self.userid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("corpId") && dict["corpId"] != nil {
                self.corpId = dict["corpId"] as! String
            }
            if dict.keys.contains("unionEmpMapList") && dict["unionEmpMapList"] != nil {
                var tmp : [GetUserResponseBody.UnionEmpExt.UnionEmpMapList] = []
                for v in dict["unionEmpMapList"] as! [Any] {
                    var model = GetUserResponseBody.UnionEmpExt.UnionEmpMapList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.unionEmpMapList = tmp
            }
            if dict.keys.contains("userid") && dict["userid"] != nil {
                self.userid = dict["userid"] as! String
            }
        }
    }
    public var active: Bool?

    public var admin: Bool?

    public var avatar: String?

    public var boss: Bool?

    public var deptIdList: [Int64]?

    public var deptOrderList: [GetUserResponseBody.DeptOrderList]?

    public var email: String?

    public var exclusiveAccount: Bool?

    public var exclusiveAccountCorpId: String?

    public var exclusiveAccountCorpName: String?

    public var exclusiveAccountType: String?

    public var extension_: String?

    public var hideMobile: Bool?

    public var hiredDate: Int64?

    public var jobNumber: String?

    public var leaderInDept: [GetUserResponseBody.LeaderInDept]?

    public var loginId: String?

    public var managerUserid: String?

    public var mobile: String?

    public var name: String?

    public var nickname: String?

    public var orgEmail: String?

    public var realAuthed: Bool?

    public var remark: String?

    public var requestId: String?

    public var roleList: [GetUserResponseBody.RoleList]?

    public var senior: Bool?

    public var stateCode: String?

    public var telephone: String?

    public var title: String?

    public var unionEmpExt: GetUserResponseBody.UnionEmpExt?

    public var userid: String?

    public var workPlace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.unionEmpExt?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.active != nil {
            map["active"] = self.active!
        }
        if self.admin != nil {
            map["admin"] = self.admin!
        }
        if self.avatar != nil {
            map["avatar"] = self.avatar!
        }
        if self.boss != nil {
            map["boss"] = self.boss!
        }
        if self.deptIdList != nil {
            map["deptIdList"] = self.deptIdList!
        }
        if self.deptOrderList != nil {
            var tmp : [Any] = []
            for k in self.deptOrderList! {
                tmp.append(k.toMap())
            }
            map["deptOrderList"] = tmp
        }
        if self.email != nil {
            map["email"] = self.email!
        }
        if self.exclusiveAccount != nil {
            map["exclusiveAccount"] = self.exclusiveAccount!
        }
        if self.exclusiveAccountCorpId != nil {
            map["exclusiveAccountCorpId"] = self.exclusiveAccountCorpId!
        }
        if self.exclusiveAccountCorpName != nil {
            map["exclusiveAccountCorpName"] = self.exclusiveAccountCorpName!
        }
        if self.exclusiveAccountType != nil {
            map["exclusiveAccountType"] = self.exclusiveAccountType!
        }
        if self.extension_ != nil {
            map["extension"] = self.extension_!
        }
        if self.hideMobile != nil {
            map["hideMobile"] = self.hideMobile!
        }
        if self.hiredDate != nil {
            map["hiredDate"] = self.hiredDate!
        }
        if self.jobNumber != nil {
            map["jobNumber"] = self.jobNumber!
        }
        if self.leaderInDept != nil {
            var tmp : [Any] = []
            for k in self.leaderInDept! {
                tmp.append(k.toMap())
            }
            map["leaderInDept"] = tmp
        }
        if self.loginId != nil {
            map["loginId"] = self.loginId!
        }
        if self.managerUserid != nil {
            map["managerUserid"] = self.managerUserid!
        }
        if self.mobile != nil {
            map["mobile"] = self.mobile!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.nickname != nil {
            map["nickname"] = self.nickname!
        }
        if self.orgEmail != nil {
            map["orgEmail"] = self.orgEmail!
        }
        if self.realAuthed != nil {
            map["realAuthed"] = self.realAuthed!
        }
        if self.remark != nil {
            map["remark"] = self.remark!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.roleList != nil {
            var tmp : [Any] = []
            for k in self.roleList! {
                tmp.append(k.toMap())
            }
            map["roleList"] = tmp
        }
        if self.senior != nil {
            map["senior"] = self.senior!
        }
        if self.stateCode != nil {
            map["stateCode"] = self.stateCode!
        }
        if self.telephone != nil {
            map["telephone"] = self.telephone!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        if self.unionEmpExt != nil {
            map["unionEmpExt"] = self.unionEmpExt?.toMap()
        }
        if self.userid != nil {
            map["userid"] = self.userid!
        }
        if self.workPlace != nil {
            map["workPlace"] = self.workPlace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("active") && dict["active"] != nil {
            self.active = dict["active"] as! Bool
        }
        if dict.keys.contains("admin") && dict["admin"] != nil {
            self.admin = dict["admin"] as! Bool
        }
        if dict.keys.contains("avatar") && dict["avatar"] != nil {
            self.avatar = dict["avatar"] as! String
        }
        if dict.keys.contains("boss") && dict["boss"] != nil {
            self.boss = dict["boss"] as! Bool
        }
        if dict.keys.contains("deptIdList") && dict["deptIdList"] != nil {
            self.deptIdList = dict["deptIdList"] as! [Int64]
        }
        if dict.keys.contains("deptOrderList") && dict["deptOrderList"] != nil {
            var tmp : [GetUserResponseBody.DeptOrderList] = []
            for v in dict["deptOrderList"] as! [Any] {
                var model = GetUserResponseBody.DeptOrderList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.deptOrderList = tmp
        }
        if dict.keys.contains("email") && dict["email"] != nil {
            self.email = dict["email"] as! String
        }
        if dict.keys.contains("exclusiveAccount") && dict["exclusiveAccount"] != nil {
            self.exclusiveAccount = dict["exclusiveAccount"] as! Bool
        }
        if dict.keys.contains("exclusiveAccountCorpId") && dict["exclusiveAccountCorpId"] != nil {
            self.exclusiveAccountCorpId = dict["exclusiveAccountCorpId"] as! String
        }
        if dict.keys.contains("exclusiveAccountCorpName") && dict["exclusiveAccountCorpName"] != nil {
            self.exclusiveAccountCorpName = dict["exclusiveAccountCorpName"] as! String
        }
        if dict.keys.contains("exclusiveAccountType") && dict["exclusiveAccountType"] != nil {
            self.exclusiveAccountType = dict["exclusiveAccountType"] as! String
        }
        if dict.keys.contains("extension") && dict["extension"] != nil {
            self.extension_ = dict["extension"] as! String
        }
        if dict.keys.contains("hideMobile") && dict["hideMobile"] != nil {
            self.hideMobile = dict["hideMobile"] as! Bool
        }
        if dict.keys.contains("hiredDate") && dict["hiredDate"] != nil {
            self.hiredDate = dict["hiredDate"] as! Int64
        }
        if dict.keys.contains("jobNumber") && dict["jobNumber"] != nil {
            self.jobNumber = dict["jobNumber"] as! String
        }
        if dict.keys.contains("leaderInDept") && dict["leaderInDept"] != nil {
            var tmp : [GetUserResponseBody.LeaderInDept] = []
            for v in dict["leaderInDept"] as! [Any] {
                var model = GetUserResponseBody.LeaderInDept()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.leaderInDept = tmp
        }
        if dict.keys.contains("loginId") && dict["loginId"] != nil {
            self.loginId = dict["loginId"] as! String
        }
        if dict.keys.contains("managerUserid") && dict["managerUserid"] != nil {
            self.managerUserid = dict["managerUserid"] as! String
        }
        if dict.keys.contains("mobile") && dict["mobile"] != nil {
            self.mobile = dict["mobile"] as! String
        }
        if dict.keys.contains("name") && dict["name"] != nil {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("nickname") && dict["nickname"] != nil {
            self.nickname = dict["nickname"] as! String
        }
        if dict.keys.contains("orgEmail") && dict["orgEmail"] != nil {
            self.orgEmail = dict["orgEmail"] as! String
        }
        if dict.keys.contains("realAuthed") && dict["realAuthed"] != nil {
            self.realAuthed = dict["realAuthed"] as! Bool
        }
        if dict.keys.contains("remark") && dict["remark"] != nil {
            self.remark = dict["remark"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("roleList") && dict["roleList"] != nil {
            var tmp : [GetUserResponseBody.RoleList] = []
            for v in dict["roleList"] as! [Any] {
                var model = GetUserResponseBody.RoleList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.roleList = tmp
        }
        if dict.keys.contains("senior") && dict["senior"] != nil {
            self.senior = dict["senior"] as! Bool
        }
        if dict.keys.contains("stateCode") && dict["stateCode"] != nil {
            self.stateCode = dict["stateCode"] as! String
        }
        if dict.keys.contains("telephone") && dict["telephone"] != nil {
            self.telephone = dict["telephone"] as! String
        }
        if dict.keys.contains("title") && dict["title"] != nil {
            self.title = dict["title"] as! String
        }
        if dict.keys.contains("unionEmpExt") && dict["unionEmpExt"] != nil {
            var model = GetUserResponseBody.UnionEmpExt()
            model.fromMap(dict["unionEmpExt"] as! [String: Any])
            self.unionEmpExt = model
        }
        if dict.keys.contains("userid") && dict["userid"] != nil {
            self.userid = dict["userid"] as! String
        }
        if dict.keys.contains("workPlace") && dict["workPlace"] != nil {
            self.workPlace = dict["workPlace"] as! String
        }
    }
}

public class GetUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetWorkspaceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetWorkspaceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetWorkspaceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetWorkspaceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetWorkspaceRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: GetWorkspaceRequest.TenantContext?

    public var withPermissionRole: Bool?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.withPermissionRole != nil {
            map["WithPermissionRole"] = self.withPermissionRole!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GetWorkspaceRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WithPermissionRole") && dict["WithPermissionRole"] != nil {
            self.withPermissionRole = dict["WithPermissionRole"] as! Bool
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class GetWorkspaceShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var withPermissionRole: Bool?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.withPermissionRole != nil {
            map["WithPermissionRole"] = self.withPermissionRole!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WithPermissionRole") && dict["WithPermissionRole"] != nil {
            self.withPermissionRole = dict["WithPermissionRole"] as! Bool
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class GetWorkspaceResponseBody : Tea.TeaModel {
    public class Workspace : Tea.TeaModel {
        public class Icon : Tea.TeaModel {
            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var corpId: String?

        public var cover: String?

        public var createTime: String?

        public var creatorId: String?

        public var description_: String?

        public var icon: GetWorkspaceResponseBody.Workspace.Icon?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var permissionRole: String?

        public var rootNodeId: String?

        public var teamId: String?

        public var type: String?

        public var url: String?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.icon?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.cover != nil {
                map["Cover"] = self.cover!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.icon != nil {
                map["Icon"] = self.icon?.toMap()
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.permissionRole != nil {
                map["PermissionRole"] = self.permissionRole!
            }
            if self.rootNodeId != nil {
                map["RootNodeId"] = self.rootNodeId!
            }
            if self.teamId != nil {
                map["TeamId"] = self.teamId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") && dict["CorpId"] != nil {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("Cover") && dict["Cover"] != nil {
                self.cover = dict["Cover"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Icon") && dict["Icon"] != nil {
                var model = GetWorkspaceResponseBody.Workspace.Icon()
                model.fromMap(dict["Icon"] as! [String: Any])
                self.icon = model
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") && dict["ModifierId"] != nil {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PermissionRole") && dict["PermissionRole"] != nil {
                self.permissionRole = dict["PermissionRole"] as! String
            }
            if dict.keys.contains("RootNodeId") && dict["RootNodeId"] != nil {
                self.rootNodeId = dict["RootNodeId"] as! String
            }
            if dict.keys.contains("TeamId") && dict["TeamId"] != nil {
                self.teamId = dict["TeamId"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var requestId: String?

    public var workspace: GetWorkspaceResponseBody.Workspace?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workspace?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.workspace != nil {
            map["workspace"] = self.workspace?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("workspace") && dict["workspace"] != nil {
            var model = GetWorkspaceResponseBody.Workspace()
            model.fromMap(dict["workspace"] as! [String: Any])
            self.workspace = model
        }
    }
}

public class GetWorkspaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkspaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetWorkspaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetWorkspacesHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GetWorkspacesHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GetWorkspacesHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GetWorkspacesShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GetWorkspacesRequest : Tea.TeaModel {
    public class Option : Tea.TeaModel {
        public var withPermissionRole: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.withPermissionRole != nil {
                map["WithPermissionRole"] = self.withPermissionRole!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("WithPermissionRole") && dict["WithPermissionRole"] != nil {
                self.withPermissionRole = dict["WithPermissionRole"] as! Bool
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var option: GetWorkspacesRequest.Option?

    public var tenantContext: GetWorkspacesRequest.TenantContext?

    public var workspaceIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.option?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.option != nil {
            map["Option"] = self.option?.toMap()
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workspaceIds != nil {
            map["WorkspaceIds"] = self.workspaceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Option") && dict["Option"] != nil {
            var model = GetWorkspacesRequest.Option()
            model.fromMap(dict["Option"] as! [String: Any])
            self.option = model
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GetWorkspacesRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkspaceIds") && dict["WorkspaceIds"] != nil {
            self.workspaceIds = dict["WorkspaceIds"] as! [String]
        }
    }
}

public class GetWorkspacesShrinkRequest : Tea.TeaModel {
    public var optionShrink: String?

    public var tenantContextShrink: String?

    public var workspaceIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.optionShrink != nil {
            map["Option"] = self.optionShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workspaceIdsShrink != nil {
            map["WorkspaceIds"] = self.workspaceIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Option") && dict["Option"] != nil {
            self.optionShrink = dict["Option"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkspaceIds") && dict["WorkspaceIds"] != nil {
            self.workspaceIdsShrink = dict["WorkspaceIds"] as! String
        }
    }
}

public class GetWorkspacesResponseBody : Tea.TeaModel {
    public class Workspace : Tea.TeaModel {
        public class Icon : Tea.TeaModel {
            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var corpId: String?

        public var cover: String?

        public var createTime: String?

        public var creatorId: String?

        public var description_: String?

        public var icon: GetWorkspacesResponseBody.Workspace.Icon?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var permissionRole: String?

        public var rootNodeId: String?

        public var teamId: String?

        public var type: String?

        public var url: String?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.icon?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.cover != nil {
                map["Cover"] = self.cover!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.icon != nil {
                map["Icon"] = self.icon?.toMap()
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.permissionRole != nil {
                map["PermissionRole"] = self.permissionRole!
            }
            if self.rootNodeId != nil {
                map["RootNodeId"] = self.rootNodeId!
            }
            if self.teamId != nil {
                map["TeamId"] = self.teamId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") && dict["CorpId"] != nil {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("Cover") && dict["Cover"] != nil {
                self.cover = dict["Cover"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Icon") && dict["Icon"] != nil {
                var model = GetWorkspacesResponseBody.Workspace.Icon()
                model.fromMap(dict["Icon"] as! [String: Any])
                self.icon = model
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") && dict["ModifierId"] != nil {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PermissionRole") && dict["PermissionRole"] != nil {
                self.permissionRole = dict["PermissionRole"] as! String
            }
            if dict.keys.contains("RootNodeId") && dict["RootNodeId"] != nil {
                self.rootNodeId = dict["RootNodeId"] as! String
            }
            if dict.keys.contains("TeamId") && dict["TeamId"] != nil {
                self.teamId = dict["TeamId"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var requestId: String?

    public var workspace: [GetWorkspacesResponseBody.Workspace]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.workspace != nil {
            var tmp : [Any] = []
            for k in self.workspace! {
                tmp.append(k.toMap())
            }
            map["workspace"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("workspace") && dict["workspace"] != nil {
            var tmp : [GetWorkspacesResponseBody.Workspace] = []
            for v in dict["workspace"] as! [Any] {
                var model = GetWorkspacesResponseBody.Workspace()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.workspace = tmp
        }
    }
}

public class GetWorkspacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkspacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetWorkspacesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GrantHonorHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: GrantHonorHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = GrantHonorHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class GrantHonorShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class GrantHonorRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: GrantHonorRequest.TenantContext?

    public var expirationTime: Int64?

    public var grantReason: String?

    public var granterName: String?

    public var honorId: String?

    public var noticeAnnouncer: Bool?

    public var noticeSingle: Bool?

    public var openConversationIds: [String]?

    public var orgId: Int64?

    public var receiverUserIds: [String]?

    public var senderUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.expirationTime != nil {
            map["expirationTime"] = self.expirationTime!
        }
        if self.grantReason != nil {
            map["grantReason"] = self.grantReason!
        }
        if self.granterName != nil {
            map["granterName"] = self.granterName!
        }
        if self.honorId != nil {
            map["honorId"] = self.honorId!
        }
        if self.noticeAnnouncer != nil {
            map["noticeAnnouncer"] = self.noticeAnnouncer!
        }
        if self.noticeSingle != nil {
            map["noticeSingle"] = self.noticeSingle!
        }
        if self.openConversationIds != nil {
            map["openConversationIds"] = self.openConversationIds!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.receiverUserIds != nil {
            map["receiverUserIds"] = self.receiverUserIds!
        }
        if self.senderUserId != nil {
            map["senderUserId"] = self.senderUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = GrantHonorRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("expirationTime") && dict["expirationTime"] != nil {
            self.expirationTime = dict["expirationTime"] as! Int64
        }
        if dict.keys.contains("grantReason") && dict["grantReason"] != nil {
            self.grantReason = dict["grantReason"] as! String
        }
        if dict.keys.contains("granterName") && dict["granterName"] != nil {
            self.granterName = dict["granterName"] as! String
        }
        if dict.keys.contains("honorId") && dict["honorId"] != nil {
            self.honorId = dict["honorId"] as! String
        }
        if dict.keys.contains("noticeAnnouncer") && dict["noticeAnnouncer"] != nil {
            self.noticeAnnouncer = dict["noticeAnnouncer"] as! Bool
        }
        if dict.keys.contains("noticeSingle") && dict["noticeSingle"] != nil {
            self.noticeSingle = dict["noticeSingle"] as! Bool
        }
        if dict.keys.contains("openConversationIds") && dict["openConversationIds"] != nil {
            self.openConversationIds = dict["openConversationIds"] as! [String]
        }
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("receiverUserIds") && dict["receiverUserIds"] != nil {
            self.receiverUserIds = dict["receiverUserIds"] as! [String]
        }
        if dict.keys.contains("senderUserId") && dict["senderUserId"] != nil {
            self.senderUserId = dict["senderUserId"] as! String
        }
    }
}

public class GrantHonorShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var expirationTime: Int64?

    public var grantReason: String?

    public var granterName: String?

    public var honorId: String?

    public var noticeAnnouncer: Bool?

    public var noticeSingle: Bool?

    public var openConversationIdsShrink: String?

    public var orgId: Int64?

    public var receiverUserIdsShrink: String?

    public var senderUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.expirationTime != nil {
            map["expirationTime"] = self.expirationTime!
        }
        if self.grantReason != nil {
            map["grantReason"] = self.grantReason!
        }
        if self.granterName != nil {
            map["granterName"] = self.granterName!
        }
        if self.honorId != nil {
            map["honorId"] = self.honorId!
        }
        if self.noticeAnnouncer != nil {
            map["noticeAnnouncer"] = self.noticeAnnouncer!
        }
        if self.noticeSingle != nil {
            map["noticeSingle"] = self.noticeSingle!
        }
        if self.openConversationIdsShrink != nil {
            map["openConversationIds"] = self.openConversationIdsShrink!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.receiverUserIdsShrink != nil {
            map["receiverUserIds"] = self.receiverUserIdsShrink!
        }
        if self.senderUserId != nil {
            map["senderUserId"] = self.senderUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("expirationTime") && dict["expirationTime"] != nil {
            self.expirationTime = dict["expirationTime"] as! Int64
        }
        if dict.keys.contains("grantReason") && dict["grantReason"] != nil {
            self.grantReason = dict["grantReason"] as! String
        }
        if dict.keys.contains("granterName") && dict["granterName"] != nil {
            self.granterName = dict["granterName"] as! String
        }
        if dict.keys.contains("honorId") && dict["honorId"] != nil {
            self.honorId = dict["honorId"] as! String
        }
        if dict.keys.contains("noticeAnnouncer") && dict["noticeAnnouncer"] != nil {
            self.noticeAnnouncer = dict["noticeAnnouncer"] as! Bool
        }
        if dict.keys.contains("noticeSingle") && dict["noticeSingle"] != nil {
            self.noticeSingle = dict["noticeSingle"] as! Bool
        }
        if dict.keys.contains("openConversationIds") && dict["openConversationIds"] != nil {
            self.openConversationIdsShrink = dict["openConversationIds"] as! String
        }
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("receiverUserIds") && dict["receiverUserIds"] != nil {
            self.receiverUserIdsShrink = dict["receiverUserIds"] as! String
        }
        if dict.keys.contains("senderUserId") && dict["senderUserId"] != nil {
            self.senderUserId = dict["senderUserId"] as! String
        }
    }
}

public class GrantHonorResponseBody : Tea.TeaModel {
    public var failedUserIds: [String]?

    public var requestId: String?

    public var successUserIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failedUserIds != nil {
            map["failedUserIds"] = self.failedUserIds!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.successUserIds != nil {
            map["successUserIds"] = self.successUserIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("failedUserIds") && dict["failedUserIds"] != nil {
            self.failedUserIds = dict["failedUserIds"] as! [String]
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("successUserIds") && dict["successUserIds"] != nil {
            self.successUserIds = dict["successUserIds"] as! [String]
        }
    }
}

public class GrantHonorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GrantHonorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GrantHonorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InsertColumnsBeforeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: InsertColumnsBeforeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = InsertColumnsBeforeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class InsertColumnsBeforeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class InsertColumnsBeforeRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var column: Int64?

    public var columnCount: Int64?

    public var sheetId: String?

    public var tenantContext: InsertColumnsBeforeRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.column != nil {
            map["Column"] = self.column!
        }
        if self.columnCount != nil {
            map["ColumnCount"] = self.columnCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Column") && dict["Column"] != nil {
            self.column = dict["Column"] as! Int64
        }
        if dict.keys.contains("ColumnCount") && dict["ColumnCount"] != nil {
            self.columnCount = dict["ColumnCount"] as! Int64
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = InsertColumnsBeforeRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class InsertColumnsBeforeShrinkRequest : Tea.TeaModel {
    public var column: Int64?

    public var columnCount: Int64?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.column != nil {
            map["Column"] = self.column!
        }
        if self.columnCount != nil {
            map["ColumnCount"] = self.columnCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Column") && dict["Column"] != nil {
            self.column = dict["Column"] as! Int64
        }
        if dict.keys.contains("ColumnCount") && dict["ColumnCount"] != nil {
            self.columnCount = dict["ColumnCount"] as! Int64
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class InsertColumnsBeforeResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class InsertColumnsBeforeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertColumnsBeforeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InsertColumnsBeforeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InsertRowsBeforeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: InsertRowsBeforeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = InsertRowsBeforeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class InsertRowsBeforeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class InsertRowsBeforeRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var row: Int64?

    public var rowCount: Int64?

    public var sheetId: String?

    public var tenantContext: InsertRowsBeforeRequest.TenantContext?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.row != nil {
            map["Row"] = self.row!
        }
        if self.rowCount != nil {
            map["RowCount"] = self.rowCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Row") && dict["Row"] != nil {
            self.row = dict["Row"] as! Int64
        }
        if dict.keys.contains("RowCount") && dict["RowCount"] != nil {
            self.rowCount = dict["RowCount"] as! Int64
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = InsertRowsBeforeRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class InsertRowsBeforeShrinkRequest : Tea.TeaModel {
    public var row: Int64?

    public var rowCount: Int64?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.row != nil {
            map["Row"] = self.row!
        }
        if self.rowCount != nil {
            map["RowCount"] = self.rowCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Row") && dict["Row"] != nil {
            self.row = dict["Row"] as! Int64
        }
        if dict.keys.contains("RowCount") && dict["RowCount"] != nil {
            self.rowCount = dict["RowCount"] as! Int64
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class InsertRowsBeforeResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class InsertRowsBeforeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InsertRowsBeforeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InsertRowsBeforeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InviteUsersHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: InviteUsersHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = InviteUsersHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class InviteUsersShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class InviteUsersRequest : Tea.TeaModel {
    public class InviteeList : Tea.TeaModel {
        public var nick: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nick != nil {
                map["Nick"] = self.nick!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Nick") && dict["Nick"] != nil {
                self.nick = dict["Nick"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var inviteeList: [InviteUsersRequest.InviteeList]?

    public var tenantContext: InviteUsersRequest.TenantContext?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inviteeList != nil {
            var tmp : [Any] = []
            for k in self.inviteeList! {
                tmp.append(k.toMap())
            }
            map["InviteeList"] = tmp
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InviteeList") && dict["InviteeList"] != nil {
            var tmp : [InviteUsersRequest.InviteeList] = []
            for v in dict["InviteeList"] as! [Any] {
                var model = InviteUsersRequest.InviteeList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.inviteeList = tmp
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = InviteUsersRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("conferenceId") && dict["conferenceId"] != nil {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class InviteUsersShrinkRequest : Tea.TeaModel {
    public var inviteeListShrink: String?

    public var tenantContextShrink: String?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inviteeListShrink != nil {
            map["InviteeList"] = self.inviteeListShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InviteeList") && dict["InviteeList"] != nil {
            self.inviteeListShrink = dict["InviteeList"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("conferenceId") && dict["conferenceId"] != nil {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class InviteUsersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
    }
}

public class InviteUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InviteUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InviteUsersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListApplicationHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListApplicationHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = ListApplicationHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListApplicationShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListApplicationRequest : Tea.TeaModel {
    public var appFilter: String?

    public var appNameSearchKeyword: String?

    public var corpId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appFilter != nil {
            map["AppFilter"] = self.appFilter!
        }
        if self.appNameSearchKeyword != nil {
            map["AppNameSearchKeyword"] = self.appNameSearchKeyword!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppFilter") && dict["AppFilter"] != nil {
            self.appFilter = dict["AppFilter"] as! String
        }
        if dict.keys.contains("AppNameSearchKeyword") && dict["AppNameSearchKeyword"] != nil {
            self.appNameSearchKeyword = dict["AppNameSearchKeyword"] as! String
        }
        if dict.keys.contains("CorpId") && dict["CorpId"] != nil {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Token") && dict["Token"] != nil {
            self.token = dict["Token"] as! String
        }
    }
}

public class ListApplicationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appConfig: String?

        public var appType: String?

        public var applicationStatus: String?

        public var corpId: String?

        public var creatorUserId: String?

        public var description_: String?

        public var icon: String?

        public var inexistence: String?

        public var name: String?

        public var subCorpId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appConfig != nil {
                map["AppConfig"] = self.appConfig!
            }
            if self.appType != nil {
                map["AppType"] = self.appType!
            }
            if self.applicationStatus != nil {
                map["ApplicationStatus"] = self.applicationStatus!
            }
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.creatorUserId != nil {
                map["CreatorUserId"] = self.creatorUserId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.icon != nil {
                map["Icon"] = self.icon!
            }
            if self.inexistence != nil {
                map["Inexistence"] = self.inexistence!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.subCorpId != nil {
                map["SubCorpId"] = self.subCorpId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppConfig") && dict["AppConfig"] != nil {
                self.appConfig = dict["AppConfig"] as! String
            }
            if dict.keys.contains("AppType") && dict["AppType"] != nil {
                self.appType = dict["AppType"] as! String
            }
            if dict.keys.contains("ApplicationStatus") && dict["ApplicationStatus"] != nil {
                self.applicationStatus = dict["ApplicationStatus"] as! String
            }
            if dict.keys.contains("CorpId") && dict["CorpId"] != nil {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("CreatorUserId") && dict["CreatorUserId"] != nil {
                self.creatorUserId = dict["CreatorUserId"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Icon") && dict["Icon"] != nil {
                self.icon = dict["Icon"] as! String
            }
            if dict.keys.contains("Inexistence") && dict["Inexistence"] != nil {
                self.inexistence = dict["Inexistence"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("SubCorpId") && dict["SubCorpId"] != nil {
                self.subCorpId = dict["SubCorpId"] as! String
            }
        }
    }
    public var data: [ListApplicationResponseBody.Data]?

    public var pageNumber: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListApplicationResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListApplicationResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class ListApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCalendarsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListCalendarsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = ListCalendarsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListCalendarsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListCalendarsRequest : Tea.TeaModel {
    public var request: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.request != nil {
            map["Request"] = self.request!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Request") && dict["Request"] != nil {
            self.request = dict["Request"] as! [String: Any]
        }
    }
}

public class ListCalendarsShrinkRequest : Tea.TeaModel {
    public var requestShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestShrink != nil {
            map["Request"] = self.requestShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Request") && dict["Request"] != nil {
            self.requestShrink = dict["Request"] as! String
        }
    }
}

public class ListCalendarsResponseBody : Tea.TeaModel {
    public class Response : Tea.TeaModel {
        public class Calendars : Tea.TeaModel {
            public var description_: String?

            public var ETag: String?

            public var id: String?

            public var privilege: String?

            public var summary: String?

            public var timeZone: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ETag != nil {
                    map["ETag"] = self.ETag!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.privilege != nil {
                    map["Privilege"] = self.privilege!
                }
                if self.summary != nil {
                    map["Summary"] = self.summary!
                }
                if self.timeZone != nil {
                    map["TimeZone"] = self.timeZone!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ETag") && dict["ETag"] != nil {
                    self.ETag = dict["ETag"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Privilege") && dict["Privilege"] != nil {
                    self.privilege = dict["Privilege"] as! String
                }
                if dict.keys.contains("Summary") && dict["Summary"] != nil {
                    self.summary = dict["Summary"] as! String
                }
                if dict.keys.contains("TimeZone") && dict["TimeZone"] != nil {
                    self.timeZone = dict["TimeZone"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var calendars: [ListCalendarsResponseBody.Response.Calendars]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.calendars != nil {
                var tmp : [Any] = []
                for k in self.calendars! {
                    tmp.append(k.toMap())
                }
                map["Calendars"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Calendars") && dict["Calendars"] != nil {
                var tmp : [ListCalendarsResponseBody.Response.Calendars] = []
                for v in dict["Calendars"] as! [Any] {
                    var model = ListCalendarsResponseBody.Response.Calendars()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.calendars = tmp
            }
        }
    }
    public var requestId: String?

    public var response: ListCalendarsResponseBody.Response?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.response?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.response != nil {
            map["response"] = self.response?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("response") && dict["response"] != nil {
            var model = ListCalendarsResponseBody.Response()
            model.fromMap(dict["response"] as! [String: Any])
            self.response = model
        }
    }
}

public class ListCalendarsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCalendarsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListCalendarsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEventsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListEventsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = ListEventsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListEventsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListEventsRequest : Tea.TeaModel {
    public var calendarId: String?

    public var maxAttendees: Int32?

    public var maxResults: Int32?

    public var nextToken: String?

    public var seriesMasterId: String?

    public var showDeleted: Bool?

    public var syncToken: String?

    public var timeMax: String?

    public var timeMin: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.maxAttendees != nil {
            map["MaxAttendees"] = self.maxAttendees!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.seriesMasterId != nil {
            map["SeriesMasterId"] = self.seriesMasterId!
        }
        if self.showDeleted != nil {
            map["ShowDeleted"] = self.showDeleted!
        }
        if self.syncToken != nil {
            map["SyncToken"] = self.syncToken!
        }
        if self.timeMax != nil {
            map["TimeMax"] = self.timeMax!
        }
        if self.timeMin != nil {
            map["TimeMin"] = self.timeMin!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("MaxAttendees") && dict["MaxAttendees"] != nil {
            self.maxAttendees = dict["MaxAttendees"] as! Int32
        }
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("SeriesMasterId") && dict["SeriesMasterId"] != nil {
            self.seriesMasterId = dict["SeriesMasterId"] as! String
        }
        if dict.keys.contains("ShowDeleted") && dict["ShowDeleted"] != nil {
            self.showDeleted = dict["ShowDeleted"] as! Bool
        }
        if dict.keys.contains("SyncToken") && dict["SyncToken"] != nil {
            self.syncToken = dict["SyncToken"] as! String
        }
        if dict.keys.contains("TimeMax") && dict["TimeMax"] != nil {
            self.timeMax = dict["TimeMax"] as! String
        }
        if dict.keys.contains("TimeMin") && dict["TimeMin"] != nil {
            self.timeMin = dict["TimeMin"] as! String
        }
    }
}

public class ListEventsResponseBody : Tea.TeaModel {
    public class Events : Tea.TeaModel {
        public class Attendees : Tea.TeaModel {
            public var displayName: String?

            public var isOptional: Bool?

            public var responseStatus: String?

            public var self_: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.isOptional != nil {
                    map["IsOptional"] = self.isOptional!
                }
                if self.responseStatus != nil {
                    map["ResponseStatus"] = self.responseStatus!
                }
                if self.self_ != nil {
                    map["Self"] = self.self_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("IsOptional") && dict["IsOptional"] != nil {
                    self.isOptional = dict["IsOptional"] as! Bool
                }
                if dict.keys.contains("ResponseStatus") && dict["ResponseStatus"] != nil {
                    self.responseStatus = dict["ResponseStatus"] as! String
                }
                if dict.keys.contains("Self") && dict["Self"] != nil {
                    self.self_ = dict["Self"] as! Bool
                }
            }
        }
        public class Categories : Tea.TeaModel {
            public var displayName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                    self.displayName = dict["DisplayName"] as! String
                }
            }
        }
        public class End : Tea.TeaModel {
            public var date: String?

            public var dateTime: String?

            public var timeZone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.date != nil {
                    map["Date"] = self.date!
                }
                if self.dateTime != nil {
                    map["DateTime"] = self.dateTime!
                }
                if self.timeZone != nil {
                    map["TimeZone"] = self.timeZone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Date") && dict["Date"] != nil {
                    self.date = dict["Date"] as! String
                }
                if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                    self.dateTime = dict["DateTime"] as! String
                }
                if dict.keys.contains("TimeZone") && dict["TimeZone"] != nil {
                    self.timeZone = dict["TimeZone"] as! String
                }
            }
        }
        public class ExtendedProperties : Tea.TeaModel {
            public class SharedProperties : Tea.TeaModel {
                public var belongCorpId: String?

                public var sourceOpenCid: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.belongCorpId != nil {
                        map["BelongCorpId"] = self.belongCorpId!
                    }
                    if self.sourceOpenCid != nil {
                        map["SourceOpenCid"] = self.sourceOpenCid!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BelongCorpId") && dict["BelongCorpId"] != nil {
                        self.belongCorpId = dict["BelongCorpId"] as! String
                    }
                    if dict.keys.contains("SourceOpenCid") && dict["SourceOpenCid"] != nil {
                        self.sourceOpenCid = dict["SourceOpenCid"] as! String
                    }
                }
            }
            public var sharedProperties: ListEventsResponseBody.Events.ExtendedProperties.SharedProperties?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.sharedProperties?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sharedProperties != nil {
                    map["SharedProperties"] = self.sharedProperties?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("SharedProperties") && dict["SharedProperties"] != nil {
                    var model = ListEventsResponseBody.Events.ExtendedProperties.SharedProperties()
                    model.fromMap(dict["SharedProperties"] as! [String: Any])
                    self.sharedProperties = model
                }
            }
        }
        public class Location : Tea.TeaModel {
            public var displayName: String?

            public var meetingRooms: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.meetingRooms != nil {
                    map["MeetingRooms"] = self.meetingRooms!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("MeetingRooms") && dict["MeetingRooms"] != nil {
                    self.meetingRooms = dict["MeetingRooms"] as! [String]
                }
            }
        }
        public class MeetingRooms : Tea.TeaModel {
            public var displayName: String?

            public var responseStatus: String?

            public var roomId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.responseStatus != nil {
                    map["ResponseStatus"] = self.responseStatus!
                }
                if self.roomId != nil {
                    map["RoomId"] = self.roomId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("ResponseStatus") && dict["ResponseStatus"] != nil {
                    self.responseStatus = dict["ResponseStatus"] as! String
                }
                if dict.keys.contains("RoomId") && dict["RoomId"] != nil {
                    self.roomId = dict["RoomId"] as! String
                }
            }
        }
        public class OnlineMeetingInfo : Tea.TeaModel {
            public var conferenceId: String?

            public var extraInfo: [String: Any]?

            public var type: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.conferenceId != nil {
                    map["ConferenceId"] = self.conferenceId!
                }
                if self.extraInfo != nil {
                    map["ExtraInfo"] = self.extraInfo!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConferenceId") && dict["ConferenceId"] != nil {
                    self.conferenceId = dict["ConferenceId"] as! String
                }
                if dict.keys.contains("ExtraInfo") && dict["ExtraInfo"] != nil {
                    self.extraInfo = dict["ExtraInfo"] as! [String: Any]
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Url") && dict["Url"] != nil {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public class Organizer : Tea.TeaModel {
            public var displayName: String?

            public var responseStatus: String?

            public var self_: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.responseStatus != nil {
                    map["ResponseStatus"] = self.responseStatus!
                }
                if self.self_ != nil {
                    map["Self"] = self.self_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("ResponseStatus") && dict["ResponseStatus"] != nil {
                    self.responseStatus = dict["ResponseStatus"] as! String
                }
                if dict.keys.contains("Self") && dict["Self"] != nil {
                    self.self_ = dict["Self"] as! Bool
                }
            }
        }
        public class OriginStart : Tea.TeaModel {
            public var dateTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dateTime != nil {
                    map["DateTime"] = self.dateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                    self.dateTime = dict["DateTime"] as! String
                }
            }
        }
        public class Recurrence : Tea.TeaModel {
            public class Pattern : Tea.TeaModel {
                public var dayOfMonth: Int32?

                public var daysOfWeek: String?

                public var index: String?

                public var interval: Int32?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dayOfMonth != nil {
                        map["DayOfMonth"] = self.dayOfMonth!
                    }
                    if self.daysOfWeek != nil {
                        map["DaysOfWeek"] = self.daysOfWeek!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.interval != nil {
                        map["Interval"] = self.interval!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DayOfMonth") && dict["DayOfMonth"] != nil {
                        self.dayOfMonth = dict["DayOfMonth"] as! Int32
                    }
                    if dict.keys.contains("DaysOfWeek") && dict["DaysOfWeek"] != nil {
                        self.daysOfWeek = dict["DaysOfWeek"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Interval") && dict["Interval"] != nil {
                        self.interval = dict["Interval"] as! Int32
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class Range : Tea.TeaModel {
                public var endDate: String?

                public var numberOfOccurrences: Int32?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.endDate != nil {
                        map["EndDate"] = self.endDate!
                    }
                    if self.numberOfOccurrences != nil {
                        map["NumberOfOccurrences"] = self.numberOfOccurrences!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EndDate") && dict["EndDate"] != nil {
                        self.endDate = dict["EndDate"] as! String
                    }
                    if dict.keys.contains("NumberOfOccurrences") && dict["NumberOfOccurrences"] != nil {
                        self.numberOfOccurrences = dict["NumberOfOccurrences"] as! Int32
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var pattern: ListEventsResponseBody.Events.Recurrence.Pattern?

            public var range: ListEventsResponseBody.Events.Recurrence.Range?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.pattern?.validate()
                try self.range?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pattern != nil {
                    map["Pattern"] = self.pattern?.toMap()
                }
                if self.range != nil {
                    map["Range"] = self.range?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Pattern") && dict["Pattern"] != nil {
                    var model = ListEventsResponseBody.Events.Recurrence.Pattern()
                    model.fromMap(dict["Pattern"] as! [String: Any])
                    self.pattern = model
                }
                if dict.keys.contains("Range") && dict["Range"] != nil {
                    var model = ListEventsResponseBody.Events.Recurrence.Range()
                    model.fromMap(dict["Range"] as! [String: Any])
                    self.range = model
                }
            }
        }
        public class Reminders : Tea.TeaModel {
            public var method: String?

            public var minutes: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.minutes != nil {
                    map["Minutes"] = self.minutes!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Method") && dict["Method"] != nil {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("Minutes") && dict["Minutes"] != nil {
                    self.minutes = dict["Minutes"] as! String
                }
            }
        }
        public class RichTextDescription : Tea.TeaModel {
            public var text: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.text != nil {
                    map["Text"] = self.text!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Text") && dict["Text"] != nil {
                    self.text = dict["Text"] as! String
                }
            }
        }
        public class Start : Tea.TeaModel {
            public var date: String?

            public var dateTime: String?

            public var timeZone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.date != nil {
                    map["Date"] = self.date!
                }
                if self.dateTime != nil {
                    map["DateTime"] = self.dateTime!
                }
                if self.timeZone != nil {
                    map["TimeZone"] = self.timeZone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Date") && dict["Date"] != nil {
                    self.date = dict["Date"] as! String
                }
                if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                    self.dateTime = dict["DateTime"] as! String
                }
                if dict.keys.contains("TimeZone") && dict["TimeZone"] != nil {
                    self.timeZone = dict["TimeZone"] as! String
                }
            }
        }
        public var attendees: [ListEventsResponseBody.Events.Attendees]?

        public var categories: [ListEventsResponseBody.Events.Categories]?

        public var createTime: String?

        public var description_: String?

        public var end: ListEventsResponseBody.Events.End?

        public var extendedProperties: ListEventsResponseBody.Events.ExtendedProperties?

        public var id: String?

        public var isAllDay: Bool?

        public var location: ListEventsResponseBody.Events.Location?

        public var meetingRooms: [ListEventsResponseBody.Events.MeetingRooms]?

        public var onlineMeetingInfo: ListEventsResponseBody.Events.OnlineMeetingInfo?

        public var organizer: ListEventsResponseBody.Events.Organizer?

        public var originStart: ListEventsResponseBody.Events.OriginStart?

        public var recurrence: ListEventsResponseBody.Events.Recurrence?

        public var reminders: [ListEventsResponseBody.Events.Reminders]?

        public var richTextDescription: ListEventsResponseBody.Events.RichTextDescription?

        public var seriesMasterId: String?

        public var start: ListEventsResponseBody.Events.Start?

        public var status: String?

        public var summary: String?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.end?.validate()
            try self.extendedProperties?.validate()
            try self.location?.validate()
            try self.onlineMeetingInfo?.validate()
            try self.organizer?.validate()
            try self.originStart?.validate()
            try self.recurrence?.validate()
            try self.richTextDescription?.validate()
            try self.start?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attendees != nil {
                var tmp : [Any] = []
                for k in self.attendees! {
                    tmp.append(k.toMap())
                }
                map["Attendees"] = tmp
            }
            if self.categories != nil {
                var tmp : [Any] = []
                for k in self.categories! {
                    tmp.append(k.toMap())
                }
                map["Categories"] = tmp
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.end != nil {
                map["End"] = self.end?.toMap()
            }
            if self.extendedProperties != nil {
                map["ExtendedProperties"] = self.extendedProperties?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.isAllDay != nil {
                map["IsAllDay"] = self.isAllDay!
            }
            if self.location != nil {
                map["Location"] = self.location?.toMap()
            }
            if self.meetingRooms != nil {
                var tmp : [Any] = []
                for k in self.meetingRooms! {
                    tmp.append(k.toMap())
                }
                map["MeetingRooms"] = tmp
            }
            if self.onlineMeetingInfo != nil {
                map["OnlineMeetingInfo"] = self.onlineMeetingInfo?.toMap()
            }
            if self.organizer != nil {
                map["Organizer"] = self.organizer?.toMap()
            }
            if self.originStart != nil {
                map["OriginStart"] = self.originStart?.toMap()
            }
            if self.recurrence != nil {
                map["Recurrence"] = self.recurrence?.toMap()
            }
            if self.reminders != nil {
                var tmp : [Any] = []
                for k in self.reminders! {
                    tmp.append(k.toMap())
                }
                map["Reminders"] = tmp
            }
            if self.richTextDescription != nil {
                map["RichTextDescription"] = self.richTextDescription?.toMap()
            }
            if self.seriesMasterId != nil {
                map["SeriesMasterId"] = self.seriesMasterId!
            }
            if self.start != nil {
                map["Start"] = self.start?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.summary != nil {
                map["Summary"] = self.summary!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Attendees") && dict["Attendees"] != nil {
                var tmp : [ListEventsResponseBody.Events.Attendees] = []
                for v in dict["Attendees"] as! [Any] {
                    var model = ListEventsResponseBody.Events.Attendees()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.attendees = tmp
            }
            if dict.keys.contains("Categories") && dict["Categories"] != nil {
                var tmp : [ListEventsResponseBody.Events.Categories] = []
                for v in dict["Categories"] as! [Any] {
                    var model = ListEventsResponseBody.Events.Categories()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.categories = tmp
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("End") && dict["End"] != nil {
                var model = ListEventsResponseBody.Events.End()
                model.fromMap(dict["End"] as! [String: Any])
                self.end = model
            }
            if dict.keys.contains("ExtendedProperties") && dict["ExtendedProperties"] != nil {
                var model = ListEventsResponseBody.Events.ExtendedProperties()
                model.fromMap(dict["ExtendedProperties"] as! [String: Any])
                self.extendedProperties = model
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("IsAllDay") && dict["IsAllDay"] != nil {
                self.isAllDay = dict["IsAllDay"] as! Bool
            }
            if dict.keys.contains("Location") && dict["Location"] != nil {
                var model = ListEventsResponseBody.Events.Location()
                model.fromMap(dict["Location"] as! [String: Any])
                self.location = model
            }
            if dict.keys.contains("MeetingRooms") && dict["MeetingRooms"] != nil {
                var tmp : [ListEventsResponseBody.Events.MeetingRooms] = []
                for v in dict["MeetingRooms"] as! [Any] {
                    var model = ListEventsResponseBody.Events.MeetingRooms()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.meetingRooms = tmp
            }
            if dict.keys.contains("OnlineMeetingInfo") && dict["OnlineMeetingInfo"] != nil {
                var model = ListEventsResponseBody.Events.OnlineMeetingInfo()
                model.fromMap(dict["OnlineMeetingInfo"] as! [String: Any])
                self.onlineMeetingInfo = model
            }
            if dict.keys.contains("Organizer") && dict["Organizer"] != nil {
                var model = ListEventsResponseBody.Events.Organizer()
                model.fromMap(dict["Organizer"] as! [String: Any])
                self.organizer = model
            }
            if dict.keys.contains("OriginStart") && dict["OriginStart"] != nil {
                var model = ListEventsResponseBody.Events.OriginStart()
                model.fromMap(dict["OriginStart"] as! [String: Any])
                self.originStart = model
            }
            if dict.keys.contains("Recurrence") && dict["Recurrence"] != nil {
                var model = ListEventsResponseBody.Events.Recurrence()
                model.fromMap(dict["Recurrence"] as! [String: Any])
                self.recurrence = model
            }
            if dict.keys.contains("Reminders") && dict["Reminders"] != nil {
                var tmp : [ListEventsResponseBody.Events.Reminders] = []
                for v in dict["Reminders"] as! [Any] {
                    var model = ListEventsResponseBody.Events.Reminders()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.reminders = tmp
            }
            if dict.keys.contains("RichTextDescription") && dict["RichTextDescription"] != nil {
                var model = ListEventsResponseBody.Events.RichTextDescription()
                model.fromMap(dict["RichTextDescription"] as! [String: Any])
                self.richTextDescription = model
            }
            if dict.keys.contains("SeriesMasterId") && dict["SeriesMasterId"] != nil {
                self.seriesMasterId = dict["SeriesMasterId"] as! String
            }
            if dict.keys.contains("Start") && dict["Start"] != nil {
                var model = ListEventsResponseBody.Events.Start()
                model.fromMap(dict["Start"] as! [String: Any])
                self.start = model
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Summary") && dict["Summary"] != nil {
                self.summary = dict["Summary"] as! String
            }
            if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                self.updateTime = dict["UpdateTime"] as! String
            }
        }
    }
    public var events: [ListEventsResponseBody.Events]?

    public var nextToken: String?

    public var requestId: String?

    public var syncToken: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.events != nil {
            var tmp : [Any] = []
            for k in self.events! {
                tmp.append(k.toMap())
            }
            map["events"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.syncToken != nil {
            map["syncToken"] = self.syncToken!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("events") && dict["events"] != nil {
            var tmp : [ListEventsResponseBody.Events] = []
            for v in dict["events"] as! [Any] {
                var model = ListEventsResponseBody.Events()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.events = tmp
        }
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("syncToken") && dict["syncToken"] != nil {
            self.syncToken = dict["syncToken"] as! String
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class ListEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEventsViewHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListEventsViewHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = ListEventsViewHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListEventsViewShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListEventsViewRequest : Tea.TeaModel {
    public var calendarId: String?

    public var maxAttendees: Int32?

    public var maxResults: Int32?

    public var nextToken: String?

    public var timeMax: String?

    public var timeMin: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.maxAttendees != nil {
            map["MaxAttendees"] = self.maxAttendees!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.timeMax != nil {
            map["TimeMax"] = self.timeMax!
        }
        if self.timeMin != nil {
            map["TimeMin"] = self.timeMin!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("MaxAttendees") && dict["MaxAttendees"] != nil {
            self.maxAttendees = dict["MaxAttendees"] as! Int32
        }
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("TimeMax") && dict["TimeMax"] != nil {
            self.timeMax = dict["TimeMax"] as! String
        }
        if dict.keys.contains("TimeMin") && dict["TimeMin"] != nil {
            self.timeMin = dict["TimeMin"] as! String
        }
    }
}

public class ListEventsViewResponseBody : Tea.TeaModel {
    public class Events : Tea.TeaModel {
        public class Attendees : Tea.TeaModel {
            public var displayName: String?

            public var id: String?

            public var isOptional: Bool?

            public var responseStatus: String?

            public var self_: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.isOptional != nil {
                    map["IsOptional"] = self.isOptional!
                }
                if self.responseStatus != nil {
                    map["ResponseStatus"] = self.responseStatus!
                }
                if self.self_ != nil {
                    map["Self"] = self.self_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("IsOptional") && dict["IsOptional"] != nil {
                    self.isOptional = dict["IsOptional"] as! Bool
                }
                if dict.keys.contains("ResponseStatus") && dict["ResponseStatus"] != nil {
                    self.responseStatus = dict["ResponseStatus"] as! String
                }
                if dict.keys.contains("Self") && dict["Self"] != nil {
                    self.self_ = dict["Self"] as! Bool
                }
            }
        }
        public class Categories : Tea.TeaModel {
            public var displayName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                    self.displayName = dict["DisplayName"] as! String
                }
            }
        }
        public class End : Tea.TeaModel {
            public var date: String?

            public var dateTime: String?

            public var timeZone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.date != nil {
                    map["Date"] = self.date!
                }
                if self.dateTime != nil {
                    map["DateTime"] = self.dateTime!
                }
                if self.timeZone != nil {
                    map["TimeZone"] = self.timeZone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Date") && dict["Date"] != nil {
                    self.date = dict["Date"] as! String
                }
                if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                    self.dateTime = dict["DateTime"] as! String
                }
                if dict.keys.contains("TimeZone") && dict["TimeZone"] != nil {
                    self.timeZone = dict["TimeZone"] as! String
                }
            }
        }
        public class ExtendedProperties : Tea.TeaModel {
            public class SharedProperties : Tea.TeaModel {
                public var belongCorpId: String?

                public var sourceOpenCid: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.belongCorpId != nil {
                        map["BelongCorpId"] = self.belongCorpId!
                    }
                    if self.sourceOpenCid != nil {
                        map["SourceOpenCid"] = self.sourceOpenCid!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BelongCorpId") && dict["BelongCorpId"] != nil {
                        self.belongCorpId = dict["BelongCorpId"] as! String
                    }
                    if dict.keys.contains("SourceOpenCid") && dict["SourceOpenCid"] != nil {
                        self.sourceOpenCid = dict["SourceOpenCid"] as! String
                    }
                }
            }
            public var sharedProperties: ListEventsViewResponseBody.Events.ExtendedProperties.SharedProperties?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.sharedProperties?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sharedProperties != nil {
                    map["SharedProperties"] = self.sharedProperties?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("SharedProperties") && dict["SharedProperties"] != nil {
                    var model = ListEventsViewResponseBody.Events.ExtendedProperties.SharedProperties()
                    model.fromMap(dict["SharedProperties"] as! [String: Any])
                    self.sharedProperties = model
                }
            }
        }
        public class Location : Tea.TeaModel {
            public var displayName: String?

            public var meetingRooms: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.meetingRooms != nil {
                    map["MeetingRooms"] = self.meetingRooms!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("MeetingRooms") && dict["MeetingRooms"] != nil {
                    self.meetingRooms = dict["MeetingRooms"] as! [String]
                }
            }
        }
        public class MeetingRooms : Tea.TeaModel {
            public var displayName: String?

            public var responseStatus: String?

            public var roomId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.responseStatus != nil {
                    map["ResponseStatus"] = self.responseStatus!
                }
                if self.roomId != nil {
                    map["RoomId"] = self.roomId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("ResponseStatus") && dict["ResponseStatus"] != nil {
                    self.responseStatus = dict["ResponseStatus"] as! String
                }
                if dict.keys.contains("RoomId") && dict["RoomId"] != nil {
                    self.roomId = dict["RoomId"] as! String
                }
            }
        }
        public class OnlineMeetingInfo : Tea.TeaModel {
            public var conferenceId: String?

            public var extraInfo: [String: Any]?

            public var type: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.conferenceId != nil {
                    map["ConferenceId"] = self.conferenceId!
                }
                if self.extraInfo != nil {
                    map["ExtraInfo"] = self.extraInfo!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConferenceId") && dict["ConferenceId"] != nil {
                    self.conferenceId = dict["ConferenceId"] as! String
                }
                if dict.keys.contains("ExtraInfo") && dict["ExtraInfo"] != nil {
                    self.extraInfo = dict["ExtraInfo"] as! [String: Any]
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Url") && dict["Url"] != nil {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public class Organizer : Tea.TeaModel {
            public var displayName: String?

            public var id: String?

            public var responseStatus: String?

            public var self_: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.responseStatus != nil {
                    map["ResponseStatus"] = self.responseStatus!
                }
                if self.self_ != nil {
                    map["Self"] = self.self_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("ResponseStatus") && dict["ResponseStatus"] != nil {
                    self.responseStatus = dict["ResponseStatus"] as! String
                }
                if dict.keys.contains("Self") && dict["Self"] != nil {
                    self.self_ = dict["Self"] as! Bool
                }
            }
        }
        public class OriginStart : Tea.TeaModel {
            public var dateTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dateTime != nil {
                    map["DateTime"] = self.dateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                    self.dateTime = dict["DateTime"] as! String
                }
            }
        }
        public class Recurrence : Tea.TeaModel {
            public class Pattern : Tea.TeaModel {
                public var dayOfMonth: Int32?

                public var daysOfWeek: String?

                public var index: String?

                public var interval: Int32?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dayOfMonth != nil {
                        map["DayOfMonth"] = self.dayOfMonth!
                    }
                    if self.daysOfWeek != nil {
                        map["DaysOfWeek"] = self.daysOfWeek!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.interval != nil {
                        map["Interval"] = self.interval!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DayOfMonth") && dict["DayOfMonth"] != nil {
                        self.dayOfMonth = dict["DayOfMonth"] as! Int32
                    }
                    if dict.keys.contains("DaysOfWeek") && dict["DaysOfWeek"] != nil {
                        self.daysOfWeek = dict["DaysOfWeek"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! String
                    }
                    if dict.keys.contains("Interval") && dict["Interval"] != nil {
                        self.interval = dict["Interval"] as! Int32
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class Range : Tea.TeaModel {
                public var endDate: String?

                public var numberOfOccurrences: Int32?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.endDate != nil {
                        map["EndDate"] = self.endDate!
                    }
                    if self.numberOfOccurrences != nil {
                        map["NumberOfOccurrences"] = self.numberOfOccurrences!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EndDate") && dict["EndDate"] != nil {
                        self.endDate = dict["EndDate"] as! String
                    }
                    if dict.keys.contains("NumberOfOccurrences") && dict["NumberOfOccurrences"] != nil {
                        self.numberOfOccurrences = dict["NumberOfOccurrences"] as! Int32
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var pattern: ListEventsViewResponseBody.Events.Recurrence.Pattern?

            public var range: ListEventsViewResponseBody.Events.Recurrence.Range?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.pattern?.validate()
                try self.range?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pattern != nil {
                    map["Pattern"] = self.pattern?.toMap()
                }
                if self.range != nil {
                    map["Range"] = self.range?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Pattern") && dict["Pattern"] != nil {
                    var model = ListEventsViewResponseBody.Events.Recurrence.Pattern()
                    model.fromMap(dict["Pattern"] as! [String: Any])
                    self.pattern = model
                }
                if dict.keys.contains("Range") && dict["Range"] != nil {
                    var model = ListEventsViewResponseBody.Events.Recurrence.Range()
                    model.fromMap(dict["Range"] as! [String: Any])
                    self.range = model
                }
            }
        }
        public class RichTextDescription : Tea.TeaModel {
            public var text: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.text != nil {
                    map["Text"] = self.text!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Text") && dict["Text"] != nil {
                    self.text = dict["Text"] as! String
                }
            }
        }
        public class Start : Tea.TeaModel {
            public var date: String?

            public var dateTime: String?

            public var timeZone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.date != nil {
                    map["Date"] = self.date!
                }
                if self.dateTime != nil {
                    map["DateTime"] = self.dateTime!
                }
                if self.timeZone != nil {
                    map["TimeZone"] = self.timeZone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Date") && dict["Date"] != nil {
                    self.date = dict["Date"] as! String
                }
                if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                    self.dateTime = dict["DateTime"] as! String
                }
                if dict.keys.contains("TimeZone") && dict["TimeZone"] != nil {
                    self.timeZone = dict["TimeZone"] as! String
                }
            }
        }
        public var attendees: [ListEventsViewResponseBody.Events.Attendees]?

        public var categories: [ListEventsViewResponseBody.Events.Categories]?

        public var createTime: String?

        public var description_: String?

        public var end: ListEventsViewResponseBody.Events.End?

        public var extendedProperties: ListEventsViewResponseBody.Events.ExtendedProperties?

        public var id: String?

        public var isAllDay: Bool?

        public var location: ListEventsViewResponseBody.Events.Location?

        public var meetingRooms: [ListEventsViewResponseBody.Events.MeetingRooms]?

        public var onlineMeetingInfo: ListEventsViewResponseBody.Events.OnlineMeetingInfo?

        public var organizer: ListEventsViewResponseBody.Events.Organizer?

        public var originStart: ListEventsViewResponseBody.Events.OriginStart?

        public var recurrence: ListEventsViewResponseBody.Events.Recurrence?

        public var richTextDescription: ListEventsViewResponseBody.Events.RichTextDescription?

        public var seriesMasterId: String?

        public var start: ListEventsViewResponseBody.Events.Start?

        public var status: String?

        public var summary: String?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.end?.validate()
            try self.extendedProperties?.validate()
            try self.location?.validate()
            try self.onlineMeetingInfo?.validate()
            try self.organizer?.validate()
            try self.originStart?.validate()
            try self.recurrence?.validate()
            try self.richTextDescription?.validate()
            try self.start?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attendees != nil {
                var tmp : [Any] = []
                for k in self.attendees! {
                    tmp.append(k.toMap())
                }
                map["Attendees"] = tmp
            }
            if self.categories != nil {
                var tmp : [Any] = []
                for k in self.categories! {
                    tmp.append(k.toMap())
                }
                map["Categories"] = tmp
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.end != nil {
                map["End"] = self.end?.toMap()
            }
            if self.extendedProperties != nil {
                map["ExtendedProperties"] = self.extendedProperties?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.isAllDay != nil {
                map["IsAllDay"] = self.isAllDay!
            }
            if self.location != nil {
                map["Location"] = self.location?.toMap()
            }
            if self.meetingRooms != nil {
                var tmp : [Any] = []
                for k in self.meetingRooms! {
                    tmp.append(k.toMap())
                }
                map["MeetingRooms"] = tmp
            }
            if self.onlineMeetingInfo != nil {
                map["OnlineMeetingInfo"] = self.onlineMeetingInfo?.toMap()
            }
            if self.organizer != nil {
                map["Organizer"] = self.organizer?.toMap()
            }
            if self.originStart != nil {
                map["OriginStart"] = self.originStart?.toMap()
            }
            if self.recurrence != nil {
                map["Recurrence"] = self.recurrence?.toMap()
            }
            if self.richTextDescription != nil {
                map["RichTextDescription"] = self.richTextDescription?.toMap()
            }
            if self.seriesMasterId != nil {
                map["SeriesMasterId"] = self.seriesMasterId!
            }
            if self.start != nil {
                map["Start"] = self.start?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.summary != nil {
                map["Summary"] = self.summary!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Attendees") && dict["Attendees"] != nil {
                var tmp : [ListEventsViewResponseBody.Events.Attendees] = []
                for v in dict["Attendees"] as! [Any] {
                    var model = ListEventsViewResponseBody.Events.Attendees()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.attendees = tmp
            }
            if dict.keys.contains("Categories") && dict["Categories"] != nil {
                var tmp : [ListEventsViewResponseBody.Events.Categories] = []
                for v in dict["Categories"] as! [Any] {
                    var model = ListEventsViewResponseBody.Events.Categories()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.categories = tmp
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("End") && dict["End"] != nil {
                var model = ListEventsViewResponseBody.Events.End()
                model.fromMap(dict["End"] as! [String: Any])
                self.end = model
            }
            if dict.keys.contains("ExtendedProperties") && dict["ExtendedProperties"] != nil {
                var model = ListEventsViewResponseBody.Events.ExtendedProperties()
                model.fromMap(dict["ExtendedProperties"] as! [String: Any])
                self.extendedProperties = model
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("IsAllDay") && dict["IsAllDay"] != nil {
                self.isAllDay = dict["IsAllDay"] as! Bool
            }
            if dict.keys.contains("Location") && dict["Location"] != nil {
                var model = ListEventsViewResponseBody.Events.Location()
                model.fromMap(dict["Location"] as! [String: Any])
                self.location = model
            }
            if dict.keys.contains("MeetingRooms") && dict["MeetingRooms"] != nil {
                var tmp : [ListEventsViewResponseBody.Events.MeetingRooms] = []
                for v in dict["MeetingRooms"] as! [Any] {
                    var model = ListEventsViewResponseBody.Events.MeetingRooms()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.meetingRooms = tmp
            }
            if dict.keys.contains("OnlineMeetingInfo") && dict["OnlineMeetingInfo"] != nil {
                var model = ListEventsViewResponseBody.Events.OnlineMeetingInfo()
                model.fromMap(dict["OnlineMeetingInfo"] as! [String: Any])
                self.onlineMeetingInfo = model
            }
            if dict.keys.contains("Organizer") && dict["Organizer"] != nil {
                var model = ListEventsViewResponseBody.Events.Organizer()
                model.fromMap(dict["Organizer"] as! [String: Any])
                self.organizer = model
            }
            if dict.keys.contains("OriginStart") && dict["OriginStart"] != nil {
                var model = ListEventsViewResponseBody.Events.OriginStart()
                model.fromMap(dict["OriginStart"] as! [String: Any])
                self.originStart = model
            }
            if dict.keys.contains("Recurrence") && dict["Recurrence"] != nil {
                var model = ListEventsViewResponseBody.Events.Recurrence()
                model.fromMap(dict["Recurrence"] as! [String: Any])
                self.recurrence = model
            }
            if dict.keys.contains("RichTextDescription") && dict["RichTextDescription"] != nil {
                var model = ListEventsViewResponseBody.Events.RichTextDescription()
                model.fromMap(dict["RichTextDescription"] as! [String: Any])
                self.richTextDescription = model
            }
            if dict.keys.contains("SeriesMasterId") && dict["SeriesMasterId"] != nil {
                self.seriesMasterId = dict["SeriesMasterId"] as! String
            }
            if dict.keys.contains("Start") && dict["Start"] != nil {
                var model = ListEventsViewResponseBody.Events.Start()
                model.fromMap(dict["Start"] as! [String: Any])
                self.start = model
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Summary") && dict["Summary"] != nil {
                self.summary = dict["Summary"] as! String
            }
            if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                self.updateTime = dict["UpdateTime"] as! String
            }
        }
    }
    public var events: [ListEventsViewResponseBody.Events]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.events != nil {
            var tmp : [Any] = []
            for k in self.events! {
                tmp.append(k.toMap())
            }
            map["events"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("events") && dict["events"] != nil {
            var tmp : [ListEventsViewResponseBody.Events] = []
            for v in dict["events"] as! [Any] {
                var model = ListEventsViewResponseBody.Events()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.events = tmp
        }
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListEventsViewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEventsViewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListEventsViewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFormRemarksHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListFormRemarksHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = ListFormRemarksHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListFormRemarksShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListFormRemarksRequest : Tea.TeaModel {
    public var appType: String?

    public var formInstanceIdList: [String]?

    public var formUuid: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.formInstanceIdList != nil {
            map["FormInstanceIdList"] = self.formInstanceIdList!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FormInstanceIdList") && dict["FormInstanceIdList"] != nil {
            self.formInstanceIdList = dict["FormInstanceIdList"] as! [String]
        }
        if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class ListFormRemarksShrinkRequest : Tea.TeaModel {
    public var appType: String?

    public var formInstanceIdListShrink: String?

    public var formUuid: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.formInstanceIdListShrink != nil {
            map["FormInstanceIdList"] = self.formInstanceIdListShrink!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FormInstanceIdList") && dict["FormInstanceIdList"] != nil {
            self.formInstanceIdListShrink = dict["FormInstanceIdList"] as! String
        }
        if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class ListFormRemarksResponseBody : Tea.TeaModel {
    public var formRemarkVoMap: [String: Any]?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.formRemarkVoMap != nil {
            map["formRemarkVoMap"] = self.formRemarkVoMap!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("formRemarkVoMap") && dict["formRemarkVoMap"] != nil {
            self.formRemarkVoMap = dict["formRemarkVoMap"] as! [String: Any]
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class ListFormRemarksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFormRemarksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListFormRemarksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNavigationByFormTypeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListNavigationByFormTypeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = ListNavigationByFormTypeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListNavigationByFormTypeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListNavigationByFormTypeRequest : Tea.TeaModel {
    public var appType: String?

    public var formType: String?

    public var language: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.formType != nil {
            map["FormType"] = self.formType!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FormType") && dict["FormType"] != nil {
            self.formType = dict["FormType"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class ListNavigationByFormTypeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Title : Tea.TeaModel {
            public var nameInChinese: String?

            public var nameInEnglish: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.nameInChinese != nil {
                    map["NameInChinese"] = self.nameInChinese!
                }
                if self.nameInEnglish != nil {
                    map["NameInEnglish"] = self.nameInEnglish!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NameInChinese") && dict["NameInChinese"] != nil {
                    self.nameInChinese = dict["NameInChinese"] as! String
                }
                if dict.keys.contains("NameInEnglish") && dict["NameInEnglish"] != nil {
                    self.nameInEnglish = dict["NameInEnglish"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var formUuid: String?

        public var processCode: String?

        public var title: ListNavigationByFormTypeResponseBody.Result.Title?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.title?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.formUuid != nil {
                map["FormUuid"] = self.formUuid!
            }
            if self.processCode != nil {
                map["ProcessCode"] = self.processCode!
            }
            if self.title != nil {
                map["Title"] = self.title?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
                self.formUuid = dict["FormUuid"] as! String
            }
            if dict.keys.contains("ProcessCode") && dict["ProcessCode"] != nil {
                self.processCode = dict["ProcessCode"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                var model = ListNavigationByFormTypeResponseBody.Result.Title()
                model.fromMap(dict["Title"] as! [String: Any])
                self.title = model
            }
        }
    }
    public var requestId: String?

    public var result: [ListNavigationByFormTypeResponseBody.Result]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            var tmp : [ListNavigationByFormTypeResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ListNavigationByFormTypeResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class ListNavigationByFormTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNavigationByFormTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListNavigationByFormTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNodesHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListNodesHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = ListNodesHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListNodesShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListNodesRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var parentNodeId: String?

    public var tenantContext: ListNodesRequest.TenantContext?

    public var withPermissionRole: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.parentNodeId != nil {
            map["ParentNodeId"] = self.parentNodeId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.withPermissionRole != nil {
            map["WithPermissionRole"] = self.withPermissionRole!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("ParentNodeId") && dict["ParentNodeId"] != nil {
            self.parentNodeId = dict["ParentNodeId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = ListNodesRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WithPermissionRole") && dict["WithPermissionRole"] != nil {
            self.withPermissionRole = dict["WithPermissionRole"] as! Bool
        }
    }
}

public class ListNodesShrinkRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var parentNodeId: String?

    public var tenantContextShrink: String?

    public var withPermissionRole: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.parentNodeId != nil {
            map["ParentNodeId"] = self.parentNodeId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.withPermissionRole != nil {
            map["WithPermissionRole"] = self.withPermissionRole!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("ParentNodeId") && dict["ParentNodeId"] != nil {
            self.parentNodeId = dict["ParentNodeId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WithPermissionRole") && dict["WithPermissionRole"] != nil {
            self.withPermissionRole = dict["WithPermissionRole"] as! Bool
        }
    }
}

public class ListNodesResponseBody : Tea.TeaModel {
    public class Nodes : Tea.TeaModel {
        public class StatisticalInfo : Tea.TeaModel {
            public var wordCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.wordCount != nil {
                    map["WordCount"] = self.wordCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("WordCount") && dict["WordCount"] != nil {
                    self.wordCount = dict["WordCount"] as! Int64
                }
            }
        }
        public var category: String?

        public var createTime: String?

        public var creatorId: String?

        public var extension_: String?

        public var hasChildren: Bool?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var nodeId: String?

        public var permissionRole: String?

        public var size: Int64?

        public var statisticalInfo: ListNodesResponseBody.Nodes.StatisticalInfo?

        public var type: String?

        public var url: String?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.statisticalInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.hasChildren != nil {
                map["HasChildren"] = self.hasChildren!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.permissionRole != nil {
                map["PermissionRole"] = self.permissionRole!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.statisticalInfo != nil {
                map["StatisticalInfo"] = self.statisticalInfo?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Extension") && dict["Extension"] != nil {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("HasChildren") && dict["HasChildren"] != nil {
                self.hasChildren = dict["HasChildren"] as! Bool
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") && dict["ModifierId"] != nil {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("PermissionRole") && dict["PermissionRole"] != nil {
                self.permissionRole = dict["PermissionRole"] as! String
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("StatisticalInfo") && dict["StatisticalInfo"] != nil {
                var model = ListNodesResponseBody.Nodes.StatisticalInfo()
                model.fromMap(dict["StatisticalInfo"] as! [String: Any])
                self.statisticalInfo = model
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var nextToken: String?

    public var nodes: [ListNodesResponseBody.Nodes]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.nodes != nil {
            var tmp : [Any] = []
            for k in self.nodes! {
                tmp.append(k.toMap())
            }
            map["nodes"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("nodes") && dict["nodes"] != nil {
            var tmp : [ListNodesResponseBody.Nodes] = []
            for v in dict["nodes"] as! [Any] {
                var model = ListNodesResponseBody.Nodes()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.nodes = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListNodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListReportHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListReportHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = ListReportHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListReportShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListReportRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var cursor: Int64?

    public var endTime: Int64?

    public var modifiedEndTime: Int64?

    public var modifiedStartTime: Int64?

    public var size: Int64?

    public var startTime: Int64?

    public var templateName: String?

    public var tenantContext: ListReportRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cursor != nil {
            map["Cursor"] = self.cursor!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.modifiedEndTime != nil {
            map["ModifiedEndTime"] = self.modifiedEndTime!
        }
        if self.modifiedStartTime != nil {
            map["ModifiedStartTime"] = self.modifiedStartTime!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cursor") && dict["Cursor"] != nil {
            self.cursor = dict["Cursor"] as! Int64
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ModifiedEndTime") && dict["ModifiedEndTime"] != nil {
            self.modifiedEndTime = dict["ModifiedEndTime"] as! Int64
        }
        if dict.keys.contains("ModifiedStartTime") && dict["ModifiedStartTime"] != nil {
            self.modifiedStartTime = dict["ModifiedStartTime"] as! Int64
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = ListReportRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class ListReportShrinkRequest : Tea.TeaModel {
    public var cursor: Int64?

    public var endTime: Int64?

    public var modifiedEndTime: Int64?

    public var modifiedStartTime: Int64?

    public var size: Int64?

    public var startTime: Int64?

    public var templateName: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cursor != nil {
            map["Cursor"] = self.cursor!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.modifiedEndTime != nil {
            map["ModifiedEndTime"] = self.modifiedEndTime!
        }
        if self.modifiedStartTime != nil {
            map["ModifiedStartTime"] = self.modifiedStartTime!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cursor") && dict["Cursor"] != nil {
            self.cursor = dict["Cursor"] as! Int64
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ModifiedEndTime") && dict["ModifiedEndTime"] != nil {
            self.modifiedEndTime = dict["ModifiedEndTime"] as! Int64
        }
        if dict.keys.contains("ModifiedStartTime") && dict["ModifiedStartTime"] != nil {
            self.modifiedStartTime = dict["ModifiedStartTime"] as! Int64
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class ListReportResponseBody : Tea.TeaModel {
    public class DataList : Tea.TeaModel {
        public class Contents : Tea.TeaModel {
            public var key: String?

            public var sort: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.sort != nil {
                    map["Sort"] = self.sort!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Sort") && dict["Sort"] != nil {
                    self.sort = dict["Sort"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var contents: [ListReportResponseBody.DataList.Contents]?

        public var createTime: Int64?

        public var creatorId: String?

        public var creatorName: String?

        public var deptName: String?

        public var images: [String]?

        public var latitude: String?

        public var longitude: String?

        public var modifiedTime: Int64?

        public var remark: String?

        public var reportId: String?

        public var templateName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contents != nil {
                var tmp : [Any] = []
                for k in self.contents! {
                    tmp.append(k.toMap())
                }
                map["Contents"] = tmp
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.creatorName != nil {
                map["CreatorName"] = self.creatorName!
            }
            if self.deptName != nil {
                map["DeptName"] = self.deptName!
            }
            if self.images != nil {
                map["Images"] = self.images!
            }
            if self.latitude != nil {
                map["Latitude"] = self.latitude!
            }
            if self.longitude != nil {
                map["Longitude"] = self.longitude!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.remark != nil {
                map["Remark"] = self.remark!
            }
            if self.reportId != nil {
                map["ReportId"] = self.reportId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Contents") && dict["Contents"] != nil {
                var tmp : [ListReportResponseBody.DataList.Contents] = []
                for v in dict["Contents"] as! [Any] {
                    var model = ListReportResponseBody.DataList.Contents()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.contents = tmp
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("CreatorName") && dict["CreatorName"] != nil {
                self.creatorName = dict["CreatorName"] as! String
            }
            if dict.keys.contains("DeptName") && dict["DeptName"] != nil {
                self.deptName = dict["DeptName"] as! String
            }
            if dict.keys.contains("Images") && dict["Images"] != nil {
                self.images = dict["Images"] as! [String]
            }
            if dict.keys.contains("Latitude") && dict["Latitude"] != nil {
                self.latitude = dict["Latitude"] as! String
            }
            if dict.keys.contains("Longitude") && dict["Longitude"] != nil {
                self.longitude = dict["Longitude"] as! String
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! Int64
            }
            if dict.keys.contains("Remark") && dict["Remark"] != nil {
                self.remark = dict["Remark"] as! String
            }
            if dict.keys.contains("ReportId") && dict["ReportId"] != nil {
                self.reportId = dict["ReportId"] as! String
            }
            if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
                self.templateName = dict["TemplateName"] as! String
            }
        }
    }
    public var dataList: [ListReportResponseBody.DataList]?

    public var hasMore: Bool?

    public var nextCursor: Int64?

    public var requestId: String?

    public var size: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataList != nil {
            var tmp : [Any] = []
            for k in self.dataList! {
                tmp.append(k.toMap())
            }
            map["dataList"] = tmp
        }
        if self.hasMore != nil {
            map["hasMore"] = self.hasMore!
        }
        if self.nextCursor != nil {
            map["nextCursor"] = self.nextCursor!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("dataList") && dict["dataList"] != nil {
            var tmp : [ListReportResponseBody.DataList] = []
            for v in dict["dataList"] as! [Any] {
                var model = ListReportResponseBody.DataList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataList = tmp
        }
        if dict.keys.contains("hasMore") && dict["hasMore"] != nil {
            self.hasMore = dict["hasMore"] as! Bool
        }
        if dict.keys.contains("nextCursor") && dict["nextCursor"] != nil {
            self.nextCursor = dict["nextCursor"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("size") && dict["size"] != nil {
            self.size = dict["size"] as! Int64
        }
    }
}

public class ListReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTableDataByFormInstanceIdTableIdHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListTableDataByFormInstanceIdTableIdHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = ListTableDataByFormInstanceIdTableIdHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListTableDataByFormInstanceIdTableIdShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListTableDataByFormInstanceIdTableIdRequest : Tea.TeaModel {
    public var appType: String?

    public var formInstanceId: String?

    public var formUuid: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var systemToken: String?

    public var tableFieldId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.formInstanceId != nil {
            map["FormInstanceId"] = self.formInstanceId!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.tableFieldId != nil {
            map["TableFieldId"] = self.tableFieldId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FormInstanceId") && dict["FormInstanceId"] != nil {
            self.formInstanceId = dict["FormInstanceId"] as! String
        }
        if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("TableFieldId") && dict["TableFieldId"] != nil {
            self.tableFieldId = dict["TableFieldId"] as! String
        }
    }
}

public class ListTableDataByFormInstanceIdTableIdResponseBody : Tea.TeaModel {
    public var data: [String]?

    public var pageNumber: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data!
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            self.data = dict["data"] as! [String]
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class ListTableDataByFormInstanceIdTableIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTableDataByFormInstanceIdTableIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListTableDataByFormInstanceIdTableIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTeamsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListTeamsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = ListTeamsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListTeamsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListTeamsRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var tenantContext: ListTeamsRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = ListTeamsRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class ListTeamsShrinkRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class ListTeamsResponseBody : Tea.TeaModel {
    public class Teams : Tea.TeaModel {
        public class Icon : Tea.TeaModel {
            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var corpId: String?

        public var cover: String?

        public var createTime: String?

        public var creatorId: String?

        public var description_: String?

        public var icon: ListTeamsResponseBody.Teams.Icon?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var teamId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.icon?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.cover != nil {
                map["Cover"] = self.cover!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.icon != nil {
                map["Icon"] = self.icon?.toMap()
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.teamId != nil {
                map["TeamId"] = self.teamId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") && dict["CorpId"] != nil {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("Cover") && dict["Cover"] != nil {
                self.cover = dict["Cover"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Icon") && dict["Icon"] != nil {
                var model = ListTeamsResponseBody.Teams.Icon()
                model.fromMap(dict["Icon"] as! [String: Any])
                self.icon = model
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") && dict["ModifierId"] != nil {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TeamId") && dict["TeamId"] != nil {
                self.teamId = dict["TeamId"] as! String
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var teams: [ListTeamsResponseBody.Teams]?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.teams != nil {
            var tmp : [Any] = []
            for k in self.teams! {
                tmp.append(k.toMap())
            }
            map["teams"] = tmp
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("teams") && dict["teams"] != nil {
            var tmp : [ListTeamsResponseBody.Teams] = []
            for v in dict["teams"] as! [Any] {
                var model = ListTeamsResponseBody.Teams()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.teams = tmp
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class ListTeamsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTeamsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListTeamsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListWorkspacesHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ListWorkspacesHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = ListWorkspacesHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ListWorkspacesShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ListWorkspacesRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var orderBy: String?

    public var teamId: String?

    public var tenantContext: ListWorkspacesRequest.TenantContext?

    public var withPermissionRole: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.teamId != nil {
            map["TeamId"] = self.teamId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.withPermissionRole != nil {
            map["WithPermissionRole"] = self.withPermissionRole!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OrderBy") && dict["OrderBy"] != nil {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("TeamId") && dict["TeamId"] != nil {
            self.teamId = dict["TeamId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = ListWorkspacesRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WithPermissionRole") && dict["WithPermissionRole"] != nil {
            self.withPermissionRole = dict["WithPermissionRole"] as! Bool
        }
    }
}

public class ListWorkspacesShrinkRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var orderBy: String?

    public var teamId: String?

    public var tenantContextShrink: String?

    public var withPermissionRole: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.teamId != nil {
            map["TeamId"] = self.teamId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.withPermissionRole != nil {
            map["WithPermissionRole"] = self.withPermissionRole!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OrderBy") && dict["OrderBy"] != nil {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("TeamId") && dict["TeamId"] != nil {
            self.teamId = dict["TeamId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WithPermissionRole") && dict["WithPermissionRole"] != nil {
            self.withPermissionRole = dict["WithPermissionRole"] as! Bool
        }
    }
}

public class ListWorkspacesResponseBody : Tea.TeaModel {
    public class Workspaces : Tea.TeaModel {
        public class Icon : Tea.TeaModel {
            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var corpId: String?

        public var cover: String?

        public var createTime: String?

        public var creatorId: String?

        public var description_: String?

        public var icon: ListWorkspacesResponseBody.Workspaces.Icon?

        public var modifiedTime: String?

        public var modifierId: String?

        public var name: String?

        public var permissionRole: String?

        public var rootNodeId: String?

        public var teamId: String?

        public var type: String?

        public var url: String?

        public var workspaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.icon?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.cover != nil {
                map["Cover"] = self.cover!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.icon != nil {
                map["Icon"] = self.icon?.toMap()
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.modifierId != nil {
                map["ModifierId"] = self.modifierId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.permissionRole != nil {
                map["PermissionRole"] = self.permissionRole!
            }
            if self.rootNodeId != nil {
                map["RootNodeId"] = self.rootNodeId!
            }
            if self.teamId != nil {
                map["TeamId"] = self.teamId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.workspaceId != nil {
                map["WorkspaceId"] = self.workspaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") && dict["CorpId"] != nil {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("Cover") && dict["Cover"] != nil {
                self.cover = dict["Cover"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Icon") && dict["Icon"] != nil {
                var model = ListWorkspacesResponseBody.Workspaces.Icon()
                model.fromMap(dict["Icon"] as! [String: Any])
                self.icon = model
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ModifierId") && dict["ModifierId"] != nil {
                self.modifierId = dict["ModifierId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PermissionRole") && dict["PermissionRole"] != nil {
                self.permissionRole = dict["PermissionRole"] as! String
            }
            if dict.keys.contains("RootNodeId") && dict["RootNodeId"] != nil {
                self.rootNodeId = dict["RootNodeId"] as! String
            }
            if dict.keys.contains("TeamId") && dict["TeamId"] != nil {
                self.teamId = dict["TeamId"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                self.workspaceId = dict["WorkspaceId"] as! String
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var workspaces: [ListWorkspacesResponseBody.Workspaces]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.workspaces != nil {
            var tmp : [Any] = []
            for k in self.workspaces! {
                tmp.append(k.toMap())
            }
            map["workspaces"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("workspaces") && dict["workspaces"] != nil {
            var tmp : [ListWorkspacesResponseBody.Workspaces] = []
            for v in dict["workspaces"] as! [Any] {
                var model = ListWorkspacesResponseBody.Workspaces()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.workspaces = tmp
        }
    }
}

public class ListWorkspacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWorkspacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListWorkspacesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PatchEventHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: PatchEventHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = PatchEventHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class PatchEventShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class PatchEventRequest : Tea.TeaModel {
    public class Attendees : Tea.TeaModel {
        public var id: String?

        public var isOptional: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.isOptional != nil {
                map["isOptional"] = self.isOptional!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") && dict["id"] != nil {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("isOptional") && dict["isOptional"] != nil {
                self.isOptional = dict["isOptional"] as! Bool
            }
        }
    }
    public class End : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["date"] = self.date!
            }
            if self.dateTime != nil {
                map["dateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["timeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("date") && dict["date"] != nil {
                self.date = dict["date"] as! String
            }
            if dict.keys.contains("dateTime") && dict["dateTime"] != nil {
                self.dateTime = dict["dateTime"] as! String
            }
            if dict.keys.contains("timeZone") && dict["timeZone"] != nil {
                self.timeZone = dict["timeZone"] as! String
            }
        }
    }
    public class Location : Tea.TeaModel {
        public var displayName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["displayName"] = self.displayName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("displayName") && dict["displayName"] != nil {
                self.displayName = dict["displayName"] as! String
            }
        }
    }
    public class Recurrence : Tea.TeaModel {
        public class Pattern : Tea.TeaModel {
            public var dayOfMonth: Int32?

            public var daysOfWeek: String?

            public var index: String?

            public var interval: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dayOfMonth != nil {
                    map["dayOfMonth"] = self.dayOfMonth!
                }
                if self.daysOfWeek != nil {
                    map["daysOfWeek"] = self.daysOfWeek!
                }
                if self.index != nil {
                    map["index"] = self.index!
                }
                if self.interval != nil {
                    map["interval"] = self.interval!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("dayOfMonth") && dict["dayOfMonth"] != nil {
                    self.dayOfMonth = dict["dayOfMonth"] as! Int32
                }
                if dict.keys.contains("daysOfWeek") && dict["daysOfWeek"] != nil {
                    self.daysOfWeek = dict["daysOfWeek"] as! String
                }
                if dict.keys.contains("index") && dict["index"] != nil {
                    self.index = dict["index"] as! String
                }
                if dict.keys.contains("interval") && dict["interval"] != nil {
                    self.interval = dict["interval"] as! Int32
                }
                if dict.keys.contains("type") && dict["type"] != nil {
                    self.type = dict["type"] as! String
                }
            }
        }
        public class Range : Tea.TeaModel {
            public var endDate: String?

            public var numberOfOccurrences: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endDate != nil {
                    map["endDate"] = self.endDate!
                }
                if self.numberOfOccurrences != nil {
                    map["numberOfOccurrences"] = self.numberOfOccurrences!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("endDate") && dict["endDate"] != nil {
                    self.endDate = dict["endDate"] as! String
                }
                if dict.keys.contains("numberOfOccurrences") && dict["numberOfOccurrences"] != nil {
                    self.numberOfOccurrences = dict["numberOfOccurrences"] as! Int32
                }
                if dict.keys.contains("type") && dict["type"] != nil {
                    self.type = dict["type"] as! String
                }
            }
        }
        public var pattern: PatchEventRequest.Recurrence.Pattern?

        public var range: PatchEventRequest.Recurrence.Range?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pattern?.validate()
            try self.range?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pattern != nil {
                map["pattern"] = self.pattern?.toMap()
            }
            if self.range != nil {
                map["range"] = self.range?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("pattern") && dict["pattern"] != nil {
                var model = PatchEventRequest.Recurrence.Pattern()
                model.fromMap(dict["pattern"] as! [String: Any])
                self.pattern = model
            }
            if dict.keys.contains("range") && dict["range"] != nil {
                var model = PatchEventRequest.Recurrence.Range()
                model.fromMap(dict["range"] as! [String: Any])
                self.range = model
            }
        }
    }
    public class Reminders : Tea.TeaModel {
        public var method: String?

        public var minutes: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.method != nil {
                map["method"] = self.method!
            }
            if self.minutes != nil {
                map["minutes"] = self.minutes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("method") && dict["method"] != nil {
                self.method = dict["method"] as! String
            }
            if dict.keys.contains("minutes") && dict["minutes"] != nil {
                self.minutes = dict["minutes"] as! Int32
            }
        }
    }
    public class Start : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["date"] = self.date!
            }
            if self.dateTime != nil {
                map["dateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["timeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("date") && dict["date"] != nil {
                self.date = dict["date"] as! String
            }
            if dict.keys.contains("dateTime") && dict["dateTime"] != nil {
                self.dateTime = dict["dateTime"] as! String
            }
            if dict.keys.contains("timeZone") && dict["timeZone"] != nil {
                self.timeZone = dict["timeZone"] as! String
            }
        }
    }
    public var attendees: [PatchEventRequest.Attendees]?

    public var calendarId: String?

    public var description_: String?

    public var end: PatchEventRequest.End?

    public var eventId: String?

    public var extra: [String: String]?

    public var isAllDay: Bool?

    public var location: PatchEventRequest.Location?

    public var recurrence: PatchEventRequest.Recurrence?

    public var reminders: [PatchEventRequest.Reminders]?

    public var start: PatchEventRequest.Start?

    public var summary: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.end?.validate()
        try self.location?.validate()
        try self.recurrence?.validate()
        try self.start?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendees != nil {
            var tmp : [Any] = []
            for k in self.attendees! {
                tmp.append(k.toMap())
            }
            map["Attendees"] = tmp
        }
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.end != nil {
            map["End"] = self.end?.toMap()
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.extra != nil {
            map["Extra"] = self.extra!
        }
        if self.isAllDay != nil {
            map["IsAllDay"] = self.isAllDay!
        }
        if self.location != nil {
            map["Location"] = self.location?.toMap()
        }
        if self.recurrence != nil {
            map["Recurrence"] = self.recurrence?.toMap()
        }
        if self.reminders != nil {
            var tmp : [Any] = []
            for k in self.reminders! {
                tmp.append(k.toMap())
            }
            map["Reminders"] = tmp
        }
        if self.start != nil {
            map["Start"] = self.start?.toMap()
        }
        if self.summary != nil {
            map["Summary"] = self.summary!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Attendees") && dict["Attendees"] != nil {
            var tmp : [PatchEventRequest.Attendees] = []
            for v in dict["Attendees"] as! [Any] {
                var model = PatchEventRequest.Attendees()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.attendees = tmp
        }
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("End") && dict["End"] != nil {
            var model = PatchEventRequest.End()
            model.fromMap(dict["End"] as! [String: Any])
            self.end = model
        }
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("Extra") && dict["Extra"] != nil {
            self.extra = dict["Extra"] as! [String: String]
        }
        if dict.keys.contains("IsAllDay") && dict["IsAllDay"] != nil {
            self.isAllDay = dict["IsAllDay"] as! Bool
        }
        if dict.keys.contains("Location") && dict["Location"] != nil {
            var model = PatchEventRequest.Location()
            model.fromMap(dict["Location"] as! [String: Any])
            self.location = model
        }
        if dict.keys.contains("Recurrence") && dict["Recurrence"] != nil {
            var model = PatchEventRequest.Recurrence()
            model.fromMap(dict["Recurrence"] as! [String: Any])
            self.recurrence = model
        }
        if dict.keys.contains("Reminders") && dict["Reminders"] != nil {
            var tmp : [PatchEventRequest.Reminders] = []
            for v in dict["Reminders"] as! [Any] {
                var model = PatchEventRequest.Reminders()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.reminders = tmp
        }
        if dict.keys.contains("Start") && dict["Start"] != nil {
            var model = PatchEventRequest.Start()
            model.fromMap(dict["Start"] as! [String: Any])
            self.start = model
        }
        if dict.keys.contains("Summary") && dict["Summary"] != nil {
            self.summary = dict["Summary"] as! String
        }
    }
}

public class PatchEventShrinkRequest : Tea.TeaModel {
    public var attendeesShrink: String?

    public var calendarId: String?

    public var description_: String?

    public var endShrink: String?

    public var eventId: String?

    public var extraShrink: String?

    public var isAllDay: Bool?

    public var locationShrink: String?

    public var recurrenceShrink: String?

    public var remindersShrink: String?

    public var startShrink: String?

    public var summary: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendeesShrink != nil {
            map["Attendees"] = self.attendeesShrink!
        }
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endShrink != nil {
            map["End"] = self.endShrink!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.extraShrink != nil {
            map["Extra"] = self.extraShrink!
        }
        if self.isAllDay != nil {
            map["IsAllDay"] = self.isAllDay!
        }
        if self.locationShrink != nil {
            map["Location"] = self.locationShrink!
        }
        if self.recurrenceShrink != nil {
            map["Recurrence"] = self.recurrenceShrink!
        }
        if self.remindersShrink != nil {
            map["Reminders"] = self.remindersShrink!
        }
        if self.startShrink != nil {
            map["Start"] = self.startShrink!
        }
        if self.summary != nil {
            map["Summary"] = self.summary!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Attendees") && dict["Attendees"] != nil {
            self.attendeesShrink = dict["Attendees"] as! String
        }
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("End") && dict["End"] != nil {
            self.endShrink = dict["End"] as! String
        }
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("Extra") && dict["Extra"] != nil {
            self.extraShrink = dict["Extra"] as! String
        }
        if dict.keys.contains("IsAllDay") && dict["IsAllDay"] != nil {
            self.isAllDay = dict["IsAllDay"] as! Bool
        }
        if dict.keys.contains("Location") && dict["Location"] != nil {
            self.locationShrink = dict["Location"] as! String
        }
        if dict.keys.contains("Recurrence") && dict["Recurrence"] != nil {
            self.recurrenceShrink = dict["Recurrence"] as! String
        }
        if dict.keys.contains("Reminders") && dict["Reminders"] != nil {
            self.remindersShrink = dict["Reminders"] as! String
        }
        if dict.keys.contains("Start") && dict["Start"] != nil {
            self.startShrink = dict["Start"] as! String
        }
        if dict.keys.contains("Summary") && dict["Summary"] != nil {
            self.summary = dict["Summary"] as! String
        }
    }
}

public class PatchEventResponseBody : Tea.TeaModel {
    public class Attendees : Tea.TeaModel {
        public var displayName: String?

        public var id: String?

        public var isOptional: Bool?

        public var responseStatus: String?

        public var self_: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.isOptional != nil {
                map["IsOptional"] = self.isOptional!
            }
            if self.responseStatus != nil {
                map["ResponseStatus"] = self.responseStatus!
            }
            if self.self_ != nil {
                map["Self"] = self.self_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("IsOptional") && dict["IsOptional"] != nil {
                self.isOptional = dict["IsOptional"] as! Bool
            }
            if dict.keys.contains("ResponseStatus") && dict["ResponseStatus"] != nil {
                self.responseStatus = dict["ResponseStatus"] as! String
            }
            if dict.keys.contains("Self") && dict["Self"] != nil {
                self.self_ = dict["Self"] as! Bool
            }
        }
    }
    public class End : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["Date"] = self.date!
            }
            if self.dateTime != nil {
                map["DateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["TimeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Date") && dict["Date"] != nil {
                self.date = dict["Date"] as! String
            }
            if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                self.dateTime = dict["DateTime"] as! String
            }
            if dict.keys.contains("TimeZone") && dict["TimeZone"] != nil {
                self.timeZone = dict["TimeZone"] as! String
            }
        }
    }
    public class Location : Tea.TeaModel {
        public var displayName: String?

        public var meetingRooms: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.meetingRooms != nil {
                map["MeetingRooms"] = self.meetingRooms!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("MeetingRooms") && dict["MeetingRooms"] != nil {
                self.meetingRooms = dict["MeetingRooms"] as! [String]
            }
        }
    }
    public class Organizer : Tea.TeaModel {
        public var displayName: String?

        public var id: String?

        public var responseStatus: String?

        public var self_: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.responseStatus != nil {
                map["ResponseStatus"] = self.responseStatus!
            }
            if self.self_ != nil {
                map["Self"] = self.self_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("ResponseStatus") && dict["ResponseStatus"] != nil {
                self.responseStatus = dict["ResponseStatus"] as! String
            }
            if dict.keys.contains("Self") && dict["Self"] != nil {
                self.self_ = dict["Self"] as! Bool
            }
        }
    }
    public class Recurrence : Tea.TeaModel {
        public class Pattern : Tea.TeaModel {
            public var dayOfMonth: Int32?

            public var daysOfWeek: String?

            public var index: String?

            public var interval: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dayOfMonth != nil {
                    map["DayOfMonth"] = self.dayOfMonth!
                }
                if self.daysOfWeek != nil {
                    map["DaysOfWeek"] = self.daysOfWeek!
                }
                if self.index != nil {
                    map["Index"] = self.index!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DayOfMonth") && dict["DayOfMonth"] != nil {
                    self.dayOfMonth = dict["DayOfMonth"] as! Int32
                }
                if dict.keys.contains("DaysOfWeek") && dict["DaysOfWeek"] != nil {
                    self.daysOfWeek = dict["DaysOfWeek"] as! String
                }
                if dict.keys.contains("Index") && dict["Index"] != nil {
                    self.index = dict["Index"] as! String
                }
                if dict.keys.contains("Interval") && dict["Interval"] != nil {
                    self.interval = dict["Interval"] as! Int32
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Range : Tea.TeaModel {
            public var endDate: String?

            public var numberOfOccurrences: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endDate != nil {
                    map["EndDate"] = self.endDate!
                }
                if self.numberOfOccurrences != nil {
                    map["NumberOfOccurrences"] = self.numberOfOccurrences!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndDate") && dict["EndDate"] != nil {
                    self.endDate = dict["EndDate"] as! String
                }
                if dict.keys.contains("NumberOfOccurrences") && dict["NumberOfOccurrences"] != nil {
                    self.numberOfOccurrences = dict["NumberOfOccurrences"] as! Int32
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var pattern: PatchEventResponseBody.Recurrence.Pattern?

        public var range: PatchEventResponseBody.Recurrence.Range?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pattern?.validate()
            try self.range?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pattern != nil {
                map["Pattern"] = self.pattern?.toMap()
            }
            if self.range != nil {
                map["Range"] = self.range?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Pattern") && dict["Pattern"] != nil {
                var model = PatchEventResponseBody.Recurrence.Pattern()
                model.fromMap(dict["Pattern"] as! [String: Any])
                self.pattern = model
            }
            if dict.keys.contains("Range") && dict["Range"] != nil {
                var model = PatchEventResponseBody.Recurrence.Range()
                model.fromMap(dict["Range"] as! [String: Any])
                self.range = model
            }
        }
    }
    public class Reminders : Tea.TeaModel {
        public var method: String?

        public var minutes: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.method != nil {
                map["Method"] = self.method!
            }
            if self.minutes != nil {
                map["Minutes"] = self.minutes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Method") && dict["Method"] != nil {
                self.method = dict["Method"] as! String
            }
            if dict.keys.contains("Minutes") && dict["Minutes"] != nil {
                self.minutes = dict["Minutes"] as! String
            }
        }
    }
    public class Start : Tea.TeaModel {
        public var date: String?

        public var dateTime: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.date != nil {
                map["Date"] = self.date!
            }
            if self.dateTime != nil {
                map["DateTime"] = self.dateTime!
            }
            if self.timeZone != nil {
                map["TimeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Date") && dict["Date"] != nil {
                self.date = dict["Date"] as! String
            }
            if dict.keys.contains("DateTime") && dict["DateTime"] != nil {
                self.dateTime = dict["DateTime"] as! String
            }
            if dict.keys.contains("TimeZone") && dict["TimeZone"] != nil {
                self.timeZone = dict["TimeZone"] as! String
            }
        }
    }
    public var attendees: [PatchEventResponseBody.Attendees]?

    public var createTime: String?

    public var description_: String?

    public var end: PatchEventResponseBody.End?

    public var id: String?

    public var isAllDay: Bool?

    public var location: PatchEventResponseBody.Location?

    public var organizer: PatchEventResponseBody.Organizer?

    public var recurrence: PatchEventResponseBody.Recurrence?

    public var reminders: [PatchEventResponseBody.Reminders]?

    public var requestId: String?

    public var start: PatchEventResponseBody.Start?

    public var summary: String?

    public var updateTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.end?.validate()
        try self.location?.validate()
        try self.organizer?.validate()
        try self.recurrence?.validate()
        try self.start?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendees != nil {
            var tmp : [Any] = []
            for k in self.attendees! {
                tmp.append(k.toMap())
            }
            map["attendees"] = tmp
        }
        if self.createTime != nil {
            map["createTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.end != nil {
            map["end"] = self.end?.toMap()
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.isAllDay != nil {
            map["isAllDay"] = self.isAllDay!
        }
        if self.location != nil {
            map["location"] = self.location?.toMap()
        }
        if self.organizer != nil {
            map["organizer"] = self.organizer?.toMap()
        }
        if self.recurrence != nil {
            map["recurrence"] = self.recurrence?.toMap()
        }
        if self.reminders != nil {
            var tmp : [Any] = []
            for k in self.reminders! {
                tmp.append(k.toMap())
            }
            map["reminders"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.start != nil {
            map["start"] = self.start?.toMap()
        }
        if self.summary != nil {
            map["summary"] = self.summary!
        }
        if self.updateTime != nil {
            map["updateTime"] = self.updateTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("attendees") && dict["attendees"] != nil {
            var tmp : [PatchEventResponseBody.Attendees] = []
            for v in dict["attendees"] as! [Any] {
                var model = PatchEventResponseBody.Attendees()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.attendees = tmp
        }
        if dict.keys.contains("createTime") && dict["createTime"] != nil {
            self.createTime = dict["createTime"] as! String
        }
        if dict.keys.contains("description") && dict["description"] != nil {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("end") && dict["end"] != nil {
            var model = PatchEventResponseBody.End()
            model.fromMap(dict["end"] as! [String: Any])
            self.end = model
        }
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("isAllDay") && dict["isAllDay"] != nil {
            self.isAllDay = dict["isAllDay"] as! Bool
        }
        if dict.keys.contains("location") && dict["location"] != nil {
            var model = PatchEventResponseBody.Location()
            model.fromMap(dict["location"] as! [String: Any])
            self.location = model
        }
        if dict.keys.contains("organizer") && dict["organizer"] != nil {
            var model = PatchEventResponseBody.Organizer()
            model.fromMap(dict["organizer"] as! [String: Any])
            self.organizer = model
        }
        if dict.keys.contains("recurrence") && dict["recurrence"] != nil {
            var model = PatchEventResponseBody.Recurrence()
            model.fromMap(dict["recurrence"] as! [String: Any])
            self.recurrence = model
        }
        if dict.keys.contains("reminders") && dict["reminders"] != nil {
            var tmp : [PatchEventResponseBody.Reminders] = []
            for v in dict["reminders"] as! [Any] {
                var model = PatchEventResponseBody.Reminders()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.reminders = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("start") && dict["start"] != nil {
            var model = PatchEventResponseBody.Start()
            model.fromMap(dict["start"] as! [String: Any])
            self.start = model
        }
        if dict.keys.contains("summary") && dict["summary"] != nil {
            self.summary = dict["summary"] as! String
        }
        if dict.keys.contains("updateTime") && dict["updateTime"] != nil {
            self.updateTime = dict["updateTime"] as! String
        }
    }
}

public class PatchEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PatchEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PatchEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryCloudRecordTextHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryCloudRecordTextHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryCloudRecordTextHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryCloudRecordTextShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryCloudRecordTextRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var direction: String?

    public var maxResults: Int64?

    public var nextToken: Int64?

    public var startTime: Int64?

    public var tenantContext: QueryCloudRecordTextRequest.TenantContext?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Direction") && dict["Direction"] != nil {
            self.direction = dict["Direction"] as! String
        }
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryCloudRecordTextRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("conferenceId") && dict["conferenceId"] != nil {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class QueryCloudRecordTextShrinkRequest : Tea.TeaModel {
    public var direction: String?

    public var maxResults: Int64?

    public var nextToken: Int64?

    public var startTime: Int64?

    public var tenantContextShrink: String?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Direction") && dict["Direction"] != nil {
            self.direction = dict["Direction"] as! String
        }
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("conferenceId") && dict["conferenceId"] != nil {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class QueryCloudRecordTextResponseBody : Tea.TeaModel {
    public class ParagraphList : Tea.TeaModel {
        public class SentenceList : Tea.TeaModel {
            public class WordList : Tea.TeaModel {
                public var endTime: Int64?

                public var startTime: Int64?

                public var word: String?

                public var wordId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.word != nil {
                        map["Word"] = self.word!
                    }
                    if self.wordId != nil {
                        map["WordId"] = self.wordId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                        self.endTime = dict["EndTime"] as! Int64
                    }
                    if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                        self.startTime = dict["StartTime"] as! Int64
                    }
                    if dict.keys.contains("Word") && dict["Word"] != nil {
                        self.word = dict["Word"] as! String
                    }
                    if dict.keys.contains("WordId") && dict["WordId"] != nil {
                        self.wordId = dict["WordId"] as! String
                    }
                }
            }
            public var endTime: Int64?

            public var sentence: String?

            public var startTime: Int64?

            public var userId: String?

            public var wordList: [QueryCloudRecordTextResponseBody.ParagraphList.SentenceList.WordList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.sentence != nil {
                    map["Sentence"] = self.sentence!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.wordList != nil {
                    var tmp : [Any] = []
                    for k in self.wordList! {
                        tmp.append(k.toMap())
                    }
                    map["WordList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("Sentence") && dict["Sentence"] != nil {
                    self.sentence = dict["Sentence"] as! String
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! Int64
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("WordList") && dict["WordList"] != nil {
                    var tmp : [QueryCloudRecordTextResponseBody.ParagraphList.SentenceList.WordList] = []
                    for v in dict["WordList"] as! [Any] {
                        var model = QueryCloudRecordTextResponseBody.ParagraphList.SentenceList.WordList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.wordList = tmp
                }
            }
        }
        public var endTime: Int64?

        public var nextTtoken: Int64?

        public var nickName: String?

        public var paragraph: String?

        public var recordId: Int64?

        public var sentenceList: [QueryCloudRecordTextResponseBody.ParagraphList.SentenceList]?

        public var startTime: Int64?

        public var status: Int64?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.nextTtoken != nil {
                map["NextTtoken"] = self.nextTtoken!
            }
            if self.nickName != nil {
                map["NickName"] = self.nickName!
            }
            if self.paragraph != nil {
                map["Paragraph"] = self.paragraph!
            }
            if self.recordId != nil {
                map["RecordId"] = self.recordId!
            }
            if self.sentenceList != nil {
                var tmp : [Any] = []
                for k in self.sentenceList! {
                    tmp.append(k.toMap())
                }
                map["SentenceList"] = tmp
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("NextTtoken") && dict["NextTtoken"] != nil {
                self.nextTtoken = dict["NextTtoken"] as! Int64
            }
            if dict.keys.contains("NickName") && dict["NickName"] != nil {
                self.nickName = dict["NickName"] as! String
            }
            if dict.keys.contains("Paragraph") && dict["Paragraph"] != nil {
                self.paragraph = dict["Paragraph"] as! String
            }
            if dict.keys.contains("RecordId") && dict["RecordId"] != nil {
                self.recordId = dict["RecordId"] as! Int64
            }
            if dict.keys.contains("SentenceList") && dict["SentenceList"] != nil {
                var tmp : [QueryCloudRecordTextResponseBody.ParagraphList.SentenceList] = []
                for v in dict["SentenceList"] as! [Any] {
                    var model = QueryCloudRecordTextResponseBody.ParagraphList.SentenceList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sentenceList = tmp
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int64
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var hasMore: Bool?

    public var paragraphList: [QueryCloudRecordTextResponseBody.ParagraphList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hasMore != nil {
            map["hasMore"] = self.hasMore!
        }
        if self.paragraphList != nil {
            var tmp : [Any] = []
            for k in self.paragraphList! {
                tmp.append(k.toMap())
            }
            map["paragraphList"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("hasMore") && dict["hasMore"] != nil {
            self.hasMore = dict["hasMore"] as! Bool
        }
        if dict.keys.contains("paragraphList") && dict["paragraphList"] != nil {
            var tmp : [QueryCloudRecordTextResponseBody.ParagraphList] = []
            for v in dict["paragraphList"] as! [Any] {
                var model = QueryCloudRecordTextResponseBody.ParagraphList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.paragraphList = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class QueryCloudRecordTextResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryCloudRecordTextResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryCloudRecordTextResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryCloudRecordVideoHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryCloudRecordVideoHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryCloudRecordVideoHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryCloudRecordVideoShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryCloudRecordVideoRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: QueryCloudRecordVideoRequest.TenantContext?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryCloudRecordVideoRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("conferenceId") && dict["conferenceId"] != nil {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class QueryCloudRecordVideoShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("conferenceId") && dict["conferenceId"] != nil {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class QueryCloudRecordVideoResponseBody : Tea.TeaModel {
    public class VideoList : Tea.TeaModel {
        public var duration: Int64?

        public var endTime: Int64?

        public var fileSize: Int64?

        public var mediaId: String?

        public var recordId: String?

        public var recordType: Int64?

        public var regionId: String?

        public var startTime: Int64?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.fileSize != nil {
                map["FileSize"] = self.fileSize!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.recordId != nil {
                map["RecordId"] = self.recordId!
            }
            if self.recordType != nil {
                map["RecordType"] = self.recordType!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("FileSize") && dict["FileSize"] != nil {
                self.fileSize = dict["FileSize"] as! Int64
            }
            if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("RecordId") && dict["RecordId"] != nil {
                self.recordId = dict["RecordId"] as! String
            }
            if dict.keys.contains("RecordType") && dict["RecordType"] != nil {
                self.recordType = dict["RecordType"] as! Int64
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var requestId: String?

    public var videoList: [QueryCloudRecordVideoResponseBody.VideoList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.videoList != nil {
            var tmp : [Any] = []
            for k in self.videoList! {
                tmp.append(k.toMap())
            }
            map["videoList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("videoList") && dict["videoList"] != nil {
            var tmp : [QueryCloudRecordVideoResponseBody.VideoList] = []
            for v in dict["videoList"] as! [Any] {
                var model = QueryCloudRecordVideoResponseBody.VideoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.videoList = tmp
        }
    }
}

public class QueryCloudRecordVideoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryCloudRecordVideoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryCloudRecordVideoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryCloudRecordVideoPlayInfoHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryCloudRecordVideoPlayInfoHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryCloudRecordVideoPlayInfoHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryCloudRecordVideoPlayInfoShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryCloudRecordVideoPlayInfoRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var conferenceId: String?

    public var mediaId: String?

    public var regionId: String?

    public var tenantContext: QueryCloudRecordVideoPlayInfoRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conferenceId != nil {
            map["ConferenceId"] = self.conferenceId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConferenceId") && dict["ConferenceId"] != nil {
            self.conferenceId = dict["ConferenceId"] as! String
        }
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryCloudRecordVideoPlayInfoRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryCloudRecordVideoPlayInfoShrinkRequest : Tea.TeaModel {
    public var conferenceId: String?

    public var mediaId: String?

    public var regionId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conferenceId != nil {
            map["ConferenceId"] = self.conferenceId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConferenceId") && dict["ConferenceId"] != nil {
            self.conferenceId = dict["ConferenceId"] as! String
        }
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryCloudRecordVideoPlayInfoResponseBody : Tea.TeaModel {
    public var duration: Int64?

    public var fileSize: Int64?

    public var mp4FileUrl: String?

    public var playUrl: String?

    public var requestId: String?

    public var status: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.duration != nil {
            map["duration"] = self.duration!
        }
        if self.fileSize != nil {
            map["fileSize"] = self.fileSize!
        }
        if self.mp4FileUrl != nil {
            map["mp4FileUrl"] = self.mp4FileUrl!
        }
        if self.playUrl != nil {
            map["playUrl"] = self.playUrl!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("duration") && dict["duration"] != nil {
            self.duration = dict["duration"] as! Int64
        }
        if dict.keys.contains("fileSize") && dict["fileSize"] != nil {
            self.fileSize = dict["fileSize"] as! Int64
        }
        if dict.keys.contains("mp4FileUrl") && dict["mp4FileUrl"] != nil {
            self.mp4FileUrl = dict["mp4FileUrl"] as! String
        }
        if dict.keys.contains("playUrl") && dict["playUrl"] != nil {
            self.playUrl = dict["playUrl"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("status") && dict["status"] != nil {
            self.status = dict["status"] as! Int64
        }
    }
}

public class QueryCloudRecordVideoPlayInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryCloudRecordVideoPlayInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryCloudRecordVideoPlayInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryConferenceInfoHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryConferenceInfoHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryConferenceInfoHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryConferenceInfoShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryConferenceInfoRequest : Tea.TeaModel {
    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("conferenceId") && dict["conferenceId"] != nil {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class QueryConferenceInfoResponseBody : Tea.TeaModel {
    public class ConfInfo : Tea.TeaModel {
        public var activeNum: Int32?

        public var attendNum: Int32?

        public var confDuration: Int64?

        public var conferenceId: String?

        public var creatorId: String?

        public var creatorNick: String?

        public var endTime: Int64?

        public var externalLinkUrl: String?

        public var invitedNum: Int32?

        public var roomCode: String?

        public var startTime: Int64?

        public var status: Int32?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activeNum != nil {
                map["ActiveNum"] = self.activeNum!
            }
            if self.attendNum != nil {
                map["AttendNum"] = self.attendNum!
            }
            if self.confDuration != nil {
                map["ConfDuration"] = self.confDuration!
            }
            if self.conferenceId != nil {
                map["ConferenceId"] = self.conferenceId!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.creatorNick != nil {
                map["CreatorNick"] = self.creatorNick!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.externalLinkUrl != nil {
                map["ExternalLinkUrl"] = self.externalLinkUrl!
            }
            if self.invitedNum != nil {
                map["InvitedNum"] = self.invitedNum!
            }
            if self.roomCode != nil {
                map["RoomCode"] = self.roomCode!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActiveNum") && dict["ActiveNum"] != nil {
                self.activeNum = dict["ActiveNum"] as! Int32
            }
            if dict.keys.contains("AttendNum") && dict["AttendNum"] != nil {
                self.attendNum = dict["AttendNum"] as! Int32
            }
            if dict.keys.contains("ConfDuration") && dict["ConfDuration"] != nil {
                self.confDuration = dict["ConfDuration"] as! Int64
            }
            if dict.keys.contains("ConferenceId") && dict["ConferenceId"] != nil {
                self.conferenceId = dict["ConferenceId"] as! String
            }
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("CreatorNick") && dict["CreatorNick"] != nil {
                self.creatorNick = dict["CreatorNick"] as! String
            }
            if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("ExternalLinkUrl") && dict["ExternalLinkUrl"] != nil {
                self.externalLinkUrl = dict["ExternalLinkUrl"] as! String
            }
            if dict.keys.contains("InvitedNum") && dict["InvitedNum"] != nil {
                self.invitedNum = dict["InvitedNum"] as! Int32
            }
            if dict.keys.contains("RoomCode") && dict["RoomCode"] != nil {
                self.roomCode = dict["RoomCode"] as! String
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var confInfo: QueryConferenceInfoResponseBody.ConfInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.confInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.confInfo != nil {
            map["confInfo"] = self.confInfo?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("confInfo") && dict["confInfo"] != nil {
            var model = QueryConferenceInfoResponseBody.ConfInfo()
            model.fromMap(dict["confInfo"] as! [String: Any])
            self.confInfo = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class QueryConferenceInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryConferenceInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryConferenceInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryConferenceMembersHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryConferenceMembersHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryConferenceMembersHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryConferenceMembersShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryConferenceMembersRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var tenantContext: QueryConferenceMembersRequest.TenantContext?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryConferenceMembersRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("conferenceId") && dict["conferenceId"] != nil {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class QueryConferenceMembersShrinkRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var tenantContextShrink: String?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("conferenceId") && dict["conferenceId"] != nil {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class QueryConferenceMembersResponseBody : Tea.TeaModel {
    public class MemberModels : Tea.TeaModel {
        public var attendStatus: Int32?

        public var coHost: Bool?

        public var conferenceId: String?

        public var duration: Int64?

        public var host: Bool?

        public var joinTime: Int64?

        public var leaveTime: Int64?

        public var outerOrgMember: Bool?

        public var pstnJoin: Bool?

        public var userId: String?

        public var userNick: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attendStatus != nil {
                map["AttendStatus"] = self.attendStatus!
            }
            if self.coHost != nil {
                map["CoHost"] = self.coHost!
            }
            if self.conferenceId != nil {
                map["ConferenceId"] = self.conferenceId!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.joinTime != nil {
                map["JoinTime"] = self.joinTime!
            }
            if self.leaveTime != nil {
                map["LeaveTime"] = self.leaveTime!
            }
            if self.outerOrgMember != nil {
                map["OuterOrgMember"] = self.outerOrgMember!
            }
            if self.pstnJoin != nil {
                map["PstnJoin"] = self.pstnJoin!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userNick != nil {
                map["UserNick"] = self.userNick!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AttendStatus") && dict["AttendStatus"] != nil {
                self.attendStatus = dict["AttendStatus"] as! Int32
            }
            if dict.keys.contains("CoHost") && dict["CoHost"] != nil {
                self.coHost = dict["CoHost"] as! Bool
            }
            if dict.keys.contains("ConferenceId") && dict["ConferenceId"] != nil {
                self.conferenceId = dict["ConferenceId"] as! String
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Host") && dict["Host"] != nil {
                self.host = dict["Host"] as! Bool
            }
            if dict.keys.contains("JoinTime") && dict["JoinTime"] != nil {
                self.joinTime = dict["JoinTime"] as! Int64
            }
            if dict.keys.contains("LeaveTime") && dict["LeaveTime"] != nil {
                self.leaveTime = dict["LeaveTime"] as! Int64
            }
            if dict.keys.contains("OuterOrgMember") && dict["OuterOrgMember"] != nil {
                self.outerOrgMember = dict["OuterOrgMember"] as! Bool
            }
            if dict.keys.contains("PstnJoin") && dict["PstnJoin"] != nil {
                self.pstnJoin = dict["PstnJoin"] as! Bool
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserNick") && dict["UserNick"] != nil {
                self.userNick = dict["UserNick"] as! String
            }
        }
    }
    public var memberModels: [QueryConferenceMembersResponseBody.MemberModels]?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.memberModels != nil {
            var tmp : [Any] = []
            for k in self.memberModels! {
                tmp.append(k.toMap())
            }
            map["memberModels"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("memberModels") && dict["memberModels"] != nil {
            var tmp : [QueryConferenceMembersResponseBody.MemberModels] = []
            for v in dict["memberModels"] as! [Any] {
                var model = QueryConferenceMembersResponseBody.MemberModels()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.memberModels = tmp
        }
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int32
        }
    }
}

public class QueryConferenceMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryConferenceMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryConferenceMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryDentryHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryDentryHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryDentryHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryDentryShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryDentryRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var dentryId: String?

    public var includeSpace: Bool?

    public var spaceId: String?

    public var tenantContext: QueryDentryRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dentryId != nil {
            map["DentryId"] = self.dentryId!
        }
        if self.includeSpace != nil {
            map["IncludeSpace"] = self.includeSpace!
        }
        if self.spaceId != nil {
            map["SpaceId"] = self.spaceId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DentryId") && dict["DentryId"] != nil {
            self.dentryId = dict["DentryId"] as! String
        }
        if dict.keys.contains("IncludeSpace") && dict["IncludeSpace"] != nil {
            self.includeSpace = dict["IncludeSpace"] as! Bool
        }
        if dict.keys.contains("SpaceId") && dict["SpaceId"] != nil {
            self.spaceId = dict["SpaceId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryDentryRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryDentryShrinkRequest : Tea.TeaModel {
    public var dentryId: String?

    public var includeSpace: Bool?

    public var spaceId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dentryId != nil {
            map["DentryId"] = self.dentryId!
        }
        if self.includeSpace != nil {
            map["IncludeSpace"] = self.includeSpace!
        }
        if self.spaceId != nil {
            map["SpaceId"] = self.spaceId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DentryId") && dict["DentryId"] != nil {
            self.dentryId = dict["DentryId"] as! String
        }
        if dict.keys.contains("IncludeSpace") && dict["IncludeSpace"] != nil {
            self.includeSpace = dict["IncludeSpace"] as! Bool
        }
        if dict.keys.contains("SpaceId") && dict["SpaceId"] != nil {
            self.spaceId = dict["SpaceId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryDentryResponseBody : Tea.TeaModel {
    public class Creator : Tea.TeaModel {
        public var name: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public class LinkSourceInfo : Tea.TeaModel {
        public class IconUrl : Tea.TeaModel {
            public var line: String?

            public var small: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.line != nil {
                    map["Line"] = self.line!
                }
                if self.small != nil {
                    map["Small"] = self.small!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Line") && dict["Line"] != nil {
                    self.line = dict["Line"] as! String
                }
                if dict.keys.contains("Small") && dict["Small"] != nil {
                    self.small = dict["Small"] as! String
                }
            }
        }
        public var extension_: String?

        public var iconUrl: QueryDentryResponseBody.LinkSourceInfo.IconUrl?

        public var id: String?

        public var linkType: Int64?

        public var spaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.iconUrl?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.iconUrl != nil {
                map["IconUrl"] = self.iconUrl?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.linkType != nil {
                map["LinkType"] = self.linkType!
            }
            if self.spaceId != nil {
                map["SpaceId"] = self.spaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Extension") && dict["Extension"] != nil {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("IconUrl") && dict["IconUrl"] != nil {
                var model = QueryDentryResponseBody.LinkSourceInfo.IconUrl()
                model.fromMap(dict["IconUrl"] as! [String: Any])
                self.iconUrl = model
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("LinkType") && dict["LinkType"] != nil {
                self.linkType = dict["LinkType"] as! Int64
            }
            if dict.keys.contains("SpaceId") && dict["SpaceId"] != nil {
                self.spaceId = dict["SpaceId"] as! String
            }
        }
    }
    public class Space : Tea.TeaModel {
        public class HdIconVO : Tea.TeaModel {
            public var icon: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.icon != nil {
                    map["Icon"] = self.icon!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Icon") && dict["Icon"] != nil {
                    self.icon = dict["Icon"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class IconVO : Tea.TeaModel {
            public var icon: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.icon != nil {
                    map["Icon"] = self.icon!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Icon") && dict["Icon"] != nil {
                    self.icon = dict["Icon"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Owner : Tea.TeaModel {
            public var name: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public class RecentList : Tea.TeaModel {
            public class Creator : Tea.TeaModel {
                public var name: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public class LinkSourceInfo : Tea.TeaModel {
                public class IconUrl : Tea.TeaModel {
                    public var line: String?

                    public var small: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.line != nil {
                            map["Line"] = self.line!
                        }
                        if self.small != nil {
                            map["Small"] = self.small!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Line") && dict["Line"] != nil {
                            self.line = dict["Line"] as! String
                        }
                        if dict.keys.contains("Small") && dict["Small"] != nil {
                            self.small = dict["Small"] as! String
                        }
                    }
                }
                public var extension_: String?

                public var iconUrl: QueryDentryResponseBody.Space.RecentList.LinkSourceInfo.IconUrl?

                public var id: String?

                public var linkType: Int64?

                public var spaceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.iconUrl?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.extension_ != nil {
                        map["Extension"] = self.extension_!
                    }
                    if self.iconUrl != nil {
                        map["IconUrl"] = self.iconUrl?.toMap()
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.linkType != nil {
                        map["LinkType"] = self.linkType!
                    }
                    if self.spaceId != nil {
                        map["SpaceId"] = self.spaceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Extension") && dict["Extension"] != nil {
                        self.extension_ = dict["Extension"] as! String
                    }
                    if dict.keys.contains("IconUrl") && dict["IconUrl"] != nil {
                        var model = QueryDentryResponseBody.Space.RecentList.LinkSourceInfo.IconUrl()
                        model.fromMap(dict["IconUrl"] as! [String: Any])
                        self.iconUrl = model
                    }
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("LinkType") && dict["LinkType"] != nil {
                        self.linkType = dict["LinkType"] as! Int64
                    }
                    if dict.keys.contains("SpaceId") && dict["SpaceId"] != nil {
                        self.spaceId = dict["SpaceId"] as! String
                    }
                }
            }
            public class StatisticalInfo : Tea.TeaModel {
                public var wordCount: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.wordCount != nil {
                        map["WordCount"] = self.wordCount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("WordCount") && dict["WordCount"] != nil {
                        self.wordCount = dict["WordCount"] as! Int64
                    }
                }
            }
            public class Updater : Tea.TeaModel {
                public var name: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public class VisitorInfo : Tea.TeaModel {
                public var dentryActions: [String]?

                public var roleCode: String?

                public var spaceActions: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dentryActions != nil {
                        map["DentryActions"] = self.dentryActions!
                    }
                    if self.roleCode != nil {
                        map["RoleCode"] = self.roleCode!
                    }
                    if self.spaceActions != nil {
                        map["SpaceActions"] = self.spaceActions!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DentryActions") && dict["DentryActions"] != nil {
                        self.dentryActions = dict["DentryActions"] as! [String]
                    }
                    if dict.keys.contains("RoleCode") && dict["RoleCode"] != nil {
                        self.roleCode = dict["RoleCode"] as! String
                    }
                    if dict.keys.contains("SpaceActions") && dict["SpaceActions"] != nil {
                        self.spaceActions = dict["SpaceActions"] as! [String]
                    }
                }
            }
            public var contentType: String?

            public var createdTime: Int64?

            public var creator: QueryDentryResponseBody.Space.RecentList.Creator?

            public var dentryId: String?

            public var dentryType: String?

            public var dentryUuid: String?

            public var docKey: String?

            public var extension_: String?

            public var hasChildren: Bool?

            public var linkSourceInfo: QueryDentryResponseBody.Space.RecentList.LinkSourceInfo?

            public var name: String?

            public var path: String?

            public var space: Any?

            public var spaceId: String?

            public var statisticalInfo: QueryDentryResponseBody.Space.RecentList.StatisticalInfo?

            public var updatedTime: Int64?

            public var updater: QueryDentryResponseBody.Space.RecentList.Updater?

            public var url: String?

            public var visitorInfo: QueryDentryResponseBody.Space.RecentList.VisitorInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.creator?.validate()
                try self.linkSourceInfo?.validate()
                try self.statisticalInfo?.validate()
                try self.updater?.validate()
                try self.visitorInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contentType != nil {
                    map["ContentType"] = self.contentType!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator?.toMap()
                }
                if self.dentryId != nil {
                    map["DentryId"] = self.dentryId!
                }
                if self.dentryType != nil {
                    map["DentryType"] = self.dentryType!
                }
                if self.dentryUuid != nil {
                    map["DentryUuid"] = self.dentryUuid!
                }
                if self.docKey != nil {
                    map["DocKey"] = self.docKey!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.hasChildren != nil {
                    map["HasChildren"] = self.hasChildren!
                }
                if self.linkSourceInfo != nil {
                    map["LinkSourceInfo"] = self.linkSourceInfo?.toMap()
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.space != nil {
                    map["Space"] = self.space!
                }
                if self.spaceId != nil {
                    map["SpaceId"] = self.spaceId!
                }
                if self.statisticalInfo != nil {
                    map["StatisticalInfo"] = self.statisticalInfo?.toMap()
                }
                if self.updatedTime != nil {
                    map["UpdatedTime"] = self.updatedTime!
                }
                if self.updater != nil {
                    map["Updater"] = self.updater?.toMap()
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                if self.visitorInfo != nil {
                    map["VisitorInfo"] = self.visitorInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContentType") && dict["ContentType"] != nil {
                    self.contentType = dict["ContentType"] as! String
                }
                if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                    self.createdTime = dict["CreatedTime"] as! Int64
                }
                if dict.keys.contains("Creator") && dict["Creator"] != nil {
                    var model = QueryDentryResponseBody.Space.RecentList.Creator()
                    model.fromMap(dict["Creator"] as! [String: Any])
                    self.creator = model
                }
                if dict.keys.contains("DentryId") && dict["DentryId"] != nil {
                    self.dentryId = dict["DentryId"] as! String
                }
                if dict.keys.contains("DentryType") && dict["DentryType"] != nil {
                    self.dentryType = dict["DentryType"] as! String
                }
                if dict.keys.contains("DentryUuid") && dict["DentryUuid"] != nil {
                    self.dentryUuid = dict["DentryUuid"] as! String
                }
                if dict.keys.contains("DocKey") && dict["DocKey"] != nil {
                    self.docKey = dict["DocKey"] as! String
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("HasChildren") && dict["HasChildren"] != nil {
                    self.hasChildren = dict["HasChildren"] as! Bool
                }
                if dict.keys.contains("LinkSourceInfo") && dict["LinkSourceInfo"] != nil {
                    var model = QueryDentryResponseBody.Space.RecentList.LinkSourceInfo()
                    model.fromMap(dict["LinkSourceInfo"] as! [String: Any])
                    self.linkSourceInfo = model
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("Space") && dict["Space"] != nil {
                    self.space = dict["Space"] as! Any
                }
                if dict.keys.contains("SpaceId") && dict["SpaceId"] != nil {
                    self.spaceId = dict["SpaceId"] as! String
                }
                if dict.keys.contains("StatisticalInfo") && dict["StatisticalInfo"] != nil {
                    var model = QueryDentryResponseBody.Space.RecentList.StatisticalInfo()
                    model.fromMap(dict["StatisticalInfo"] as! [String: Any])
                    self.statisticalInfo = model
                }
                if dict.keys.contains("UpdatedTime") && dict["UpdatedTime"] != nil {
                    self.updatedTime = dict["UpdatedTime"] as! Int64
                }
                if dict.keys.contains("Updater") && dict["Updater"] != nil {
                    var model = QueryDentryResponseBody.Space.RecentList.Updater()
                    model.fromMap(dict["Updater"] as! [String: Any])
                    self.updater = model
                }
                if dict.keys.contains("Url") && dict["Url"] != nil {
                    self.url = dict["Url"] as! String
                }
                if dict.keys.contains("VisitorInfo") && dict["VisitorInfo"] != nil {
                    var model = QueryDentryResponseBody.Space.RecentList.VisitorInfo()
                    model.fromMap(dict["VisitorInfo"] as! [String: Any])
                    self.visitorInfo = model
                }
            }
        }
        public class VisitorInfo : Tea.TeaModel {
            public var dentryActions: [String]?

            public var roleCode: String?

            public var spaceActions: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dentryActions != nil {
                    map["DentryActions"] = self.dentryActions!
                }
                if self.roleCode != nil {
                    map["RoleCode"] = self.roleCode!
                }
                if self.spaceActions != nil {
                    map["SpaceActions"] = self.spaceActions!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DentryActions") && dict["DentryActions"] != nil {
                    self.dentryActions = dict["DentryActions"] as! [String]
                }
                if dict.keys.contains("RoleCode") && dict["RoleCode"] != nil {
                    self.roleCode = dict["RoleCode"] as! String
                }
                if dict.keys.contains("SpaceActions") && dict["SpaceActions"] != nil {
                    self.spaceActions = dict["SpaceActions"] as! [String]
                }
            }
        }
        public var cover: String?

        public var description_: String?

        public var hdIconVO: QueryDentryResponseBody.Space.HdIconVO?

        public var iconVO: QueryDentryResponseBody.Space.IconVO?

        public var id: String?

        public var name: String?

        public var owner: QueryDentryResponseBody.Space.Owner?

        public var recentList: [QueryDentryResponseBody.Space.RecentList]?

        public var type: Int32?

        public var url: String?

        public var visitorInfo: QueryDentryResponseBody.Space.VisitorInfo?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.hdIconVO?.validate()
            try self.iconVO?.validate()
            try self.owner?.validate()
            try self.visitorInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cover != nil {
                map["Cover"] = self.cover!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.hdIconVO != nil {
                map["HdIconVO"] = self.hdIconVO?.toMap()
            }
            if self.iconVO != nil {
                map["IconVO"] = self.iconVO?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.owner != nil {
                map["Owner"] = self.owner?.toMap()
            }
            if self.recentList != nil {
                var tmp : [Any] = []
                for k in self.recentList! {
                    tmp.append(k.toMap())
                }
                map["RecentList"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.visitorInfo != nil {
                map["VisitorInfo"] = self.visitorInfo?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cover") && dict["Cover"] != nil {
                self.cover = dict["Cover"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("HdIconVO") && dict["HdIconVO"] != nil {
                var model = QueryDentryResponseBody.Space.HdIconVO()
                model.fromMap(dict["HdIconVO"] as! [String: Any])
                self.hdIconVO = model
            }
            if dict.keys.contains("IconVO") && dict["IconVO"] != nil {
                var model = QueryDentryResponseBody.Space.IconVO()
                model.fromMap(dict["IconVO"] as! [String: Any])
                self.iconVO = model
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Owner") && dict["Owner"] != nil {
                var model = QueryDentryResponseBody.Space.Owner()
                model.fromMap(dict["Owner"] as! [String: Any])
                self.owner = model
            }
            if dict.keys.contains("RecentList") && dict["RecentList"] != nil {
                var tmp : [QueryDentryResponseBody.Space.RecentList] = []
                for v in dict["RecentList"] as! [Any] {
                    var model = QueryDentryResponseBody.Space.RecentList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.recentList = tmp
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("VisitorInfo") && dict["VisitorInfo"] != nil {
                var model = QueryDentryResponseBody.Space.VisitorInfo()
                model.fromMap(dict["VisitorInfo"] as! [String: Any])
                self.visitorInfo = model
            }
        }
    }
    public class Updater : Tea.TeaModel {
        public var name: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public class VisitorInfo : Tea.TeaModel {
        public var dentryActions: [String]?

        public var roleCode: String?

        public var spaceActions: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dentryActions != nil {
                map["DentryActions"] = self.dentryActions!
            }
            if self.roleCode != nil {
                map["RoleCode"] = self.roleCode!
            }
            if self.spaceActions != nil {
                map["SpaceActions"] = self.spaceActions!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DentryActions") && dict["DentryActions"] != nil {
                self.dentryActions = dict["DentryActions"] as! [String]
            }
            if dict.keys.contains("RoleCode") && dict["RoleCode"] != nil {
                self.roleCode = dict["RoleCode"] as! String
            }
            if dict.keys.contains("SpaceActions") && dict["SpaceActions"] != nil {
                self.spaceActions = dict["SpaceActions"] as! [String]
            }
        }
    }
    public var contentType: String?

    public var createdTime: Int64?

    public var creator: QueryDentryResponseBody.Creator?

    public var dentryId: String?

    public var dentryType: String?

    public var dentryUuid: String?

    public var docKey: String?

    public var extension_: String?

    public var hasChildren: Bool?

    public var linkSourceInfo: QueryDentryResponseBody.LinkSourceInfo?

    public var name: String?

    public var path: String?

    public var requestId: String?

    public var space: QueryDentryResponseBody.Space?

    public var spaceId: String?

    public var updatedTime: Int64?

    public var updater: QueryDentryResponseBody.Updater?

    public var url: String?

    public var visitorInfo: QueryDentryResponseBody.VisitorInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.creator?.validate()
        try self.linkSourceInfo?.validate()
        try self.space?.validate()
        try self.updater?.validate()
        try self.visitorInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contentType != nil {
            map["contentType"] = self.contentType!
        }
        if self.createdTime != nil {
            map["createdTime"] = self.createdTime!
        }
        if self.creator != nil {
            map["creator"] = self.creator?.toMap()
        }
        if self.dentryId != nil {
            map["dentryId"] = self.dentryId!
        }
        if self.dentryType != nil {
            map["dentryType"] = self.dentryType!
        }
        if self.dentryUuid != nil {
            map["dentryUuid"] = self.dentryUuid!
        }
        if self.docKey != nil {
            map["docKey"] = self.docKey!
        }
        if self.extension_ != nil {
            map["extension"] = self.extension_!
        }
        if self.hasChildren != nil {
            map["hasChildren"] = self.hasChildren!
        }
        if self.linkSourceInfo != nil {
            map["linkSourceInfo"] = self.linkSourceInfo?.toMap()
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.path != nil {
            map["path"] = self.path!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.space != nil {
            map["space"] = self.space?.toMap()
        }
        if self.spaceId != nil {
            map["spaceId"] = self.spaceId!
        }
        if self.updatedTime != nil {
            map["updatedTime"] = self.updatedTime!
        }
        if self.updater != nil {
            map["updater"] = self.updater?.toMap()
        }
        if self.url != nil {
            map["url"] = self.url!
        }
        if self.visitorInfo != nil {
            map["visitorInfo"] = self.visitorInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("contentType") && dict["contentType"] != nil {
            self.contentType = dict["contentType"] as! String
        }
        if dict.keys.contains("createdTime") && dict["createdTime"] != nil {
            self.createdTime = dict["createdTime"] as! Int64
        }
        if dict.keys.contains("creator") && dict["creator"] != nil {
            var model = QueryDentryResponseBody.Creator()
            model.fromMap(dict["creator"] as! [String: Any])
            self.creator = model
        }
        if dict.keys.contains("dentryId") && dict["dentryId"] != nil {
            self.dentryId = dict["dentryId"] as! String
        }
        if dict.keys.contains("dentryType") && dict["dentryType"] != nil {
            self.dentryType = dict["dentryType"] as! String
        }
        if dict.keys.contains("dentryUuid") && dict["dentryUuid"] != nil {
            self.dentryUuid = dict["dentryUuid"] as! String
        }
        if dict.keys.contains("docKey") && dict["docKey"] != nil {
            self.docKey = dict["docKey"] as! String
        }
        if dict.keys.contains("extension") && dict["extension"] != nil {
            self.extension_ = dict["extension"] as! String
        }
        if dict.keys.contains("hasChildren") && dict["hasChildren"] != nil {
            self.hasChildren = dict["hasChildren"] as! Bool
        }
        if dict.keys.contains("linkSourceInfo") && dict["linkSourceInfo"] != nil {
            var model = QueryDentryResponseBody.LinkSourceInfo()
            model.fromMap(dict["linkSourceInfo"] as! [String: Any])
            self.linkSourceInfo = model
        }
        if dict.keys.contains("name") && dict["name"] != nil {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("path") && dict["path"] != nil {
            self.path = dict["path"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("space") && dict["space"] != nil {
            var model = QueryDentryResponseBody.Space()
            model.fromMap(dict["space"] as! [String: Any])
            self.space = model
        }
        if dict.keys.contains("spaceId") && dict["spaceId"] != nil {
            self.spaceId = dict["spaceId"] as! String
        }
        if dict.keys.contains("updatedTime") && dict["updatedTime"] != nil {
            self.updatedTime = dict["updatedTime"] as! Int64
        }
        if dict.keys.contains("updater") && dict["updater"] != nil {
            var model = QueryDentryResponseBody.Updater()
            model.fromMap(dict["updater"] as! [String: Any])
            self.updater = model
        }
        if dict.keys.contains("url") && dict["url"] != nil {
            self.url = dict["url"] as! String
        }
        if dict.keys.contains("visitorInfo") && dict["visitorInfo"] != nil {
            var model = QueryDentryResponseBody.VisitorInfo()
            model.fromMap(dict["visitorInfo"] as! [String: Any])
            self.visitorInfo = model
        }
    }
}

public class QueryDentryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryDentryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryDentryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryLiveInfoHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryLiveInfoHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryLiveInfoHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryLiveInfoShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryLiveInfoRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var liveId: String?

    public var tenantContext: QueryLiveInfoRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveId") && dict["LiveId"] != nil {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryLiveInfoRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryLiveInfoShrinkRequest : Tea.TeaModel {
    public var liveId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveId") && dict["LiveId"] != nil {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryLiveInfoResponseBody : Tea.TeaModel {
    public var coverUrl: String?

    public var duration: Int64?

    public var endTime: Int64?

    public var introduction: String?

    public var liveId: String?

    public var livePlayUrl: String?

    public var liveStatus: Int32?

    public var playbackDuration: Int64?

    public var requestId: String?

    public var startTime: Int64?

    public var subscribeCount: Int32?

    public var title: String?

    public var uv: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coverUrl != nil {
            map["coverUrl"] = self.coverUrl!
        }
        if self.duration != nil {
            map["duration"] = self.duration!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.introduction != nil {
            map["introduction"] = self.introduction!
        }
        if self.liveId != nil {
            map["liveId"] = self.liveId!
        }
        if self.livePlayUrl != nil {
            map["livePlayUrl"] = self.livePlayUrl!
        }
        if self.liveStatus != nil {
            map["liveStatus"] = self.liveStatus!
        }
        if self.playbackDuration != nil {
            map["playbackDuration"] = self.playbackDuration!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.subscribeCount != nil {
            map["subscribeCount"] = self.subscribeCount!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        if self.uv != nil {
            map["uv"] = self.uv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("coverUrl") && dict["coverUrl"] != nil {
            self.coverUrl = dict["coverUrl"] as! String
        }
        if dict.keys.contains("duration") && dict["duration"] != nil {
            self.duration = dict["duration"] as! Int64
        }
        if dict.keys.contains("endTime") && dict["endTime"] != nil {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("introduction") && dict["introduction"] != nil {
            self.introduction = dict["introduction"] as! String
        }
        if dict.keys.contains("liveId") && dict["liveId"] != nil {
            self.liveId = dict["liveId"] as! String
        }
        if dict.keys.contains("livePlayUrl") && dict["livePlayUrl"] != nil {
            self.livePlayUrl = dict["livePlayUrl"] as! String
        }
        if dict.keys.contains("liveStatus") && dict["liveStatus"] != nil {
            self.liveStatus = dict["liveStatus"] as! Int32
        }
        if dict.keys.contains("playbackDuration") && dict["playbackDuration"] != nil {
            self.playbackDuration = dict["playbackDuration"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("startTime") && dict["startTime"] != nil {
            self.startTime = dict["startTime"] as! Int64
        }
        if dict.keys.contains("subscribeCount") && dict["subscribeCount"] != nil {
            self.subscribeCount = dict["subscribeCount"] as! Int32
        }
        if dict.keys.contains("title") && dict["title"] != nil {
            self.title = dict["title"] as! String
        }
        if dict.keys.contains("uv") && dict["uv"] != nil {
            self.uv = dict["uv"] as! Int32
        }
    }
}

public class QueryLiveInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryLiveInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryLiveInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryLiveWatchDetailHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryLiveWatchDetailHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryLiveWatchDetailHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryLiveWatchDetailShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryLiveWatchDetailRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var liveId: String?

    public var tenantContext: QueryLiveWatchDetailRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveId") && dict["LiveId"] != nil {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryLiveWatchDetailRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryLiveWatchDetailShrinkRequest : Tea.TeaModel {
    public var liveId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveId") && dict["LiveId"] != nil {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryLiveWatchDetailResponseBody : Tea.TeaModel {
    public var avgWatchTime: Int64?

    public var liveUv: Int32?

    public var msgCount: Int32?

    public var playbackUv: Int32?

    public var praiseCount: Int32?

    public var pv: Int32?

    public var requestId: String?

    public var totalWatchTime: Int64?

    public var uv: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.avgWatchTime != nil {
            map["avgWatchTime"] = self.avgWatchTime!
        }
        if self.liveUv != nil {
            map["liveUv"] = self.liveUv!
        }
        if self.msgCount != nil {
            map["msgCount"] = self.msgCount!
        }
        if self.playbackUv != nil {
            map["playbackUv"] = self.playbackUv!
        }
        if self.praiseCount != nil {
            map["praiseCount"] = self.praiseCount!
        }
        if self.pv != nil {
            map["pv"] = self.pv!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalWatchTime != nil {
            map["totalWatchTime"] = self.totalWatchTime!
        }
        if self.uv != nil {
            map["uv"] = self.uv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("avgWatchTime") && dict["avgWatchTime"] != nil {
            self.avgWatchTime = dict["avgWatchTime"] as! Int64
        }
        if dict.keys.contains("liveUv") && dict["liveUv"] != nil {
            self.liveUv = dict["liveUv"] as! Int32
        }
        if dict.keys.contains("msgCount") && dict["msgCount"] != nil {
            self.msgCount = dict["msgCount"] as! Int32
        }
        if dict.keys.contains("playbackUv") && dict["playbackUv"] != nil {
            self.playbackUv = dict["playbackUv"] as! Int32
        }
        if dict.keys.contains("praiseCount") && dict["praiseCount"] != nil {
            self.praiseCount = dict["praiseCount"] as! Int32
        }
        if dict.keys.contains("pv") && dict["pv"] != nil {
            self.pv = dict["pv"] as! Int32
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalWatchTime") && dict["totalWatchTime"] != nil {
            self.totalWatchTime = dict["totalWatchTime"] as! Int64
        }
        if dict.keys.contains("uv") && dict["uv"] != nil {
            self.uv = dict["uv"] as! Int32
        }
    }
}

public class QueryLiveWatchDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryLiveWatchDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryLiveWatchDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryLiveWatchUserListHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryLiveWatchUserListHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryLiveWatchUserListHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryLiveWatchUserListShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryLiveWatchUserListRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var liveId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var tenantContext: QueryLiveWatchUserListRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveId") && dict["LiveId"] != nil {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryLiveWatchUserListRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryLiveWatchUserListShrinkRequest : Tea.TeaModel {
    public var liveId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveId") && dict["LiveId"] != nil {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryLiveWatchUserListResponseBody : Tea.TeaModel {
    public class OrgUsesList : Tea.TeaModel {
        public var deptName: String?

        public var name: String?

        public var userId: String?

        public var watchLiveTime: Int64?

        public var watchPlaybackTime: Int64?

        public var watchProgressMs: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deptName != nil {
                map["DeptName"] = self.deptName!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.watchLiveTime != nil {
                map["WatchLiveTime"] = self.watchLiveTime!
            }
            if self.watchPlaybackTime != nil {
                map["WatchPlaybackTime"] = self.watchPlaybackTime!
            }
            if self.watchProgressMs != nil {
                map["WatchProgressMs"] = self.watchProgressMs!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeptName") && dict["DeptName"] != nil {
                self.deptName = dict["DeptName"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("WatchLiveTime") && dict["WatchLiveTime"] != nil {
                self.watchLiveTime = dict["WatchLiveTime"] as! Int64
            }
            if dict.keys.contains("WatchPlaybackTime") && dict["WatchPlaybackTime"] != nil {
                self.watchPlaybackTime = dict["WatchPlaybackTime"] as! Int64
            }
            if dict.keys.contains("WatchProgressMs") && dict["WatchProgressMs"] != nil {
                self.watchProgressMs = dict["WatchProgressMs"] as! Int64
            }
        }
    }
    public class OutOrgUserList : Tea.TeaModel {
        public var name: String?

        public var watchLiveTime: Int64?

        public var watchPlaybackTime: Int64?

        public var watchProgressMs: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.watchLiveTime != nil {
                map["WatchLiveTime"] = self.watchLiveTime!
            }
            if self.watchPlaybackTime != nil {
                map["WatchPlaybackTime"] = self.watchPlaybackTime!
            }
            if self.watchProgressMs != nil {
                map["WatchProgressMs"] = self.watchProgressMs!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("WatchLiveTime") && dict["WatchLiveTime"] != nil {
                self.watchLiveTime = dict["WatchLiveTime"] as! Int64
            }
            if dict.keys.contains("WatchPlaybackTime") && dict["WatchPlaybackTime"] != nil {
                self.watchPlaybackTime = dict["WatchPlaybackTime"] as! Int64
            }
            if dict.keys.contains("WatchProgressMs") && dict["WatchProgressMs"] != nil {
                self.watchProgressMs = dict["WatchProgressMs"] as! Int64
            }
        }
    }
    public var orgUsesList: [QueryLiveWatchUserListResponseBody.OrgUsesList]?

    public var outOrgUserList: [QueryLiveWatchUserListResponseBody.OutOrgUserList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orgUsesList != nil {
            var tmp : [Any] = []
            for k in self.orgUsesList! {
                tmp.append(k.toMap())
            }
            map["orgUsesList"] = tmp
        }
        if self.outOrgUserList != nil {
            var tmp : [Any] = []
            for k in self.outOrgUserList! {
                tmp.append(k.toMap())
            }
            map["outOrgUserList"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("orgUsesList") && dict["orgUsesList"] != nil {
            var tmp : [QueryLiveWatchUserListResponseBody.OrgUsesList] = []
            for v in dict["orgUsesList"] as! [Any] {
                var model = QueryLiveWatchUserListResponseBody.OrgUsesList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.orgUsesList = tmp
        }
        if dict.keys.contains("outOrgUserList") && dict["outOrgUserList"] != nil {
            var tmp : [QueryLiveWatchUserListResponseBody.OutOrgUserList] = []
            for v in dict["outOrgUserList"] as! [Any] {
                var model = QueryLiveWatchUserListResponseBody.OutOrgUserList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.outOrgUserList = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class QueryLiveWatchUserListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryLiveWatchUserListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryLiveWatchUserListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMeetingRoomHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryMeetingRoomHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryMeetingRoomHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryMeetingRoomShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryMeetingRoomRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var roomId: String?

    public var tenantContext: QueryMeetingRoomRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.roomId != nil {
            map["RoomId"] = self.roomId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RoomId") && dict["RoomId"] != nil {
            self.roomId = dict["RoomId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryMeetingRoomRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryMeetingRoomShrinkRequest : Tea.TeaModel {
    public var roomId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.roomId != nil {
            map["RoomId"] = self.roomId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RoomId") && dict["RoomId"] != nil {
            self.roomId = dict["RoomId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryMeetingRoomResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ReservationAuthority : Tea.TeaModel {
            public class AuthorizedMembers : Tea.TeaModel {
                public var memberId: String?

                public var memberName: String?

                public var memberType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.memberId != nil {
                        map["MemberId"] = self.memberId!
                    }
                    if self.memberName != nil {
                        map["MemberName"] = self.memberName!
                    }
                    if self.memberType != nil {
                        map["MemberType"] = self.memberType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MemberId") && dict["MemberId"] != nil {
                        self.memberId = dict["MemberId"] as! String
                    }
                    if dict.keys.contains("MemberName") && dict["MemberName"] != nil {
                        self.memberName = dict["MemberName"] as! String
                    }
                    if dict.keys.contains("MemberType") && dict["MemberType"] != nil {
                        self.memberType = dict["MemberType"] as! String
                    }
                }
            }
            public var authorizedMembers: [QueryMeetingRoomResponseBody.Result.ReservationAuthority.AuthorizedMembers]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authorizedMembers != nil {
                    var tmp : [Any] = []
                    for k in self.authorizedMembers! {
                        tmp.append(k.toMap())
                    }
                    map["AuthorizedMembers"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AuthorizedMembers") && dict["AuthorizedMembers"] != nil {
                    var tmp : [QueryMeetingRoomResponseBody.Result.ReservationAuthority.AuthorizedMembers] = []
                    for v in dict["AuthorizedMembers"] as! [Any] {
                        var model = QueryMeetingRoomResponseBody.Result.ReservationAuthority.AuthorizedMembers()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.authorizedMembers = tmp
                }
            }
        }
        public class RoomGroup : Tea.TeaModel {
            public var groupId: Int64?

            public var groupName: String?

            public var parentId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! Int64
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
                    self.parentId = dict["ParentId"] as! Int64
                }
            }
        }
        public class RoomLabels : Tea.TeaModel {
            public var labelId: Int64?

            public var labelName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.labelId != nil {
                    map["LabelId"] = self.labelId!
                }
                if self.labelName != nil {
                    map["LabelName"] = self.labelName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LabelId") && dict["LabelId"] != nil {
                    self.labelId = dict["LabelId"] as! Int64
                }
                if dict.keys.contains("LabelName") && dict["LabelName"] != nil {
                    self.labelName = dict["LabelName"] as! String
                }
            }
        }
        public class RoomLocation : Tea.TeaModel {
            public var desc: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.desc != nil {
                    map["Desc"] = self.desc!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Desc") && dict["Desc"] != nil {
                    self.desc = dict["Desc"] as! String
                }
                if dict.keys.contains("Title") && dict["Title"] != nil {
                    self.title = dict["Title"] as! String
                }
            }
        }
        public var corpId: String?

        public var deviceUnionIds: [String]?

        public var enableCycleReservation: Bool?

        public var isvRoomId: String?

        public var reservationAuthority: QueryMeetingRoomResponseBody.Result.ReservationAuthority?

        public var roomCapacity: Int32?

        public var roomGroup: QueryMeetingRoomResponseBody.Result.RoomGroup?

        public var roomId: String?

        public var roomLabels: [QueryMeetingRoomResponseBody.Result.RoomLabels]?

        public var roomLocation: QueryMeetingRoomResponseBody.Result.RoomLocation?

        public var roomName: String?

        public var roomPicture: String?

        public var roomStaffId: String?

        public var roomStatus: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.reservationAuthority?.validate()
            try self.roomGroup?.validate()
            try self.roomLocation?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.deviceUnionIds != nil {
                map["DeviceUnionIds"] = self.deviceUnionIds!
            }
            if self.enableCycleReservation != nil {
                map["EnableCycleReservation"] = self.enableCycleReservation!
            }
            if self.isvRoomId != nil {
                map["IsvRoomId"] = self.isvRoomId!
            }
            if self.reservationAuthority != nil {
                map["ReservationAuthority"] = self.reservationAuthority?.toMap()
            }
            if self.roomCapacity != nil {
                map["RoomCapacity"] = self.roomCapacity!
            }
            if self.roomGroup != nil {
                map["RoomGroup"] = self.roomGroup?.toMap()
            }
            if self.roomId != nil {
                map["RoomId"] = self.roomId!
            }
            if self.roomLabels != nil {
                var tmp : [Any] = []
                for k in self.roomLabels! {
                    tmp.append(k.toMap())
                }
                map["RoomLabels"] = tmp
            }
            if self.roomLocation != nil {
                map["RoomLocation"] = self.roomLocation?.toMap()
            }
            if self.roomName != nil {
                map["RoomName"] = self.roomName!
            }
            if self.roomPicture != nil {
                map["RoomPicture"] = self.roomPicture!
            }
            if self.roomStaffId != nil {
                map["RoomStaffId"] = self.roomStaffId!
            }
            if self.roomStatus != nil {
                map["RoomStatus"] = self.roomStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") && dict["CorpId"] != nil {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("DeviceUnionIds") && dict["DeviceUnionIds"] != nil {
                self.deviceUnionIds = dict["DeviceUnionIds"] as! [String]
            }
            if dict.keys.contains("EnableCycleReservation") && dict["EnableCycleReservation"] != nil {
                self.enableCycleReservation = dict["EnableCycleReservation"] as! Bool
            }
            if dict.keys.contains("IsvRoomId") && dict["IsvRoomId"] != nil {
                self.isvRoomId = dict["IsvRoomId"] as! String
            }
            if dict.keys.contains("ReservationAuthority") && dict["ReservationAuthority"] != nil {
                var model = QueryMeetingRoomResponseBody.Result.ReservationAuthority()
                model.fromMap(dict["ReservationAuthority"] as! [String: Any])
                self.reservationAuthority = model
            }
            if dict.keys.contains("RoomCapacity") && dict["RoomCapacity"] != nil {
                self.roomCapacity = dict["RoomCapacity"] as! Int32
            }
            if dict.keys.contains("RoomGroup") && dict["RoomGroup"] != nil {
                var model = QueryMeetingRoomResponseBody.Result.RoomGroup()
                model.fromMap(dict["RoomGroup"] as! [String: Any])
                self.roomGroup = model
            }
            if dict.keys.contains("RoomId") && dict["RoomId"] != nil {
                self.roomId = dict["RoomId"] as! String
            }
            if dict.keys.contains("RoomLabels") && dict["RoomLabels"] != nil {
                var tmp : [QueryMeetingRoomResponseBody.Result.RoomLabels] = []
                for v in dict["RoomLabels"] as! [Any] {
                    var model = QueryMeetingRoomResponseBody.Result.RoomLabels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.roomLabels = tmp
            }
            if dict.keys.contains("RoomLocation") && dict["RoomLocation"] != nil {
                var model = QueryMeetingRoomResponseBody.Result.RoomLocation()
                model.fromMap(dict["RoomLocation"] as! [String: Any])
                self.roomLocation = model
            }
            if dict.keys.contains("RoomName") && dict["RoomName"] != nil {
                self.roomName = dict["RoomName"] as! String
            }
            if dict.keys.contains("RoomPicture") && dict["RoomPicture"] != nil {
                self.roomPicture = dict["RoomPicture"] as! String
            }
            if dict.keys.contains("RoomStaffId") && dict["RoomStaffId"] != nil {
                self.roomStaffId = dict["RoomStaffId"] as! String
            }
            if dict.keys.contains("RoomStatus") && dict["RoomStatus"] != nil {
                self.roomStatus = dict["RoomStatus"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var result: QueryMeetingRoomResponseBody.Result?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            var model = QueryMeetingRoomResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class QueryMeetingRoomResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMeetingRoomResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMeetingRoomResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMeetingRoomGroupHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryMeetingRoomGroupHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryMeetingRoomGroupHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryMeetingRoomGroupShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryMeetingRoomGroupRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var groupId: String?

    public var tenantContext: QueryMeetingRoomGroupRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryMeetingRoomGroupRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryMeetingRoomGroupShrinkRequest : Tea.TeaModel {
    public var groupId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryMeetingRoomGroupResponseBody : Tea.TeaModel {
    public var groupId: Int64?

    public var groupName: String?

    public var parentId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["groupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["groupName"] = self.groupName!
        }
        if self.parentId != nil {
            map["parentId"] = self.parentId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("groupId") && dict["groupId"] != nil {
            self.groupId = dict["groupId"] as! Int64
        }
        if dict.keys.contains("groupName") && dict["groupName"] != nil {
            self.groupName = dict["groupName"] as! String
        }
        if dict.keys.contains("parentId") && dict["parentId"] != nil {
            self.parentId = dict["parentId"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class QueryMeetingRoomGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMeetingRoomGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMeetingRoomGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMeetingRoomGroupListHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryMeetingRoomGroupListHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryMeetingRoomGroupListHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryMeetingRoomGroupListShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryMeetingRoomGroupListRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var request: [String: Any]?

    public var tenantContext: QueryMeetingRoomGroupListRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.request != nil {
            map["Request"] = self.request!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Request") && dict["Request"] != nil {
            self.request = dict["Request"] as! [String: Any]
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryMeetingRoomGroupListRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryMeetingRoomGroupListShrinkRequest : Tea.TeaModel {
    public var requestShrink: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestShrink != nil {
            map["Request"] = self.requestShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Request") && dict["Request"] != nil {
            self.requestShrink = dict["Request"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryMeetingRoomGroupListResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var groupId: Int64?

        public var groupName: String?

        public var parentId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.parentId != nil {
                map["ParentId"] = self.parentId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                self.groupId = dict["GroupId"] as! Int64
            }
            if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
                self.parentId = dict["ParentId"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var result: [QueryMeetingRoomGroupListResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            var tmp : [QueryMeetingRoomGroupListResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = QueryMeetingRoomGroupListResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class QueryMeetingRoomGroupListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMeetingRoomGroupListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMeetingRoomGroupListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMeetingRoomListHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryMeetingRoomListHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryMeetingRoomListHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryMeetingRoomListShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryMeetingRoomListRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: Int64?

    public var tenantContext: QueryMeetingRoomListRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryMeetingRoomListRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryMeetingRoomListShrinkRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: Int64?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryMeetingRoomListResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class RoomGroup : Tea.TeaModel {
            public var groupId: Int64?

            public var groupName: String?

            public var parentId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! Int64
                }
                if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
                    self.parentId = dict["ParentId"] as! Int64
                }
            }
        }
        public class RoomLabels : Tea.TeaModel {
            public var labelId: Int64?

            public var labelName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.labelId != nil {
                    map["LabelId"] = self.labelId!
                }
                if self.labelName != nil {
                    map["LabelName"] = self.labelName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LabelId") && dict["LabelId"] != nil {
                    self.labelId = dict["LabelId"] as! Int64
                }
                if dict.keys.contains("LabelName") && dict["LabelName"] != nil {
                    self.labelName = dict["LabelName"] as! String
                }
            }
        }
        public class RoomLocation : Tea.TeaModel {
            public var desc: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.desc != nil {
                    map["Desc"] = self.desc!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Desc") && dict["Desc"] != nil {
                    self.desc = dict["Desc"] as! String
                }
                if dict.keys.contains("Title") && dict["Title"] != nil {
                    self.title = dict["Title"] as! String
                }
            }
        }
        public var corpId: String?

        public var isvRoomId: String?

        public var roomCapacity: Int32?

        public var roomGroup: QueryMeetingRoomListResponseBody.Result.RoomGroup?

        public var roomId: String?

        public var roomLabels: [QueryMeetingRoomListResponseBody.Result.RoomLabels]?

        public var roomLocation: QueryMeetingRoomListResponseBody.Result.RoomLocation?

        public var roomName: String?

        public var roomPicture: String?

        public var roomStaffId: String?

        public var roomStatus: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.roomGroup?.validate()
            try self.roomLocation?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.isvRoomId != nil {
                map["IsvRoomId"] = self.isvRoomId!
            }
            if self.roomCapacity != nil {
                map["RoomCapacity"] = self.roomCapacity!
            }
            if self.roomGroup != nil {
                map["RoomGroup"] = self.roomGroup?.toMap()
            }
            if self.roomId != nil {
                map["RoomId"] = self.roomId!
            }
            if self.roomLabels != nil {
                var tmp : [Any] = []
                for k in self.roomLabels! {
                    tmp.append(k.toMap())
                }
                map["RoomLabels"] = tmp
            }
            if self.roomLocation != nil {
                map["RoomLocation"] = self.roomLocation?.toMap()
            }
            if self.roomName != nil {
                map["RoomName"] = self.roomName!
            }
            if self.roomPicture != nil {
                map["RoomPicture"] = self.roomPicture!
            }
            if self.roomStaffId != nil {
                map["RoomStaffId"] = self.roomStaffId!
            }
            if self.roomStatus != nil {
                map["RoomStatus"] = self.roomStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") && dict["CorpId"] != nil {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("IsvRoomId") && dict["IsvRoomId"] != nil {
                self.isvRoomId = dict["IsvRoomId"] as! String
            }
            if dict.keys.contains("RoomCapacity") && dict["RoomCapacity"] != nil {
                self.roomCapacity = dict["RoomCapacity"] as! Int32
            }
            if dict.keys.contains("RoomGroup") && dict["RoomGroup"] != nil {
                var model = QueryMeetingRoomListResponseBody.Result.RoomGroup()
                model.fromMap(dict["RoomGroup"] as! [String: Any])
                self.roomGroup = model
            }
            if dict.keys.contains("RoomId") && dict["RoomId"] != nil {
                self.roomId = dict["RoomId"] as! String
            }
            if dict.keys.contains("RoomLabels") && dict["RoomLabels"] != nil {
                var tmp : [QueryMeetingRoomListResponseBody.Result.RoomLabels] = []
                for v in dict["RoomLabels"] as! [Any] {
                    var model = QueryMeetingRoomListResponseBody.Result.RoomLabels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.roomLabels = tmp
            }
            if dict.keys.contains("RoomLocation") && dict["RoomLocation"] != nil {
                var model = QueryMeetingRoomListResponseBody.Result.RoomLocation()
                model.fromMap(dict["RoomLocation"] as! [String: Any])
                self.roomLocation = model
            }
            if dict.keys.contains("RoomName") && dict["RoomName"] != nil {
                self.roomName = dict["RoomName"] as! String
            }
            if dict.keys.contains("RoomPicture") && dict["RoomPicture"] != nil {
                self.roomPicture = dict["RoomPicture"] as! String
            }
            if dict.keys.contains("RoomStaffId") && dict["RoomStaffId"] != nil {
                self.roomStaffId = dict["RoomStaffId"] as! String
            }
            if dict.keys.contains("RoomStatus") && dict["RoomStatus"] != nil {
                self.roomStatus = dict["RoomStatus"] as! Int32
            }
        }
    }
    public var hasMore: Bool?

    public var nextToken: Int64?

    public var requestId: String?

    public var result: [QueryMeetingRoomListResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hasMore != nil {
            map["hasMore"] = self.hasMore!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("hasMore") && dict["hasMore"] != nil {
            self.hasMore = dict["hasMore"] as! Bool
        }
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            var tmp : [QueryMeetingRoomListResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = QueryMeetingRoomListResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class QueryMeetingRoomListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMeetingRoomListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMeetingRoomListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryOrgHonorsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryOrgHonorsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryOrgHonorsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryOrgHonorsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryOrgHonorsRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: QueryOrgHonorsRequest.TenantContext?

    public var maxResults: Int32?

    public var nextToken: String?

    public var orgId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryOrgHonorsRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("maxResults") && dict["maxResults"] != nil {
            self.maxResults = dict["maxResults"] as! Int32
        }
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! Int64
        }
    }
}

public class QueryOrgHonorsShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var orgId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("maxResults") && dict["maxResults"] != nil {
            self.maxResults = dict["maxResults"] as! Int32
        }
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! Int64
        }
    }
}

public class QueryOrgHonorsResponseBody : Tea.TeaModel {
    public class OpenHonors : Tea.TeaModel {
        public var honorDesc: String?

        public var honorId: Int64?

        public var honorImgUrl: String?

        public var honorName: String?

        public var honorPendantImgUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.honorDesc != nil {
                map["honorDesc"] = self.honorDesc!
            }
            if self.honorId != nil {
                map["honorId"] = self.honorId!
            }
            if self.honorImgUrl != nil {
                map["honorImgUrl"] = self.honorImgUrl!
            }
            if self.honorName != nil {
                map["honorName"] = self.honorName!
            }
            if self.honorPendantImgUrl != nil {
                map["honorPendantImgUrl"] = self.honorPendantImgUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("honorDesc") && dict["honorDesc"] != nil {
                self.honorDesc = dict["honorDesc"] as! String
            }
            if dict.keys.contains("honorId") && dict["honorId"] != nil {
                self.honorId = dict["honorId"] as! Int64
            }
            if dict.keys.contains("honorImgUrl") && dict["honorImgUrl"] != nil {
                self.honorImgUrl = dict["honorImgUrl"] as! String
            }
            if dict.keys.contains("honorName") && dict["honorName"] != nil {
                self.honorName = dict["honorName"] as! String
            }
            if dict.keys.contains("honorPendantImgUrl") && dict["honorPendantImgUrl"] != nil {
                self.honorPendantImgUrl = dict["honorPendantImgUrl"] as! String
            }
        }
    }
    public var nextToken: String?

    public var openHonors: [QueryOrgHonorsResponseBody.OpenHonors]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.openHonors != nil {
            var tmp : [Any] = []
            for k in self.openHonors! {
                tmp.append(k.toMap())
            }
            map["openHonors"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("openHonors") && dict["openHonors"] != nil {
            var tmp : [QueryOrgHonorsResponseBody.OpenHonors] = []
            for v in dict["openHonors"] as! [Any] {
                var model = QueryOrgHonorsResponseBody.OpenHonors()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.openHonors = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class QueryOrgHonorsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryOrgHonorsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryOrgHonorsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryOrgTodoTasksHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryOrgTodoTasksHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryOrgTodoTasksHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryOrgTodoTasksShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryOrgTodoTasksRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: QueryOrgTodoTasksRequest.TenantContext?

    public var isDone: Bool?

    public var nextToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.isDone != nil {
            map["isDone"] = self.isDone!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryOrgTodoTasksRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("isDone") && dict["isDone"] != nil {
            self.isDone = dict["isDone"] as! Bool
        }
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
    }
}

public class QueryOrgTodoTasksShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var isDone: Bool?

    public var nextToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.isDone != nil {
            map["isDone"] = self.isDone!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("isDone") && dict["isDone"] != nil {
            self.isDone = dict["isDone"] as! Bool
        }
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
    }
}

public class QueryOrgTodoTasksResponseBody : Tea.TeaModel {
    public class TodoCards : Tea.TeaModel {
        public class DetailUrl : Tea.TeaModel {
            public var appUrl: String?

            public var pcUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appUrl != nil {
                    map["appUrl"] = self.appUrl!
                }
                if self.pcUrl != nil {
                    map["pcUrl"] = self.pcUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("appUrl") && dict["appUrl"] != nil {
                    self.appUrl = dict["appUrl"] as! String
                }
                if dict.keys.contains("pcUrl") && dict["pcUrl"] != nil {
                    self.pcUrl = dict["pcUrl"] as! String
                }
            }
        }
        public var bizTag: String?

        public var createdTime: Int64?

        public var creatorId: String?

        public var detailUrl: QueryOrgTodoTasksResponseBody.TodoCards.DetailUrl?

        public var dueTime: Int64?

        public var isDone: Bool?

        public var modifiedTime: Int64?

        public var priority: Int32?

        public var sourceId: String?

        public var subject: String?

        public var taskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.detailUrl?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizTag != nil {
                map["bizTag"] = self.bizTag!
            }
            if self.createdTime != nil {
                map["createdTime"] = self.createdTime!
            }
            if self.creatorId != nil {
                map["creatorId"] = self.creatorId!
            }
            if self.detailUrl != nil {
                map["detailUrl"] = self.detailUrl?.toMap()
            }
            if self.dueTime != nil {
                map["dueTime"] = self.dueTime!
            }
            if self.isDone != nil {
                map["isDone"] = self.isDone!
            }
            if self.modifiedTime != nil {
                map["modifiedTime"] = self.modifiedTime!
            }
            if self.priority != nil {
                map["priority"] = self.priority!
            }
            if self.sourceId != nil {
                map["sourceId"] = self.sourceId!
            }
            if self.subject != nil {
                map["subject"] = self.subject!
            }
            if self.taskId != nil {
                map["taskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("bizTag") && dict["bizTag"] != nil {
                self.bizTag = dict["bizTag"] as! String
            }
            if dict.keys.contains("createdTime") && dict["createdTime"] != nil {
                self.createdTime = dict["createdTime"] as! Int64
            }
            if dict.keys.contains("creatorId") && dict["creatorId"] != nil {
                self.creatorId = dict["creatorId"] as! String
            }
            if dict.keys.contains("detailUrl") && dict["detailUrl"] != nil {
                var model = QueryOrgTodoTasksResponseBody.TodoCards.DetailUrl()
                model.fromMap(dict["detailUrl"] as! [String: Any])
                self.detailUrl = model
            }
            if dict.keys.contains("dueTime") && dict["dueTime"] != nil {
                self.dueTime = dict["dueTime"] as! Int64
            }
            if dict.keys.contains("isDone") && dict["isDone"] != nil {
                self.isDone = dict["isDone"] as! Bool
            }
            if dict.keys.contains("modifiedTime") && dict["modifiedTime"] != nil {
                self.modifiedTime = dict["modifiedTime"] as! Int64
            }
            if dict.keys.contains("priority") && dict["priority"] != nil {
                self.priority = dict["priority"] as! Int32
            }
            if dict.keys.contains("sourceId") && dict["sourceId"] != nil {
                self.sourceId = dict["sourceId"] as! String
            }
            if dict.keys.contains("subject") && dict["subject"] != nil {
                self.subject = dict["subject"] as! String
            }
            if dict.keys.contains("taskId") && dict["taskId"] != nil {
                self.taskId = dict["taskId"] as! String
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var todoCards: [QueryOrgTodoTasksResponseBody.TodoCards]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.todoCards != nil {
            var tmp : [Any] = []
            for k in self.todoCards! {
                tmp.append(k.toMap())
            }
            map["todoCards"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("todoCards") && dict["todoCards"] != nil {
            var tmp : [QueryOrgTodoTasksResponseBody.TodoCards] = []
            for v in dict["todoCards"] as! [Any] {
                var model = QueryOrgTodoTasksResponseBody.TodoCards()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.todoCards = tmp
        }
    }
}

public class QueryOrgTodoTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryOrgTodoTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryOrgTodoTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryScheduleConferenceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryScheduleConferenceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryScheduleConferenceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryScheduleConferenceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryScheduleConferenceRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var requestUnionId: String?

    public var tenantContext: QueryScheduleConferenceRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestUnionId != nil {
            map["RequestUnionId"] = self.requestUnionId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestUnionId") && dict["RequestUnionId"] != nil {
            self.requestUnionId = dict["RequestUnionId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryScheduleConferenceRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class QueryScheduleConferenceShrinkRequest : Tea.TeaModel {
    public var requestUnionId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestUnionId != nil {
            map["RequestUnionId"] = self.requestUnionId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestUnionId") && dict["RequestUnionId"] != nil {
            self.requestUnionId = dict["RequestUnionId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class QueryScheduleConferenceResponseBody : Tea.TeaModel {
    public var endTime: Int64?

    public var phones: [String]?

    public var requestId: String?

    public var roomCode: String?

    public var scheduleConferenceId: String?

    public var startTime: Int64?

    public var title: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.phones != nil {
            map["phones"] = self.phones!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.roomCode != nil {
            map["roomCode"] = self.roomCode!
        }
        if self.scheduleConferenceId != nil {
            map["scheduleConferenceId"] = self.scheduleConferenceId!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        if self.url != nil {
            map["url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("endTime") && dict["endTime"] != nil {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("phones") && dict["phones"] != nil {
            self.phones = dict["phones"] as! [String]
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("roomCode") && dict["roomCode"] != nil {
            self.roomCode = dict["roomCode"] as! String
        }
        if dict.keys.contains("scheduleConferenceId") && dict["scheduleConferenceId"] != nil {
            self.scheduleConferenceId = dict["scheduleConferenceId"] as! String
        }
        if dict.keys.contains("startTime") && dict["startTime"] != nil {
            self.startTime = dict["startTime"] as! Int64
        }
        if dict.keys.contains("title") && dict["title"] != nil {
            self.title = dict["title"] as! String
        }
        if dict.keys.contains("url") && dict["url"] != nil {
            self.url = dict["url"] as! String
        }
    }
}

public class QueryScheduleConferenceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryScheduleConferenceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryScheduleConferenceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryUserHonorsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: QueryUserHonorsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = QueryUserHonorsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class QueryUserHonorsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class QueryUserHonorsRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: QueryUserHonorsRequest.TenantContext?

    public var maxResults: Int32?

    public var nextToken: String?

    public var orgId: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = QueryUserHonorsRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("maxResults") && dict["maxResults"] != nil {
            self.maxResults = dict["maxResults"] as! Int32
        }
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! String
        }
    }
}

public class QueryUserHonorsShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var orgId: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("maxResults") && dict["maxResults"] != nil {
            self.maxResults = dict["maxResults"] as! Int32
        }
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! String
        }
    }
}

public class QueryUserHonorsResponseBody : Tea.TeaModel {
    public class Honors : Tea.TeaModel {
        public class GrantHistory : Tea.TeaModel {
            public var grantTime: Int64?

            public var senderUserid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.grantTime != nil {
                    map["grantTime"] = self.grantTime!
                }
                if self.senderUserid != nil {
                    map["senderUserid"] = self.senderUserid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("grantTime") && dict["grantTime"] != nil {
                    self.grantTime = dict["grantTime"] as! Int64
                }
                if dict.keys.contains("senderUserid") && dict["senderUserid"] != nil {
                    self.senderUserid = dict["senderUserid"] as! String
                }
            }
        }
        public var expirationTime: Int64?

        public var grantHistory: [QueryUserHonorsResponseBody.Honors.GrantHistory]?

        public var honorDesc: String?

        public var honorId: String?

        public var honorName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.expirationTime != nil {
                map["expirationTime"] = self.expirationTime!
            }
            if self.grantHistory != nil {
                var tmp : [Any] = []
                for k in self.grantHistory! {
                    tmp.append(k.toMap())
                }
                map["grantHistory"] = tmp
            }
            if self.honorDesc != nil {
                map["honorDesc"] = self.honorDesc!
            }
            if self.honorId != nil {
                map["honorId"] = self.honorId!
            }
            if self.honorName != nil {
                map["honorName"] = self.honorName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("expirationTime") && dict["expirationTime"] != nil {
                self.expirationTime = dict["expirationTime"] as! Int64
            }
            if dict.keys.contains("grantHistory") && dict["grantHistory"] != nil {
                var tmp : [QueryUserHonorsResponseBody.Honors.GrantHistory] = []
                for v in dict["grantHistory"] as! [Any] {
                    var model = QueryUserHonorsResponseBody.Honors.GrantHistory()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.grantHistory = tmp
            }
            if dict.keys.contains("honorDesc") && dict["honorDesc"] != nil {
                self.honorDesc = dict["honorDesc"] as! String
            }
            if dict.keys.contains("honorId") && dict["honorId"] != nil {
                self.honorId = dict["honorId"] as! String
            }
            if dict.keys.contains("honorName") && dict["honorName"] != nil {
                self.honorName = dict["honorName"] as! String
            }
        }
    }
    public var honors: [QueryUserHonorsResponseBody.Honors]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.honors != nil {
            var tmp : [Any] = []
            for k in self.honors! {
                tmp.append(k.toMap())
            }
            map["honors"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("honors") && dict["honors"] != nil {
            var tmp : [QueryUserHonorsResponseBody.Honors] = []
            for v in dict["honors"] as! [Any] {
                var model = QueryUserHonorsResponseBody.Honors()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.honors = tmp
        }
        if dict.keys.contains("nextToken") && dict["nextToken"] != nil {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class QueryUserHonorsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryUserHonorsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryUserHonorsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RecallHonorHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: RecallHonorHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = RecallHonorHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class RecallHonorShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class RecallHonorRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: RecallHonorRequest.TenantContext?

    public var honorId: String?

    public var orgId: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.honorId != nil {
            map["honorId"] = self.honorId!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = RecallHonorRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("honorId") && dict["honorId"] != nil {
            self.honorId = dict["honorId"] as! String
        }
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! String
        }
    }
}

public class RecallHonorShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var honorId: String?

    public var orgId: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.honorId != nil {
            map["honorId"] = self.honorId!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("honorId") && dict["honorId"] != nil {
            self.honorId = dict["honorId"] as! String
        }
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! String
        }
    }
}

public class RecallHonorResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public var data: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["data"] = self.data!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("data") && dict["data"] != nil {
                self.data = dict["data"] as! Any
            }
        }
    }
    public var content: RecallHonorResponseBody.Content?

    public var errorCode: String?

    public var errorCtx: [String: Any]?

    public var errorMsg: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["content"] = self.content?.toMap()
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorCtx != nil {
            map["errorCtx"] = self.errorCtx!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("content") && dict["content"] != nil {
            var model = RecallHonorResponseBody.Content()
            model.fromMap(dict["content"] as! [String: Any])
            self.content = model
        }
        if dict.keys.contains("errorCode") && dict["errorCode"] != nil {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorCtx") && dict["errorCtx"] != nil {
            self.errorCtx = dict["errorCtx"] as! [String: Any]
        }
        if dict.keys.contains("errorMsg") && dict["errorMsg"] != nil {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("httpStatusCode") && dict["httpStatusCode"] != nil {
            self.httpStatusCode = dict["httpStatusCode"] as! Int32
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
    }
}

public class RecallHonorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RecallHonorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RecallHonorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReceiverListReportHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: ReceiverListReportHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = ReceiverListReportHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class ReceiverListReportShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class ReceiverListReportRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var offset: Int64?

    public var reportId: String?

    public var size: Int64?

    public var tenantContext: ReceiverListReportRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Offset") && dict["Offset"] != nil {
            self.offset = dict["Offset"] as! Int64
        }
        if dict.keys.contains("ReportId") && dict["ReportId"] != nil {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = ReceiverListReportRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class ReceiverListReportShrinkRequest : Tea.TeaModel {
    public var offset: Int64?

    public var reportId: String?

    public var size: Int64?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Offset") && dict["Offset"] != nil {
            self.offset = dict["Offset"] as! Int64
        }
        if dict.keys.contains("ReportId") && dict["ReportId"] != nil {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class ReceiverListReportResponseBody : Tea.TeaModel {
    public var hasMore: Bool?

    public var nextCursor: Int64?

    public var requestId: String?

    public var useridList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hasMore != nil {
            map["hasMore"] = self.hasMore!
        }
        if self.nextCursor != nil {
            map["nextCursor"] = self.nextCursor!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.useridList != nil {
            map["useridList"] = self.useridList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("hasMore") && dict["hasMore"] != nil {
            self.hasMore = dict["hasMore"] as! Bool
        }
        if dict.keys.contains("nextCursor") && dict["nextCursor"] != nil {
            self.nextCursor = dict["nextCursor"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("useridList") && dict["useridList"] != nil {
            self.useridList = dict["useridList"] as! [String]
        }
    }
}

public class ReceiverListReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReceiverListReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ReceiverListReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RedirectTaskHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: RedirectTaskHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = RedirectTaskHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class RedirectTaskShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class RedirectTaskRequest : Tea.TeaModel {
    public var appType: String?

    public var byManager: String?

    public var language: String?

    public var nowActionExecutorId: String?

    public var processInstanceId: String?

    public var remark: String?

    public var systemToken: String?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.byManager != nil {
            map["ByManager"] = self.byManager!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.nowActionExecutorId != nil {
            map["NowActionExecutorId"] = self.nowActionExecutorId!
        }
        if self.processInstanceId != nil {
            map["ProcessInstanceId"] = self.processInstanceId!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("ByManager") && dict["ByManager"] != nil {
            self.byManager = dict["ByManager"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("NowActionExecutorId") && dict["NowActionExecutorId"] != nil {
            self.nowActionExecutorId = dict["NowActionExecutorId"] as! String
        }
        if dict.keys.contains("ProcessInstanceId") && dict["ProcessInstanceId"] != nil {
            self.processInstanceId = dict["ProcessInstanceId"] as! String
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! Int64
        }
    }
}

public class RedirectTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class RedirectTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RedirectTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RedirectTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveAttendeeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: RemoveAttendeeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = RemoveAttendeeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class RemoveAttendeeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class RemoveAttendeeRequest : Tea.TeaModel {
    public var attendeesToRemove: [String]?

    public var calendarId: String?

    public var eventId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendeesToRemove != nil {
            map["AttendeesToRemove"] = self.attendeesToRemove!
        }
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttendeesToRemove") && dict["AttendeesToRemove"] != nil {
            self.attendeesToRemove = dict["AttendeesToRemove"] as! [String]
        }
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! String
        }
    }
}

public class RemoveAttendeeShrinkRequest : Tea.TeaModel {
    public var attendeesToRemoveShrink: String?

    public var calendarId: String?

    public var eventId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attendeesToRemoveShrink != nil {
            map["AttendeesToRemove"] = self.attendeesToRemoveShrink!
        }
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttendeesToRemove") && dict["AttendeesToRemove"] != nil {
            self.attendeesToRemoveShrink = dict["AttendeesToRemove"] as! String
        }
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! String
        }
    }
}

public class RemoveAttendeeResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public var data: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! Any
            }
        }
    }
    public var content: RemoveAttendeeResponseBody.Content?

    public var errorCode: String?

    public var errorCtx: [String: Any]?

    public var errorMsg: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorCtx != nil {
            map["ErrorCtx"] = self.errorCtx!
        }
        if self.errorMsg != nil {
            map["ErrorMsg"] = self.errorMsg!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") && dict["Content"] != nil {
            var model = RemoveAttendeeResponseBody.Content()
            model.fromMap(dict["Content"] as! [String: Any])
            self.content = model
        }
        if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("ErrorCtx") && dict["ErrorCtx"] != nil {
            self.errorCtx = dict["ErrorCtx"] as! [String: Any]
        }
        if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
            self.errorMsg = dict["ErrorMsg"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RemoveAttendeeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveAttendeeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveAttendeeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveMeetingRoomsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: RemoveMeetingRoomsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = RemoveMeetingRoomsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class RemoveMeetingRoomsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class RemoveMeetingRoomsRequest : Tea.TeaModel {
    public class MeetingRoomsToRemove : Tea.TeaModel {
        public var roomId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.roomId != nil {
                map["RoomId"] = self.roomId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RoomId") && dict["RoomId"] != nil {
                self.roomId = dict["RoomId"] as! String
            }
        }
    }
    public var calendarId: String?

    public var eventId: String?

    public var meetingRoomsToRemove: [RemoveMeetingRoomsRequest.MeetingRoomsToRemove]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.meetingRoomsToRemove != nil {
            var tmp : [Any] = []
            for k in self.meetingRoomsToRemove! {
                tmp.append(k.toMap())
            }
            map["MeetingRoomsToRemove"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("MeetingRoomsToRemove") && dict["MeetingRoomsToRemove"] != nil {
            var tmp : [RemoveMeetingRoomsRequest.MeetingRoomsToRemove] = []
            for v in dict["MeetingRoomsToRemove"] as! [Any] {
                var model = RemoveMeetingRoomsRequest.MeetingRoomsToRemove()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.meetingRoomsToRemove = tmp
        }
    }
}

public class RemoveMeetingRoomsShrinkRequest : Tea.TeaModel {
    public var calendarId: String?

    public var eventId: String?

    public var meetingRoomsToRemoveShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.meetingRoomsToRemoveShrink != nil {
            map["MeetingRoomsToRemove"] = self.meetingRoomsToRemoveShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("MeetingRoomsToRemove") && dict["MeetingRoomsToRemove"] != nil {
            self.meetingRoomsToRemoveShrink = dict["MeetingRoomsToRemove"] as! String
        }
    }
}

public class RemoveMeetingRoomsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! Bool
        }
    }
}

public class RemoveMeetingRoomsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveMeetingRoomsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveMeetingRoomsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveContentHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SaveContentHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = SaveContentHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SaveContentShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SaveContentRequest : Tea.TeaModel {
    public class Contents : Tea.TeaModel {
        public var content: String?

        public var contentType: String?

        public var key: String?

        public var sort: Int64?

        public var type: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.contentType != nil {
                map["ContentType"] = self.contentType!
            }
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.sort != nil {
                map["Sort"] = self.sort!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") && dict["Content"] != nil {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("ContentType") && dict["ContentType"] != nil {
                self.contentType = dict["ContentType"] as! String
            }
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Sort") && dict["Sort"] != nil {
                self.sort = dict["Sort"] as! Int64
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! Int64
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var contents: [SaveContentRequest.Contents]?

    public var ddFrom: String?

    public var templateId: String?

    public var tenantContext: SaveContentRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contents != nil {
            var tmp : [Any] = []
            for k in self.contents! {
                tmp.append(k.toMap())
            }
            map["Contents"] = tmp
        }
        if self.ddFrom != nil {
            map["DdFrom"] = self.ddFrom!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Contents") && dict["Contents"] != nil {
            var tmp : [SaveContentRequest.Contents] = []
            for v in dict["Contents"] as! [Any] {
                var model = SaveContentRequest.Contents()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.contents = tmp
        }
        if dict.keys.contains("DdFrom") && dict["DdFrom"] != nil {
            self.ddFrom = dict["DdFrom"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = SaveContentRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class SaveContentShrinkRequest : Tea.TeaModel {
    public var contentsShrink: String?

    public var ddFrom: String?

    public var templateId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contentsShrink != nil {
            map["Contents"] = self.contentsShrink!
        }
        if self.ddFrom != nil {
            map["DdFrom"] = self.ddFrom!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Contents") && dict["Contents"] != nil {
            self.contentsShrink = dict["Contents"] as! String
        }
        if dict.keys.contains("DdFrom") && dict["DdFrom"] != nil {
            self.ddFrom = dict["DdFrom"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class SaveContentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
    }
}

public class SaveContentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveContentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SaveContentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveFormDataHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SaveFormDataHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = SaveFormDataHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SaveFormDataShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SaveFormDataRequest : Tea.TeaModel {
    public var appType: String?

    public var formDataJson: String?

    public var formUuid: String?

    public var language: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.formDataJson != nil {
            map["FormDataJson"] = self.formDataJson!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FormDataJson") && dict["FormDataJson"] != nil {
            self.formDataJson = dict["FormDataJson"] as! String
        }
        if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class SaveFormDataResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! String
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class SaveFormDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveFormDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SaveFormDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveFormRemarkHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SaveFormRemarkHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = SaveFormRemarkHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SaveFormRemarkShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SaveFormRemarkRequest : Tea.TeaModel {
    public var appType: String?

    public var atUserId: String?

    public var content: String?

    public var formInstanceId: String?

    public var language: String?

    public var replyId: Int64?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.atUserId != nil {
            map["AtUserId"] = self.atUserId!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.formInstanceId != nil {
            map["FormInstanceId"] = self.formInstanceId!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.replyId != nil {
            map["ReplyId"] = self.replyId!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("AtUserId") && dict["AtUserId"] != nil {
            self.atUserId = dict["AtUserId"] as! String
        }
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("FormInstanceId") && dict["FormInstanceId"] != nil {
            self.formInstanceId = dict["FormInstanceId"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("ReplyId") && dict["ReplyId"] != nil {
            self.replyId = dict["ReplyId"] as! Int64
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class SaveFormRemarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class SaveFormRemarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveFormRemarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SaveFormRemarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchEmployeeFieldValuesHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SearchEmployeeFieldValuesHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = SearchEmployeeFieldValuesHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SearchEmployeeFieldValuesShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SearchEmployeeFieldValuesRequest : Tea.TeaModel {
    public var appType: String?

    public var createFromTimeGMT: String?

    public var createToTimeGMT: String?

    public var formUuid: String?

    public var language: String?

    public var modifiedFromTimeGMT: String?

    public var modifiedToTimeGMT: String?

    public var originatorId: String?

    public var searchFieldJson: String?

    public var systemToken: String?

    public var targetFieldJson: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.createFromTimeGMT != nil {
            map["CreateFromTimeGMT"] = self.createFromTimeGMT!
        }
        if self.createToTimeGMT != nil {
            map["CreateToTimeGMT"] = self.createToTimeGMT!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.modifiedFromTimeGMT != nil {
            map["ModifiedFromTimeGMT"] = self.modifiedFromTimeGMT!
        }
        if self.modifiedToTimeGMT != nil {
            map["ModifiedToTimeGMT"] = self.modifiedToTimeGMT!
        }
        if self.originatorId != nil {
            map["OriginatorId"] = self.originatorId!
        }
        if self.searchFieldJson != nil {
            map["SearchFieldJson"] = self.searchFieldJson!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.targetFieldJson != nil {
            map["TargetFieldJson"] = self.targetFieldJson!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("CreateFromTimeGMT") && dict["CreateFromTimeGMT"] != nil {
            self.createFromTimeGMT = dict["CreateFromTimeGMT"] as! String
        }
        if dict.keys.contains("CreateToTimeGMT") && dict["CreateToTimeGMT"] != nil {
            self.createToTimeGMT = dict["CreateToTimeGMT"] as! String
        }
        if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("ModifiedFromTimeGMT") && dict["ModifiedFromTimeGMT"] != nil {
            self.modifiedFromTimeGMT = dict["ModifiedFromTimeGMT"] as! String
        }
        if dict.keys.contains("ModifiedToTimeGMT") && dict["ModifiedToTimeGMT"] != nil {
            self.modifiedToTimeGMT = dict["ModifiedToTimeGMT"] as! String
        }
        if dict.keys.contains("OriginatorId") && dict["OriginatorId"] != nil {
            self.originatorId = dict["OriginatorId"] as! String
        }
        if dict.keys.contains("SearchFieldJson") && dict["SearchFieldJson"] != nil {
            self.searchFieldJson = dict["SearchFieldJson"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("TargetFieldJson") && dict["TargetFieldJson"] != nil {
            self.targetFieldJson = dict["TargetFieldJson"] as! String
        }
    }
}

public class SearchEmployeeFieldValuesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! String
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class SearchEmployeeFieldValuesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchEmployeeFieldValuesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SearchEmployeeFieldValuesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchFormDataIdListHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SearchFormDataIdListHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = SearchFormDataIdListHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SearchFormDataIdListShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SearchFormDataIdListRequest : Tea.TeaModel {
    public var appType: String?

    public var createFromTimeGMT: String?

    public var createToTimeGMT: String?

    public var formUuid: String?

    public var language: String?

    public var modifiedFromTimeGMT: String?

    public var modifiedToTimeGMT: String?

    public var originatorId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchFieldJson: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.createFromTimeGMT != nil {
            map["CreateFromTimeGMT"] = self.createFromTimeGMT!
        }
        if self.createToTimeGMT != nil {
            map["CreateToTimeGMT"] = self.createToTimeGMT!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.modifiedFromTimeGMT != nil {
            map["ModifiedFromTimeGMT"] = self.modifiedFromTimeGMT!
        }
        if self.modifiedToTimeGMT != nil {
            map["ModifiedToTimeGMT"] = self.modifiedToTimeGMT!
        }
        if self.originatorId != nil {
            map["OriginatorId"] = self.originatorId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchFieldJson != nil {
            map["SearchFieldJson"] = self.searchFieldJson!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("CreateFromTimeGMT") && dict["CreateFromTimeGMT"] != nil {
            self.createFromTimeGMT = dict["CreateFromTimeGMT"] as! String
        }
        if dict.keys.contains("CreateToTimeGMT") && dict["CreateToTimeGMT"] != nil {
            self.createToTimeGMT = dict["CreateToTimeGMT"] as! String
        }
        if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("ModifiedFromTimeGMT") && dict["ModifiedFromTimeGMT"] != nil {
            self.modifiedFromTimeGMT = dict["ModifiedFromTimeGMT"] as! String
        }
        if dict.keys.contains("ModifiedToTimeGMT") && dict["ModifiedToTimeGMT"] != nil {
            self.modifiedToTimeGMT = dict["ModifiedToTimeGMT"] as! String
        }
        if dict.keys.contains("OriginatorId") && dict["OriginatorId"] != nil {
            self.originatorId = dict["OriginatorId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchFieldJson") && dict["SearchFieldJson"] != nil {
            self.searchFieldJson = dict["SearchFieldJson"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class SearchFormDataIdListResponseBody : Tea.TeaModel {
    public var data: [String]?

    public var pageNumber: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data!
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            self.data = dict["data"] as! [String]
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class SearchFormDataIdListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchFormDataIdListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SearchFormDataIdListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchFormDataSecondGenerationHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SearchFormDataSecondGenerationHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = SearchFormDataSecondGenerationHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SearchFormDataSecondGenerationShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SearchFormDataSecondGenerationRequest : Tea.TeaModel {
    public var appType: String?

    public var createFromTimeGMT: String?

    public var createToTimeGMT: String?

    public var formUuid: String?

    public var modifiedFromTimeGMT: String?

    public var modifiedToTimeGMT: String?

    public var orderConfigJson: String?

    public var originatorId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchCondition: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.createFromTimeGMT != nil {
            map["CreateFromTimeGMT"] = self.createFromTimeGMT!
        }
        if self.createToTimeGMT != nil {
            map["CreateToTimeGMT"] = self.createToTimeGMT!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.modifiedFromTimeGMT != nil {
            map["ModifiedFromTimeGMT"] = self.modifiedFromTimeGMT!
        }
        if self.modifiedToTimeGMT != nil {
            map["ModifiedToTimeGMT"] = self.modifiedToTimeGMT!
        }
        if self.orderConfigJson != nil {
            map["OrderConfigJson"] = self.orderConfigJson!
        }
        if self.originatorId != nil {
            map["OriginatorId"] = self.originatorId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchCondition != nil {
            map["SearchCondition"] = self.searchCondition!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("CreateFromTimeGMT") && dict["CreateFromTimeGMT"] != nil {
            self.createFromTimeGMT = dict["CreateFromTimeGMT"] as! String
        }
        if dict.keys.contains("CreateToTimeGMT") && dict["CreateToTimeGMT"] != nil {
            self.createToTimeGMT = dict["CreateToTimeGMT"] as! String
        }
        if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("ModifiedFromTimeGMT") && dict["ModifiedFromTimeGMT"] != nil {
            self.modifiedFromTimeGMT = dict["ModifiedFromTimeGMT"] as! String
        }
        if dict.keys.contains("ModifiedToTimeGMT") && dict["ModifiedToTimeGMT"] != nil {
            self.modifiedToTimeGMT = dict["ModifiedToTimeGMT"] as! String
        }
        if dict.keys.contains("OrderConfigJson") && dict["OrderConfigJson"] != nil {
            self.orderConfigJson = dict["OrderConfigJson"] as! String
        }
        if dict.keys.contains("OriginatorId") && dict["OriginatorId"] != nil {
            self.originatorId = dict["OriginatorId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchCondition") && dict["SearchCondition"] != nil {
            self.searchCondition = dict["SearchCondition"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class SearchFormDataSecondGenerationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ModifyUser : Tea.TeaModel {
            public class Name : Tea.TeaModel {
                public var nameInChinese: String?

                public var nameInEnglish: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nameInChinese != nil {
                        map["NameInChinese"] = self.nameInChinese!
                    }
                    if self.nameInEnglish != nil {
                        map["NameInEnglish"] = self.nameInEnglish!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NameInChinese") && dict["NameInChinese"] != nil {
                        self.nameInChinese = dict["NameInChinese"] as! String
                    }
                    if dict.keys.contains("NameInEnglish") && dict["NameInEnglish"] != nil {
                        self.nameInEnglish = dict["NameInEnglish"] as! String
                    }
                }
            }
            public var name: SearchFormDataSecondGenerationResponseBody.Data.ModifyUser.Name?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.name?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name?.toMap()
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    var model = SearchFormDataSecondGenerationResponseBody.Data.ModifyUser.Name()
                    model.fromMap(dict["Name"] as! [String: Any])
                    self.name = model
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public class Originator : Tea.TeaModel {
            public class Name : Tea.TeaModel {
                public var nameInChinese: String?

                public var nameInEnglish: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nameInChinese != nil {
                        map["NameInChinese"] = self.nameInChinese!
                    }
                    if self.nameInEnglish != nil {
                        map["NameInEnglish"] = self.nameInEnglish!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NameInChinese") && dict["NameInChinese"] != nil {
                        self.nameInChinese = dict["NameInChinese"] as! String
                    }
                    if dict.keys.contains("NameInEnglish") && dict["NameInEnglish"] != nil {
                        self.nameInEnglish = dict["NameInEnglish"] as! String
                    }
                }
            }
            public var name: SearchFormDataSecondGenerationResponseBody.Data.Originator.Name?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.name?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name?.toMap()
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    var model = SearchFormDataSecondGenerationResponseBody.Data.Originator.Name()
                    model.fromMap(dict["Name"] as! [String: Any])
                    self.name = model
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var createTimeGMT: String?

        public var creatorUserId: String?

        public var formData: [String: Any]?

        public var formInstanceId: String?

        public var formUuid: String?

        public var id: Int64?

        public var instanceValue: String?

        public var modifiedTimeGMT: String?

        public var modifier: String?

        public var modifyUser: SearchFormDataSecondGenerationResponseBody.Data.ModifyUser?

        public var originator: SearchFormDataSecondGenerationResponseBody.Data.Originator?

        public var sequence: String?

        public var serialNumber: String?

        public var title: String?

        public var version: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.modifyUser?.validate()
            try self.originator?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTimeGMT != nil {
                map["CreateTimeGMT"] = self.createTimeGMT!
            }
            if self.creatorUserId != nil {
                map["CreatorUserId"] = self.creatorUserId!
            }
            if self.formData != nil {
                map["FormData"] = self.formData!
            }
            if self.formInstanceId != nil {
                map["FormInstanceId"] = self.formInstanceId!
            }
            if self.formUuid != nil {
                map["FormUuid"] = self.formUuid!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.instanceValue != nil {
                map["InstanceValue"] = self.instanceValue!
            }
            if self.modifiedTimeGMT != nil {
                map["ModifiedTimeGMT"] = self.modifiedTimeGMT!
            }
            if self.modifier != nil {
                map["Modifier"] = self.modifier!
            }
            if self.modifyUser != nil {
                map["ModifyUser"] = self.modifyUser?.toMap()
            }
            if self.originator != nil {
                map["Originator"] = self.originator?.toMap()
            }
            if self.sequence != nil {
                map["Sequence"] = self.sequence!
            }
            if self.serialNumber != nil {
                map["SerialNumber"] = self.serialNumber!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTimeGMT") && dict["CreateTimeGMT"] != nil {
                self.createTimeGMT = dict["CreateTimeGMT"] as! String
            }
            if dict.keys.contains("CreatorUserId") && dict["CreatorUserId"] != nil {
                self.creatorUserId = dict["CreatorUserId"] as! String
            }
            if dict.keys.contains("FormData") && dict["FormData"] != nil {
                self.formData = dict["FormData"] as! [String: Any]
            }
            if dict.keys.contains("FormInstanceId") && dict["FormInstanceId"] != nil {
                self.formInstanceId = dict["FormInstanceId"] as! String
            }
            if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
                self.formUuid = dict["FormUuid"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("InstanceValue") && dict["InstanceValue"] != nil {
                self.instanceValue = dict["InstanceValue"] as! String
            }
            if dict.keys.contains("ModifiedTimeGMT") && dict["ModifiedTimeGMT"] != nil {
                self.modifiedTimeGMT = dict["ModifiedTimeGMT"] as! String
            }
            if dict.keys.contains("Modifier") && dict["Modifier"] != nil {
                self.modifier = dict["Modifier"] as! String
            }
            if dict.keys.contains("ModifyUser") && dict["ModifyUser"] != nil {
                var model = SearchFormDataSecondGenerationResponseBody.Data.ModifyUser()
                model.fromMap(dict["ModifyUser"] as! [String: Any])
                self.modifyUser = model
            }
            if dict.keys.contains("Originator") && dict["Originator"] != nil {
                var model = SearchFormDataSecondGenerationResponseBody.Data.Originator()
                model.fromMap(dict["Originator"] as! [String: Any])
                self.originator = model
            }
            if dict.keys.contains("Sequence") && dict["Sequence"] != nil {
                self.sequence = dict["Sequence"] as! String
            }
            if dict.keys.contains("SerialNumber") && dict["SerialNumber"] != nil {
                self.serialNumber = dict["SerialNumber"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("Version") && dict["Version"] != nil {
                self.version = dict["Version"] as! Int64
            }
        }
    }
    public var data: [SearchFormDataSecondGenerationResponseBody.Data]?

    public var pageNumber: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [SearchFormDataSecondGenerationResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = SearchFormDataSecondGenerationResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class SearchFormDataSecondGenerationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchFormDataSecondGenerationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SearchFormDataSecondGenerationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchFormDataSecondGenerationNoTableFieldHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SearchFormDataSecondGenerationNoTableFieldHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = SearchFormDataSecondGenerationNoTableFieldHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SearchFormDataSecondGenerationNoTableFieldShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SearchFormDataSecondGenerationNoTableFieldRequest : Tea.TeaModel {
    public var appType: String?

    public var createFromTimeGMT: String?

    public var createToTimeGMT: String?

    public var formUuid: String?

    public var modifiedFromTimeGMT: String?

    public var modifiedToTimeGMT: String?

    public var orderConfigJson: String?

    public var originatorId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchCondition: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.createFromTimeGMT != nil {
            map["CreateFromTimeGMT"] = self.createFromTimeGMT!
        }
        if self.createToTimeGMT != nil {
            map["CreateToTimeGMT"] = self.createToTimeGMT!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.modifiedFromTimeGMT != nil {
            map["ModifiedFromTimeGMT"] = self.modifiedFromTimeGMT!
        }
        if self.modifiedToTimeGMT != nil {
            map["ModifiedToTimeGMT"] = self.modifiedToTimeGMT!
        }
        if self.orderConfigJson != nil {
            map["OrderConfigJson"] = self.orderConfigJson!
        }
        if self.originatorId != nil {
            map["OriginatorId"] = self.originatorId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchCondition != nil {
            map["SearchCondition"] = self.searchCondition!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("CreateFromTimeGMT") && dict["CreateFromTimeGMT"] != nil {
            self.createFromTimeGMT = dict["CreateFromTimeGMT"] as! String
        }
        if dict.keys.contains("CreateToTimeGMT") && dict["CreateToTimeGMT"] != nil {
            self.createToTimeGMT = dict["CreateToTimeGMT"] as! String
        }
        if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("ModifiedFromTimeGMT") && dict["ModifiedFromTimeGMT"] != nil {
            self.modifiedFromTimeGMT = dict["ModifiedFromTimeGMT"] as! String
        }
        if dict.keys.contains("ModifiedToTimeGMT") && dict["ModifiedToTimeGMT"] != nil {
            self.modifiedToTimeGMT = dict["ModifiedToTimeGMT"] as! String
        }
        if dict.keys.contains("OrderConfigJson") && dict["OrderConfigJson"] != nil {
            self.orderConfigJson = dict["OrderConfigJson"] as! String
        }
        if dict.keys.contains("OriginatorId") && dict["OriginatorId"] != nil {
            self.originatorId = dict["OriginatorId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchCondition") && dict["SearchCondition"] != nil {
            self.searchCondition = dict["SearchCondition"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class SearchFormDataSecondGenerationNoTableFieldResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ModifyUser : Tea.TeaModel {
            public class Name : Tea.TeaModel {
                public var nameInChinese: String?

                public var nameInEnglish: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nameInChinese != nil {
                        map["NameInChinese"] = self.nameInChinese!
                    }
                    if self.nameInEnglish != nil {
                        map["NameInEnglish"] = self.nameInEnglish!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NameInChinese") && dict["NameInChinese"] != nil {
                        self.nameInChinese = dict["NameInChinese"] as! String
                    }
                    if dict.keys.contains("NameInEnglish") && dict["NameInEnglish"] != nil {
                        self.nameInEnglish = dict["NameInEnglish"] as! String
                    }
                }
            }
            public var name: SearchFormDataSecondGenerationNoTableFieldResponseBody.Data.ModifyUser.Name?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.name?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name?.toMap()
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    var model = SearchFormDataSecondGenerationNoTableFieldResponseBody.Data.ModifyUser.Name()
                    model.fromMap(dict["Name"] as! [String: Any])
                    self.name = model
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public class Originator : Tea.TeaModel {
            public class Name : Tea.TeaModel {
                public var nameInChinese: String?

                public var nameInEnglish: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nameInChinese != nil {
                        map["NameInChinese"] = self.nameInChinese!
                    }
                    if self.nameInEnglish != nil {
                        map["NameInEnglish"] = self.nameInEnglish!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NameInChinese") && dict["NameInChinese"] != nil {
                        self.nameInChinese = dict["NameInChinese"] as! String
                    }
                    if dict.keys.contains("NameInEnglish") && dict["NameInEnglish"] != nil {
                        self.nameInEnglish = dict["NameInEnglish"] as! String
                    }
                }
            }
            public var name: SearchFormDataSecondGenerationNoTableFieldResponseBody.Data.Originator.Name?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.name?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name?.toMap()
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    var model = SearchFormDataSecondGenerationNoTableFieldResponseBody.Data.Originator.Name()
                    model.fromMap(dict["Name"] as! [String: Any])
                    self.name = model
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var createTimeGMT: String?

        public var creatorUserId: String?

        public var formData: [String: Any]?

        public var formInstanceId: String?

        public var formUuid: String?

        public var id: Int64?

        public var instanceValue: String?

        public var modifiedTimeGMT: String?

        public var modifier: String?

        public var modifyUser: SearchFormDataSecondGenerationNoTableFieldResponseBody.Data.ModifyUser?

        public var originator: SearchFormDataSecondGenerationNoTableFieldResponseBody.Data.Originator?

        public var sequence: String?

        public var serialNumber: String?

        public var title: String?

        public var version: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.modifyUser?.validate()
            try self.originator?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTimeGMT != nil {
                map["CreateTimeGMT"] = self.createTimeGMT!
            }
            if self.creatorUserId != nil {
                map["CreatorUserId"] = self.creatorUserId!
            }
            if self.formData != nil {
                map["FormData"] = self.formData!
            }
            if self.formInstanceId != nil {
                map["FormInstanceId"] = self.formInstanceId!
            }
            if self.formUuid != nil {
                map["FormUuid"] = self.formUuid!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.instanceValue != nil {
                map["InstanceValue"] = self.instanceValue!
            }
            if self.modifiedTimeGMT != nil {
                map["ModifiedTimeGMT"] = self.modifiedTimeGMT!
            }
            if self.modifier != nil {
                map["Modifier"] = self.modifier!
            }
            if self.modifyUser != nil {
                map["ModifyUser"] = self.modifyUser?.toMap()
            }
            if self.originator != nil {
                map["Originator"] = self.originator?.toMap()
            }
            if self.sequence != nil {
                map["Sequence"] = self.sequence!
            }
            if self.serialNumber != nil {
                map["SerialNumber"] = self.serialNumber!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTimeGMT") && dict["CreateTimeGMT"] != nil {
                self.createTimeGMT = dict["CreateTimeGMT"] as! String
            }
            if dict.keys.contains("CreatorUserId") && dict["CreatorUserId"] != nil {
                self.creatorUserId = dict["CreatorUserId"] as! String
            }
            if dict.keys.contains("FormData") && dict["FormData"] != nil {
                self.formData = dict["FormData"] as! [String: Any]
            }
            if dict.keys.contains("FormInstanceId") && dict["FormInstanceId"] != nil {
                self.formInstanceId = dict["FormInstanceId"] as! String
            }
            if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
                self.formUuid = dict["FormUuid"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("InstanceValue") && dict["InstanceValue"] != nil {
                self.instanceValue = dict["InstanceValue"] as! String
            }
            if dict.keys.contains("ModifiedTimeGMT") && dict["ModifiedTimeGMT"] != nil {
                self.modifiedTimeGMT = dict["ModifiedTimeGMT"] as! String
            }
            if dict.keys.contains("Modifier") && dict["Modifier"] != nil {
                self.modifier = dict["Modifier"] as! String
            }
            if dict.keys.contains("ModifyUser") && dict["ModifyUser"] != nil {
                var model = SearchFormDataSecondGenerationNoTableFieldResponseBody.Data.ModifyUser()
                model.fromMap(dict["ModifyUser"] as! [String: Any])
                self.modifyUser = model
            }
            if dict.keys.contains("Originator") && dict["Originator"] != nil {
                var model = SearchFormDataSecondGenerationNoTableFieldResponseBody.Data.Originator()
                model.fromMap(dict["Originator"] as! [String: Any])
                self.originator = model
            }
            if dict.keys.contains("Sequence") && dict["Sequence"] != nil {
                self.sequence = dict["Sequence"] as! String
            }
            if dict.keys.contains("SerialNumber") && dict["SerialNumber"] != nil {
                self.serialNumber = dict["SerialNumber"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("Version") && dict["Version"] != nil {
                self.version = dict["Version"] as! Int64
            }
        }
    }
    public var data: [SearchFormDataSecondGenerationNoTableFieldResponseBody.Data]?

    public var pageNumber: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [SearchFormDataSecondGenerationNoTableFieldResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = SearchFormDataSecondGenerationNoTableFieldResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int64
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class SearchFormDataSecondGenerationNoTableFieldResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchFormDataSecondGenerationNoTableFieldResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SearchFormDataSecondGenerationNoTableFieldResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchFormDatasHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SearchFormDatasHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = SearchFormDatasHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SearchFormDatasShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SearchFormDatasRequest : Tea.TeaModel {
    public var appType: String?

    public var createFromTimeGMT: String?

    public var createToTimeGMT: String?

    public var currentPage: Int32?

    public var dynamicOrder: String?

    public var formUuid: String?

    public var language: String?

    public var modifiedFromTimeGMT: String?

    public var modifiedToTimeGMT: String?

    public var originatorId: String?

    public var pageSize: Int32?

    public var searchFieldJson: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.createFromTimeGMT != nil {
            map["CreateFromTimeGMT"] = self.createFromTimeGMT!
        }
        if self.createToTimeGMT != nil {
            map["CreateToTimeGMT"] = self.createToTimeGMT!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.dynamicOrder != nil {
            map["DynamicOrder"] = self.dynamicOrder!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.modifiedFromTimeGMT != nil {
            map["ModifiedFromTimeGMT"] = self.modifiedFromTimeGMT!
        }
        if self.modifiedToTimeGMT != nil {
            map["ModifiedToTimeGMT"] = self.modifiedToTimeGMT!
        }
        if self.originatorId != nil {
            map["OriginatorId"] = self.originatorId!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchFieldJson != nil {
            map["SearchFieldJson"] = self.searchFieldJson!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("CreateFromTimeGMT") && dict["CreateFromTimeGMT"] != nil {
            self.createFromTimeGMT = dict["CreateFromTimeGMT"] as! String
        }
        if dict.keys.contains("CreateToTimeGMT") && dict["CreateToTimeGMT"] != nil {
            self.createToTimeGMT = dict["CreateToTimeGMT"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("DynamicOrder") && dict["DynamicOrder"] != nil {
            self.dynamicOrder = dict["DynamicOrder"] as! String
        }
        if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("ModifiedFromTimeGMT") && dict["ModifiedFromTimeGMT"] != nil {
            self.modifiedFromTimeGMT = dict["ModifiedFromTimeGMT"] as! String
        }
        if dict.keys.contains("ModifiedToTimeGMT") && dict["ModifiedToTimeGMT"] != nil {
            self.modifiedToTimeGMT = dict["ModifiedToTimeGMT"] as! String
        }
        if dict.keys.contains("OriginatorId") && dict["OriginatorId"] != nil {
            self.originatorId = dict["OriginatorId"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchFieldJson") && dict["SearchFieldJson"] != nil {
            self.searchFieldJson = dict["SearchFieldJson"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class SearchFormDatasResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ModifyUser : Tea.TeaModel {
            public class UserName : Tea.TeaModel {
                public var nameInChinese: String?

                public var nameInEnglish: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nameInChinese != nil {
                        map["NameInChinese"] = self.nameInChinese!
                    }
                    if self.nameInEnglish != nil {
                        map["NameInEnglish"] = self.nameInEnglish!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NameInChinese") && dict["NameInChinese"] != nil {
                        self.nameInChinese = dict["NameInChinese"] as! String
                    }
                    if dict.keys.contains("NameInEnglish") && dict["NameInEnglish"] != nil {
                        self.nameInEnglish = dict["NameInEnglish"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var userId: String?

            public var userName: SearchFormDatasResponseBody.Data.ModifyUser.UserName?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.userName?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserName") && dict["UserName"] != nil {
                    var model = SearchFormDatasResponseBody.Data.ModifyUser.UserName()
                    model.fromMap(dict["UserName"] as! [String: Any])
                    self.userName = model
                }
            }
        }
        public class Originator : Tea.TeaModel {
            public class UserName : Tea.TeaModel {
                public var nameInChinese: String?

                public var nameInEnglish: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nameInChinese != nil {
                        map["NameInChinese"] = self.nameInChinese!
                    }
                    if self.nameInEnglish != nil {
                        map["NameInEnglish"] = self.nameInEnglish!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NameInChinese") && dict["NameInChinese"] != nil {
                        self.nameInChinese = dict["NameInChinese"] as! String
                    }
                    if dict.keys.contains("NameInEnglish") && dict["NameInEnglish"] != nil {
                        self.nameInEnglish = dict["NameInEnglish"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var userId: String?

            public var userName: SearchFormDatasResponseBody.Data.Originator.UserName?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.userName?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserName") && dict["UserName"] != nil {
                    var model = SearchFormDatasResponseBody.Data.Originator.UserName()
                    model.fromMap(dict["UserName"] as! [String: Any])
                    self.userName = model
                }
            }
        }
        public var createdTimeGMT: String?

        public var creatorUserId: String?

        public var dataId: Int64?

        public var formData: [String: Any]?

        public var formInstanceId: String?

        public var formUuid: String?

        public var instanceValue: String?

        public var modelUuid: String?

        public var modifiedTimeGMT: String?

        public var modifierUserId: String?

        public var modifyUser: SearchFormDatasResponseBody.Data.ModifyUser?

        public var originator: SearchFormDatasResponseBody.Data.Originator?

        public var sequence: String?

        public var serialNo: String?

        public var title: String?

        public var version: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.modifyUser?.validate()
            try self.originator?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdTimeGMT != nil {
                map["CreatedTimeGMT"] = self.createdTimeGMT!
            }
            if self.creatorUserId != nil {
                map["CreatorUserId"] = self.creatorUserId!
            }
            if self.dataId != nil {
                map["DataId"] = self.dataId!
            }
            if self.formData != nil {
                map["FormData"] = self.formData!
            }
            if self.formInstanceId != nil {
                map["FormInstanceId"] = self.formInstanceId!
            }
            if self.formUuid != nil {
                map["FormUuid"] = self.formUuid!
            }
            if self.instanceValue != nil {
                map["InstanceValue"] = self.instanceValue!
            }
            if self.modelUuid != nil {
                map["ModelUuid"] = self.modelUuid!
            }
            if self.modifiedTimeGMT != nil {
                map["ModifiedTimeGMT"] = self.modifiedTimeGMT!
            }
            if self.modifierUserId != nil {
                map["ModifierUserId"] = self.modifierUserId!
            }
            if self.modifyUser != nil {
                map["ModifyUser"] = self.modifyUser?.toMap()
            }
            if self.originator != nil {
                map["Originator"] = self.originator?.toMap()
            }
            if self.sequence != nil {
                map["Sequence"] = self.sequence!
            }
            if self.serialNo != nil {
                map["SerialNo"] = self.serialNo!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreatedTimeGMT") && dict["CreatedTimeGMT"] != nil {
                self.createdTimeGMT = dict["CreatedTimeGMT"] as! String
            }
            if dict.keys.contains("CreatorUserId") && dict["CreatorUserId"] != nil {
                self.creatorUserId = dict["CreatorUserId"] as! String
            }
            if dict.keys.contains("DataId") && dict["DataId"] != nil {
                self.dataId = dict["DataId"] as! Int64
            }
            if dict.keys.contains("FormData") && dict["FormData"] != nil {
                self.formData = dict["FormData"] as! [String: Any]
            }
            if dict.keys.contains("FormInstanceId") && dict["FormInstanceId"] != nil {
                self.formInstanceId = dict["FormInstanceId"] as! String
            }
            if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
                self.formUuid = dict["FormUuid"] as! String
            }
            if dict.keys.contains("InstanceValue") && dict["InstanceValue"] != nil {
                self.instanceValue = dict["InstanceValue"] as! String
            }
            if dict.keys.contains("ModelUuid") && dict["ModelUuid"] != nil {
                self.modelUuid = dict["ModelUuid"] as! String
            }
            if dict.keys.contains("ModifiedTimeGMT") && dict["ModifiedTimeGMT"] != nil {
                self.modifiedTimeGMT = dict["ModifiedTimeGMT"] as! String
            }
            if dict.keys.contains("ModifierUserId") && dict["ModifierUserId"] != nil {
                self.modifierUserId = dict["ModifierUserId"] as! String
            }
            if dict.keys.contains("ModifyUser") && dict["ModifyUser"] != nil {
                var model = SearchFormDatasResponseBody.Data.ModifyUser()
                model.fromMap(dict["ModifyUser"] as! [String: Any])
                self.modifyUser = model
            }
            if dict.keys.contains("Originator") && dict["Originator"] != nil {
                var model = SearchFormDatasResponseBody.Data.Originator()
                model.fromMap(dict["Originator"] as! [String: Any])
                self.originator = model
            }
            if dict.keys.contains("Sequence") && dict["Sequence"] != nil {
                self.sequence = dict["Sequence"] as! String
            }
            if dict.keys.contains("SerialNo") && dict["SerialNo"] != nil {
                self.serialNo = dict["SerialNo"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("Version") && dict["Version"] != nil {
                self.version = dict["Version"] as! Int64
            }
        }
    }
    public var currentPage: Int32?

    public var data: [SearchFormDatasResponseBody.Data]?

    public var requestId: String?

    public var totalCount: Int32?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["currentPage"] = self.currentPage!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("currentPage") && dict["currentPage"] != nil {
            self.currentPage = dict["currentPage"] as! Int32
        }
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [SearchFormDatasResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = SearchFormDatasResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int32
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class SearchFormDatasResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchFormDatasResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SearchFormDatasResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendBannerHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SendBannerHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = SendBannerHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SendBannerShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SendBannerRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var content: [String: Any]?

    public var endTime: Int64?

    public var startTime: Int64?

    public var tenantContext: SendBannerRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.content = dict["Content"] as! [String: Any]
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = SendBannerRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class SendBannerShrinkRequest : Tea.TeaModel {
    public var contentShrink: String?

    public var endTime: Int64?

    public var startTime: Int64?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contentShrink != nil {
            map["Content"] = self.contentShrink!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.contentShrink = dict["Content"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class SendBannerResponseBody : Tea.TeaModel {
    public var arguments: [Any]?

    public var requestId: String?

    public var success: Bool?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.arguments != nil {
            map["arguments"] = self.arguments!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("arguments") && dict["arguments"] != nil {
            self.arguments = dict["arguments"] as! [Any]
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class SendBannerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendBannerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SendBannerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendPopupHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SendPopupHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = SendPopupHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SendPopupShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SendPopupRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var content: [String: Any]?

    public var endTime: Int64?

    public var startTime: Int64?

    public var tenantContext: SendPopupRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.content = dict["Content"] as! [String: Any]
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = SendPopupRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class SendPopupShrinkRequest : Tea.TeaModel {
    public var contentShrink: String?

    public var endTime: Int64?

    public var startTime: Int64?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contentShrink != nil {
            map["Content"] = self.contentShrink!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.contentShrink = dict["Content"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class SendPopupResponseBody : Tea.TeaModel {
    public var arguments: [Any]?

    public var requestId: String?

    public var success: Bool?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.arguments != nil {
            map["arguments"] = self.arguments!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("arguments") && dict["arguments"] != nil {
            self.arguments = dict["arguments"] as! [Any]
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class SendPopupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendPopupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SendPopupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendSearchShadeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SendSearchShadeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = SendSearchShadeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SendSearchShadeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SendSearchShadeRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var content: [String: Any]?

    public var endTime: Int64?

    public var startTime: Int64?

    public var tenantContext: SendSearchShadeRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.content = dict["Content"] as! [String: Any]
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = SendSearchShadeRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class SendSearchShadeShrinkRequest : Tea.TeaModel {
    public var contentShrink: String?

    public var endTime: Int64?

    public var startTime: Int64?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contentShrink != nil {
            map["Content"] = self.contentShrink!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.contentShrink = dict["Content"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class SendSearchShadeResponseBody : Tea.TeaModel {
    public var arguments: [Any]?

    public var requestId: String?

    public var success: Bool?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.arguments != nil {
            map["arguments"] = self.arguments!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("arguments") && dict["arguments"] != nil {
            self.arguments = dict["arguments"] as! [Any]
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class SendSearchShadeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendSearchShadeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SendSearchShadeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetColumnsVisibilityHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SetColumnsVisibilityHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = SetColumnsVisibilityHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SetColumnsVisibilityShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SetColumnsVisibilityRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var column: Int64?

    public var columnCount: Int64?

    public var sheetId: String?

    public var tenantContext: SetColumnsVisibilityRequest.TenantContext?

    public var visibility: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.column != nil {
            map["Column"] = self.column!
        }
        if self.columnCount != nil {
            map["ColumnCount"] = self.columnCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Column") && dict["Column"] != nil {
            self.column = dict["Column"] as! Int64
        }
        if dict.keys.contains("ColumnCount") && dict["ColumnCount"] != nil {
            self.columnCount = dict["ColumnCount"] as! Int64
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = SetColumnsVisibilityRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("Visibility") && dict["Visibility"] != nil {
            self.visibility = dict["Visibility"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class SetColumnsVisibilityShrinkRequest : Tea.TeaModel {
    public var column: Int64?

    public var columnCount: Int64?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var visibility: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.column != nil {
            map["Column"] = self.column!
        }
        if self.columnCount != nil {
            map["ColumnCount"] = self.columnCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Column") && dict["Column"] != nil {
            self.column = dict["Column"] as! Int64
        }
        if dict.keys.contains("ColumnCount") && dict["ColumnCount"] != nil {
            self.columnCount = dict["ColumnCount"] as! Int64
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("Visibility") && dict["Visibility"] != nil {
            self.visibility = dict["Visibility"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class SetColumnsVisibilityResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class SetColumnsVisibilityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetColumnsVisibilityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetColumnsVisibilityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetRowsVisibilityHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SetRowsVisibilityHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = SetRowsVisibilityHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SetRowsVisibilityShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SetRowsVisibilityRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var row: Int64?

    public var rowCount: Int64?

    public var sheetId: String?

    public var tenantContext: SetRowsVisibilityRequest.TenantContext?

    public var visibility: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.row != nil {
            map["Row"] = self.row!
        }
        if self.rowCount != nil {
            map["RowCount"] = self.rowCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Row") && dict["Row"] != nil {
            self.row = dict["Row"] as! Int64
        }
        if dict.keys.contains("RowCount") && dict["RowCount"] != nil {
            self.rowCount = dict["RowCount"] as! Int64
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = SetRowsVisibilityRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("Visibility") && dict["Visibility"] != nil {
            self.visibility = dict["Visibility"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class SetRowsVisibilityShrinkRequest : Tea.TeaModel {
    public var row: Int64?

    public var rowCount: Int64?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var visibility: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.row != nil {
            map["Row"] = self.row!
        }
        if self.rowCount != nil {
            map["RowCount"] = self.rowCount!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Row") && dict["Row"] != nil {
            self.row = dict["Row"] as! Int64
        }
        if dict.keys.contains("RowCount") && dict["RowCount"] != nil {
            self.rowCount = dict["RowCount"] as! Int64
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("Visibility") && dict["Visibility"] != nil {
            self.visibility = dict["Visibility"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class SetRowsVisibilityResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("id") && dict["id"] != nil {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class SetRowsVisibilityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetRowsVisibilityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetRowsVisibilityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SimpleListReportHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SimpleListReportHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = SimpleListReportHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SimpleListReportShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SimpleListReportRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var cursor: Int64?

    public var endTime: Int64?

    public var size: Int64?

    public var startTime: Int64?

    public var templateName: String?

    public var tenantContext: SimpleListReportRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cursor != nil {
            map["Cursor"] = self.cursor!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cursor") && dict["Cursor"] != nil {
            self.cursor = dict["Cursor"] as! Int64
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = SimpleListReportRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class SimpleListReportShrinkRequest : Tea.TeaModel {
    public var cursor: Int64?

    public var endTime: Int64?

    public var size: Int64?

    public var startTime: Int64?

    public var templateName: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cursor != nil {
            map["Cursor"] = self.cursor!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cursor") && dict["Cursor"] != nil {
            self.cursor = dict["Cursor"] as! Int64
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class SimpleListReportResponseBody : Tea.TeaModel {
    public class DataList : Tea.TeaModel {
        public var createTime: Int64?

        public var creatorId: String?

        public var creatorName: String?

        public var deptName: String?

        public var remark: String?

        public var reportId: String?

        public var templateName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.creatorName != nil {
                map["CreatorName"] = self.creatorName!
            }
            if self.deptName != nil {
                map["DeptName"] = self.deptName!
            }
            if self.remark != nil {
                map["Remark"] = self.remark!
            }
            if self.reportId != nil {
                map["ReportId"] = self.reportId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("CreatorId") && dict["CreatorId"] != nil {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("CreatorName") && dict["CreatorName"] != nil {
                self.creatorName = dict["CreatorName"] as! String
            }
            if dict.keys.contains("DeptName") && dict["DeptName"] != nil {
                self.deptName = dict["DeptName"] as! String
            }
            if dict.keys.contains("Remark") && dict["Remark"] != nil {
                self.remark = dict["Remark"] as! String
            }
            if dict.keys.contains("ReportId") && dict["ReportId"] != nil {
                self.reportId = dict["ReportId"] as! String
            }
            if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
                self.templateName = dict["TemplateName"] as! String
            }
        }
    }
    public var dataList: [SimpleListReportResponseBody.DataList]?

    public var hasMore: Bool?

    public var nextCursor: Int64?

    public var requestId: String?

    public var size: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataList != nil {
            var tmp : [Any] = []
            for k in self.dataList! {
                tmp.append(k.toMap())
            }
            map["dataList"] = tmp
        }
        if self.hasMore != nil {
            map["hasMore"] = self.hasMore!
        }
        if self.nextCursor != nil {
            map["nextCursor"] = self.nextCursor!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("dataList") && dict["dataList"] != nil {
            var tmp : [SimpleListReportResponseBody.DataList] = []
            for v in dict["dataList"] as! [Any] {
                var model = SimpleListReportResponseBody.DataList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataList = tmp
        }
        if dict.keys.contains("hasMore") && dict["hasMore"] != nil {
            self.hasMore = dict["hasMore"] as! Bool
        }
        if dict.keys.contains("nextCursor") && dict["nextCursor"] != nil {
            self.nextCursor = dict["nextCursor"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("size") && dict["size"] != nil {
            self.size = dict["size"] as! Int64
        }
    }
}

public class SimpleListReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SimpleListReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SimpleListReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartCloudRecordHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: StartCloudRecordHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = StartCloudRecordHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class StartCloudRecordShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class StartCloudRecordRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var mode: String?

    public var smallWindowPosition: String?

    public var tenantContext: StartCloudRecordRequest.TenantContext?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        if self.smallWindowPosition != nil {
            map["SmallWindowPosition"] = self.smallWindowPosition!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Mode") && dict["Mode"] != nil {
            self.mode = dict["Mode"] as! String
        }
        if dict.keys.contains("SmallWindowPosition") && dict["SmallWindowPosition"] != nil {
            self.smallWindowPosition = dict["SmallWindowPosition"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = StartCloudRecordRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("conferenceId") && dict["conferenceId"] != nil {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class StartCloudRecordShrinkRequest : Tea.TeaModel {
    public var mode: String?

    public var smallWindowPosition: String?

    public var tenantContextShrink: String?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        if self.smallWindowPosition != nil {
            map["SmallWindowPosition"] = self.smallWindowPosition!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Mode") && dict["Mode"] != nil {
            self.mode = dict["Mode"] as! String
        }
        if dict.keys.contains("SmallWindowPosition") && dict["SmallWindowPosition"] != nil {
            self.smallWindowPosition = dict["SmallWindowPosition"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("conferenceId") && dict["conferenceId"] != nil {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class StartCloudRecordResponseBody : Tea.TeaModel {
    public var code: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") && dict["code"] != nil {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class StartCloudRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartCloudRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StartCloudRecordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartInstanceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: StartInstanceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = StartInstanceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class StartInstanceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class StartInstanceRequest : Tea.TeaModel {
    public var appType: String?

    public var departmentId: String?

    public var formDataJson: String?

    public var formUuid: String?

    public var language: String?

    public var processCode: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.departmentId != nil {
            map["DepartmentId"] = self.departmentId!
        }
        if self.formDataJson != nil {
            map["FormDataJson"] = self.formDataJson!
        }
        if self.formUuid != nil {
            map["FormUuid"] = self.formUuid!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.processCode != nil {
            map["ProcessCode"] = self.processCode!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("DepartmentId") && dict["DepartmentId"] != nil {
            self.departmentId = dict["DepartmentId"] as! String
        }
        if dict.keys.contains("FormDataJson") && dict["FormDataJson"] != nil {
            self.formDataJson = dict["FormDataJson"] as! String
        }
        if dict.keys.contains("FormUuid") && dict["FormUuid"] != nil {
            self.formUuid = dict["FormUuid"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("ProcessCode") && dict["ProcessCode"] != nil {
            self.processCode = dict["ProcessCode"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class StartInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! String
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class StartInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StartInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StatisticsListByTypeReportHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: StatisticsListByTypeReportHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = StatisticsListByTypeReportHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class StatisticsListByTypeReportShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class StatisticsListByTypeReportRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var offset: Int64?

    public var reportId: String?

    public var size: Int64?

    public var tenantContext: StatisticsListByTypeReportRequest.TenantContext?

    public var type: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Offset") && dict["Offset"] != nil {
            self.offset = dict["Offset"] as! Int64
        }
        if dict.keys.contains("ReportId") && dict["ReportId"] != nil {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = StatisticsListByTypeReportRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int64
        }
    }
}

public class StatisticsListByTypeReportShrinkRequest : Tea.TeaModel {
    public var offset: Int64?

    public var reportId: String?

    public var size: Int64?

    public var tenantContextShrink: String?

    public var type: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Offset") && dict["Offset"] != nil {
            self.offset = dict["Offset"] as! Int64
        }
        if dict.keys.contains("ReportId") && dict["ReportId"] != nil {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int64
        }
    }
}

public class StatisticsListByTypeReportResponseBody : Tea.TeaModel {
    public var hasMore: Bool?

    public var nextCursor: Int64?

    public var requestId: String?

    public var useridList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hasMore != nil {
            map["hasMore"] = self.hasMore!
        }
        if self.nextCursor != nil {
            map["nextCursor"] = self.nextCursor!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.useridList != nil {
            map["useridList"] = self.useridList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("hasMore") && dict["hasMore"] != nil {
            self.hasMore = dict["hasMore"] as! Bool
        }
        if dict.keys.contains("nextCursor") && dict["nextCursor"] != nil {
            self.nextCursor = dict["nextCursor"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("useridList") && dict["useridList"] != nil {
            self.useridList = dict["useridList"] as! [String]
        }
    }
}

public class StatisticsListByTypeReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StatisticsListByTypeReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StatisticsListByTypeReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StatisticsReportHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: StatisticsReportHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = StatisticsReportHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class StatisticsReportShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class StatisticsReportRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var reportId: String?

    public var tenantContext: StatisticsReportRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ReportId") && dict["ReportId"] != nil {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = StatisticsReportRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class StatisticsReportShrinkRequest : Tea.TeaModel {
    public var reportId: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ReportId") && dict["ReportId"] != nil {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class StatisticsReportResponseBody : Tea.TeaModel {
    public var commentNum: Int64?

    public var commentUserNum: Int64?

    public var likeNum: Int64?

    public var readNum: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commentNum != nil {
            map["commentNum"] = self.commentNum!
        }
        if self.commentUserNum != nil {
            map["commentUserNum"] = self.commentUserNum!
        }
        if self.likeNum != nil {
            map["likeNum"] = self.likeNum!
        }
        if self.readNum != nil {
            map["readNum"] = self.readNum!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commentNum") && dict["commentNum"] != nil {
            self.commentNum = dict["commentNum"] as! Int64
        }
        if dict.keys.contains("commentUserNum") && dict["commentUserNum"] != nil {
            self.commentUserNum = dict["commentUserNum"] as! Int64
        }
        if dict.keys.contains("likeNum") && dict["likeNum"] != nil {
            self.likeNum = dict["likeNum"] as! Int64
        }
        if dict.keys.contains("readNum") && dict["readNum"] != nil {
            self.readNum = dict["readNum"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class StatisticsReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StatisticsReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StatisticsReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopCloudRecordHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: StopCloudRecordHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = StopCloudRecordHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class StopCloudRecordShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class StopCloudRecordRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: StopCloudRecordRequest.TenantContext?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = StopCloudRecordRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("conferenceId") && dict["conferenceId"] != nil {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class StopCloudRecordShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var conferenceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.conferenceId != nil {
            map["conferenceId"] = self.conferenceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("conferenceId") && dict["conferenceId"] != nil {
            self.conferenceId = dict["conferenceId"] as! String
        }
    }
}

public class StopCloudRecordResponseBody : Tea.TeaModel {
    public var code: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") && dict["code"] != nil {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class StopCloudRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopCloudRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StopCloudRecordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubscribeCalendarHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: SubscribeCalendarHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = SubscribeCalendarHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class SubscribeCalendarShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class SubscribeCalendarRequest : Tea.TeaModel {
    public var calendarId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
    }
}

public class SubscribeCalendarResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class SubscribeCalendarResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubscribeCalendarResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubscribeCalendarResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TerminateInstanceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: TerminateInstanceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = TerminateInstanceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class TerminateInstanceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class TerminateInstanceRequest : Tea.TeaModel {
    public var appType: String?

    public var language: String?

    public var processInstanceId: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.processInstanceId != nil {
            map["ProcessInstanceId"] = self.processInstanceId!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("ProcessInstanceId") && dict["ProcessInstanceId"] != nil {
            self.processInstanceId = dict["ProcessInstanceId"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class TerminateInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class TerminateInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TerminateInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = TerminateInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnsubscribeCalendarHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UnsubscribeCalendarHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = UnsubscribeCalendarHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UnsubscribeCalendarShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UnsubscribeCalendarRequest : Tea.TeaModel {
    public var calendarId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
    }
}

public class UnsubscribeCalendarResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! Bool
        }
    }
}

public class UnsubscribeCalendarResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnsubscribeCalendarResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UnsubscribeCalendarResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateFormDataHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateFormDataHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = UpdateFormDataHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateFormDataShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateFormDataRequest : Tea.TeaModel {
    public var appType: String?

    public var formInstanceId: String?

    public var language: String?

    public var systemToken: String?

    public var updateFormDataJson: String?

    public var useLatestVersion: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.formInstanceId != nil {
            map["FormInstanceId"] = self.formInstanceId!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.updateFormDataJson != nil {
            map["UpdateFormDataJson"] = self.updateFormDataJson!
        }
        if self.useLatestVersion != nil {
            map["UseLatestVersion"] = self.useLatestVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("FormInstanceId") && dict["FormInstanceId"] != nil {
            self.formInstanceId = dict["FormInstanceId"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("UpdateFormDataJson") && dict["UpdateFormDataJson"] != nil {
            self.updateFormDataJson = dict["UpdateFormDataJson"] as! String
        }
        if dict.keys.contains("UseLatestVersion") && dict["UseLatestVersion"] != nil {
            self.useLatestVersion = dict["UseLatestVersion"] as! Bool
        }
    }
}

public class UpdateFormDataResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class UpdateFormDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateFormDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateFormDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateInstanceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateInstanceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = UpdateInstanceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateInstanceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateInstanceRequest : Tea.TeaModel {
    public var appType: String?

    public var language: String?

    public var processInstanceId: String?

    public var systemToken: String?

    public var updateFormDataJson: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.processInstanceId != nil {
            map["ProcessInstanceId"] = self.processInstanceId!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        if self.updateFormDataJson != nil {
            map["UpdateFormDataJson"] = self.updateFormDataJson!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("ProcessInstanceId") && dict["ProcessInstanceId"] != nil {
            self.processInstanceId = dict["ProcessInstanceId"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
        if dict.keys.contains("UpdateFormDataJson") && dict["UpdateFormDataJson"] != nil {
            self.updateFormDataJson = dict["UpdateFormDataJson"] as! String
        }
    }
}

public class UpdateInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class UpdateInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateLiveHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = UpdateLiveHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateLiveShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateLiveRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var coverUrl: String?

    public var introduction: String?

    public var liveId: String?

    public var preEndTime: Int64?

    public var preStartTime: Int64?

    public var tenantContext: UpdateLiveRequest.TenantContext?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coverUrl != nil {
            map["CoverUrl"] = self.coverUrl!
        }
        if self.introduction != nil {
            map["Introduction"] = self.introduction!
        }
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.preEndTime != nil {
            map["PreEndTime"] = self.preEndTime!
        }
        if self.preStartTime != nil {
            map["PreStartTime"] = self.preStartTime!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CoverUrl") && dict["CoverUrl"] != nil {
            self.coverUrl = dict["CoverUrl"] as! String
        }
        if dict.keys.contains("Introduction") && dict["Introduction"] != nil {
            self.introduction = dict["Introduction"] as! String
        }
        if dict.keys.contains("LiveId") && dict["LiveId"] != nil {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("PreEndTime") && dict["PreEndTime"] != nil {
            self.preEndTime = dict["PreEndTime"] as! Int64
        }
        if dict.keys.contains("PreStartTime") && dict["PreStartTime"] != nil {
            self.preStartTime = dict["PreStartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = UpdateLiveRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class UpdateLiveShrinkRequest : Tea.TeaModel {
    public var coverUrl: String?

    public var introduction: String?

    public var liveId: String?

    public var preEndTime: Int64?

    public var preStartTime: Int64?

    public var tenantContextShrink: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coverUrl != nil {
            map["CoverUrl"] = self.coverUrl!
        }
        if self.introduction != nil {
            map["Introduction"] = self.introduction!
        }
        if self.liveId != nil {
            map["LiveId"] = self.liveId!
        }
        if self.preEndTime != nil {
            map["PreEndTime"] = self.preEndTime!
        }
        if self.preStartTime != nil {
            map["PreStartTime"] = self.preStartTime!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CoverUrl") && dict["CoverUrl"] != nil {
            self.coverUrl = dict["CoverUrl"] as! String
        }
        if dict.keys.contains("Introduction") && dict["Introduction"] != nil {
            self.introduction = dict["Introduction"] as! String
        }
        if dict.keys.contains("LiveId") && dict["LiveId"] != nil {
            self.liveId = dict["LiveId"] as! String
        }
        if dict.keys.contains("PreEndTime") && dict["PreEndTime"] != nil {
            self.preEndTime = dict["PreEndTime"] as! Int64
        }
        if dict.keys.contains("PreStartTime") && dict["PreStartTime"] != nil {
            self.preStartTime = dict["PreStartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class UpdateLiveResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdateLiveResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateLiveResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMeetingRoomHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateMeetingRoomHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = UpdateMeetingRoomHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateMeetingRoomShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateMeetingRoomRequest : Tea.TeaModel {
    public class ReservationAuthority : Tea.TeaModel {
        public class AuthorizedMembers : Tea.TeaModel {
            public var memberId: String?

            public var memberName: String?

            public var memberType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.memberId != nil {
                    map["MemberId"] = self.memberId!
                }
                if self.memberName != nil {
                    map["MemberName"] = self.memberName!
                }
                if self.memberType != nil {
                    map["MemberType"] = self.memberType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MemberId") && dict["MemberId"] != nil {
                    self.memberId = dict["MemberId"] as! String
                }
                if dict.keys.contains("MemberName") && dict["MemberName"] != nil {
                    self.memberName = dict["MemberName"] as! String
                }
                if dict.keys.contains("MemberType") && dict["MemberType"] != nil {
                    self.memberType = dict["MemberType"] as! String
                }
            }
        }
        public var authorizedMembers: [UpdateMeetingRoomRequest.ReservationAuthority.AuthorizedMembers]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authorizedMembers != nil {
                var tmp : [Any] = []
                for k in self.authorizedMembers! {
                    tmp.append(k.toMap())
                }
                map["AuthorizedMembers"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthorizedMembers") && dict["AuthorizedMembers"] != nil {
                var tmp : [UpdateMeetingRoomRequest.ReservationAuthority.AuthorizedMembers] = []
                for v in dict["AuthorizedMembers"] as! [Any] {
                    var model = UpdateMeetingRoomRequest.ReservationAuthority.AuthorizedMembers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.authorizedMembers = tmp
            }
        }
    }
    public class RoomLocation : Tea.TeaModel {
        public var desc: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.desc != nil {
                map["Desc"] = self.desc!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Desc") && dict["Desc"] != nil {
                self.desc = dict["Desc"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var enableCycleReservation: Bool?

    public var groupId: Int64?

    public var isvRoomId: String?

    public var reservationAuthority: UpdateMeetingRoomRequest.ReservationAuthority?

    public var roomCapacity: Int32?

    public var roomId: String?

    public var roomLabelIds: [Int64]?

    public var roomLocation: UpdateMeetingRoomRequest.RoomLocation?

    public var roomName: String?

    public var roomPicture: String?

    public var roomStatus: Int32?

    public var tenantContext: UpdateMeetingRoomRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.reservationAuthority?.validate()
        try self.roomLocation?.validate()
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableCycleReservation != nil {
            map["EnableCycleReservation"] = self.enableCycleReservation!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.isvRoomId != nil {
            map["IsvRoomId"] = self.isvRoomId!
        }
        if self.reservationAuthority != nil {
            map["ReservationAuthority"] = self.reservationAuthority?.toMap()
        }
        if self.roomCapacity != nil {
            map["RoomCapacity"] = self.roomCapacity!
        }
        if self.roomId != nil {
            map["RoomId"] = self.roomId!
        }
        if self.roomLabelIds != nil {
            map["RoomLabelIds"] = self.roomLabelIds!
        }
        if self.roomLocation != nil {
            map["RoomLocation"] = self.roomLocation?.toMap()
        }
        if self.roomName != nil {
            map["RoomName"] = self.roomName!
        }
        if self.roomPicture != nil {
            map["RoomPicture"] = self.roomPicture!
        }
        if self.roomStatus != nil {
            map["RoomStatus"] = self.roomStatus!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnableCycleReservation") && dict["EnableCycleReservation"] != nil {
            self.enableCycleReservation = dict["EnableCycleReservation"] as! Bool
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("IsvRoomId") && dict["IsvRoomId"] != nil {
            self.isvRoomId = dict["IsvRoomId"] as! String
        }
        if dict.keys.contains("ReservationAuthority") && dict["ReservationAuthority"] != nil {
            var model = UpdateMeetingRoomRequest.ReservationAuthority()
            model.fromMap(dict["ReservationAuthority"] as! [String: Any])
            self.reservationAuthority = model
        }
        if dict.keys.contains("RoomCapacity") && dict["RoomCapacity"] != nil {
            self.roomCapacity = dict["RoomCapacity"] as! Int32
        }
        if dict.keys.contains("RoomId") && dict["RoomId"] != nil {
            self.roomId = dict["RoomId"] as! String
        }
        if dict.keys.contains("RoomLabelIds") && dict["RoomLabelIds"] != nil {
            self.roomLabelIds = dict["RoomLabelIds"] as! [Int64]
        }
        if dict.keys.contains("RoomLocation") && dict["RoomLocation"] != nil {
            var model = UpdateMeetingRoomRequest.RoomLocation()
            model.fromMap(dict["RoomLocation"] as! [String: Any])
            self.roomLocation = model
        }
        if dict.keys.contains("RoomName") && dict["RoomName"] != nil {
            self.roomName = dict["RoomName"] as! String
        }
        if dict.keys.contains("RoomPicture") && dict["RoomPicture"] != nil {
            self.roomPicture = dict["RoomPicture"] as! String
        }
        if dict.keys.contains("RoomStatus") && dict["RoomStatus"] != nil {
            self.roomStatus = dict["RoomStatus"] as! Int32
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = UpdateMeetingRoomRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class UpdateMeetingRoomShrinkRequest : Tea.TeaModel {
    public var enableCycleReservation: Bool?

    public var groupId: Int64?

    public var isvRoomId: String?

    public var reservationAuthorityShrink: String?

    public var roomCapacity: Int32?

    public var roomId: String?

    public var roomLabelIdsShrink: String?

    public var roomLocationShrink: String?

    public var roomName: String?

    public var roomPicture: String?

    public var roomStatus: Int32?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableCycleReservation != nil {
            map["EnableCycleReservation"] = self.enableCycleReservation!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.isvRoomId != nil {
            map["IsvRoomId"] = self.isvRoomId!
        }
        if self.reservationAuthorityShrink != nil {
            map["ReservationAuthority"] = self.reservationAuthorityShrink!
        }
        if self.roomCapacity != nil {
            map["RoomCapacity"] = self.roomCapacity!
        }
        if self.roomId != nil {
            map["RoomId"] = self.roomId!
        }
        if self.roomLabelIdsShrink != nil {
            map["RoomLabelIds"] = self.roomLabelIdsShrink!
        }
        if self.roomLocationShrink != nil {
            map["RoomLocation"] = self.roomLocationShrink!
        }
        if self.roomName != nil {
            map["RoomName"] = self.roomName!
        }
        if self.roomPicture != nil {
            map["RoomPicture"] = self.roomPicture!
        }
        if self.roomStatus != nil {
            map["RoomStatus"] = self.roomStatus!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnableCycleReservation") && dict["EnableCycleReservation"] != nil {
            self.enableCycleReservation = dict["EnableCycleReservation"] as! Bool
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("IsvRoomId") && dict["IsvRoomId"] != nil {
            self.isvRoomId = dict["IsvRoomId"] as! String
        }
        if dict.keys.contains("ReservationAuthority") && dict["ReservationAuthority"] != nil {
            self.reservationAuthorityShrink = dict["ReservationAuthority"] as! String
        }
        if dict.keys.contains("RoomCapacity") && dict["RoomCapacity"] != nil {
            self.roomCapacity = dict["RoomCapacity"] as! Int32
        }
        if dict.keys.contains("RoomId") && dict["RoomId"] != nil {
            self.roomId = dict["RoomId"] as! String
        }
        if dict.keys.contains("RoomLabelIds") && dict["RoomLabelIds"] != nil {
            self.roomLabelIdsShrink = dict["RoomLabelIds"] as! String
        }
        if dict.keys.contains("RoomLocation") && dict["RoomLocation"] != nil {
            self.roomLocationShrink = dict["RoomLocation"] as! String
        }
        if dict.keys.contains("RoomName") && dict["RoomName"] != nil {
            self.roomName = dict["RoomName"] as! String
        }
        if dict.keys.contains("RoomPicture") && dict["RoomPicture"] != nil {
            self.roomPicture = dict["RoomPicture"] as! String
        }
        if dict.keys.contains("RoomStatus") && dict["RoomStatus"] != nil {
            self.roomStatus = dict["RoomStatus"] as! Int32
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class UpdateMeetingRoomResponseBody : Tea.TeaModel {
    public var result: Bool?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! Bool
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class UpdateMeetingRoomResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMeetingRoomResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateMeetingRoomResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMeetingRoomGroupHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateMeetingRoomGroupHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = UpdateMeetingRoomGroupHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateMeetingRoomGroupShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateMeetingRoomGroupRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var groupId: String?

    public var groupName: String?

    public var tenantContext: UpdateMeetingRoomGroupRequest.TenantContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = UpdateMeetingRoomGroupRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
    }
}

public class UpdateMeetingRoomGroupShrinkRequest : Tea.TeaModel {
    public var groupId: String?

    public var groupName: String?

    public var tenantContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
    }
}

public class UpdateMeetingRoomGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! Bool
        }
    }
}

public class UpdateMeetingRoomGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMeetingRoomGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateMeetingRoomGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateRangeHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateRangeHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = UpdateRangeHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateRangeShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateRangeRequest : Tea.TeaModel {
    public class Hyperlinks : Tea.TeaModel {
        public var type: String?

        public var link: String?

        public var text: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.link != nil {
                map["Link"] = self.link!
            }
            if self.text != nil {
                map["Text"] = self.text!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Link") && dict["Link"] != nil {
                self.link = dict["Link"] as! String
            }
            if dict.keys.contains("Text") && dict["Text"] != nil {
                self.text = dict["Text"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var backgroundColors: [[String]]?

    public var hyperlinks: [[UpdateRangeRequest.Hyperlinks]]?

    public var numberFormat: String?

    public var rangeAddress: String?

    public var sheetId: String?

    public var tenantContext: UpdateRangeRequest.TenantContext?

    public var values: [[String]]?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backgroundColors != nil {
            map["BackgroundColors"] = self.backgroundColors!
        }
        if self.hyperlinks != nil {
            var tmp : [Any] = []
            for k in self.hyperlinks! {
                var l1 : [Any] = []
                for k1 in k {
                    l1.append(k1.toMap())
                }
                tmp.append(l1)
            }
            map["Hyperlinks"] = tmp
        }
        if self.numberFormat != nil {
            map["NumberFormat"] = self.numberFormat!
        }
        if self.rangeAddress != nil {
            map["RangeAddress"] = self.rangeAddress!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.values != nil {
            map["Values"] = self.values!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackgroundColors") && dict["BackgroundColors"] != nil {
            self.backgroundColors = dict["BackgroundColors"] as! [[String]]
        }
        if dict.keys.contains("Hyperlinks") && dict["Hyperlinks"] != nil {
            var tmp : [[UpdateRangeRequest.Hyperlinks]] = []
            for v in dict["Hyperlinks"] as! [Any] {
                var l1 : [UpdateRangeRequest.Hyperlinks] = []
                for v1 in v as! [Any] {
                    var model = UpdateRangeRequest.Hyperlinks()
                    if v1 != nil {
                        model.fromMap(v1 as! [String: Any])
                    }
                    l1.append(model)
                }
                tmp.append(l1)
            }
            self.hyperlinks = tmp
        }
        if dict.keys.contains("NumberFormat") && dict["NumberFormat"] != nil {
            self.numberFormat = dict["NumberFormat"] as! String
        }
        if dict.keys.contains("RangeAddress") && dict["RangeAddress"] != nil {
            self.rangeAddress = dict["RangeAddress"] as! String
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = UpdateRangeRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("Values") && dict["Values"] != nil {
            self.values = dict["Values"] as! [[String]]
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class UpdateRangeShrinkRequest : Tea.TeaModel {
    public var backgroundColorsShrink: String?

    public var hyperlinksShrink: String?

    public var numberFormat: String?

    public var rangeAddress: String?

    public var sheetId: String?

    public var tenantContextShrink: String?

    public var valuesShrink: String?

    public var workbookId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backgroundColorsShrink != nil {
            map["BackgroundColors"] = self.backgroundColorsShrink!
        }
        if self.hyperlinksShrink != nil {
            map["Hyperlinks"] = self.hyperlinksShrink!
        }
        if self.numberFormat != nil {
            map["NumberFormat"] = self.numberFormat!
        }
        if self.rangeAddress != nil {
            map["RangeAddress"] = self.rangeAddress!
        }
        if self.sheetId != nil {
            map["SheetId"] = self.sheetId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.valuesShrink != nil {
            map["Values"] = self.valuesShrink!
        }
        if self.workbookId != nil {
            map["WorkbookId"] = self.workbookId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackgroundColors") && dict["BackgroundColors"] != nil {
            self.backgroundColorsShrink = dict["BackgroundColors"] as! String
        }
        if dict.keys.contains("Hyperlinks") && dict["Hyperlinks"] != nil {
            self.hyperlinksShrink = dict["Hyperlinks"] as! String
        }
        if dict.keys.contains("NumberFormat") && dict["NumberFormat"] != nil {
            self.numberFormat = dict["NumberFormat"] as! String
        }
        if dict.keys.contains("RangeAddress") && dict["RangeAddress"] != nil {
            self.rangeAddress = dict["RangeAddress"] as! String
        }
        if dict.keys.contains("SheetId") && dict["SheetId"] != nil {
            self.sheetId = dict["SheetId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("Values") && dict["Values"] != nil {
            self.valuesShrink = dict["Values"] as! String
        }
        if dict.keys.contains("WorkbookId") && dict["WorkbookId"] != nil {
            self.workbookId = dict["WorkbookId"] as! String
        }
    }
}

public class UpdateRangeResponseBody : Tea.TeaModel {
    public var a1Notation: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.a1Notation != nil {
            map["a1Notation"] = self.a1Notation!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("a1Notation") && dict["a1Notation"] != nil {
            self.a1Notation = dict["a1Notation"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateRangeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRangeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateRangeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateScheduleConferenceHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateScheduleConferenceHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = UpdateScheduleConferenceHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateScheduleConferenceShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateScheduleConferenceRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var endTime: Int64?

    public var scheduleConferenceId: String?

    public var startTime: Int64?

    public var tenantContext: UpdateScheduleConferenceRequest.TenantContext?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.scheduleConferenceId != nil {
            map["ScheduleConferenceId"] = self.scheduleConferenceId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ScheduleConferenceId") && dict["ScheduleConferenceId"] != nil {
            self.scheduleConferenceId = dict["ScheduleConferenceId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = UpdateScheduleConferenceRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class UpdateScheduleConferenceShrinkRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var scheduleConferenceId: String?

    public var startTime: Int64?

    public var tenantContextShrink: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.scheduleConferenceId != nil {
            map["ScheduleConferenceId"] = self.scheduleConferenceId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ScheduleConferenceId") && dict["ScheduleConferenceId"] != nil {
            self.scheduleConferenceId = dict["ScheduleConferenceId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class UpdateScheduleConferenceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdateScheduleConferenceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateScheduleConferenceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateScheduleConferenceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateStatusHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateStatusHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = UpdateStatusHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateStatusShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateStatusRequest : Tea.TeaModel {
    public var appType: String?

    public var errorLines: [Int32]?

    public var importSequence: String?

    public var language: String?

    public var status: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.errorLines != nil {
            map["ErrorLines"] = self.errorLines!
        }
        if self.importSequence != nil {
            map["ImportSequence"] = self.importSequence!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("ErrorLines") && dict["ErrorLines"] != nil {
            self.errorLines = dict["ErrorLines"] as! [Int32]
        }
        if dict.keys.contains("ImportSequence") && dict["ImportSequence"] != nil {
            self.importSequence = dict["ImportSequence"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class UpdateStatusShrinkRequest : Tea.TeaModel {
    public var appType: String?

    public var errorLinesShrink: String?

    public var importSequence: String?

    public var language: String?

    public var status: String?

    public var systemToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.errorLinesShrink != nil {
            map["ErrorLines"] = self.errorLinesShrink!
        }
        if self.importSequence != nil {
            map["ImportSequence"] = self.importSequence!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.systemToken != nil {
            map["SystemToken"] = self.systemToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") && dict["AppType"] != nil {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("ErrorLines") && dict["ErrorLines"] != nil {
            self.errorLinesShrink = dict["ErrorLines"] as! String
        }
        if dict.keys.contains("ImportSequence") && dict["ImportSequence"] != nil {
            self.importSequence = dict["ImportSequence"] as! String
        }
        if dict.keys.contains("Language") && dict["Language"] != nil {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("SystemToken") && dict["SystemToken"] != nil {
            self.systemToken = dict["SystemToken"] as! String
        }
    }
}

public class UpdateStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class UpdateStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateSubscribedCalendarsHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateSubscribedCalendarsHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = UpdateSubscribedCalendarsHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateSubscribedCalendarsShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateSubscribedCalendarsRequest : Tea.TeaModel {
    public class SubscribeScope : Tea.TeaModel {
        public var userIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userIds != nil {
                map["UserIds"] = self.userIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UserIds") && dict["UserIds"] != nil {
                self.userIds = dict["UserIds"] as! [String]
            }
        }
    }
    public var calendarId: String?

    public var description_: String?

    public var managers: [String]?

    public var name: String?

    public var subscribeScope: UpdateSubscribedCalendarsRequest.SubscribeScope?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.subscribeScope?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.managers != nil {
            map["Managers"] = self.managers!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.subscribeScope != nil {
            map["SubscribeScope"] = self.subscribeScope?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Managers") && dict["Managers"] != nil {
            self.managers = dict["Managers"] as! [String]
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("SubscribeScope") && dict["SubscribeScope"] != nil {
            var model = UpdateSubscribedCalendarsRequest.SubscribeScope()
            model.fromMap(dict["SubscribeScope"] as! [String: Any])
            self.subscribeScope = model
        }
    }
}

public class UpdateSubscribedCalendarsShrinkRequest : Tea.TeaModel {
    public var calendarId: String?

    public var description_: String?

    public var managersShrink: String?

    public var name: String?

    public var subscribeScopeShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calendarId != nil {
            map["CalendarId"] = self.calendarId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.managersShrink != nil {
            map["Managers"] = self.managersShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.subscribeScopeShrink != nil {
            map["SubscribeScope"] = self.subscribeScopeShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalendarId") && dict["CalendarId"] != nil {
            self.calendarId = dict["CalendarId"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Managers") && dict["Managers"] != nil {
            self.managersShrink = dict["Managers"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("SubscribeScope") && dict["SubscribeScope"] != nil {
            self.subscribeScopeShrink = dict["SubscribeScope"] as! String
        }
    }
}

public class UpdateSubscribedCalendarsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! Bool
        }
    }
}

public class UpdateSubscribedCalendarsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSubscribedCalendarsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateSubscribedCalendarsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTodoTaskHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateTodoTaskHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = UpdateTodoTaskHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateTodoTaskShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateTodoTaskRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: UpdateTodoTaskRequest.TenantContext?

    public var description_: String?

    public var done: Bool?

    public var dueTime: Int64?

    public var executorIds: [String]?

    public var participantIds: [String]?

    public var subject: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.done != nil {
            map["done"] = self.done!
        }
        if self.dueTime != nil {
            map["dueTime"] = self.dueTime!
        }
        if self.executorIds != nil {
            map["executorIds"] = self.executorIds!
        }
        if self.participantIds != nil {
            map["participantIds"] = self.participantIds!
        }
        if self.subject != nil {
            map["subject"] = self.subject!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = UpdateTodoTaskRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("description") && dict["description"] != nil {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("done") && dict["done"] != nil {
            self.done = dict["done"] as! Bool
        }
        if dict.keys.contains("dueTime") && dict["dueTime"] != nil {
            self.dueTime = dict["dueTime"] as! Int64
        }
        if dict.keys.contains("executorIds") && dict["executorIds"] != nil {
            self.executorIds = dict["executorIds"] as! [String]
        }
        if dict.keys.contains("participantIds") && dict["participantIds"] != nil {
            self.participantIds = dict["participantIds"] as! [String]
        }
        if dict.keys.contains("subject") && dict["subject"] != nil {
            self.subject = dict["subject"] as! String
        }
        if dict.keys.contains("taskId") && dict["taskId"] != nil {
            self.taskId = dict["taskId"] as! String
        }
    }
}

public class UpdateTodoTaskShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var description_: String?

    public var done: Bool?

    public var dueTime: Int64?

    public var executorIdsShrink: String?

    public var participantIdsShrink: String?

    public var subject: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.done != nil {
            map["done"] = self.done!
        }
        if self.dueTime != nil {
            map["dueTime"] = self.dueTime!
        }
        if self.executorIdsShrink != nil {
            map["executorIds"] = self.executorIdsShrink!
        }
        if self.participantIdsShrink != nil {
            map["participantIds"] = self.participantIdsShrink!
        }
        if self.subject != nil {
            map["subject"] = self.subject!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("description") && dict["description"] != nil {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("done") && dict["done"] != nil {
            self.done = dict["done"] as! Bool
        }
        if dict.keys.contains("dueTime") && dict["dueTime"] != nil {
            self.dueTime = dict["dueTime"] as! Int64
        }
        if dict.keys.contains("executorIds") && dict["executorIds"] != nil {
            self.executorIdsShrink = dict["executorIds"] as! String
        }
        if dict.keys.contains("participantIds") && dict["participantIds"] != nil {
            self.participantIdsShrink = dict["participantIds"] as! String
        }
        if dict.keys.contains("subject") && dict["subject"] != nil {
            self.subject = dict["subject"] as! String
        }
        if dict.keys.contains("taskId") && dict["taskId"] != nil {
            self.taskId = dict["taskId"] as! String
        }
    }
}

public class UpdateTodoTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! Bool
        }
    }
}

public class UpdateTodoTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTodoTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateTodoTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTodoTaskExecutorStatusHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateTodoTaskExecutorStatusHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = UpdateTodoTaskExecutorStatusHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateTodoTaskExecutorStatusShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateTodoTaskExecutorStatusRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public class ExecutorStatusList : Tea.TeaModel {
        public var id: String?

        public var isDone: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.isDone != nil {
                map["isDone"] = self.isDone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") && dict["id"] != nil {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("isDone") && dict["isDone"] != nil {
                self.isDone = dict["isDone"] as! Bool
            }
        }
    }
    public var tenantContext: UpdateTodoTaskExecutorStatusRequest.TenantContext?

    public var executorStatusList: [UpdateTodoTaskExecutorStatusRequest.ExecutorStatusList]?

    public var operatorId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.executorStatusList != nil {
            var tmp : [Any] = []
            for k in self.executorStatusList! {
                tmp.append(k.toMap())
            }
            map["executorStatusList"] = tmp
        }
        if self.operatorId != nil {
            map["operatorId"] = self.operatorId!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = UpdateTodoTaskExecutorStatusRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("executorStatusList") && dict["executorStatusList"] != nil {
            var tmp : [UpdateTodoTaskExecutorStatusRequest.ExecutorStatusList] = []
            for v in dict["executorStatusList"] as! [Any] {
                var model = UpdateTodoTaskExecutorStatusRequest.ExecutorStatusList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.executorStatusList = tmp
        }
        if dict.keys.contains("operatorId") && dict["operatorId"] != nil {
            self.operatorId = dict["operatorId"] as! String
        }
        if dict.keys.contains("taskId") && dict["taskId"] != nil {
            self.taskId = dict["taskId"] as! String
        }
    }
}

public class UpdateTodoTaskExecutorStatusShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var executorStatusListShrink: String?

    public var operatorId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.executorStatusListShrink != nil {
            map["executorStatusList"] = self.executorStatusListShrink!
        }
        if self.operatorId != nil {
            map["operatorId"] = self.operatorId!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("executorStatusList") && dict["executorStatusList"] != nil {
            self.executorStatusListShrink = dict["executorStatusList"] as! String
        }
        if dict.keys.contains("operatorId") && dict["operatorId"] != nil {
            self.operatorId = dict["operatorId"] as! String
        }
        if dict.keys.contains("taskId") && dict["taskId"] != nil {
            self.taskId = dict["taskId"] as! String
        }
    }
}

public class UpdateTodoTaskExecutorStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") && dict["result"] != nil {
            self.result = dict["result"] as! Bool
        }
    }
}

public class UpdateTodoTaskExecutorStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTodoTaskExecutorStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateTodoTaskExecutorStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateUserAvatarHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateUserAvatarHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = UpdateUserAvatarHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateUserAvatarShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateUserAvatarRequest : Tea.TeaModel {
    public var avatarMediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.avatarMediaId != nil {
            map["AvatarMediaId"] = self.avatarMediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvatarMediaId") && dict["AvatarMediaId"] != nil {
            self.avatarMediaId = dict["AvatarMediaId"] as! String
        }
    }
}

public class UpdateUserAvatarResponseBody : Tea.TeaModel {
    public var errcode: String?

    public var errmsg: String?

    public var requestId: String?

    public var vendorRequestId: String?

    public var vendorType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errcode != nil {
            map["errcode"] = self.errcode!
        }
        if self.errmsg != nil {
            map["errmsg"] = self.errmsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.vendorRequestId != nil {
            map["vendorRequestId"] = self.vendorRequestId!
        }
        if self.vendorType != nil {
            map["vendorType"] = self.vendorType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errcode") && dict["errcode"] != nil {
            self.errcode = dict["errcode"] as! String
        }
        if dict.keys.contains("errmsg") && dict["errmsg"] != nil {
            self.errmsg = dict["errmsg"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("vendorRequestId") && dict["vendorRequestId"] != nil {
            self.vendorRequestId = dict["vendorRequestId"] as! String
        }
        if dict.keys.contains("vendorType") && dict["vendorType"] != nil {
            self.vendorType = dict["vendorType"] as! String
        }
    }
}

public class UpdateUserAvatarResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateUserAvatarResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateUserAvatarResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateWorkspaceDocMembersHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateWorkspaceDocMembersHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = UpdateWorkspaceDocMembersHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateWorkspaceDocMembersShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateWorkspaceDocMembersRequest : Tea.TeaModel {
    public class Members : Tea.TeaModel {
        public var memberId: String?

        public var memberType: String?

        public var roleType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.memberId != nil {
                map["MemberId"] = self.memberId!
            }
            if self.memberType != nil {
                map["MemberType"] = self.memberType!
            }
            if self.roleType != nil {
                map["RoleType"] = self.roleType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MemberId") && dict["MemberId"] != nil {
                self.memberId = dict["MemberId"] as! String
            }
            if dict.keys.contains("MemberType") && dict["MemberType"] != nil {
                self.memberType = dict["MemberType"] as! String
            }
            if dict.keys.contains("RoleType") && dict["RoleType"] != nil {
                self.roleType = dict["RoleType"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var members: [UpdateWorkspaceDocMembersRequest.Members]?

    public var nodeId: String?

    public var tenantContext: UpdateWorkspaceDocMembersRequest.TenantContext?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.members != nil {
            var tmp : [Any] = []
            for k in self.members! {
                tmp.append(k.toMap())
            }
            map["Members"] = tmp
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") && dict["Members"] != nil {
            var tmp : [UpdateWorkspaceDocMembersRequest.Members] = []
            for v in dict["Members"] as! [Any] {
                var model = UpdateWorkspaceDocMembersRequest.Members()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.members = tmp
        }
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = UpdateWorkspaceDocMembersRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class UpdateWorkspaceDocMembersShrinkRequest : Tea.TeaModel {
    public var membersShrink: String?

    public var nodeId: String?

    public var tenantContextShrink: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.membersShrink != nil {
            map["Members"] = self.membersShrink!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") && dict["Members"] != nil {
            self.membersShrink = dict["Members"] as! String
        }
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class UpdateWorkspaceDocMembersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateWorkspaceDocMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateWorkspaceDocMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateWorkspaceDocMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateWorkspaceMembersHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UpdateWorkspaceMembersHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = UpdateWorkspaceMembersHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UpdateWorkspaceMembersShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UpdateWorkspaceMembersRequest : Tea.TeaModel {
    public class Members : Tea.TeaModel {
        public var memberId: String?

        public var memberType: String?

        public var roleType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.memberId != nil {
                map["MemberId"] = self.memberId!
            }
            if self.memberType != nil {
                map["MemberType"] = self.memberType!
            }
            if self.roleType != nil {
                map["RoleType"] = self.roleType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MemberId") && dict["MemberId"] != nil {
                self.memberId = dict["MemberId"] as! String
            }
            if dict.keys.contains("MemberType") && dict["MemberType"] != nil {
                self.memberType = dict["MemberType"] as! String
            }
            if dict.keys.contains("RoleType") && dict["RoleType"] != nil {
                self.roleType = dict["RoleType"] as! String
            }
        }
    }
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var members: [UpdateWorkspaceMembersRequest.Members]?

    public var tenantContext: UpdateWorkspaceMembersRequest.TenantContext?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.members != nil {
            var tmp : [Any] = []
            for k in self.members! {
                tmp.append(k.toMap())
            }
            map["Members"] = tmp
        }
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") && dict["Members"] != nil {
            var tmp : [UpdateWorkspaceMembersRequest.Members] = []
            for v in dict["Members"] as! [Any] {
                var model = UpdateWorkspaceMembersRequest.Members()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.members = tmp
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = UpdateWorkspaceMembersRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class UpdateWorkspaceMembersShrinkRequest : Tea.TeaModel {
    public var membersShrink: String?

    public var tenantContextShrink: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.membersShrink != nil {
            map["Members"] = self.membersShrink!
        }
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Members") && dict["Members"] != nil {
            self.membersShrink = dict["Members"] as! String
        }
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class UpdateWorkspaceMembersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateWorkspaceMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateWorkspaceMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateWorkspaceMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UploadMediaHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: UploadMediaHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = UploadMediaHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class UploadMediaShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class UploadMediaRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: UploadMediaRequest.TenantContext?

    public var mediaName: String?

    public var mediaType: String?

    public var orgId: Int64?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.mediaName != nil {
            map["mediaName"] = self.mediaName!
        }
        if self.mediaType != nil {
            map["mediaType"] = self.mediaType!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.url != nil {
            map["url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = UploadMediaRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("mediaName") && dict["mediaName"] != nil {
            self.mediaName = dict["mediaName"] as! String
        }
        if dict.keys.contains("mediaType") && dict["mediaType"] != nil {
            self.mediaType = dict["mediaType"] as! String
        }
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("url") && dict["url"] != nil {
            self.url = dict["url"] as! String
        }
    }
}

public class UploadMediaShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var mediaName: String?

    public var mediaType: String?

    public var orgId: Int64?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.mediaName != nil {
            map["mediaName"] = self.mediaName!
        }
        if self.mediaType != nil {
            map["mediaType"] = self.mediaType!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.url != nil {
            map["url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("mediaName") && dict["mediaName"] != nil {
            self.mediaName = dict["mediaName"] as! String
        }
        if dict.keys.contains("mediaType") && dict["mediaType"] != nil {
            self.mediaType = dict["mediaType"] as! String
        }
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("url") && dict["url"] != nil {
            self.url = dict["url"] as! String
        }
    }
}

public class UploadMediaResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["mediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("mediaId") && dict["mediaId"] != nil {
            self.mediaId = dict["mediaId"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UploadMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UploadMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UploadMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class WearOrgHonorHeaders : Tea.TeaModel {
    public class AccountContext : Tea.TeaModel {
        public var accountId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") && dict["accountId"] != nil {
                self.accountId = dict["accountId"] as! String
            }
        }
    }
    public var commonHeaders: [String: String]?

    public var accountContext: WearOrgHonorHeaders.AccountContext?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContext != nil {
            map["AccountContext"] = self.accountContext?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            var model = WearOrgHonorHeaders.AccountContext()
            model.fromMap(dict["AccountContext"] as! [String: Any])
            self.accountContext = model
        }
    }
}

public class WearOrgHonorShrinkHeaders : Tea.TeaModel {
    public var commonHeaders: [String: String]?

    public var accountContextShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commonHeaders != nil {
            map["commonHeaders"] = self.commonHeaders!
        }
        if self.accountContextShrink != nil {
            map["AccountContext"] = self.accountContextShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commonHeaders") && dict["commonHeaders"] != nil {
            self.commonHeaders = dict["commonHeaders"] as! [String: String]
        }
        if dict.keys.contains("AccountContext") && dict["AccountContext"] != nil {
            self.accountContextShrink = dict["AccountContext"] as! String
        }
    }
}

public class WearOrgHonorRequest : Tea.TeaModel {
    public class TenantContext : Tea.TeaModel {
        public var tenantId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantId != nil {
                map["tenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantId") && dict["tenantId"] != nil {
                self.tenantId = dict["tenantId"] as! String
            }
        }
    }
    public var tenantContext: WearOrgHonorRequest.TenantContext?

    public var honorId: String?

    public var orgId: Int64?

    public var userId: String?

    public var wear: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tenantContext?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContext != nil {
            map["TenantContext"] = self.tenantContext?.toMap()
        }
        if self.honorId != nil {
            map["honorId"] = self.honorId!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        if self.wear != nil {
            map["wear"] = self.wear!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            var model = WearOrgHonorRequest.TenantContext()
            model.fromMap(dict["TenantContext"] as! [String: Any])
            self.tenantContext = model
        }
        if dict.keys.contains("honorId") && dict["honorId"] != nil {
            self.honorId = dict["honorId"] as! String
        }
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! String
        }
        if dict.keys.contains("wear") && dict["wear"] != nil {
            self.wear = dict["wear"] as! Bool
        }
    }
}

public class WearOrgHonorShrinkRequest : Tea.TeaModel {
    public var tenantContextShrink: String?

    public var honorId: String?

    public var orgId: Int64?

    public var userId: String?

    public var wear: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantContextShrink != nil {
            map["TenantContext"] = self.tenantContextShrink!
        }
        if self.honorId != nil {
            map["honorId"] = self.honorId!
        }
        if self.orgId != nil {
            map["orgId"] = self.orgId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        if self.wear != nil {
            map["wear"] = self.wear!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TenantContext") && dict["TenantContext"] != nil {
            self.tenantContextShrink = dict["TenantContext"] as! String
        }
        if dict.keys.contains("honorId") && dict["honorId"] != nil {
            self.honorId = dict["honorId"] as! String
        }
        if dict.keys.contains("orgId") && dict["orgId"] != nil {
            self.orgId = dict["orgId"] as! Int64
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! String
        }
        if dict.keys.contains("wear") && dict["wear"] != nil {
            self.wear = dict["wear"] as! Bool
        }
    }
}

public class WearOrgHonorResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public var data: Any?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["data"] = self.data!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("data") && dict["data"] != nil {
                self.data = dict["data"] as! Any
            }
        }
    }
    public var content: WearOrgHonorResponseBody.Content?

    public var errorCode: String?

    public var errorCtx: [String: Any]?

    public var errorMsg: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["content"] = self.content?.toMap()
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorCtx != nil {
            map["errorCtx"] = self.errorCtx!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.httpStatusCode != nil {
            map["httpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("content") && dict["content"] != nil {
            var model = WearOrgHonorResponseBody.Content()
            model.fromMap(dict["content"] as! [String: Any])
            self.content = model
        }
        if dict.keys.contains("errorCode") && dict["errorCode"] != nil {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorCtx") && dict["errorCtx"] != nil {
            self.errorCtx = dict["errorCtx"] as! [String: Any]
        }
        if dict.keys.contains("errorMsg") && dict["errorMsg"] != nil {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("httpStatusCode") && dict["httpStatusCode"] != nil {
            self.httpStatusCode = dict["httpStatusCode"] as! Int32
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") && dict["success"] != nil {
            self.success = dict["success"] as! Bool
        }
    }
}

public class WearOrgHonorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WearOrgHonorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = WearOrgHonorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
